{"version":3,"file":"test-settings-CGBxsjCB.js","sources":["../../public/js/modules/api-factory.js","../../public/test-settings.html?html-proxy&index=1.js"],"sourcesContent":["/**\n * API Factory - Creates API clients with automatic token re-authentication\n * \n * This module provides a factory for creating API clients that automatically\n * handle token expiration by detecting 401 responses and retrying with new tokens\n * using stored credentials.\n */\n\nimport TokenManager from './token-manager.js';\nimport { LocalAPIClient, localAPIClient } from './local-api-client.js';\nimport { PingOneClient } from './pingone-client.js';\n\n/**\n * Create an API client with automatic token re-authentication\n * @param {Object} settings - API settings including credentials\n * @param {Object} logger - Logger instance\n * @returns {Object} API client with auto-retry capabilities\n */\nexport function createAutoRetryAPIClient(settings, logger) {\n    if (!settings) {\n        throw new Error('Settings are required for API client creation');\n    }\n    \n    const tokenManager = new TokenManager(logger, settings);\n    \n    /**\n     * Make an API request with automatic token re-authentication\n     * @param {string} url - The API endpoint URL\n     * @param {Object} options - Request options\n     * @returns {Promise<Object>} The API response\n     */\n    async function makeRequest(url, options = {}) {\n        if (!url) {\n            throw new Error('URL is required for API request');\n        }\n        \n        return await tokenManager.retryWithNewToken(async (token) => {\n            const requestOptions = {\n                ...options,\n                headers: {\n                    ...options.headers,\n                    'Authorization': `Bearer ${token}`,\n                    'Content-Type': 'application/json',\n                    'Accept': 'application/json'\n                }\n            };\n            \n            const response = await fetch(url, requestOptions);\n            \n            // Check for token expiration\n            if (response.status === 401) {\n                const responseText = await response.text().catch(() => '');\n                const isTokenExpired = responseText.includes('token_expired') || \n                                     responseText.includes('invalid_token') ||\n                                     responseText.includes('expired');\n                \n                if (isTokenExpired) {\n                    throw new Error('TOKEN_EXPIRED');\n                }\n            }\n            \n            return response;\n        });\n    }\n    \n    /**\n     * GET request with auto-retry\n     * @param {string} url - The API endpoint URL\n     * @param {Object} options - Request options\n     * @returns {Promise<Object>} The API response\n     */\n    async function get(url, options = {}) {\n        if (!url) {\n            throw new Error('URL is required for GET request');\n        }\n        \n        return await makeRequest(url, { ...options, method: 'GET' });\n    }\n    \n    /**\n     * POST request with auto-retry\n     * @param {string} url - The API endpoint URL\n     * @param {Object} data - Request body data\n     * @param {Object} options - Request options\n     * @returns {Promise<Object>} The API response\n     */\n    async function post(url, data = null, options = {}) {\n        if (!url) {\n            throw new Error('URL is required for POST request');\n        }\n        \n        const requestOptions = { ...options, method: 'POST' };\n        \n        if (data) {\n            requestOptions.body = JSON.stringify(data);\n        }\n        \n        return await makeRequest(url, requestOptions);\n    }\n    \n    /**\n     * PUT request with auto-retry\n     * @param {string} url - The API endpoint URL\n     * @param {Object} data - Request body data\n     * @param {Object} options - Request options\n     * @returns {Promise<Object>} The API response\n     */\n    async function put(url, data = null, options = {}) {\n        if (!url) {\n            throw new Error('URL is required for PUT request');\n        }\n        \n        const requestOptions = { ...options, method: 'PUT' };\n        \n        if (data) {\n            requestOptions.body = JSON.stringify(data);\n        }\n        \n        return await makeRequest(url, requestOptions);\n    }\n    \n    /**\n     * DELETE request with auto-retry\n     * @param {string} url - The API endpoint URL\n     * @param {Object} options - Request options\n     * @returns {Promise<Object>} The API response\n     */\n    async function del(url, options = {}) {\n        if (!url) {\n            throw new Error('URL is required for DELETE request');\n        }\n        \n        return await makeRequest(url, { ...options, method: 'DELETE' });\n    }\n    \n    /**\n     * PATCH request with auto-retry\n     * @param {string} url - The API endpoint URL\n     * @param {Object} data - Request body data\n     * @param {Object} options - Request options\n     * @returns {Promise<Object>} The API response\n     */\n    async function patch(url, data = null, options = {}) {\n        if (!url) {\n            throw new Error('URL is required for PATCH request');\n        }\n        \n        const requestOptions = { ...options, method: 'PATCH' };\n        \n        if (data) {\n            requestOptions.body = JSON.stringify(data);\n        }\n        \n        return await makeRequest(url, requestOptions);\n    }\n    \n    /**\n     * Get token information\n     * @returns {Object|null} Token info\n     */\n    function getTokenInfo() {\n        return tokenManager.getTokenInfo();\n    }\n    \n    /**\n     * Update settings and clear token cache if credentials changed\n     * @param {Object} newSettings - New settings\n     */\n    function updateSettings(newSettings) {\n        if (!newSettings) {\n            throw new Error('New settings are required');\n        }\n        \n        tokenManager.updateSettings(newSettings);\n    }\n    \n    return {\n        get,\n        post,\n        put,\n        del,\n        patch,\n        getTokenInfo,\n        updateSettings,\n        tokenManager\n    };\n}\n\n/**\n * Create a PingOne API client with automatic token re-authentication\n * @param {Object} settings - PingOne API settings\n * @param {Object} logger - Logger instance\n * @returns {Object} PingOne API client\n */\nexport function createPingOneAPIClient(settings, logger) {\n    if (!settings) {\n        throw new Error('Settings are required for PingOne API client creation');\n    }\n    \n    if (!settings.environmentId) {\n        throw new Error('Environment ID is required for PingOne API client');\n    }\n    \n    const baseURL = getPingOneBaseURL(settings.region);\n    const apiClient = createAutoRetryAPIClient(settings, logger);\n    \n    /**\n     * Get PingOne base URL for the region\n     * @param {string} region - The region\n     * @returns {string} Base URL\n     */\n    function getPingOneBaseURL(region) {\n        const baseURLs = {\n            'NorthAmerica': 'https://api.pingone.com',\n            'Europe': 'https://api.eu.pingone.com',\n            'Canada': 'https://api.ca.pingone.com',\n            'Asia': 'https://api.apsoutheast.pingone.com',\n            'Australia': 'https://api.aus.pingone.com',\n            'US': 'https://api.pingone.com',\n            'EU': 'https://api.eu.pingone.com',\n            'AP': 'https://api.apsoutheast.pingone.com'\n        };\n        return baseURLs[region] || 'https://api.pingone.com';\n    }\n    \n    /**\n     * Make a PingOne API request\n     * @param {string} endpoint - API endpoint (without base URL)\n     * @param {Object} options - Request options\n     * @returns {Promise<Object>} The API response\n     */\n    async function pingOneRequest(endpoint, options = {}) {\n        if (!endpoint) {\n            throw new Error('Endpoint is required for PingOne request');\n        }\n        \n        const url = `${baseURL}/v1${endpoint}`;\n        return await apiClient.makeRequest(url, options);\n    }\n    \n    /**\n     * Get users from PingOne\n     * @param {Object} options - Query options\n     * @returns {Promise<Object>} Users response\n     */\n    async function getUsers(options = {}) {\n        const queryParams = new URLSearchParams(options).toString();\n        const endpoint = `/environments/${settings.environmentId}/users${queryParams ? `?${queryParams}` : ''}`;\n        return await pingOneRequest(endpoint, { method: 'GET' });\n    }\n    \n    /**\n     * Create user in PingOne\n     * @param {Object} userData - User data\n     * @returns {Promise<Object>} Create user response\n     */\n    async function createUser(userData) {\n        if (!userData) {\n            throw new Error('User data is required for user creation');\n        }\n        \n        const endpoint = `/environments/${settings.environmentId}/users`;\n        return await pingOneRequest(endpoint, { \n            method: 'POST',\n            body: JSON.stringify(userData)\n        });\n    }\n    \n    /**\n     * Update user in PingOne\n     * @param {string} userId - User ID\n     * @param {Object} userData - User data\n     * @returns {Promise<Object>} Update user response\n     */\n    async function updateUser(userId, userData) {\n        if (!userId) {\n            throw new Error('User ID is required for user update');\n        }\n        \n        if (!userData) {\n            throw new Error('User data is required for user update');\n        }\n        \n        const endpoint = `/environments/${settings.environmentId}/users/${userId}`;\n        return await pingOneRequest(endpoint, { \n            method: 'PUT',\n            body: JSON.stringify(userData)\n        });\n    }\n    \n    /**\n     * Delete user from PingOne\n     * @param {string} userId - User ID\n     * @returns {Promise<Object>} Delete user response\n     */\n    async function deleteUser(userId) {\n        if (!userId) {\n            throw new Error('User ID is required for user deletion');\n        }\n        \n        const endpoint = `/environments/${settings.environmentId}/users/${userId}`;\n        return await pingOneRequest(endpoint, { method: 'DELETE' });\n    }\n    \n    /**\n     * Get populations from PingOne\n     * @param {Object} options - Query options\n     * @returns {Promise<Object>} Populations response\n     */\n    async function getPopulations(options = {}) {\n        const queryParams = new URLSearchParams(options).toString();\n        const endpoint = `/environments/${settings.environmentId}/populations${queryParams ? `?${queryParams}` : ''}`;\n        return await pingOneRequest(endpoint, { method: 'GET' });\n    }\n    \n    /**\n     * Create population in PingOne\n     * @param {Object} populationData - Population data\n     * @returns {Promise<Object>} Create population response\n     */\n    async function createPopulation(populationData) {\n        if (!populationData) {\n            throw new Error('Population data is required for population creation');\n        }\n        \n        const endpoint = `/environments/${settings.environmentId}/populations`;\n        return await pingOneRequest(endpoint, { \n            method: 'POST',\n            body: JSON.stringify(populationData)\n        });\n    }\n    \n    /**\n     * Delete population from PingOne\n     * @param {string} populationId - Population ID\n     * @returns {Promise<Object>} Delete population response\n     */\n    async function deletePopulation(populationId) {\n        if (!populationId) {\n            throw new Error('Population ID is required for population deletion');\n        }\n        \n        const endpoint = `/environments/${settings.environmentId}/populations/${populationId}`;\n        return await pingOneRequest(endpoint, { method: 'DELETE' });\n    }\n    \n    return {\n        // API methods\n        getUsers,\n        createUser,\n        updateUser,\n        deleteUser,\n        getPopulations,\n        createPopulation,\n        deletePopulation,\n        \n        // Token management\n        getTokenInfo: apiClient.getTokenInfo,\n        updateSettings: apiClient.updateSettings,\n        \n        // Raw request method\n        request: pingOneRequest\n    };\n}\n\n/**\n * API Factory class - Backward compatibility\n */\nclass APIFactory {\n    /**\n     * Create a new APIFactory instance\n     * @param {Object} logger - Logger instance\n     * @param {Object} settingsManager - Settings manager instance\n     */\n    constructor(logger, settingsManager) {\n        if (!settingsManager) {\n            throw new Error('Settings manager is required for API factory');\n        }\n        \n        this.logger = logger || console;\n        this.settingsManager = settingsManager;\n        this.clients = new Map();\n    }\n\n    /**\n     * Get or create a PingOne API client\n     * @returns {PingOneClient} PingOne API client instance\n     */\n    getPingOneClient() {\n        if (!this.clients.has('pingone')) {\n            this.clients.set('pingone', new PingOneClient(this.logger, this.settingsManager));\n        }\n        return this.clients.get('pingone');\n    }\n\n    /**\n     * Get or create a local API client\n     * @param {string} [baseUrl=''] - Base URL for the API\n     * @returns {LocalAPIClient} Local API client instance\n     */\n    getLocalClient(baseUrl = '') {\n        const cacheKey = `local_${baseUrl}`;\n        if (!this.clients.has(cacheKey)) {\n            this.clients.set(cacheKey, new LocalAPIClient(this.logger, baseUrl));\n        }\n        return this.clients.get(cacheKey);\n    }\n\n    /**\n     * Get the default local API client (singleton)\n     * @returns {LocalAPIClient} Default local API client instance\n     */\n    getDefaultLocalClient() {\n        return localAPIClient;\n    }\n}\n\n// Create a singleton instance but don't export it directly\nlet _apiFactoryInstance = null;\nlet isInitializing = false;\nlet initializationPromise = null;\n\n/**\n * Initialize the API factory with required dependencies\n * @param {Object} logger - Logger instance\n * @param {Object} settingsManager - Settings manager instance\n * @returns {Promise<APIFactory>} Initialized API factory instance\n */\nconst initAPIFactory = async (logger, settingsManager) => {\n    // If already initialized, return the existing instance\n    if (_apiFactoryInstance) {\n        return _apiFactoryInstance;\n    }\n    \n    // If initialization is in progress, wait for it to complete\n    if (isInitializing) {\n        if (initializationPromise) {\n            return initializationPromise;\n        }\n    }\n    \n    // Set initialization flag and create a new promise\n    isInitializing = true;\n    initializationPromise = new Promise(async (resolve, reject) => {\n        try {\n            // Create the factory instance\n            const factory = new APIFactory(logger, settingsManager);\n            \n            // Set the instance\n            _apiFactoryInstance = factory;\n            defaultAPIFactory = factory;\n            \n            // Log successful initialization\n            if (logger && logger.info) {\n                logger.info('API Factory initialized successfully');\n            } else {\n                console.log('API Factory initialized successfully');\n            }\n            \n            resolve(factory);\n        } catch (error) {\n            const errorMsg = `Failed to initialize API Factory: ${error.message}`;\n            if (logger && logger.error) {\n                logger.error(errorMsg, { error });\n            } else {\n                console.error(errorMsg, error);\n            }\n            reject(new Error(errorMsg));\n        } finally {\n            isInitializing = false;\n            initializationPromise = null;\n        }\n    });\n    \n    return initializationPromise;\n};\n\n// Export the singleton instance and initialization function\nexport { APIFactory, initAPIFactory };\n\n// For backward compatibility, export a default instance (will be initialized when initAPIFactory is called)\nlet defaultAPIFactory = null;\n\n/**\n * API Factory singleton for backward compatibility\n */\nexport const apiFactory = {\n    /**\n     * Get PingOne client\n     * @returns {PingOneClient} PingOne API client\n     * @throws {Error} If API factory is not initialized\n     */\n    getPingOneClient: () => {\n        if (!defaultAPIFactory) {\n            throw new Error('API Factory not initialized. Call initAPIFactory() first.');\n        }\n        return defaultAPIFactory.getPingOneClient();\n    },\n    \n    /**\n     * Get local client\n     * @param {string} [baseUrl=''] - Base URL for the API\n     * @returns {LocalAPIClient} Local API client\n     * @throws {Error} If API factory is not initialized\n     */\n    getLocalClient: (baseUrl = '') => {\n        if (!defaultAPIFactory) {\n            throw new Error('API Factory not initialized. Call initAPIFactory() first.');\n        }\n        return defaultAPIFactory.getLocalClient(baseUrl);\n    }\n};\n\n/**\n * Get the default API factory instance\n * @returns {APIFactory|null} The default API factory instance\n */\nexport const getAPIFactory = () => defaultAPIFactory;\n\nexport default {\n    createAutoRetryAPIClient,\n    createPingOneAPIClient,\n    initAPIFactory,\n    apiFactory\n};\n","\n        import { initAPIFactory } from './js/modules/api-factory.js';\n        import { Logger } from './js/modules/logger.js';\n        import { SettingsManager } from './js/modules/settings-manager.js';\n        \n        document.addEventListener('DOMContentLoaded', async function() {\n            // Initialize logger with console fallback\n            const logContainer = document.getElementById('log-entries');\n            const logger = logContainer ? new Logger(logContainer) : console;\n            \n            // Initialize settings manager\n            const settingsManager = new SettingsManager(logger);\n            \n            // Initialize API factory\n            const apiFactory = initAPIFactory(logger, settingsManager);\n            \n            // DOM Elements\n            const form = document.getElementById('settings-form');\n            const testBtn = document.getElementById('test-connection');\n            const loadBtn = document.getElementById('load-settings');\n            const testSpinner = document.getElementById('test-spinner');\n            const saveSpinner = document.getElementById('save-spinner');\n            const testResult = document.getElementById('test-result');\n            const saveResult = document.getElementById('save-result');\n            const statusBox = document.getElementById('connection-status');\n            const statusText = document.getElementById('status-text');\n            const togglePasswordBtns = document.querySelectorAll('.toggle-password');\n            \n            // Toggle password visibility\n            togglePasswordBtns.forEach(btn => {\n                btn.addEventListener('click', function() {\n                    const input = this.previousElementSibling;\n                    const icon = this.querySelector('i');\n                    \n                    if (input.type === 'password') {\n                        input.type = 'text';\n                        icon.classList.remove('bi-eye');\n                        icon.classList.add('bi-eye-slash');\n                    } else {\n                        input.type = 'password';\n                        icon.classList.remove('bi-eye-slash');\n                        icon.classList.add('bi-eye');\n                    }\n                });\n            });\n            \n            // Show result message\n            function showResult(element, message, type = 'success') {\n                element.textContent = message;\n                element.className = `test-result test-${type} show`;\n                element.style.display = 'block';\n            }\n            \n            // Update connection status\n            function updateStatus(status, message) {\n                // Remove all status classes\n                statusBox.className = 'status-box';\n                \n                // Add appropriate status class\n                switch(status) {\n                    case 'connected':\n                        statusBox.classList.add('status-connected');\n                        break;\n                    case 'connecting':\n                        statusBox.classList.add('status-connecting');\n                        break;\n                    case 'error':\n                        statusBox.classList.add('status-error');\n                        break;\n                    default:\n                        statusBox.classList.add('status-disconnected');\n                }\n                \n                statusText.textContent = `Status: ${message}`;\n            }\n            \n            // Load settings\n            async function loadSettings() {\n                try {\n                    const response = await fetch('/api/settings');\n                    const data = await response.json();\n                    \n                    if (response.ok && data.success) {\n                        const settings = data.data || {};\n                        document.getElementById('apiClientId').value = settings.apiClientId || '';\n                        document.getElementById('apiSecret').value = settings.apiSecret || '';\n                        document.getElementById('environmentId').value = settings.environmentId || '';\n                        document.getElementById('region').value = settings.region || 'NorthAmerica';\n                        document.getElementById('populationId').value = settings.populationId || '';\n                        \n                        // Update connection status if available\n                        if (settings.connectionStatus) {\n                            updateStatus(\n                                settings.connectionStatus, \n                                settings.connectionMessage || 'Connection status loaded'\n                            );\n                        }\n                        \n                        showResult(saveResult, 'Settings loaded successfully', 'success');\n                    } else {\n                        throw new Error(data.message || 'Failed to load settings');\n                    }\n                } catch (error) {\n                    showResult(saveResult, `Error loading settings: ${error.message}`, 'error');\n                }\n            }\n            \n            // Save settings\n            async function saveSettings() {\n                const settings = {\n                    apiClientId: document.getElementById('apiClientId').value.trim(),\n                    apiSecret: document.getElementById('apiSecret').value.trim(),\n                    environmentId: document.getElementById('environmentId').value.trim(),\n                    region: document.getElementById('region').value,\n                    populationId: document.getElementById('populationId').value.trim()\n                };\n                \n                try {\n                    saveSpinner.classList.remove('d-none');\n                    \n                    const response = await fetch('/api/settings', {\n                        method: 'POST',\n                        headers: { 'Content-Type': 'application/json' },\n                        body: JSON.stringify(settings)\n                    });\n                    \n                    const data = await response.json();\n                    \n                    if (response.ok && data.success) {\n                        showResult(saveResult, 'Settings saved successfully', 'success');\n                    } else {\n                        throw new Error(data.message || 'Failed to save settings');\n                    }\n                } catch (error) {\n                    showResult(saveResult, `Error saving settings: ${error.message}`, 'error');\n                } finally {\n                    saveSpinner.classList.add('d-none');\n                }\n            }\n            \n            // Test connection\n            async function testConnection() {\n                try {\n                    testSpinner.classList.remove('d-none');\n                    testBtn.disabled = true;\n                    updateStatus('connecting', 'Testing connection...');\n                    \n                    // Get current settings from the form\n                    const settings = {\n                        apiClientId: document.getElementById('apiClientId').value.trim(),\n                        apiSecret: document.getElementById('apiSecret').value.trim(),\n                        environmentId: document.getElementById('environmentId').value.trim(),\n                        region: document.getElementById('region').value,\n                        populationId: document.getElementById('populationId').value.trim()\n                    };\n                    \n                    // First save the settings\n                    await saveSettings();\n                    \n                    // Then test the connection using the server-side endpoint\n                    const response = await fetch('/api/pingone/test-connection', {\n                        method: 'POST',\n                        headers: { 'Content-Type': 'application/json' },\n                        body: JSON.stringify(settings)\n                    });\n                    \n                    const result = await response.json();\n                    \n                    if (response.ok && result.success) {\n                        updateStatus('connected', 'Successfully connected to PingOne');\n                        showResult(testResult, 'Connection test successful', 'success');\n                    } else {\n                        updateStatus('error', 'Failed to connect to PingOne');\n                        showResult(testResult, `Connection failed: ${result.message || 'Unknown error'}`, 'error');\n                    }\n                } catch (error) {\n                    updateStatus('error', 'Connection error');\n                    showResult(testResult, `Error: ${error.message || 'Unknown error occurred'}`, 'error');\n                } finally {\n                    testSpinner.classList.add('d-none');\n                    testBtn.disabled = false;\n                }\n            }\n            \n            // Event Listeners\n            form.addEventListener('submit', async (e) => {\n                e.preventDefault();\n                await saveSettings();\n            });\n            \n            loadBtn.addEventListener('click', loadSettings);\n            testBtn.addEventListener('click', testConnection);\n            \n            // Load settings on page load\n            loadSettings();\n        });\n    "],"names":["APIFactory","logger","settingsManager","PingOneClient","baseUrl","cacheKey","LocalAPIClient","localAPIClient","_apiFactoryInstance","isInitializing","initializationPromise","initAPIFactory","resolve","reject","factory","defaultAPIFactory","error","errorMsg","logContainer","Logger","SettingsManager","form","testBtn","loadBtn","testSpinner","saveSpinner","testResult","saveResult","statusBox","statusText","btn","input","icon","showResult","element","message","type","updateStatus","status","loadSettings","response","data","settings","saveSettings","testConnection","result","e"],"mappings":"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"}