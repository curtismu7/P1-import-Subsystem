/**
 * Import-export Subsystem
 * 
 * Consolidated JavaScript for PingOne Import Tool
 * Generated: 2025-08-06T19:05:53.926Z
 * 
 * This file was automatically generated by js-cleanup-script.js
 * Organized for better maintainability and performance
 */


/* From: public/js/modules/import-subsystem.js */
/**
 * Import Management Subsystem
 * 
 * Handles all user import operations with proper separation of concerns.
 * Manages file validation, progress tracking, real-time updates, and error handling.
 */

export class ImportSubsystem {
    constructor(logger, uiManager, localClient, settingsManager, eventBus, populationService) {
        this.logger = logger;
        this.uiManager = uiManager;
        this.localClient = localClient;
        this.settingsManager = settingsManager;
        this.eventBus = eventBus;
        this.populationService = populationService;
        
        // Import state management
        this.isImporting = false;
        this.socket = null;
        this.selectedPopulationId = null;
        this.selectedPopulationName = null;
        this.fallbackPolling = null;
        
        this.logger.info('Import Subsystem initialized');
        
        // Set up event listeners for cross-subsystem communication
        this.setupCrossSubsystemEvents();
    }
    
    /**
     * Initialize the import subsystem
     */
    async init() {
        try {
            this.setupEventListeners();
            this.logger.info('Import Subsystem initialized successfully');
        } catch (error) {
            this.logger.error('Failed to initialize Import Subsystem', error);
            throw error;
        }
    }
    
    /**
     * Set up event listeners for import-related elements
     */
    setupEventListeners() {
        // Import button
        const importBtn = document.getElementById('import-btn');
        if (importBtn) {
            importBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                await this.startImport();
            });
        }
        
        // CSV file input
        const csvFileInput = document.getElementById('csv-file');
        if (csvFileInput) {
            csvFileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    await this.handleFileSelect(file);
                }
            });
        }
    }
    
    /**
     * Start the import process
     */
    async startImport() {
        if (this.isImporting) {
            this.uiManager.showNotification('An import is already in progress. Please wait for it to complete.', {
                type: 'warning',
                duration: 5000,
                title: 'Import In Progress'
            });
            return;
        }
        
        try {
            this.isImporting = true;
            this.logger.info('Starting import process');
            
            // Validate prerequisites
            if (!await this.validateImportPrerequisites()) {
                return;
            }
            
            // Get population selection
            this.getPopulationSelection();
            
            // Show progress UI
            this.uiManager.showProgress();
            
            // Start real-time connection
            const sessionId = this.generateSessionId();
            await this.establishRealTimeConnection(sessionId);
            
            // Begin import process
            await this.executeImport(sessionId);
            
        } catch (error) {
            this.logger.error('Import process failed', error);
            this.uiManager.showError('Import Failed', error.message || 'An unexpected error occurred during the import process.');
        } finally {
            this.isImporting = false;
        }
    }
    
    /**
     * Validate import prerequisites
     */
    async validateImportPrerequisites() {
        // Check for valid token
        const hasValidToken = await this.checkTokenStatus();
        if (!hasValidToken) {
            this.uiManager.showError('Authentication Required', 'You must have a valid token to start an import. Please authenticate first.');
            return false;
        }
        
        // Check file selection
        const fileInput = document.getElementById('csv-file');
        if (!fileInput || !fileInput.files || !fileInput.files[0]) {
            this.uiManager.showError('No File Selected', 'Please select a CSV file to import.');
            return false;
        }
        
        return true;
    }
    
    /**
     * Get current population selection
     */
    getPopulationSelection() {
        const popSelect = document.getElementById('import-population-select');
        this.selectedPopulationId = popSelect?.value || '';
        
        if (popSelect) {
            const selectedOption = popSelect.options[popSelect.selectedIndex];
            this.selectedPopulationName = selectedOption?.text || '';
        }
        
        this.logger.info('Population selection', {
            id: this.selectedPopulationId,
            name: this.selectedPopulationName
        });
    }
    
    /**
     * Handle progress updates
     */
    handleProgressUpdate(data) {
        if (!data || data.current === undefined || data.total === undefined) {
            this.logger.error('Invalid progress data', data);
            return;
        }
        
        const percentage = Math.round((data.current / data.total) * 100);
        
        // Update progress UI
        this.uiManager.updateProgress(percentage, data.message || `Processing ${data.current} of ${data.total} users...`);
        
        this.logger.info('Progress update', {
            current: data.current,
            total: data.total,
            percentage
        });
    }
    
    /**
     * Handle import completion
     */
    handleImportCompletion(data) {
        this.logger.info('Import completed', data);
        // TODO: Refactor: Use Notification from UI subsystem instead of alert.
        this.cleanupConnections();
    }
    
    /**
     * Handle import errors
     */
    handleImportError(data) {
        this.logger.error('Import error', data);
        // TODO: Refactor: Use Notification or Modal from UI subsystem instead of alert.
        this.cleanupConnections();
    }
    
    /**
     * Execute the import process
     */
    async executeImport(sessionId) {
        const fileInput = document.getElementById('csv-file');
        const file = fileInput.files[0];
        
        const formData = new FormData();
        formData.append('file', file);
        formData.append('populationId', this.selectedPopulationId);
        formData.append('sessionId', sessionId);
        
        try {
            const response = await this.localClient.post('/api/import', formData);
            
            if (!response.success) {
                throw new Error(response.error || 'Import failed');
            }
            
            this.logger.info('Import request sent successfully');
            
        } catch (error) {
            this.logger.error('Import request failed', error);
            throw error;
        }
    }
    
    /**
     * Generate unique session ID
     */
    generateSessionId() {
        return `import_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    /**
     * Check token status
     */
    async checkTokenStatus() {
        try {
            const response = await this.localClient.get('/api/token/status');
            return response.valid;
        } catch (error) {
            this.logger.error('Token status check failed', error);
            return false;
        }
    }
    
    /**
     * Handle file selection
     */
    async handleFileSelect(file) {
        try {
            if (!file) {
                throw new Error('No file selected');
            }

            // Check file type
            if (!file.name.endsWith('.csv') && !file.name.endsWith('.txt')) {
                throw new Error('Please select a valid CSV or text file');
            }

            // Check file size (10MB max)
            const maxSize = 10 * 1024 * 1024; // 10MB
            if (file.size > maxSize) {
                throw new Error('File size must be less than 10MB');
            }

            // Store the selected file
            this.selectedFile = file;

            // Update UI to show selected file
            this.updateFileInfoUI(file);

            // Show success message in status bar
            this.uiManager.showStatusBar(
                `File '${file.name}' selected successfully (${this.formatFileSize(file.size)})`,
                'success',
                {
                    duration: 5000,
                    source: 'file-upload',
                    context: {
                        fileName: file.name,
                        fileSize: file.size,
                        fileType: file.type || 'text/csv'
                    }
                }
            );

            // Enable import button
            const importBtn = document.getElementById('import-btn');
            if (importBtn) {
                importBtn.disabled = false;
            }

        } catch (error) {
            this.uiManager.showStatusBar(
                error.message,
                'error',
                {
                    autoDismiss: false,
                    errorId: 'file-selection-error',
                    source: 'file-upload'
                }
            );
            
            // Clear file input
            const fileInput = document.getElementById('csv-file');
            if (fileInput) {
                fileInput.value = '';
            }
        }
    }

    /**
     * Format file size in human-readable format
     * @param {number} bytes - File size in bytes
     * @returns {string} Formatted file size
     */
    formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
    /**
     * Update file info UI
     */
    updateFileInfoUI(file) {
        const fileInfoElement = document.getElementById('file-info');
        if (fileInfoElement) {
            fileInfoElement.innerHTML = `
                <div class="file-info">
                    <strong>Selected File:</strong> ${file.name}<br>
                    <strong>Size:</strong> ${this.formatFileSize(file.size)}<br>
                    <strong>Type:</strong> ${file.type || 'CSV'}
                </div>
            `;
        }
    }
    
    /**
     * Clean up connections and resources
     */
    cleanupConnections() {
        if (this.socket) {
            this.socket.disconnect();
            this.socket = null;
        }
        
        if (this.fallbackPolling) {
            clearInterval(this.fallbackPolling);
            this.fallbackPolling = null;
        }
        
        this.isImporting = false;
    }
    
    /**
     * Set up fallback polling if Socket.IO fails
     */
    setupFallbackPolling(sessionId) {
        this.fallbackPolling = setInterval(async () => {
            try {
                const response = await this.localClient.get(`/api/import/status/${sessionId}`);
                if (response.data) {
                    this.handleProgressUpdate(response.data);
                }
            } catch (error) {
                this.logger.error('Fallback polling failed', error);
            }
        }, 2000);
    }
    
    /**
     * Set up cross-subsystem event listeners
     */
    setupCrossSubsystemEvents() {
        if (!this.eventBus) {
            this.logger.warn('EventBus not available for cross-subsystem events');
            return;
        }
        
        // Listen for token expiration events
        this.eventBus.on('tokenExpired', (data) => {
            this.logger.warn('Token expired during import operation');
            if (this.isImporting) {
                this.cleanupConnections();
                this.uiManager.showError('Session Expired', 'Your authentication token expired during the import. Please re-authenticate and try again.');
            }
        });
        
        // Listen for token error events
        this.eventBus.on('tokenError', (data) => {
            this.logger.error('Token error detected', data);
            if (this.isImporting) {
                this.cleanupConnections();
                this.uiManager.showError('Authentication Error', `Authentication failed: ${data.error}`);
            }
        });
        
        // Listen for token refresh events
        this.eventBus.on('tokenRefreshed', (data) => {
            this.logger.info('Token refreshed successfully');
            // Token refresh is handled automatically, just log for now
        });
        
        // Listen for population change events
        this.eventBus.on('populationsChanged', (data) => {
            this.logger.info('Populations changed, refreshing import dropdown', { count: data.count });
            this.refreshPopulationDropdown();
        });
        
        this.logger.debug('Cross-subsystem event listeners set up for ImportSubsystem');
    }
    
    /**
     * Refresh the population dropdown for import
     */
    refreshPopulationDropdown() {
        // Use PopulationService directly instead of going through app
        if (this.populationService) {
            this.populationService.populateDropdown('import-population-select', {
                includeEmpty: true,
                emptyText: 'Select a population'
            })
                .then(() => {
                    this.logger.debug('Import population dropdown refreshed successfully');
                })
                .catch(error => {
                    this.logger.error('Failed to refresh import population dropdown', error);
                    this.uiManager.showError('Population Refresh Failed', 'Failed to refresh population dropdown.');
                });
        } else {
            this.logger.warn('PopulationService not available for dropdown refresh');
        }
    }
}


/* From: public/js/modules/export-subsystem.js */
/**
 * Export Management Subsystem
 * 
 * Handles all user export operations with proper separation of concerns.
 * Manages export configuration, progress tracking, and file generation.
 */

export class ExportSubsystem {
    constructor(logger, uiManager, localClient, settingsSubsystem, eventBus, populationService) {
        this.logger = logger;
        this.uiManager = uiManager;
        this.localClient = localClient;
        this.settingsSubsystem = settingsSubsystem;
        this.eventBus = eventBus;
        this.populationService = populationService;
        
        // Export state management
        this.isExporting = false;
        this.selectedPopulationId = null;
        this.selectedPopulationName = null;
        
        this.logger.info('Export Subsystem initialized');
        
        // Set up event listeners for cross-subsystem communication
        this.setupCrossSubsystemEvents();
    }
    
    /**
     * Initialize the export subsystem
     */
    async init() {
        try {
            this.setupEventListeners();
            await this.loadPopulations();
            this.logger.info('Export Subsystem initialized successfully');
        } catch (error) {
            this.logger.error('Failed to initialize Export Subsystem', error);
            // TODO: Refactor: Use Notification or Modal from UI subsystem instead of alert.
            this.uiManager.showError('Failed to Initialize Export Subsystem', error.message);
        }
    }
    
    /**
     * Set up event listeners for export-related elements
     */
    setupEventListeners() {
        // Export button
        const exportBtn = document.getElementById('export-btn');
        if (exportBtn) {
            exportBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                await this.startExport();
            });
        }
        
        // Population selection change
        const populationSelect = document.getElementById('export-population-select');
        if (populationSelect) {
            populationSelect.addEventListener('change', (e) => {
                this.handlePopulationChange(e.target.value);
            });
        }
        
        // Export format selection
        const formatSelect = document.getElementById('export-format');
        if (formatSelect) {
            formatSelect.addEventListener('change', (e) => {
                this.handleFormatChange(e.target.value);
            });
        }
    }
    
    /**
     * Start the export process
     */
    async startExport() {
        if (this.isExporting) {
            this.logger.warn('Export already in progress');
            return;
        }
        
        try {
            this.isExporting = true;
            this.logger.info('Starting export process');
            
            // Validate prerequisites
            if (!await this.validateExportPrerequisites()) {
                return;
            }
            
            // Get export configuration
            const config = this.getExportConfiguration();
            
            // Show progress UI
            this.uiManager.showProgress('Exporting...');
            
            // Execute export
            await this.executeExport(config);
            
        } catch (error) {
            this.logger.error('Export process failed', error);
            // TODO: Refactor: Use Notification or Modal from UI subsystem instead of alert.
            this.uiManager.showError('Export Failed', error.message);
        } finally {
            this.isExporting = false;
            this.uiManager.hideProgress();
        }
    }
    
    /**
     * Validate export prerequisites
     */
    async validateExportPrerequisites() {
        // Check for valid token
        const hasValidToken = await this.checkTokenStatus();
        if (!hasValidToken) {
            this.logger.warn('Export cancelled - no valid token');
            // TODO: Refactor: Use Notification or Modal from UI subsystem instead of alert.
            this.uiManager.showError('Authentication Required', 'Please get a valid token first');
            return false;
        }
        
        // Check population selection
        const populationSelect = document.getElementById('export-population-select');
        if (!populationSelect || !populationSelect.value) {
            // TODO: Refactor: Use Notification or Modal from UI subsystem instead of alert.
            this.uiManager.showError('No Population Selected', 'Please select a population to export');
            return false;
        }
        
        return true;
    }
    
    /**
     * Get export configuration from form with comprehensive validation
     */
    getExportConfiguration() {
        const populationSelect = document.getElementById('export-population-select');
        const formatSelect = document.getElementById('export-format');
        const includeHeaders = document.getElementById('include-headers');
        const limitUsers = document.getElementById('limit-users');
        const userLimit = document.getElementById('user-limit');
        const includeInactive = document.getElementById('include-inactive-users');
        const customFields = document.getElementById('custom-fields');
        const exportFilters = document.getElementById('export-filters');
        
        const config = {
            populationId: populationSelect?.value || '',
            populationName: populationSelect?.options[populationSelect.selectedIndex]?.text || '',
            format: formatSelect?.value || 'csv',
            includeHeaders: includeHeaders?.checked !== false,
            limitUsers: limitUsers?.checked || false,
            userLimit: limitUsers?.checked ? (parseInt(userLimit?.value) || 100) : null,
            includeInactive: includeInactive?.checked || false,
            customFields: customFields?.value ? customFields.value.split(',').map(f => f.trim()).filter(f => f) : [],
            filters: exportFilters?.value ? JSON.parse(exportFilters.value || '{}') : {},
            timestamp: new Date().toISOString(),
            sessionId: this.generateSessionId()
        };
        
        // Validate configuration
        this.validateExportConfiguration(config);
        
        return config;
    }
    
    /**
     * Validate export configuration
     */
    validateExportConfiguration(config) {
        const errors = [];
        
        // Validate population selection
        if (!config.populationId && config.populationId !== 'ALL') {
            errors.push('Please select a population to export');
        }
        
        // Validate format
        const supportedFormats = ['csv', 'json', 'xlsx'];
        if (!supportedFormats.includes(config.format)) {
            errors.push(`Unsupported export format: ${config.format}`);
        }
        
        // Validate user limit
        if (config.limitUsers && (!config.userLimit || config.userLimit < 1 || config.userLimit > 10000)) {
            errors.push('User limit must be between 1 and 10,000');
        }
        
        // Validate custom fields
        if (config.customFields.length > 50) {
            errors.push('Too many custom fields specified (maximum 50)');
        }
        
        if (errors.length > 0) {
            const errorMessage = 'Export configuration validation failed:\n' + errors.join('\n');
            this.logger.error('Export configuration validation failed', { errors, config });
            throw new Error(errorMessage);
        }
        
        this.logger.info('Export configuration validated successfully', config);
    }
    
    /**
     * Generate unique session ID for export tracking
     */
    generateSessionId() {
        return `export_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    /**
     * Execute the export process with comprehensive error handling and progress tracking
     */
    async executeExport(config) {
        let progressInterval = null;
        
        try {
            this.logger.info('Executing export with config', config);
            
            // Emit export started event
            this.eventBus.emit('exportStarted', { config, sessionId: config.sessionId });
            
            // Show initial progress
            this.updateExportProgress(0, 100, 'Initializing export...');
            
            // Pre-export validation
            await this.validateExportPrerequisites();
            this.updateExportProgress(10, 100, 'Validating prerequisites...');
            
            // Send export request with enhanced configuration
            const exportRequest = {
                ...config,
                clientInfo: {
                    userAgent: navigator.userAgent,
                    timestamp: new Date().toISOString(),
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
                }
            };
            
            this.updateExportProgress(20, 100, 'Sending export request...');
            const response = await this.localClient.post('/api/export', exportRequest);
            
            if (!response.success) {
                throw new Error(response.error || 'Export request failed');
            }
            
            // Handle different response types
            if (response.sessionId) {
                // Long-running export with progress tracking
                await this.trackExportProgress(response.sessionId, config);
            } else if (response.downloadUrl) {
                // Direct download
                this.updateExportProgress(90, 100, 'Preparing download...');
                await this.downloadFile(response.downloadUrl, response.filename);
                this.updateExportProgress(100, 100, 'Export completed successfully');
            } else if (response.data) {
                // Inline data
                this.updateExportProgress(90, 100, 'Processing export data...');
                await this.downloadData(response.data, config.format, config.populationName);
                this.updateExportProgress(100, 100, 'Export completed successfully');
            } else {
                throw new Error('Invalid export response format');
            }
            
            // Record export success
            await this.recordExportHistory(config, 'success');
            
            this.logger.info('Export completed successfully', { sessionId: config.sessionId });
            this.uiManager.showSuccess('Export completed successfully');
            
            // Emit export completed event
            this.eventBus.emit('exportCompleted', { config, sessionId: config.sessionId });
            
        } catch (error) {
            this.logger.error('Export execution failed', { error: error.message, config });
            
            // Record export failure
            await this.recordExportHistory(config, 'failed', error.message);
            
            // Emit export failed event
            this.eventBus.emit('exportFailed', { config, error: error.message, sessionId: config.sessionId });
            
            // Enhanced error handling
            await this.handleExportError(error, config);
            
            throw error;
        } finally {
            if (progressInterval) {
                clearInterval(progressInterval);
            }
            this.hideExportProgress();
        }
    }
    
    /**
     * Track export progress for long-running exports
     */
    async trackExportProgress(sessionId, config) {
        return new Promise((resolve, reject) => {
            const eventSource = new EventSource(`/api/export/progress/${sessionId}`);
            let lastProgress = 0;
            
            eventSource.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.type === 'progress') {
                        lastProgress = data.progress;
                        this.updateExportProgress(
                            data.current || data.progress,
                            data.total || 100,
                            data.message || `Exporting... ${data.progress}%`
                        );
                    } else if (data.type === 'complete') {
                        eventSource.close();
                        if (data.downloadUrl) {
                            this.downloadFile(data.downloadUrl, data.filename);
                        }
                        resolve(data);
                    } else if (data.type === 'error') {
                        eventSource.close();
                        reject(new Error(data.message || 'Export failed'));
                    }
                } catch (parseError) {
                    this.logger.error('Failed to parse progress data', parseError);
                }
            };
            
            eventSource.onerror = (error) => {
                this.logger.error('Export progress tracking error', error);
                eventSource.close();
                
                // Fallback to polling if SSE fails
                this.trackExportProgressViaPolling(sessionId, resolve, reject);
            };
            
            // Timeout after 10 minutes
            setTimeout(() => {
                if (eventSource.readyState !== EventSource.CLOSED) {
                    eventSource.close();
                    reject(new Error('Export timeout - operation took too long'));
                }
            }, 600000);
        });
    }
    
    /**
     * Fallback progress tracking via polling
     */
    async trackExportProgressViaPolling(sessionId, resolve, reject) {
        const pollInterval = setInterval(async () => {
            try {
                const response = await this.localClient.get(`/api/export/status/${sessionId}`);
                
                if (response.status === 'completed') {
                    clearInterval(pollInterval);
                    if (response.downloadUrl) {
                        this.downloadFile(response.downloadUrl, response.filename);
                    }
                    resolve(response);
                } else if (response.status === 'failed') {
                    clearInterval(pollInterval);
                    reject(new Error(response.error || 'Export failed'));
                } else if (response.status === 'processing') {
                    this.updateExportProgress(
                        response.progress || 50,
                        100,
                        response.message || 'Processing export...'
                    );
                }
            } catch (error) {
                this.logger.error('Export polling error', error);
                clearInterval(pollInterval);
                reject(error);
            }
        }, 2000); // Poll every 2 seconds
    }
    
    /**
     * Update export progress UI
     */
    updateExportProgress(current, total, message) {
        const percentage = Math.round((current / total) * 100);
        
        // Update progress bar
        const progressBar = document.getElementById('export-progress-bar');
        if (progressBar) {
            progressBar.style.width = `${percentage}%`;
            progressBar.setAttribute('aria-valuenow', percentage);
        }
        
        // Update progress text
        const progressText = document.getElementById('export-progress-text');
        if (progressText) {
            progressText.textContent = `${message} (${percentage}%)`;
        }
        
        // Update via UIManager if available
        if (this.uiManager && typeof this.uiManager.updateProgress === 'function') {
            this.uiManager.updateProgress(percentage, message);
        }
        
        this.logger.debug('Export progress updated', { current, total, percentage, message });
    }
    
    /**
     * Handle export errors with recovery options
     */
    async handleExportError(error, config) {
        const errorType = this.categorizeError(error);
        
        switch (errorType) {
            case 'network':
                this.uiManager.showError('Network Error', 'Export failed due to network issues. Please check your connection and try again.');
                break;
            case 'authentication':
                this.uiManager.showError('Authentication Error', 'Your session has expired. Please re-authenticate and try again.');
                // Emit token refresh request
                this.eventBus.emit('tokenRefreshRequired', { source: 'export', config });
                break;
            case 'validation':
                this.uiManager.showError('Validation Error', `Export configuration is invalid: ${error.message}`);
                break;
            case 'server':
                this.uiManager.showError('Server Error', 'Export failed due to a server error. Please try again later.');
                break;
            default:
                this.uiManager.showError('Export Error', `Export failed: ${error.message}`);
        }
    }
    
    /**
     * Categorize error for appropriate handling
     */
    categorizeError(error) {
        const message = error.message.toLowerCase();
        
        if (message.includes('network') || message.includes('fetch')) {
            return 'network';
        } else if (message.includes('unauthorized') || message.includes('token') || message.includes('expired')) {
            return 'authentication';
        } else if (message.includes('validation') || message.includes('invalid')) {
            return 'validation';
        } else if (message.includes('server') || message.includes('internal')) {
            return 'server';
        }
        
        return 'unknown';
    }
    
    /**
     * Record export operation in history
     */
    async recordExportHistory(config, status, errorMessage = null) {
        try {
            const historyEntry = {
                sessionId: config.sessionId,
                timestamp: new Date().toISOString(),
                populationId: config.populationId,
                populationName: config.populationName,
                format: config.format,
                userLimit: config.userLimit,
                status,
                errorMessage,
                duration: Date.now() - new Date(config.timestamp).getTime()
            };
            
            // Store in local storage for history tracking
            const history = JSON.parse(localStorage.getItem('exportHistory') || '[]');
            history.unshift(historyEntry);
            
            // Keep only last 50 entries
            if (history.length > 50) {
                history.splice(50);
            }
            
            localStorage.setItem('exportHistory', JSON.stringify(history));
            
            this.logger.info('Export history recorded', historyEntry);
        } catch (error) {
            this.logger.error('Failed to record export history', error);
        }
    }
    
    /**
     * Download file from URL with enhanced error handling
     */
    async downloadFile(url, filename) {
        try {
            this.logger.info('Starting file download', { url, filename });
            
            // Create download link
            const link = document.createElement('a');
            link.href = url;
            link.download = filename || `export_${Date.now()}.csv`;
            link.style.display = 'none';
            
            // Add to DOM temporarily
            document.body.appendChild(link);
            
            // Trigger download
            link.click();
            
            // Clean up
            setTimeout(() => {
                document.body.removeChild(link);
                if (url.startsWith('blob:')) {
                    URL.revokeObjectURL(url);
                }
            }, 100);
            
            this.logger.info('File download initiated successfully', { filename });
            
        } catch (error) {
            this.logger.error('File download failed', { error: error.message, url, filename });
            throw new Error(`Download failed: ${error.message}`);
        }
    }
    
    /**
     * Download data as file with comprehensive format support
     */
    async downloadData(data, format, populationName) {
        try {
            this.logger.info('Processing data for download', { format, populationName, recordCount: Array.isArray(data) ? data.length : 'unknown' });
            
            let content, mimeType, extension;
            
            switch (format.toLowerCase()) {
                case 'json':
                    content = JSON.stringify(data, null, 2);
                    mimeType = 'application/json';
                    extension = 'json';
                    break;
                case 'xlsx':
                    content = await this.convertToXLSX(data);
                    mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
                    extension = 'xlsx';
                    break;
                case 'csv':
                default:
                    content = this.convertToCSV(data);
                    mimeType = 'text/csv;charset=utf-8';
                    extension = 'csv';
                    break;
            }
            
            // Create blob with proper encoding
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            
            // Generate descriptive filename
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            const sanitizedPopulationName = (populationName || 'export').replace(/[^a-zA-Z0-9_-]/g, '_');
            const filename = `${sanitizedPopulationName}_${timestamp}.${extension}`;
            
            await this.downloadFile(url, filename);
            
            this.logger.info('Data download completed successfully', { filename, format });
            
        } catch (error) {
            this.logger.error('Data download failed', { error: error.message, format, populationName });
            throw new Error(`Failed to download data: ${error.message}`);
        }
    }
    
    /**
     * Hide export progress UI
     */
    hideExportProgress() {
        // Hide progress bar
        const progressContainer = document.getElementById('export-progress-container');
        if (progressContainer) {
            progressContainer.style.display = 'none';
        }
        
        // Reset progress elements
        const progressBar = document.getElementById('export-progress-bar');
        if (progressBar) {
            progressBar.style.width = '0%';
            progressBar.setAttribute('aria-valuenow', 0);
        }
        
        const progressText = document.getElementById('export-progress-text');
        if (progressText) {
            progressText.textContent = '';
        }
        
        // Hide via UIManager if available
        if (this.uiManager && typeof this.uiManager.hideProgress === 'function') {
            this.uiManager.hideProgress();
        }
        
        this.logger.debug('Export progress UI hidden');
    }
    
    /**
     * Convert data to XLSX format (placeholder for future implementation)
     */
    async convertToXLSX(data) {
        // For now, fall back to CSV until XLSX library is integrated
        this.logger.warn('XLSX export not yet implemented, falling back to CSV');
        return this.convertToCSV(data);
    }
    
    /**
     * Convert data to CSV format
     */
    convertToCSV(data) {
        if (!Array.isArray(data) || data.length === 0) {
            return '';
        }
        
        // Get headers from first object
        const headers = Object.keys(data[0]);
        const csvHeaders = headers.join(',');
        
        // Convert data rows
        const csvRows = data.map(row => {
            return headers.map(header => {
                const value = row[header];
                // Escape commas and quotes
                if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
                    return `"${value.replace(/"/g, '""')}"`;
                }
                return value || '';
            }).join(',');
        });
        
        return [csvHeaders, ...csvRows].join('\n');
    }
    
    /**
     * Load populations for dropdown
     */
    async loadPopulations() {
        try {
            const response = await this.localClient.get('/api/populations');
            
            if (response.success && response.populations) {
                this.populateDropdown(response.populations);
            }
            
        } catch (error) {
            this.logger.error('Failed to load populations', error);
            // TODO: Refactor: Use Notification or Modal from UI subsystem instead of alert.
            this.uiManager.showError('Failed to Load Populations', error.message);
        }
    }
    
    /**
     * Populate the population dropdown
     */
    populateDropdown(populations) {
        const select = document.getElementById('export-population-select');
        if (!select) return;
        
        // Clear existing options
        select.innerHTML = '<option value="">Select Population</option>';
        
        // Add population options
        populations.forEach(pop => {
            const option = document.createElement('option');
            option.value = pop.id;
            option.textContent = pop.name;
            select.appendChild(option);
        });
    }
    
    /**
     * Handle population selection change
     */
    handlePopulationChange(populationId) {
        this.selectedPopulationId = populationId;
        
        const select = document.getElementById('export-population-select');
        if (select) {
            const selectedOption = select.options[select.selectedIndex];
            this.selectedPopulationName = selectedOption?.text || '';
        }
        
        this.logger.info('Population selection changed', {
            id: this.selectedPopulationId,
            name: this.selectedPopulationName
        });
        
        // Update UI based on selection
        this.updateExportOptions();
    }
    
    /**
     * Handle export format change
     */
    handleFormatChange(format) {
        this.logger.info('Export format changed', { format });
        
        // Update UI based on format selection
        this.updateFormatOptions(format);
    }
    
    /**
     * Update export options based on population selection
     */
    updateExportOptions() {
        const exportBtn = document.getElementById('export-btn');
        if (exportBtn) {
            exportBtn.disabled = !this.selectedPopulationId;
        }
        
        // Show/hide additional options based on population
        if (this.selectedPopulationId) {
            this.showExportOptions();
        } else {
            this.hideExportOptions();
        }
    }
    
    /**
     * Update format-specific options
     */
    updateFormatOptions(format) {
        const headersOption = document.getElementById('headers-option');
        if (headersOption) {
            headersOption.style.display = format === 'csv' ? 'block' : 'none';
        }
    }
    
    /**
     * Show export options
     */
    showExportOptions() {
        const optionsContainer = document.getElementById('export-options');
        if (optionsContainer) {
            optionsContainer.style.display = 'block';
        }
    }
    
    /**
     * Hide export options
     */
    hideExportOptions() {
        const optionsContainer = document.getElementById('export-options');
        if (optionsContainer) {
            optionsContainer.style.display = 'none';
        }
    }
    
    /**
     * Show export progress
     */
    showExportProgress() {
        const progressContainer = document.getElementById('export-progress');
        if (progressContainer) {
            progressContainer.style.display = 'block';
        }
        
        const exportBtn = document.getElementById('export-btn');
        if (exportBtn) {
            exportBtn.disabled = true;
            exportBtn.textContent = 'Exporting...';
        }
    }
    
    /**
     * Hide export progress
     */
    hideExportProgress() {
        const progressContainer = document.getElementById('export-progress');
        if (progressContainer) {
            progressContainer.style.display = 'none';
        }
        
        const exportBtn = document.getElementById('export-btn');
        if (exportBtn) {
            exportBtn.disabled = false;
            exportBtn.textContent = 'Export Users';
        }
    }
    
    /**
     * Check token status
     */
    async checkTokenStatus() {
        try {
            const response = await this.localClient.get('/api/token/status');
            return response.valid;
        } catch (error) {
            this.logger.error('Token status check failed', error);
            return false;
        }
    }
    
    /**
     * Set up cross-subsystem event listeners
     */
    setupCrossSubsystemEvents() {
        if (!this.eventBus) {
            this.logger.warn('EventBus not available for cross-subsystem events');
            return;
        }
        
        // Listen for token expiration events
        this.eventBus.on('tokenExpired', (data) => {
            this.logger.warn('Token expired during export operation');
            if (this.isExporting) {
                this.isExporting = false;
                this.hideExportProgress();
                this.uiManager.showError('Session Expired', 'Your authentication token expired during the export. Please re-authenticate and try again.');
            }
        });
        
        // Listen for token error events
        this.eventBus.on('tokenError', (data) => {
            this.logger.error('Token error detected', data);
            if (this.isExporting) {
                this.isExporting = false;
                this.hideExportProgress();
                this.uiManager.showError('Authentication Error', `Authentication failed: ${data.error}`);
            }
        });
        
        // Listen for token refresh events
        this.eventBus.on('tokenRefreshed', (data) => {
            this.logger.info('Token refreshed successfully');
            // Token refresh is handled automatically, just log for now
        });
        
        // Listen for population change events
        this.eventBus.on('populationsChanged', (data) => {
            this.logger.info('Populations changed, refreshing export dropdown', { count: data.count });
            this.refreshPopulationDropdown();
        });
        
        this.logger.debug('Cross-subsystem event listeners set up for ExportSubsystem');
    }
    
    /**
     * Refresh the population dropdown for export
     */
    refreshPopulationDropdown() {
        // Use PopulationService directly instead of going through app
        if (this.populationService) {
            this.populationService.populateDropdown('export-population-select', {
                includeEmpty: true,
                emptyText: 'Select a population'
            })
                .then(() => {
                    this.logger.debug('Export population dropdown refreshed successfully');
                })
                .catch(error => {
                    this.logger.error('Failed to refresh export population dropdown', error);
                    this.uiManager.showError('Population Refresh Failed', 'Failed to refresh population dropdown.');
                });
        } else {
            this.logger.warn('PopulationService not available for dropdown refresh');
        }
    }
}


/* From: public/js/modules/export-manager.js */
/**
 * Export Manager - Enhanced export functionality with population selection, credential overrides, token handling, and JWT decoding
 * Handles all export operations with comprehensive token management and user transparency
 */

class ExportManager {
    constructor() {
        this.exportToken = null;
        this.tokenExpiration = null;
        this.tokenTimer = null;
        this.overrideCredentials = false;
        this.populations = [];
        this.logger = console;
        
        // Only initialize if we're on a page with export functionality
        if (document.getElementById('export-population-select') || 
            document.getElementById('export-format') || 
            document.getElementById('start-export')) {
            try {
                this.initializeEventListeners();
                this.loadPopulations();
                this.loadStoredCredentials();
                this.startTokenTimer();
            } catch (error) {
                console.warn('ExportManager initialization warning:', error);
            }
        }
    }

    initializeEventListeners() {
        // Population selection
        const populationSelect = document.getElementById('export-population-select');
        if (populationSelect) {
            populationSelect.addEventListener('change', (e) => {
                this.validateExportButton();
                this.logPopulationSelection();
            });
        }

        // Credential override toggle
        const overrideCheckbox = document.getElementById('export-use-override-credentials');
        if (overrideCheckbox) {
            overrideCheckbox.addEventListener('change', (e) => {
                this.toggleCredentialsOverride(e.target.checked);
            });
        }

        // Generate export token
        const generateTokenBtn = document.getElementById('generate-export-token');
        if (generateTokenBtn) {
            generateTokenBtn.addEventListener('click', () => {
                this.generateExportToken();
            });
        }

        // View raw token
        const viewTokenBtn = document.getElementById('view-export-token');
        if (viewTokenBtn) {
            viewTokenBtn.addEventListener('click', () => {
                this.showJWTDecoder();
            });
        }

        // Refresh token
        const refreshTokenBtn = document.getElementById('refresh-export-token');
        if (refreshTokenBtn) {
            refreshTokenBtn.addEventListener('click', () => {
                this.refreshExportToken();
            });
        }

        // JWT panel close
        const closeJwtBtn = document.getElementById('close-jwt-panel');
        if (closeJwtBtn) {
            closeJwtBtn.addEventListener('click', () => {
                this.hideJWTDecoder();
            });
        }

        // Copy buttons
        this.setupCopyButtons();

        // Start export
        const startExportBtn = document.getElementById('start-export');
        if (startExportBtn) {
            startExportBtn.addEventListener('click', () => {
                this.startExport();
            });
        }

        // Secret visibility toggle
        const toggleSecretBtn = document.getElementById('toggle-export-secret-visibility');
        if (toggleSecretBtn) {
            toggleSecretBtn.addEventListener('click', () => {
                this.toggleSecretVisibility();
            });
        }
    }

    async loadPopulations() {
        try {
            // Check if population select element exists before making API call
            const populationSelect = document.getElementById('export-population-select');
            if (!populationSelect) {
                console.log('Export population select not found, skipping population load');
                return;
            }
            
            this.logPopulationLoadStart();
            const response = await fetch('/api/populations');
            if (response.ok) {
                const data = await response.json();
                // Handle the API response structure: { success: true, populations: [...], total: 123 }
                const populations = data.populations || data;
                if (Array.isArray(populations)) {
                    this.populations = populations;
                    this.populatePopulationSelect(populations);
                    this.logPopulationLoadSuccess(populations.length);
                } else {
                    console.error('Invalid populations data format:', populations);
                    this.logPopulationLoadError('Invalid populations data format');
                }
            } else {
                console.error('Failed to load populations');
                this.logPopulationLoadError('Failed to load populations');
            }
        } catch (error) {
            console.error('Error loading populations:', error);
            this.logPopulationLoadError(error.message);
        }
    }

    populatePopulationSelect(populations) {
        const select = document.getElementById('export-population-select');
        if (!select) return;

        // Keep the existing ALL option and add populations
        const allOption = select.querySelector('option[value="ALL"]');
        select.innerHTML = '<option value="">Select a population...</option>';
        
        if (allOption) {
            select.appendChild(allOption);
        }
        
        populations.forEach(population => {
            const option = document.createElement('option');
            option.value = population.id;
            option.textContent = population.name;
            select.appendChild(option);
        });
    }

    toggleCredentialsOverride(enabled) {
        this.overrideCredentials = enabled;
        const credentialsFields = document.getElementById('export-credentials-form');
        const tokenStatus = document.getElementById('export-token-status');
        
        if (enabled) {
            credentialsFields.style.display = 'block';
            this.loadStoredCredentials();
        } else {
            credentialsFields.style.display = 'none';
            tokenStatus.style.display = 'none';
            this.clearExportToken();
        }
        
        this.validateExportButton();
        this.logCredentialOverride(enabled);
    }

    loadStoredCredentials() {
        try {
            const stored = localStorage.getItem('exportCredentials');
            if (stored) {
                const credentials = JSON.parse(stored);
                document.getElementById('export-environment-id').value = credentials.environmentId || '';
                document.getElementById('export-api-client-id').value = credentials.apiClientId || '';
                document.getElementById('export-api-secret').value = credentials.apiSecret || '';
                document.getElementById('export-region').value = credentials.region || 'NA';
            }
        } catch (error) {
            console.error('Error loading stored credentials:', error);
        }
    }

    saveCredentials() {
        try {
            const credentials = {
                environmentId: document.getElementById('export-environment-id').value,
                apiClientId: document.getElementById('export-api-client-id').value,
                apiSecret: document.getElementById('export-api-secret').value,
                region: document.getElementById('export-region').value
            };
            localStorage.setItem('exportCredentials', JSON.stringify(credentials));
        } catch (error) {
            console.error('Error saving credentials:', error);
        }
    }

    async generateExportToken() {
        try {
            const credentials = this.getExportCredentials();
            if (!credentials) {
                this.showError('Please fill in all credential fields');
                return;
            }

            this.saveCredentials();
            
            const response = await fetch('/api/export-token', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(credentials)
            });

            if (response.ok) {
                const result = await response.json();
                this.setExportToken(result.token, result.expiresAt);
                this.logTokenGeneration('success');
            } else {
                const error = await response.json();
                this.showError('Failed to generate token: ' + error.message);
                this.logTokenGeneration('error', error.message);
            }
        } catch (error) {
            this.showError('Error generating token: ' + error.message);
            this.logTokenGeneration('error', error.message);
        }
    }

    async refreshExportToken() {
        if (!this.overrideCredentials) {
            this.showError('Credential override must be enabled to refresh token');
            return;
        }
        await this.generateExportToken();
    }

    getExportCredentials() {
        const environmentId = document.getElementById('export-environment-id').value;
        const apiClientId = document.getElementById('export-api-client-id').value;
        const apiSecret = document.getElementById('export-api-secret').value;
        const region = document.getElementById('export-region').value;

        if (!environmentId || !apiClientId || !apiSecret) {
            return null;
        }

        return {
            environmentId,
            apiClientId,
            apiSecret,
            region
        };
    }

    setExportToken(token, expiresAt) {
        this.exportToken = token;
        this.tokenExpiration = new Date(expiresAt);
        
        // Store in localStorage
        localStorage.setItem('exportToken', token);
        localStorage.setItem('exportTokenExpires', expiresAt);
        
        // Show token status
        document.getElementById('export-token-status').style.display = 'block';
        
        // Update token metadata
        this.updateTokenMetadata();
        
        // Start timer
        this.startTokenTimer();
        
        this.validateExportButton();
        this.logTokenSet();
    }

    clearExportToken() {
        this.exportToken = null;
        this.tokenExpiration = null;
        
        // Clear from localStorage
        localStorage.removeItem('exportToken');
        localStorage.removeItem('exportTokenExpires');
        
        // Hide token status
        document.getElementById('export-token-status').style.display = 'none';
        
        // Stop timer
        if (this.tokenTimer) {
            clearInterval(this.tokenTimer);
            this.tokenTimer = null;
        }
        
        this.validateExportButton();
    }

    startTokenTimer() {
        if (this.tokenTimer) {
            clearInterval(this.tokenTimer);
        }
        
        this.tokenTimer = setInterval(() => {
            this.updateTokenTimer();
        }, 1000);
        
        this.updateTokenTimer();
    }

    updateTokenTimer() {
        if (!this.tokenExpiration) return;
        
        const now = new Date();
        const timeLeft = this.tokenExpiration.getTime() - now.getTime();
        
        if (timeLeft <= 0) {
            // Token expired
            this.clearExportToken();
            this.showError('Export token has expired. Please generate a new token.');
            return;
        }
        
        const minutes = Math.floor(timeLeft / 60000);
        const seconds = Math.floor((timeLeft % 60000) / 1000);
        const timerText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        document.getElementById('export-token-timer').textContent = timerText;
        
        // Update status indicator
        const indicator = document.getElementById('export-token-status-indicator');
        if (timeLeft < 300000) { // Less than 5 minutes
            indicator.className = 'token-status-indicator expired';
        } else if (timeLeft < 600000) { // Less than 10 minutes
            indicator.className = 'token-status-indicator warning';
        } else {
            indicator.className = 'token-status-indicator valid';
        }
    }

    updateTokenMetadata() {
        if (!this.exportToken) return;
        
        try {
            const decoded = this.decodeJWT(this.exportToken);
            
            document.getElementById('export-token-scopes').textContent = decoded.payload.scope || '--';
            document.getElementById('export-token-environment').textContent = decoded.payload.env || '--';
            document.getElementById('export-token-expires').textContent = new Date(decoded.payload.exp * 1000).toISOString();
        } catch (error) {
            console.error('Error updating token metadata:', error);
        }
    }

    decodeJWT(token) {
        const parts = token.split('.');
        if (parts.length !== 3) {
            throw new Error('Invalid JWT format');
        }
        
        const header = JSON.parse(atob(parts[0]));
        const payload = JSON.parse(atob(parts[1]));
        const signature = parts[2];
        
        return {
            header,
            payload,
            signature,
            raw: token
        };
    }

    showJWTDecoder() {
        if (!this.exportToken) {
            this.showError('No export token available');
            return;
        }
        
        try {
            const decoded = this.decodeJWT(this.exportToken);
            
            document.getElementById('export-jwt-raw').textContent = decoded.raw;
            document.getElementById('export-jwt-header').textContent = JSON.stringify(decoded.header, null, 2);
            document.getElementById('export-jwt-payload').textContent = JSON.stringify(decoded.payload, null, 2);
            document.getElementById('export-jwt-signature').textContent = decoded.signature;
            
            document.getElementById('export-jwt-panel').style.display = 'block';
            this.logJWTView();
        } catch (error) {
            this.showError('Error decoding JWT: ' + error.message);
        }
    }

    hideJWTDecoder() {
        document.getElementById('export-jwt-panel').style.display = 'none';
    }

    setupCopyButtons() {
        const copyButtons = [
            { id: 'copy-jwt-raw', target: 'export-jwt-raw' },
            { id: 'copy-jwt-header', target: 'export-jwt-header' },
            { id: 'copy-jwt-payload', target: 'export-jwt-payload' },
            { id: 'copy-jwt-signature', target: 'export-jwt-signature' }
        ];
        
        copyButtons.forEach(button => {
            const btn = document.getElementById(button.id);
            if (btn) {
                btn.addEventListener('click', () => {
                    this.copyToClipboard(button.target);
                });
            }
        });
    }

    async copyToClipboard(elementId) {
        try {
            const element = document.getElementById(elementId);
            const text = element.textContent;
            await navigator.clipboard.writeText(text);
            this.showSuccess('Copied to clipboard');
        } catch (error) {
            console.error('Error copying to clipboard:', error);
            this.showError('Failed to copy to clipboard');
        }
    }

    toggleSecretVisibility() {
        const secretInput = document.getElementById('export-api-secret');
        const toggleBtn = document.getElementById('toggle-export-secret-visibility');
        const icon = toggleBtn.querySelector('i');
        
        if (secretInput.type === 'password') {
            secretInput.type = 'text';
            icon.className = 'fas fa-eye-slash';
        } else {
            secretInput.type = 'password';
            icon.className = 'fas fa-eye';
        }
    }

    validateExportButton() {
        const startExportBtn = document.getElementById('start-export');
        const populationSelect = document.getElementById('export-population-select');
        
        if (!startExportBtn || !populationSelect) return;
        
        const hasPopulation = populationSelect.value;
        const hasToken = this.overrideCredentials ? this.exportToken : true;
        
        startExportBtn.disabled = !hasPopulation || !hasToken;
    }

    async startExport() {
        const populationSelect = document.getElementById('export-population-select');
        const selectedPopulation = populationSelect.value;
        
        if (!selectedPopulation) {
            this.showError('Please select a population');
            return;
        }
        
        if (this.overrideCredentials && !this.exportToken) {
            this.showError('Please generate an export token first');
            return;
        }
        
        try {
            const exportOptions = this.getExportOptions();
            this.logExportStart(exportOptions);
            
            // Show export status
            if (window.uiManager) {
                window.uiManager.showExportStatus();
            }
            
            // Send export request
            const response = await fetch('/api/export-users', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(exportOptions)
            });
            
            if (response.ok) {
                const result = await response.json();
                this.showSuccess('Export completed successfully', result.message);
                this.logExportSuccess(result);
                this.showExportReminder();
            } else {
                const error = await response.json();
                this.showError('Export failed: ' + error.message);
                this.logExportError(error.message);
            }
        } catch (error) {
            this.showError('Export failed: ' + error.message);
            this.logExportError(error.message);
        }
    }

    getExportOptions() {
        const populationSelect = document.getElementById('export-population-select');
        const selectedPopulation = populationSelect.value;
        const selectedPopulationName = populationSelect.selectedOptions[0]?.text || '';
        
        return {
            populationId: selectedPopulation,
            populationName: selectedPopulationName,
            userStatusFilter: document.getElementById('export-population-filter').value,
            format: document.getElementById('export-format').value,
            includeDisabled: document.getElementById('export-include-disabled').checked,
            includeMetadata: document.getElementById('export-include-metadata').checked,
            useOverrideCredentials: this.overrideCredentials,
            exportToken: this.overrideCredentials ? this.exportToken : null
        };
    }

    showExportReminder() {
        if (this.overrideCredentials) {
            this.showInfo('Export completed', 'Remember to get a new token before using Import, Delete, or Modify operations.');
        }
    }

    // Logging methods
    logPopulationLoadStart() {
        if (window.logManager && typeof window.logManager.log === 'function') {
            window.logManager.log('info', 'Loading populations for export', {
                timestamp: new Date().toISOString()
            });
        } else {
            console.info('Loading populations for export:', { timestamp: new Date().toISOString() });
        }
    }

    logPopulationLoadSuccess(count) {
        if (window.logManager && typeof window.logManager.log === 'function') {
            window.logManager.log('info', 'Populations loaded successfully for export', {
                count: count,
                timestamp: new Date().toISOString()
            });
        } else {
            console.info('Populations loaded successfully for export:', { count, timestamp: new Date().toISOString() });
        }
    }

    logPopulationLoadError(error) {
        if (window.logManager && typeof window.logManager.log === 'function') {
            window.logManager.log('error', 'Failed to load populations for export', {
                error: error,
                timestamp: new Date().toISOString()
            });
        } else {
            console.error('Failed to load populations for export:', error);
        }
    }

    logPopulationSelection() {
        const populationSelect = document.getElementById('export-population-select');
        if (window.logManager && typeof window.logManager.log === 'function') {
            window.logManager.log('info', 'Population selected for export', {
                populationId: populationSelect.value,
                populationName: populationSelect.selectedOptions[0]?.text || '',
                timestamp: new Date().toISOString()
            });
        } else {
            console.info('Population selected for export:', {
                populationId: populationSelect.value,
                populationName: populationSelect.selectedOptions[0]?.text || '',
                timestamp: new Date().toISOString()
            });
        }
    }

    logCredentialOverride(enabled) {
        if (window.logManager && typeof window.logManager.log === 'function') {
            window.logManager.log('info', 'Export credential override toggled', {
                enabled: enabled,
                timestamp: new Date().toISOString()
            });
        } else {
            console.info('Export credential override toggled:', { enabled, timestamp: new Date().toISOString() });
        }
    }

    logTokenGeneration(status, error = null) {
        if (window.logManager && typeof window.logManager.log === 'function') {
            window.logManager.log(status === 'success' ? 'info' : 'error', 'Export token generation', {
                status: status,
                error: error,
                timestamp: new Date().toISOString()
            });
        } else {
            console[status === 'success' ? 'info' : 'error']('Export token generation:', { status, error, timestamp: new Date().toISOString() });
        }
    }

    logTokenSet() {
        if (window.logManager && typeof window.logManager.log === 'function') {
            window.logManager.log('info', 'Export token set', {
                hasToken: !!this.exportToken,
                expiresAt: this.tokenExpiration?.toISOString(),
                timestamp: new Date().toISOString()
            });
        } else {
            console.info('Export token set:', {
                hasToken: !!this.exportToken,
                expiresAt: this.tokenExpiration?.toISOString(),
                timestamp: new Date().toISOString()
            });
        }
    }

    logJWTView() {
        if (window.logManager && typeof window.logManager.log === 'function') {
            window.logManager.log('info', 'JWT token viewed', {
                timestamp: new Date().toISOString()
            });
        } else {
            console.info('JWT token viewed:', { timestamp: new Date().toISOString() });
        }
    }

    logExportStart(options) {
        if (window.logManager && typeof window.logManager.log === 'function') {
            window.logManager.log('info', 'Export operation started', {
                options: options,
                timestamp: new Date().toISOString()
            });
        } else {
            console.info('Export operation started:', { options, timestamp: new Date().toISOString() });
        }
    }

    logExportSuccess(result) {
        if (window.logManager && typeof window.logManager.log === 'function') {
            window.logManager.log('info', 'Export operation completed successfully', {
                result: result,
                timestamp: new Date().toISOString()
            });
        } else {
            console.info('Export operation completed successfully:', { result, timestamp: new Date().toISOString() });
        }
    }

    logExportError(error) {
        if (window.logManager && typeof window.logManager.log === 'function') {
            window.logManager.log('error', 'Export operation failed', {
                error: error,
                timestamp: new Date().toISOString()
            });
        } else {
            console.error('Export operation failed:', { error, timestamp: new Date().toISOString() });
        }
    }

    showSuccess(title, message) {
        if (window.uiManager) {
            window.uiManager.showStatusMessage('success', title, message);
        } else {
            alert(`${title}: ${message}`);
        }
    }

    showError(message) {
        if (window.uiManager) {
            window.uiManager.showStatusMessage('error', 'Export Error', message);
        } else {
            alert('Error: ' + message);
        }
    }

    showInfo(title, message) {
        if (window.uiManager) {
            window.uiManager.showStatusMessage('info', title, message);
        } else {
            console.log(`${title}: ${message}`);
        }
    }
}

// Initialize export manager when DOM is loaded
// Only initialize if export UI elements exist
function hasExportUI() {
    return document.getElementById('export-population-select') ||
           document.getElementById('export-format') ||
           document.getElementById('start-export');
}
document.addEventListener('DOMContentLoaded', () => {
    if (hasExportUI()) {
        try {
            window.exportManager = new ExportManager();
        } catch (error) {
            console.error('Failed to initialize ExportManager:', error);
        }
    } else {
        window.exportManager = null;
    }
});

// Export for ES6 module system
export { ExportManager }; 

