/**
 * Population Subsystem
 * 
 * Consolidated JavaScript for PingOne Import Tool
 * Generated: 2025-08-06T19:05:53.927Z
 * 
 * This file was automatically generated by js-cleanup-script.js
 * Organized for better maintainability and performance
 */


/* From: public/js/modules/population-subsystem.js */
/**
 * Population Subsystem
 * Centralized population management system for dropdown handling and population operations
 * Provides population loading, caching, filtering, and event integration
 */

export class PopulationSubsystem {
    constructor(eventBus, settingsSubsystem, loggingSubsystem, apiClient) {
        this.eventBus = eventBus;
        this.settingsSubsystem = settingsSubsystem;
        this.loggingSubsystem = loggingSubsystem;
        this.apiClient = apiClient;
        
        // Population cache
        this.populationCache = new Map();
        this.cacheExpiry = 5 * 60 * 1000; // 5 minutes
        this.lastCacheUpdate = null;
        
        // Population loading state
        this.isLoading = false;
        this.loadingPromise = null;
        
        // Dropdown management
        this.managedDropdowns = new Set();
        this.dropdownConfigs = new Map();
        
        // Initialize subsystem
        this.init();
        
        if (this.loggingSubsystem) {
            this.loggingSubsystem.info('PopulationSubsystem initialized successfully', {}, 'system');
        }
    }
    
    /**
     * Initialize the population subsystem
     */
    async init() {
        try {
            // Set up event listeners
            this.setupEventListeners();
            
            // Load cached populations if available
            this.loadCachedPopulations();
            
            if (this.loggingSubsystem) {
                this.loggingSubsystem.info('PopulationSubsystem initialization complete', {
                    cachedPopulations: this.populationCache.size
                }, 'system');
            }
        } catch (error) {
            if (this.loggingSubsystem) {
                this.loggingSubsystem.error('Failed to initialize PopulationSubsystem', error, 'system');
            }
            throw error;
        }
    }
    
    /**
     * Set up event listeners for cross-subsystem communication
     */
    setupEventListeners() {
        if (this.eventBus) {
            // Listen for settings changes that might affect populations
            this.eventBus.on('settingsChanged', () => {
                this.invalidateCache();
            });
            
            // Listen for authentication events
            this.eventBus.on('authenticationSuccess', () => {
                this.refreshPopulations();
            });
            
            this.eventBus.on('authenticationFailed', () => {
                this.clearCache();
            });
            
            // Listen for population refresh requests
            this.eventBus.on('refreshPopulations', (data) => {
                this.refreshPopulations(data.force);
            });
            
            // Listen for dropdown registration
            this.eventBus.on('registerDropdown', (data) => {
                this.registerDropdown(data.dropdownId, data.config);
            });
        }
    }
    
    /**
     * Load populations from API with caching
     */
    async loadPopulations(options = {}) {
        const { force = false, useCache = true } = options;
        if (this.loggingSubsystem) {
            this.loggingSubsystem.info(`[Startup] üåê Attempting to load populations...`, { force, useCache }, 'system');
        }
        try {
            // Check cache first if not forcing refresh
            if (!force && useCache && this.isCacheValid()) {
                const cached = this.getCachedPopulations();
                if (cached && cached.length > 0) {
                    if (this.loggingSubsystem) {
                        this.loggingSubsystem.info(`[Startup] üåê Populations loaded from cache: ${cached.length} entries`, {}, 'system');
                    }
                    return cached;
                }
            }
            
            // Prevent multiple simultaneous loads
            if (this.isLoading && this.loadingPromise) {
                if (this.loggingSubsystem) {
                    this.loggingSubsystem.info(`[Startup] üåê Population loading already in progress...`, {}, 'system');
                }
                return await this.loadingPromise;
            }
            
            this.isLoading = true;
            this.loadingPromise = this.performPopulationLoad();
            
            const populations = await this.loadingPromise;
            if (this.loggingSubsystem) {
                this.loggingSubsystem.info(`[Startup] üåê Populations loaded: ${populations.length} entries`, {}, 'system');
            }
            
            // Cache the results
            this.cachePopulations(populations);
            
            // Emit event for UI updates
            if (this.eventBus) {
                this.eventBus.emit('populationsLoaded', {
                    populations,
                    count: populations.length,
                    cached: false
                });
            }
            
            if (this.loggingSubsystem) {
                this.loggingSubsystem.info('Populations loaded successfully', {
                    count: populations.length
                }, 'system');
            }
            
            return populations;
            
        } catch (error) {
            if (this.loggingSubsystem) {
                this.loggingSubsystem.error('Failed to load populations', error, 'system');
            }
            
            // Emit error event
            if (this.eventBus) {
                this.eventBus.emit('populationsLoadFailed', {
                    error: error.message
                });
            }
            
            throw error;
        } finally {
            this.isLoading = false;
            this.loadingPromise = null;
        }
    }
    
    /**
     * Perform the actual population loading from API
     */
    async performPopulationLoad() {
        if (this.loggingSubsystem) {
            this.loggingSubsystem.debug('Starting performPopulationLoad', {}, 'system');
        }
        
        if (!this.apiClient) {
            const error = 'API client not available for population loading';
            if (this.loggingSubsystem) {
                this.loggingSubsystem.error(error, {}, 'system');
            }
            throw new Error(error);
        }
        
        // Check if API client has the required method
        if (typeof this.apiClient.get !== 'function') {
            const error = 'API client does not support HTTP GET requests';
            if (this.loggingSubsystem) {
                this.loggingSubsystem.error(error, { apiClientType: typeof this.apiClient }, 'system');
            }
            throw new Error(error);
        }
        
        if (this.loggingSubsystem) {
            this.loggingSubsystem.debug('Making API call to /api/populations', {}, 'system');
        }
        
        try {
            // Load populations from API using the /api/populations endpoint
            const response = await this.apiClient.get('/api/populations');
            
            if (this.loggingSubsystem) {
                this.loggingSubsystem.debug('API response received', { 
                    hasResponse: !!response, 
                    hasPopulations: !!(response && response.populations),
                    populationsIsArray: !!(response && Array.isArray(response.populations)),
                    populationCount: response && response.populations ? response.populations.length : 0
                }, 'system');
            }
            
            if (!response || !Array.isArray(response.populations)) {
                const error = 'Invalid populations response from API';
                if (this.loggingSubsystem) {
                    this.loggingSubsystem.error(error, { response }, 'system');
                }
                throw new Error(error);
            }
            
            if (this.loggingSubsystem) {
                this.loggingSubsystem.info(`Successfully loaded ${response.populations.length} populations from API`, {}, 'system');
            }
            
            return response.populations;
            
        } catch (apiError) {
            if (this.loggingSubsystem) {
                this.loggingSubsystem.error('API call to /api/populations failed', { 
                    error: apiError.message,
                    stack: apiError.stack 
                }, 'system');
            }
            throw apiError;
        }
    }
    
    /**
     * Populate a dropdown with populations
     */
    async populateDropdown(dropdownId, config = {}) {
        try {
            if (this.loggingSubsystem) {
                this.loggingSubsystem.debug(`[DIAG] Starting population dropdown population for: ${dropdownId}`, config, 'system');
            }
            this.hideDropdownError(dropdownId);
            const {
                includeEmpty = true,
                emptyText = 'Select a population',
                emptyValue = '',
                filter = null,
                sortBy = 'name',
                sortOrder = 'asc'
            } = config;
            
            // Register dropdown for management
            this.registerDropdown(dropdownId, config);
            
            const dropdown = document.getElementById(dropdownId);
            if (!dropdown) {
                const error = `Dropdown element not found: ${dropdownId}`;
                if (this.loggingSubsystem) {
                    this.loggingSubsystem.error(error, {}, 'system');
                }
                throw new Error(error);
            }
            
            if (this.loggingSubsystem) {
                this.loggingSubsystem.debug(`Dropdown element found, showing loading state for: ${dropdownId}`, {}, 'system');
            }
            
            // Show loading state
            this.showDropdownLoading(dropdown);
            
            if (this.loggingSubsystem) {
                this.loggingSubsystem.debug(`Loading populations for dropdown: ${dropdownId}`, {}, 'system');
            }
            
            // Load populations
            const populations = await this.loadPopulations();
            if (this.loggingSubsystem) {
                this.loggingSubsystem.info(`[DIAG] Populations data for dropdown ${dropdownId}:`, { populations }, 'system');
            }
            // Filter populations if needed
            let filteredPopulations = populations;
            if (filter && typeof filter === 'function') {
                filteredPopulations = populations.filter(filter);
            }
            
            // Sort populations
            filteredPopulations = this.sortPopulations(filteredPopulations, sortBy, sortOrder);
            
            // Clear existing options
            dropdown.innerHTML = '';
            
            // Add empty option if requested
            if (includeEmpty) {
                const emptyOption = document.createElement('option');
                emptyOption.value = emptyValue;
                emptyOption.textContent = emptyText;
                dropdown.appendChild(emptyOption);
            }
            
            // Add population options
            filteredPopulations.forEach(population => {
                const option = document.createElement('option');
                option.value = population.id;
                option.textContent = population.name;
                option.dataset.populationId = population.id;
                option.dataset.populationName = population.name;
                dropdown.appendChild(option);
            });
            
            // Hide loading state
            this.hideDropdownLoading(dropdown);
            
            // Emit event for UI updates
            if (this.eventBus) {
                this.eventBus.emit('dropdownPopulated', {
                    dropdownId,
                    populationCount: filteredPopulations.length
                });
            }
            
            if (this.loggingSubsystem) {
                this.loggingSubsystem.debug('Dropdown populated successfully', {
                    dropdownId,
                    populationCount: filteredPopulations.length
                }, 'system');
            }
            
            return true;
            
        } catch (error) {
            this.showDropdownError(dropdownId, error.message);
            if (this.loggingSubsystem) {
                this.loggingSubsystem.error(`[DIAG] Failed to populate dropdown: ${dropdownId} - ${error.message}`, {}, 'system');
            }
            return false;
        }
    }
    
    /**
     * Register a dropdown for management
     */
    registerDropdown(dropdownId, config = {}) {
        this.managedDropdowns.add(dropdownId);
        this.dropdownConfigs.set(dropdownId, config);
        
        if (this.loggingSubsystem) {
            this.loggingSubsystem.debug('Dropdown registered', { dropdownId }, 'system');
        }
    }
    
    /**
     * Refresh all managed dropdowns
     */
    async refreshAllDropdowns() {
        try {
            const refreshPromises = Array.from(this.managedDropdowns).map(dropdownId => {
                const config = this.dropdownConfigs.get(dropdownId) || {};
                return this.populateDropdown(dropdownId, config);
            });
            
            await Promise.all(refreshPromises);
            
            if (this.loggingSubsystem) {
                this.loggingSubsystem.info('All dropdowns refreshed', {
                    count: this.managedDropdowns.size
                }, 'system');
            }
            
        } catch (error) {
            if (this.loggingSubsystem) {
                this.loggingSubsystem.error('Failed to refresh all dropdowns', error, 'system');
            }
        }
    }
    
    /**
     * Refresh populations and update all dropdowns
     */
    async refreshPopulations(force = false) {
        try {
            // Load fresh populations
            await this.loadPopulations({ force: true });
            
            // Refresh all managed dropdowns
            await this.refreshAllDropdowns();
            
            if (this.loggingSubsystem) {
                this.loggingSubsystem.info('Populations refreshed successfully', {}, 'system');
            }
            
        } catch (error) {
            if (this.loggingSubsystem) {
                this.loggingSubsystem.error('Failed to refresh populations', error, 'system');
            }
        }
    }
    
    /**
     * Sort populations by specified criteria
     */
    sortPopulations(populations, sortBy = 'name', sortOrder = 'asc') {
        return populations.sort((a, b) => {
            let aValue = a[sortBy];
            let bValue = b[sortBy];
            
            // Handle string comparison
            if (typeof aValue === 'string' && typeof bValue === 'string') {
                aValue = aValue.toLowerCase();
                bValue = bValue.toLowerCase();
            }
            
            let comparison = 0;
            if (aValue < bValue) {
                comparison = -1;
            } else if (aValue > bValue) {
                comparison = 1;
            }
            
            return sortOrder === 'desc' ? -comparison : comparison;
        });
    }
    
    /**
     * Show loading state for dropdown
     */
    showDropdownLoading(dropdown) {
        let spinner = dropdown.parentElement.querySelector('.dropdown-spinner');
        if (!spinner) {
            spinner = document.createElement('div');
            spinner.className = 'dropdown-spinner';
            spinner.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Loading...';
            dropdown.parentElement.insertBefore(spinner, dropdown);
            if (this.loggingSubsystem) {
                this.loggingSubsystem.debug(`[DIAG] Spinner created for dropdown: ${dropdown.id}`, {}, 'system');
            }
        } else {
            if (this.loggingSubsystem) {
                this.loggingSubsystem.debug(`[DIAG] Spinner already exists for dropdown: ${dropdown.id}`, {}, 'system');
            }
        }
        spinner.style.display = 'inline-block';
        dropdown.disabled = true;
        if (this.loggingSubsystem) {
            this.loggingSubsystem.debug(`[DIAG] Spinner shown for dropdown: ${dropdown.id}`, {}, 'system');
        }
    }

    /**
     * Hide loading state for dropdown
     */
    hideDropdownLoading(dropdown) {
        const spinner = dropdown.parentElement.querySelector('.dropdown-spinner');
        if (spinner) {
            spinner.style.display = 'none';
            if (this.loggingSubsystem) {
                this.loggingSubsystem.debug(`[DIAG] Spinner hidden for dropdown: ${dropdown.id}`, {}, 'system');
            }
        }
        dropdown.disabled = false;
    }

    /**
     * Show error state for dropdown
     */
    showDropdownError(dropdownId, errorMsg) {
        const dropdown = document.getElementById(dropdownId);
        if (!dropdown) {
            if (this.loggingSubsystem) {
                this.loggingSubsystem.error(`[DIAG] Dropdown not found for error banner: ${dropdownId}`, {}, 'system');
            }
            return;
        }
        let errorBanner = dropdown.parentElement.querySelector('.dropdown-error-banner');
        if (errorBanner) errorBanner.remove();
        errorBanner = document.createElement('div');
        errorBanner.className = 'dropdown-error-banner alert alert-danger';
        errorBanner.textContent = `Population load failed: ${errorMsg}`;
        dropdown.parentElement.insertBefore(errorBanner, dropdown);
        dropdown.disabled = true;
        if (this.loggingSubsystem) {
            this.loggingSubsystem.error(`[DIAG] Error banner shown for dropdown: ${dropdownId} - ${errorMsg}`, {}, 'system');
        }
    }

    hideDropdownError(dropdownId) {
        const dropdown = document.getElementById(dropdownId);
        if (!dropdown) return;
        let errorBanner = dropdown.parentElement.querySelector('.dropdown-error-banner');
        if (errorBanner) {
            errorBanner.remove();
            if (this.loggingSubsystem) {
                this.loggingSubsystem.debug(`[DIAG] Error banner removed for dropdown: ${dropdownId}`, {}, 'system');
            }
        }
        dropdown.disabled = false;
    }

    /**
     * Cache populations with timestamp
     */
    cachePopulations(populations) {
        this.populationCache.set('populations', populations);
        this.lastCacheUpdate = Date.now();
        
        // Save to localStorage for persistence
        try {
            localStorage.setItem('pingone-populations-cache', JSON.stringify({
                populations,
                timestamp: this.lastCacheUpdate
            }));
        } catch (error) {
            if (this.loggingSubsystem) {
                this.loggingSubsystem.warn('Failed to save populations to localStorage', error, 'system');
            }
        }
    }
    
    /**
     * Get cached populations
     */
    getCachedPopulations() {
        return this.populationCache.get('populations') || [];
    }
    
    /**
     * Check if cache is valid
     */
    isCacheValid() {
        if (!this.lastCacheUpdate) {
            return false;
        }
        
        const age = Date.now() - this.lastCacheUpdate;
        return age < this.cacheExpiry;
    }
    
    /**
     * Load cached populations from localStorage
     */
    loadCachedPopulations() {
        try {
            const cached = localStorage.getItem('pingone-populations-cache');
            if (cached) {
                const { populations, timestamp } = JSON.parse(cached);
                
                // Check if cache is still valid
                const age = Date.now() - timestamp;
                if (age < this.cacheExpiry) {
                    this.populationCache.set('populations', populations);
                    this.lastCacheUpdate = timestamp;
                    
                    if (this.loggingSubsystem) {
                        this.loggingSubsystem.debug('Loaded populations from localStorage cache', {
                            count: populations.length,
                            age: Math.round(age / 1000)
                        }, 'system');
                    }
                }
            }
        } catch (error) {
            if (this.loggingSubsystem) {
                this.loggingSubsystem.warn('Failed to load populations from localStorage', error, 'system');
            }
        }
    }
    
    /**
     * Invalidate cache
     */
    invalidateCache() {
        this.populationCache.clear();
        this.lastCacheUpdate = null;
        
        // Clear localStorage cache
        try {
            localStorage.removeItem('pingone-populations-cache');
        } catch (error) {
            // Ignore localStorage errors
        }
        
        if (this.loggingSubsystem) {
            this.loggingSubsystem.debug('Population cache invalidated', {}, 'system');
        }
    }
    
    /**
     * Clear cache completely
     */
    clearCache() {
        this.invalidateCache();
        
        if (this.loggingSubsystem) {
            this.loggingSubsystem.debug('Population cache cleared', {}, 'system');
        }
    }
    
    /**
     * Get population by ID
     */
    async getPopulationById(populationId) {
        try {
            const populations = await this.loadPopulations();
            return populations.find(pop => pop.id === populationId) || null;
        } catch (error) {
            if (this.loggingSubsystem) {
                this.loggingSubsystem.error('Failed to get population by ID', {
                    populationId,
                    error: error.message
                }, 'system');
            }
            return null;
        }
    }
    
    /**
     * Search populations by name
     */
    async searchPopulations(searchTerm) {
        try {
            const populations = await this.loadPopulations();
            const searchLower = searchTerm.toLowerCase();
            
            return populations.filter(pop => 
                pop.name.toLowerCase().includes(searchLower) ||
                (pop.description && pop.description.toLowerCase().includes(searchLower))
            );
        } catch (error) {
            if (this.loggingSubsystem) {
                this.loggingSubsystem.error('Failed to search populations', {
                    searchTerm,
                    error: error.message
                }, 'system');
            }
            return [];
        }
    }
    
    /**
     * Get cache statistics
     */
    getCacheStats() {
        return {
            isValid: this.isCacheValid(),
            lastUpdate: this.lastCacheUpdate,
            age: this.lastCacheUpdate ? Date.now() - this.lastCacheUpdate : null,
            populationCount: this.getCachedPopulations().length,
            managedDropdowns: this.managedDropdowns.size
        };
    }
}

// Export for use in other modules
export default PopulationSubsystem;



/* From: public/js/modules/population-manager.js */
/**
 * PopulationManager - Manages population selection and interaction
 * 
 * This class provides a higher-level interface for working with populations
 * and delegates the actual API interactions to the PopulationService.
 * 
 * Features:
 * - Population dropdown initialization
 * - Population selection
 * - Population refresh
 * 
 * Usage:
 * ```javascript
 * // Get the singleton instance
 * import populationManager from './modules/population-manager.js';
 * 
 * // Initialize a population dropdown
 * await populationManager.initPopulationDropdown('population-dropdown', {
 *   includeEmpty: true,
 *   emptyText: 'Select a population',
 *   selectedId: 'existing-population-id'
 * });
 * 
 * // Select a population
 * const population = await populationManager.selectPopulation('population-id');
 * 
 * // Refresh populations
 * await populationManager.refreshPopulations('population-dropdown');
 * ```
 */

import apiFactory from './api-factory.js';
import uiManager from './ui-manager.js';
import logger from './logger.js';
import PopulationService from './population-service.js';

class PopulationManager {
    constructor() {
        this.selectedPopulation = null;
        this.apiClient = apiFactory.getPingOneClient();
        this.populationService = new PopulationService(this.apiClient, null, logger);
        
        // Bind methods to ensure correct 'this' context
        this.initPopulationDropdown = this.initPopulationDropdown.bind(this);
        this.selectPopulation = this.selectPopulation.bind(this);
        this.refreshPopulations = this.refreshPopulations.bind(this);
    }

    /**
     * Initialize a dropdown element with population data
     * @param {string} dropdownId - ID of the dropdown element to populate
     * @param {Object} options - Options for populating the dropdown
     * @param {boolean} options.includeEmpty - Whether to include an empty option
     * @param {string} options.emptyText - Text for the empty option
     * @param {string} options.selectedId - ID of the population to select
     * @returns {Promise<boolean>} True if successful, false otherwise
     */
    async initPopulationDropdown(dropdownId, options = {}) {
        try {
            // Use the PopulationService to populate the dropdown
            const success = await this.populationService.populateDropdown(dropdownId, options);
            
            // Update the selected population if specified
            if (success && options.selectedId) {
                try {
                    const selectedPop = await this.populationService.getPopulationById(options.selectedId);
                    if (selectedPop) {
                        this.selectedPopulation = selectedPop;
                    }
                } catch (error) {
                    logger.warn(`Could not get details for selected population ${options.selectedId}: ${error.message}`);
                }
            }
            
            return success;
        } catch (error) {
            logger.error(`Error populating dropdown ${dropdownId}: ${error.message}`, { error });
            uiManager.showError(`Failed to load populations: ${error.message}`);
            return false;
        }
    }

    /**
     * Select a population by ID
     * @param {string} populationId - ID of the population to select
     * @returns {Promise<Object>} The selected population object, or null if not found
     */
    async selectPopulation(populationId) {
        try {
            if (!populationId) {
                this.selectedPopulation = null;
                return null;
            }
            
            // Use the PopulationService to get the population by ID
            const population = await this.populationService.getPopulationById(populationId);
            
            // Update selected population
            this.selectedPopulation = population;
            
            logger.info(`Selected population: ${population.name} (${population.id})`);
            
            return population;
        } catch (error) {
            logger.error(`Error selecting population ${populationId}: ${error.message}`, { error });
            uiManager.showError(`Failed to select population: ${error.message}`);
            return null;
        }
    }

    /**
     * Refresh the populations in a dropdown element
     * @param {string} dropdownId - ID of the dropdown element to refresh
     * @param {Object} options - Options for populating the dropdown (same as initPopulationDropdown)
     * @returns {Promise<boolean>} True if successful, false otherwise
     */
    async refreshPopulations(dropdownId, options = {}) {
        // Clear the cache to force a fresh API call
        this.populationService.clearCache();
        
        // Re-initialize the dropdown
        return this.initPopulationDropdown(dropdownId, options);
    }

    /**
     * Get the currently selected population
     * @returns {Object} The currently selected population, or null if none selected
     */
    getSelectedPopulation() {
        return this.selectedPopulation;
    }
}

// Create and export a singleton instance
const populationManager = new PopulationManager();
export default populationManager;


/* From: public/js/modules/population-service.js */
/**
 * PopulationService - Centralized service for all population-related API interactions
 * 
 * This service provides a unified interface for fetching populations, retrieving individual
 * populations by ID, populating UI dropdowns, and managing population data caching.
 * 
 * Features:
 * - In-memory caching of population data for improved performance
 * - Automatic population sorting by name for consistent UI display
 * - Graceful error handling with meaningful messages
 * - Integration with existing authentication and API client systems
 * 
 * Usage:
 * ```javascript
 * // Create an instance with dependencies
 * const populationService = new PopulationService(
 *   apiFactory.getPingOneClient(),
 *   tokenManager,
 *   logger
 * );
 * 
 * // Get all populations (uses cache if available)
 * const populations = await populationService.getPopulations();
 * 
 * // Get a specific population by ID
 * const population = await populationService.getPopulationById('populationId');
 * 
 * // Populate a dropdown with population data
 * await populationService.populateDropdown('dropdown-element-id');
 * 
 * // Clear the cache to force fresh data on next request
 * populationService.clearCache();
 * ```
 */

class PopulationService {
    /**
     * Create a new PopulationService instance
     * @param {Object} apiClient - API client for making requests to PingOne API
     * @param {Object} tokenManager - Token manager for authentication
     * @param {Object} logger - Logger for logging messages
     */
    constructor(apiClient, tokenManager, logger, eventBus) {
        // Validate required dependencies
        if (!apiClient) {
            throw new Error('API client is required for PopulationService');
        }

        this.apiClient = apiClient;
        this.tokenManager = tokenManager || null;
        this.logger = logger || console;
        this.eventBus = eventBus;
        
        // Initialize cache
        this.cache = {
            populations: {
                all: null,
                byId: {}
            },
            lastFetched: 0
        };
        
        // Cache expiration time (15 minutes)
        this.cacheExpirationTime = 15 * 60 * 1000;
        
        // Bind methods to ensure correct 'this' context
        this.getPopulations = this.getPopulations.bind(this);
        this.getPopulationById = this.getPopulationById.bind(this);
        this.populateDropdown = this.populateDropdown.bind(this);
        this.clearCache = this.clearCache.bind(this);
        
        this.logger.info('PopulationService initialized');
    }

    /**
     * Get all populations from PingOne API
     * @param {Object} options - Query options for the API call
     * @param {boolean} forceRefresh - Whether to bypass cache and force a fresh API call
     * @returns {Promise<Array>} Array of population objects
     */
    async getPopulations(options = {}, forceRefresh = false) {
        try {
            // Check if we have cached data and it's not expired
            const now = Date.now();
            const cacheIsValid = this.cache.populations.all && 
                                (now - this.cache.lastFetched) < this.cacheExpirationTime;
            
            // Use cache if available and not forcing refresh
            if (cacheIsValid && !forceRefresh) {
                this.logger.debug('Using cached populations data');
                return this.cache.populations.all;
            }
            
            // Log API call
            this.logger.info('Fetching populations from API', { forceRefresh });
            
            // Make API call to get populations
            const response = await this.apiClient.getPopulations(options);
            
            // Check if response is valid
            if (!response || !response.ok) {
                const errorText = await response.text().catch(() => 'Unknown error');
                throw new Error(`Failed to fetch populations: ${response.status} ${errorText}`);
            }
            
            // Parse response
            const data = await response.json();
            
            // Check if data has expected structure
            if (!data || !data._embedded || !Array.isArray(data._embedded.populations)) {
                throw new Error('Invalid response format from populations API');
            }
            
            // Extract populations from response
            const populations = data._embedded.populations.map(pop => ({
                id: pop.id,
                name: pop.name,
                description: pop.description || '',
                userCount: pop.userCount || 0,
                createdAt: pop.createdAt,
                updatedAt: pop.updatedAt
            }));
            
            // Sort populations by name
            const sortedPopulations = this._sortPopulations(populations);
            
            // Update cache
            this.cache.populations.all = sortedPopulations;
            this.cache.lastFetched = now;
            
            // Also update the byId cache
            sortedPopulations.forEach(pop => {
                this.cache.populations.byId[pop.id] = pop;
            });
            
            // Emit population change event
            if (this.eventBus) {
                this.eventBus.emit('populationsChanged', {
                    populations: sortedPopulations,
                    count: sortedPopulations.length
                });
            }
            
            this.logger.info(`Successfully fetched ${sortedPopulations.length} populations`);
            
            return sortedPopulations;
        } catch (error) {
            return this._handleApiError(error, 'fetching populations');
        }
    }

    /**
     * Get a specific population by ID
     * @param {string} populationId - ID of the population to fetch
     * @param {boolean} forceRefresh - Whether to bypass cache and force a fresh API call
     * @returns {Promise<Object>} Population object
     */
    async getPopulationById(populationId, forceRefresh = false) {
        try {
            if (!populationId) {
                throw new Error('Population ID is required');
            }
            
            // Check if we have this population in cache
            if (!forceRefresh && this.cache.populations.byId[populationId]) {
                this.logger.debug(`Using cached population data for ID: ${populationId}`);
                return this.cache.populations.byId[populationId];
            }
            
            // If we have all populations cached and not forcing refresh, find in cache
            const now = Date.now();
            const cacheIsValid = this.cache.populations.all && 
                                (now - this.cache.lastFetched) < this.cacheExpirationTime;
            
            if (cacheIsValid && !forceRefresh) {
                const population = this.cache.populations.all.find(p => p.id === populationId);
                if (population) {
                    // Update the byId cache
                    this.cache.populations.byId[populationId] = population;
                    return population;
                }
            }
            
            // If not in cache or forcing refresh, fetch from API
            this.logger.info(`Fetching population with ID: ${populationId}`);
            
            // Make API call to get specific population
            const environmentId = this.apiClient.settings?.environmentId;
            if (!environmentId) {
                throw new Error('Environment ID is not configured');
            }
            
            const endpoint = `/environments/${environmentId}/populations/${populationId}`;
            const response = await this.apiClient.request(endpoint, { method: 'GET' });
            
            // Check if response is valid
            if (!response || !response.ok) {
                if (response.status === 404) {
                    throw new Error(`Population with ID ${populationId} not found`);
                }
                const errorText = await response.text().catch(() => 'Unknown error');
                throw new Error(`Failed to fetch population: ${response.status} ${errorText}`);
            }
            
            // Parse response
            const population = await response.json();
            
            // Format population data
            const formattedPopulation = {
                id: population.id,
                name: population.name,
                description: population.description || '',
                userCount: population.userCount || 0,
                createdAt: population.createdAt,
                updatedAt: population.updatedAt
            };
            
            // Update cache
            this.cache.populations.byId[populationId] = formattedPopulation;
            
            // If we have all populations cached, update that entry too
            if (this.cache.populations.all) {
                const index = this.cache.populations.all.findIndex(p => p.id === populationId);
                if (index >= 0) {
                    this.cache.populations.all[index] = formattedPopulation;
                } else {
                    this.cache.populations.all.push(formattedPopulation);
                    this.cache.populations.all = this._sortPopulations(this.cache.populations.all);
                }
            }
            
            this.logger.info(`Successfully fetched population with ID: ${populationId}`);
            
            return formattedPopulation;
        } catch (error) {
            return this._handleApiError(error, `fetching population with ID ${populationId}`);
        }
    }

    /**
     * Populate a dropdown element with population data
     * @param {string} dropdownId - ID of the dropdown element to populate
     * @param {Object} options - Options for populating the dropdown
     * @param {boolean} options.includeEmpty - Whether to include an empty option
     * @param {string} options.emptyText - Text for the empty option
     * @param {string} options.selectedId - ID of the population to select
     * @returns {Promise<boolean>} True if successful, false otherwise
     */
    async populateDropdown(dropdownId, options = {}) {
        try {
            if (!dropdownId) {
                throw new Error('Dropdown ID is required');
            }
            
            // Get the dropdown element
            const dropdown = document.getElementById(dropdownId);
            if (!dropdown) {
                throw new Error(`Dropdown element with ID "${dropdownId}" not found`);
            }
            
            // Set dropdown to disabled while loading
            dropdown.disabled = true;
            dropdown.innerHTML = '<option value="">Loading populations...</option>';
            
            // Get populations
            const populations = await this.getPopulations();
            
            // Clear dropdown
            dropdown.innerHTML = '';
            
            // Add empty option if requested
            if (options.includeEmpty !== false) {
                const emptyOption = document.createElement('option');
                emptyOption.value = '';
                emptyOption.textContent = options.emptyText || 'Select a population';
                dropdown.appendChild(emptyOption);
            }
            
            // Add population options
            populations.forEach(population => {
                const option = document.createElement('option');
                option.value = population.id;
                option.textContent = this._formatPopulationForDisplay(population);
                dropdown.appendChild(option);
            });
            
            // Select population if specified
            if (options.selectedId) {
                dropdown.value = options.selectedId;
            }
            
            // Enable dropdown
            dropdown.disabled = false;
            
            this.logger.info(`Successfully populated dropdown ${dropdownId} with ${populations.length} populations`);
            
            return true;
        } catch (error) {
            // Try to re-enable the dropdown if it exists
            try {
                const dropdown = document.getElementById(dropdownId);
                if (dropdown) {
                    dropdown.disabled = false;
                    dropdown.innerHTML = '<option value="">Error loading populations</option>';
                }
            } catch (e) {
                // Ignore errors in error handling
            }
            
            return this._handleApiError(error, `populating dropdown ${dropdownId}`);
        }
    }

    /**
     * Clear the population cache
     * @param {string} populationId - Optional ID of specific population to clear from cache
     */
    clearCache(populationId = null) {
        if (populationId) {
            // Clear specific population from cache
            if (this.cache.populations.byId[populationId]) {
                delete this.cache.populations.byId[populationId];
                this.logger.debug(`Cleared population ${populationId} from cache`);
            }
            
            // Also remove from all populations if present
            if (this.cache.populations.all) {
                this.cache.populations.all = this.cache.populations.all.filter(p => p.id !== populationId);
            }
        } else {
            // Clear entire cache
            this.cache = {
                populations: {
                    all: null,
                    byId: {}
                },
                lastFetched: 0
            };
            this.logger.debug('Cleared entire population cache');
        }
    }

    /**
     * Handle API errors with consistent formatting
     * @param {Error} error - The error object
     * @param {string} operation - Description of the operation that failed
     * @returns {Promise<never>} Rejected promise with formatted error
     * @private
     */
    _handleApiError(error, operation) {
        const errorMessage = `Error ${operation}: ${error.message}`;
        this.logger.error(errorMessage, { error });
        
        // Create a new error with the formatted message
        const formattedError = new Error(errorMessage);
        formattedError.originalError = error;
        formattedError.operation = operation;
        
        // Reject with the formatted error
        return Promise.reject(formattedError);
    }

    /**
     * Format a population object for display in a dropdown
     * @param {Object} population - Population object
     * @returns {string} Formatted population name
     * @private
     */
    _formatPopulationForDisplay(population) {
        if (!population) return '';
        
        // If population has a user count, include it in the display
        if (population.userCount !== undefined) {
            return `${population.name} (${population.userCount} users)`;
        }
        
        return population.name;
    }

    /**
     * Sort populations by name
     * @param {Array} populations - Array of population objects
     * @returns {Array} Sorted array of population objects
     * @private
     */
    _sortPopulations(populations) {
        if (!Array.isArray(populations)) return [];
        
        return [...populations].sort((a, b) => {
            const nameA = (a.name || '').toLowerCase();
            const nameB = (b.name || '').toLowerCase();
            return nameA.localeCompare(nameB);
        });
    }
}

// Export the PopulationService class
export default PopulationService;

