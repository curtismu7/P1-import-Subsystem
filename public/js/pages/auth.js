/**
 * Auth Subsystem
 * 
 * Consolidated JavaScript for PingOne Import Tool
 * Generated: 2025-08-06T19:05:53.929Z
 * 
 * This file was automatically generated by js-cleanup-script.js
 * Organized for better maintainability and performance
 */


/* From: public/js/modules/auth-management-subsystem.js */
/**
 * Authentication Management Subsystem
 * 
 * Handles all authentication-related operations including token management,
 * credential validation, and authentication state tracking.
 */

export class AuthManagementSubsystem {
    constructor(logger, uiManager, localClient, settingsSubsystem) {
        this.logger = logger;
        this.uiManager = uiManager;
        this.localClient = localClient;
        this.settingsSubsystem = settingsSubsystem;
        
        // Authentication state
        this.isAuthenticated = false;
        this.tokenStatus = null;
        this.tokenExpiry = null;
        this.refreshTimer = null;
        
        this.logger.info('Authentication Management Subsystem initialized');
    }
    
    /**
     * Initialize the authentication subsystem
     */
    async init() {
        try {
            this.setupEventListeners();
            await this.checkInitialTokenStatus();
            this.setupTokenRefreshTimer();
            this.logger.info('Authentication Management Subsystem initialized successfully');
        } catch (error) {
            this.logger.error('Failed to initialize Authentication Management Subsystem', error);
            throw error;
        }
    }
    
    /**
     * Set up event listeners for authentication-related elements
     */
    setupEventListeners() {
        // Get token button
        const getTokenBtn = document.getElementById('get-token-btn');
        if (getTokenBtn) {
            getTokenBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                await this.getToken();
            });
        }
        
        // Test connection button
        const testConnectionBtn = document.getElementById('test-connection-btn');
        if (testConnectionBtn) {
            testConnectionBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                await this.testConnection();
            });
        }
        
        // Global token refresh button
        const globalRefreshBtn = document.getElementById('global-refresh-token');
        if (globalRefreshBtn) {
            globalRefreshBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                await this.refreshToken();
            });
        }
        
        // Settings form submission
        const settingsForm = document.getElementById('settings-form');
        if (settingsForm) {
            settingsForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                await this.handleSettingsSubmit(e);
            });
        }
    }
    
    /**
     * Get a new authentication token
     */
    async getToken() {
        try {
            this.logger.info('Getting new authentication token');
            this.showTokenProgress('Getting token...');
            
            // Validate settings first
            const settings = await this.settingsSubsystem.getSettings();
            if (!this.validateSettings(settings)) {
                throw new Error('Invalid settings - please check your configuration');
            }
            
            // Request token from server
            const response = await this.localClient.post('/api/token', {
                clientId: settings.clientId,
                clientSecret: settings.clientSecret,
                environmentId: settings.environmentId,
                region: settings.region
            });
            
            if (!response.success) {
                throw new Error(response.error || 'Failed to get token');
            }
            
            // Update token status
            this.tokenStatus = response.token;
            this.tokenExpiry = response.expiry;
            this.isAuthenticated = true;
            
            // Update UI
            this.updateTokenStatusUI(true, 'Token obtained successfully');
            this.uiManager.showSuccess('Authentication successful');
            
            // Set up refresh timer
            this.setupTokenRefreshTimer();
            
            this.logger.info('Token obtained successfully');
            
        } catch (error) {
            this.logger.error('Failed to get token', error);
            this.updateTokenStatusUI(false, error.message);
            this.uiManager.showError('Authentication Failed', error.message);
        } finally {
            this.hideTokenProgress();
        }
    }
    
    /**
     * Test connection with current settings
     */
    async testConnection() {
        try {
            this.logger.info('Testing connection');
            this.showConnectionProgress('Testing connection...');
            
            // Get current settings
            const settings = await this.settingsSubsystem.getSettings();
            if (!this.validateSettings(settings)) {
                throw new Error('Invalid settings - please check your configuration');
            }
            
            // Test connection
            const response = await this.localClient.post('/api/test-connection', settings);
            
            if (!response.success) {
                throw new Error(response.error || 'Connection test failed');
            }
            
            // Update UI
            this.updateConnectionStatusUI(true, 'Connection successful');
            this.uiManager.showSuccess('Connection test successful');
            
            this.logger.info('Connection test successful');
            
        } catch (error) {
            this.logger.error('Connection test failed', error);
            this.updateConnectionStatusUI(false, error.message);
            this.uiManager.showError('Connection Test Failed', error.message);
        } finally {
            this.hideConnectionProgress();
        }
    }
    
    /**
     * Refresh the current token
     */
    async refreshToken() {
        try {
            this.logger.info('Refreshing authentication token');
            this.showTokenProgress('Refreshing token...');
            
            const response = await this.localClient.post('/api/token/refresh');
            
            if (!response.success) {
                throw new Error(response.error || 'Failed to refresh token');
            }
            
            // Update token status
            this.tokenStatus = response.token;
            this.tokenExpiry = response.expiry;
            this.isAuthenticated = true;
            
            // Update UI
            this.updateTokenStatusUI(true, 'Token refreshed successfully');
            this.uiManager.showSuccess('Token refreshed successfully');
            
            // Reset refresh timer
            this.setupTokenRefreshTimer();
            
            this.logger.info('Token refreshed successfully');
            
        } catch (error) {
            this.logger.error('Failed to refresh token', error);
            this.updateTokenStatusUI(false, error.message);
            this.uiManager.showError('Token Refresh Failed', error.message);
            
            // Clear authentication state
            this.clearAuthenticationState();
        } finally {
            this.hideTokenProgress();
        }
    }
    
    /**
     * Handle settings form submission
     */
    async handleSettingsSubmit(event) {
        try {
            const formData = new FormData(event.target);
            const settings = Object.fromEntries(formData.entries());
            
            this.logger.info('Saving settings');
            
            // Validate settings
            if (!this.validateSettings(settings)) {
                throw new Error('Invalid settings - please check all required fields');
            }
            
            // Save settings
            await this.settingsSubsystem.saveSettings(settings);
            
            // Clear current authentication state since settings changed
            this.clearAuthenticationState();
            
            // Update UI
            this.uiManager.showSuccess('Settings saved successfully');
            
            this.logger.info('Settings saved successfully');
            
        } catch (error) {
            this.logger.error('Failed to save settings', error);
            this.uiManager.showError('Settings Save Failed', error.message);
        }
    }
    
    /**
     * Check initial token status
     */
    async checkInitialTokenStatus() {
        try {
            const response = await this.localClient.get('/api/token/status');
            
            if (response.success && response.valid) {
                this.tokenStatus = response.token;
                this.tokenExpiry = response.expiry;
                this.isAuthenticated = true;
                this.updateTokenStatusUI(true, 'Token is valid');
            } else {
                this.isAuthenticated = false;
                this.updateTokenStatusUI(false, 'No valid token');
            }
            
        } catch (error) {
            this.logger.error('Failed to check token status', error);
            this.isAuthenticated = false;
            this.updateTokenStatusUI(false, 'Token status unknown');
        }
    }
    
    /**
     * Set up automatic token refresh timer
     */
    setupTokenRefreshTimer() {
        // Clear existing timer
        if (this.refreshTimer) {
            clearTimeout(this.refreshTimer);
        }
        
        if (!this.tokenExpiry) {
            return;
        }
        
        // Calculate refresh time (5 minutes before expiry)
        const expiryTime = new Date(this.tokenExpiry).getTime();
        const refreshTime = expiryTime - (5 * 60 * 1000); // 5 minutes before
        const now = Date.now();
        
        if (refreshTime > now) {
            const delay = refreshTime - now;
            this.refreshTimer = setTimeout(() => {
                this.refreshToken();
            }, delay);
            
            this.logger.info('Token refresh timer set', {
                refreshIn: Math.round(delay / 1000 / 60),
                unit: 'minutes'
            });
        }
    }
    
    /**
     * Validate settings object
     */
    validateSettings(settings) {
        const required = ['clientId', 'clientSecret', 'environmentId', 'region'];
        
        for (const field of required) {
            if (!settings[field] || settings[field].trim() === '') {
                this.logger.error('Missing required setting', { field });
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Clear authentication state
     */
    clearAuthenticationState() {
        this.isAuthenticated = false;
        this.tokenStatus = null;
        this.tokenExpiry = null;
        
        if (this.refreshTimer) {
            clearTimeout(this.refreshTimer);
            this.refreshTimer = null;
        }
        
        this.updateTokenStatusUI(false, 'Authentication cleared');
    }
    
    /**
     * Update token status UI
     */
    updateTokenStatusUI(isValid, message) {
        // Update global token status
        const globalTokenStatus = document.getElementById('global-token-status');
        if (globalTokenStatus) {
            globalTokenStatus.className = `token-status ${isValid ? 'valid' : 'invalid'}`;
            globalTokenStatus.textContent = message;
        }
        
        // Update token indicator
        const tokenIndicator = document.getElementById('token-status-indicator');
        if (tokenIndicator) {
            tokenIndicator.className = `token-indicator ${isValid ? 'valid' : 'invalid'}`;
        }
        
        // Update get token button visibility
        const getTokenBtn = document.getElementById('get-token-btn');
        if (getTokenBtn) {
            getTokenBtn.style.display = isValid ? 'none' : 'inline-block';
        }
        
        // Update refresh token button visibility
        const refreshTokenBtn = document.getElementById('global-refresh-token');
        if (refreshTokenBtn) {
            refreshTokenBtn.style.display = isValid ? 'inline-block' : 'none';
        }
    }
    
    /**
     * Update connection status UI
     */
    updateConnectionStatusUI(isConnected, message) {
        const connectionStatus = document.getElementById('connection-status');
        if (connectionStatus) {
            connectionStatus.className = `connection-status ${isConnected ? 'connected' : 'disconnected'}`;
            connectionStatus.textContent = message;
        }
    }
    
    /**
     * Show token progress
     */
    showTokenProgress(message) {
        const getTokenBtn = document.getElementById('get-token-btn');
        if (getTokenBtn) {
            getTokenBtn.disabled = true;
            getTokenBtn.textContent = message;
        }
    }
    
    /**
     * Hide token progress
     */
    hideTokenProgress() {
        const getTokenBtn = document.getElementById('get-token-btn');
        if (getTokenBtn) {
            getTokenBtn.disabled = false;
            getTokenBtn.textContent = 'Get Token';
        }
    }
    
    /**
     * Show connection progress
     */
    showConnectionProgress(message) {
        const testConnectionBtn = document.getElementById('test-connection-btn');
        if (testConnectionBtn) {
            testConnectionBtn.disabled = true;
            testConnectionBtn.textContent = message;
        }
    }
    
    /**
     * Hide connection progress
     */
    hideConnectionProgress() {
        const testConnectionBtn = document.getElementById('test-connection-btn');
        if (testConnectionBtn) {
            testConnectionBtn.disabled = false;
            testConnectionBtn.textContent = 'Test Connection';
        }
    }
    
    /**
     * Get current authentication status
     */
    getAuthenticationStatus() {
        return {
            isAuthenticated: this.isAuthenticated,
            tokenStatus: this.tokenStatus,
            tokenExpiry: this.tokenExpiry,
            timeUntilExpiry: this.tokenExpiry ? 
                Math.max(0, new Date(this.tokenExpiry).getTime() - Date.now()) : 0
        };
    }
    
    /**
     * Check if token is valid and not expired
     */
    isTokenValid() {
        if (!this.isAuthenticated || !this.tokenExpiry) {
            return false;
        }
        
        const now = Date.now();
        const expiry = new Date(this.tokenExpiry).getTime();
        
        return expiry > now;
    }
}


/* From: public/js/modules/global-token-manager.js */
import { TokenAccess } from '../../../src/shared/token-integration-helper.js';
/**
 * Global Token Manager Module
 * 
 * Provides a prominent global token status display in the sidebar
 * with real-time countdown timer and enhanced visibility across all windows.
 */

const GlobalTokenManager = {
    // Timer for updating token status
    globalTokenTimer: null,

    /**
     * Initialize the global token manager
     */
    init() {
        console.log('Initializing Global Token Manager...');
        this.initGlobalTokenStatus();
    },

    /**
     * Create the global token status window
     */
    createGlobalTokenStatus() {
        // Check if it already exists
        if (document.getElementById('global-token-status')) {
            return;
        }

        // Create the status window with the same structure as provided
        const statusHTML = `
            <div id="global-token-status" class="global-token-status missing">
                <div class="global-token-header">
                    <i class="fas fa-key"></i>
                    <span class="global-token-title">Token Status</span>
                    <div class="global-token-time">
                        <span class="global-token-countdown" style="color: rgb(255, 107, 107); font-weight: bold;">No Token</span>
                    </div>
                </div>
                <div class="global-token-content">
                    <div class="global-token-status-display">
                        <span class="global-token-icon">❌</span>
                        <span class="global-token-text">No valid token</span>
                    </div>
                    <div class="global-token-actions">
                        <button id="global-refresh-token" class="btn btn-sm btn-outline-secondary" title="Refresh token status">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                        <button id="global-get-token" class="btn btn-sm btn-success" title="Get new token" style="display: inline-block;">
                            <i class="fas fa-key"></i> Get Token
                        </button>
                    </div>
                </div>
            </div>
        `;

        // Insert into the sidebar
        const sidebar = document.querySelector('.sidebar') || document.querySelector('#sidebar');
        if (sidebar) {
            sidebar.insertAdjacentHTML('beforeend', statusHTML);
            console.log('Global token status window created');
        } else {
            console.warn('Sidebar not found, cannot create global token status');
        }
    },

    /**
     * Update the global token status display
     */
    updateGlobalTokenStatus() {
        console.log('🔄 Updating global token status in sidebar...');
        const statusBox = document.getElementById('global-token-status');
        if (!statusBox) {
            console.warn('❌ Global token status box not found, creating...');
            this.createGlobalTokenStatus();
            return;
        }
        console.log('✅ Found global token status box:', statusBox);

        const countdown = statusBox.querySelector('.global-token-countdown');
        const icon = statusBox.querySelector('.global-token-icon');
        const text = statusBox.querySelector('.global-token-text');
        const getTokenBtn = document.getElementById('global-get-token');

        console.log('🔍 Token status elements found:', {
            countdown: !!countdown,
            icon: !!icon,
            text: !!text,
            getTokenBtn: !!getTokenBtn
        });

        if (!countdown || !icon || !text) {
            console.warn('❌ Global token status elements not found:', {
                countdown: !!countdown,
                icon: !!icon,
                text: !!text
            });
            return;
        }

        // Get current token info
        const tokenInfo = this.getTokenInfo();
        
        if (tokenInfo.hasToken) {
            // Token exists
            const timeLeft = tokenInfo.timeLeft;
            const formattedTime = this.formatTime(timeLeft);
            
            // Update countdown with color coding
            console.log('⏰ Setting countdown to:', formattedTime);
            countdown.textContent = formattedTime;
            if (timeLeft <= 300) { // 5 minutes or less
                countdown.style.color = 'rgb(255, 107, 107)'; // Red
                countdown.style.fontWeight = 'bold';
            } else if (timeLeft <= 900) { // 15 minutes or less
                countdown.style.color = 'rgb(255, 193, 7)'; // Orange
                countdown.style.fontWeight = 'bold';
            } else {
                countdown.style.color = 'rgb(40, 167, 69)'; // Green
                countdown.style.fontWeight = 'normal';
            }

            // Update icon and text
            if (timeLeft <= 0) {
                console.log('❌ Token expired, updating status');
                icon.textContent = '❌';
                text.textContent = '';
                text.style.visibility = 'hidden';
                statusBox.className = 'global-token-status expired';
            } else if (timeLeft <= 300) {
                console.log('⚠️ Token expiring soon, updating status');
                icon.textContent = '⚠️';
                text.textContent = 'Token expiring soon';
                statusBox.className = 'global-token-status warning';
            } else {
                console.log('✅ Token valid, updating status to: Token valid');
                icon.textContent = '✅';
                text.textContent = 'Token valid';
                statusBox.className = 'global-token-status valid';
            }

            // Show/hide Get Token button
            if (getTokenBtn) {
                getTokenBtn.style.display = timeLeft <= 0 ? 'inline-block' : 'none';
            }
        } else {
            // No token
            countdown.textContent = 'No Token';
            countdown.style.color = 'rgb(255, 107, 107)';
            countdown.style.fontWeight = 'bold';
            icon.textContent = '❌';
            text.textContent = 'No valid token';
            statusBox.className = 'global-token-status missing';
            
            // Show Get Token button
            if (getTokenBtn) {
                getTokenBtn.style.display = 'inline-block';
            }
        }
    },

    /**
     * Format time in mm:ss format
     */
    formatTime(seconds) {
        if (isNaN(seconds) || seconds < 0) return '0:00';
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    },

    /**
     * Get current token information
     */
    getTokenInfo() {
        try {
            if (window.app && window.app.pingOneClient) {
                const tokenInfo = window.app.pingOneClient.getCurrentTokenTimeRemaining();
                
                if (tokenInfo && tokenInfo.token && !tokenInfo.isExpired) {
                    // Parse the time remaining from the formatted string
                    const timeRemaining = this.parseTimeRemaining(tokenInfo.timeRemaining);
                    
                    return {
                        hasToken: true,
                        timeLeft: timeRemaining,
                        expiresAt: window.app.pingOneClient.tokenExpiry,
                        token: tokenInfo.token
                    };
                }
            }
            return { hasToken: false, timeLeft: 0 };
        } catch (error) {
            console.error('Error getting token info:', error);
            return { hasToken: false, timeLeft: 0 };
        }
    },

    /**
     * Parse time remaining string to seconds
     * Handles formats like "5m 30s", "1h 15m 30s", "45s"
     */
    parseTimeRemaining(timeString) {
        if (!timeString || timeString === 'Expired') {
            return 0;
        }
        
        try {
            let totalSeconds = 0;
            
            // Handle hours
            const hoursMatch = timeString.match(/(\d+)h/);
            if (hoursMatch) {
                totalSeconds += parseInt(hoursMatch[1]) * 3600;
            }
            
            // Handle minutes
            const minutesMatch = timeString.match(/(\d+)m/);
            if (minutesMatch) {
                totalSeconds += parseInt(minutesMatch[1]) * 60;
            }
            
            // Handle seconds
            const secondsMatch = timeString.match(/(\d+)s/);
            if (secondsMatch) {
                totalSeconds += parseInt(secondsMatch[1]);
            }
            
            return totalSeconds;
        } catch (error) {
            console.error('Error parsing time remaining:', error);
            return 0;
        }
    },

    /**
     * Initialize the global token status
     */
    initGlobalTokenStatus() {
        // Wait for app to be available before initializing
        this.waitForAppAndInit();
    },

    /**
     * Wait for app to be available and then initialize
     */
    async waitForAppAndInit() {
        let attempts = 0;
        const maxAttempts = 20; // Wait up to 10 seconds
        const retryDelay = 500;
        
        while (attempts < maxAttempts) {
            if (window.app && typeof window.app.getToken === 'function') {
                console.log('✅ App is ready, initializing global token manager...');
                this.createGlobalTokenStatus();
                this.setupGlobalTokenEventListeners();
                this.startGlobalTokenTimer();
                this.updateGlobalTokenStatus();
                return;
            } else {
                attempts++;
                console.log(`⏳ Waiting for app to be ready... (attempt ${attempts}/${maxAttempts})`);
                if (attempts < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                }
            }
        }
        
        console.warn('⚠️ App not available after waiting, initializing global token manager anyway...');
        this.createGlobalTokenStatus();
        this.setupGlobalTokenEventListeners();
        this.startGlobalTokenTimer();
        this.updateGlobalTokenStatus();
    },

    /**
     * Set up event listeners for global token buttons
     */
    setupGlobalTokenEventListeners() {
        // Refresh button
        const refreshBtn = document.getElementById('global-refresh-token');
        if (refreshBtn) {
            refreshBtn.addEventListener('click', () => {
                this.updateGlobalTokenStatus();
            });
        }

        // Get Token button
        const getTokenBtn = document.getElementById('global-get-token');
        if (getTokenBtn) {
            getTokenBtn.addEventListener('click', () => {
                this.getNewToken();
            });
        }
    },

    /**
     * Start the timer to update token status every second
     */
    startGlobalTokenTimer() {
        if (this.globalTokenTimer) {
            clearInterval(this.globalTokenTimer);
        }
        
        this.globalTokenTimer = setInterval(() => {
            this.updateGlobalTokenStatus();
        }, 1000);
    },

    /**
     * Get new token
     */
    async getNewToken() {
        try {
            console.log('Getting new token via global token manager...');
            
            // Wait for app to be available with retry mechanism
            let attempts = 0;
            const maxAttempts = 10;
            const retryDelay = 500;
            
            while (attempts < maxAttempts) {
                if (window.app && typeof window.app.getToken === 'function') {
                    await window.app.getToken();
                    this.updateGlobalTokenStatus();
                    console.log('Token refreshed successfully');
                    return;
                } else {
                    attempts++;
                    console.log(`App not ready yet, attempt ${attempts}/${maxAttempts}`);
                    if (attempts < maxAttempts) {
                        await new Promise(resolve => setTimeout(resolve, retryDelay));
                    }
                }
            }
            
            console.warn('App getToken method not available after retries');
            
            // Fallback: try to trigger token refresh through PingOne client directly
            if (window.app && window.app.pingOneClient && typeof window.app.pingOneClient.getAccessToken === 'function') {
                try {
                    await window.app.pingOneClient.getAccessToken();
                    this.updateGlobalTokenStatus();
                    console.log('Token refreshed via PingOne client');
                    return;
                } catch (error) {
                    console.error('Failed to refresh token via PingOne client:', error);
                }
            }
            
            console.error('No available method to refresh token');
            
        } catch (error) {
            console.error('Error getting new token:', error);
        }
    },

    /**
     * Update status (called from external modules)
     */
    updateStatus() {
        this.updateGlobalTokenStatus();
    }
};

// ES Modules export
export { GlobalTokenManager };
export default GlobalTokenManager;

// Browser global fallback for legacy compatibility
if (typeof window !== 'undefined') {
    window.GlobalTokenManager = GlobalTokenManager;
}

