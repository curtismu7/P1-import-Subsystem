/**
 * Core Utility Functions
 * 
 * Consolidated JavaScript for PingOne Import Tool
 * Generated: 2025-08-06T19:05:53.917Z
 * 
 * This file was automatically generated by js-cleanup-script.js
 * Organized for better maintainability and performance
 */


/* From: public/js/utils/centralized-logger.js */
/**
 * Centralized Logger Utility
 * 
 * Provides structured logging with sensitive data masking, remote logging,
 * and consistent formatting across the application.
 */

class CentralizedLogger {
    constructor(options = {}) {
        this.component = options.component || 'app';
        this.level = options.level || 'info';
        this.enableRemoteLogging = options.enableRemoteLogging !== false;
        this.enableConsoleLogging = options.enableConsoleLogging !== false;
        this.timers = new Map();
        this.sensitivePatterns = [
            /password/i,
            /token/i,
            /secret/i,
            /key/i,
            /credential/i,
            /auth/i
        ];
    }

    /**
     * Mask sensitive data in log messages
     */
    maskSensitiveData(data) {
        if (typeof data === 'string') {
            return data.replace(/("(?:password|token|secret|key|credential|auth)"\s*:\s*")([^"]+)"/gi, '$1***MASKED***"');
        }
        
        if (typeof data === 'object' && data !== null) {
            const masked = { ...data };
            for (const key in masked) {
                if (this.sensitivePatterns.some(pattern => pattern.test(key))) {
                    masked[key] = '***MASKED***';
                } else if (typeof masked[key] === 'object') {
                    masked[key] = this.maskSensitiveData(masked[key]);
                }
            }
            return masked;
        }
        
        return data;
    }

    /**
     * Format log message with timestamp and component info
     */
    formatMessage(level, message, data = null) {
        const timestamp = new Date().toISOString();
        const component = this.component;
        
        let formattedMessage = `[${timestamp}] [${level.toUpperCase()}] [${component}] ${message}`;
        
        if (data) {
            const maskedData = this.maskSensitiveData(data);
            formattedMessage += ` | Data: ${JSON.stringify(maskedData, null, 2)}`;
        }
        
        return formattedMessage;
    }

    /**
     * Send log to remote endpoint
     */
    async sendRemoteLog(level, message, data = null) {
        if (!this.enableRemoteLogging) return;
        
        try {
            const logEntry = {
                timestamp: new Date().toISOString(),
                level,
                component: this.component,
                message,
                data: this.maskSensitiveData(data),
                userAgent: navigator.userAgent,
                url: window.location.href
            };

            await fetch('/api/logs', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(logEntry)
            });
        } catch (error) {
            // Fallback to console if remote logging fails
            if (this.enableConsoleLogging) {
                console.warn('Remote logging failed:', error);
            }
        }
    }

    /**
     * Log debug message
     */
    debug(message, data = null) {
        // Only log if debug mode is enabled in settings
        const settings = window.settings || {};
        if (!settings.debugMode) {
            return; // Suppress debug log if not in debug mode
        }

        try {
            const formattedMessage = this.formatMessage ? this.formatMessage('debug', message, data) : `[DEBUG] ${message}`;
            
            if (this.enableConsoleLogging) {
                console.debug(formattedMessage);
            }
            
            // Optionally, send debug logs remotely if needed for remote debugging sessions
            this.sendRemoteLog('debug', message, data);
        } catch (error) {
            console.debug(`[DEBUG] ${message}`, data);
        }
    }

    /**
     * Log info message
     */
    info(message, data = null) {
        try {
            const formattedMessage = this.formatMessage ? this.formatMessage('info', message, data) : `[INFO] ${message}`;
            
            if (this.enableConsoleLogging) {
                console.log(formattedMessage);
            }
            
            this.sendRemoteLog('info', message, data);
        } catch (error) {
            console.log(`[INFO] ${message}`, data);
        }
    }

    /**
     * Log warning message
     */
    warn(message, data = null) {
        try {
            const formattedMessage = this.formatMessage ? this.formatMessage('warn', message, data) : `[WARN] ${message}`;
            
            if (this.enableConsoleLogging) {
                console.warn(formattedMessage);
            }
            
            this.sendRemoteLog('warn', message, data);
        } catch (error) {
            console.warn(`[WARN] ${message}`, data);
        }
    }

    /**
     * Log error message
     */
    error(message, data = null) {
        try {
            const formattedMessage = this.formatMessage ? this.formatMessage('error', message, data) : `[ERROR] ${message}`;
            
            if (this.enableConsoleLogging) {
                console.error(formattedMessage);
            }
            
            this.sendRemoteLog('error', message, data);
        } catch (error) {
            console.error(`[ERROR] ${message}`, data);
        }
    }

    /**
     * Start a performance timer
     */
    startTimer(label) {
        if (!this.timers) {
            this.timers = new Map();
        }
        
        const startTime = performance ? performance.now() : Date.now();
        this.timers.set(label, startTime);
        
        if (console.time) {
            console.time(label);
        }
        
        this.debug(`Timer started: ${label}`);
        
        return {
            label,
            startTime
        };
    }

    /**
     * End a performance timer
     */
    endTimer(timer) {
        if (!timer || !timer.label) {
            this.warn('Invalid timer object provided to endTimer');
            return 0;
        }
        
        const label = timer.label;
        
        if (!this.timers || !this.timers.has(label)) {
            this.warn(`Timer '${label}' not found`);
            return 0;
        }
        
        const startTime = this.timers.get(label);
        const endTime = performance ? performance.now() : Date.now();
        const duration = endTime - startTime;
        
        this.timers.delete(label);
        
        if (console.timeEnd) {
            console.timeEnd(label);
        }
        
        this.info(`Timer '${label}' completed in ${duration.toFixed(2)}ms`);
        
        return duration;
    }

    /**
     * Create child logger with additional component context
     */
    child(options = {}) {
        const childComponent = options.component 
            ? `${this.component}.${options.component}`
            : this.component;
            
        return new CentralizedLogger({
            ...options,
            component: childComponent,
            level: options.level || this.level,
            enableRemoteLogging: options.enableRemoteLogging !== undefined ? options.enableRemoteLogging : this.enableRemoteLogging,
            enableConsoleLogging: options.enableConsoleLogging !== undefined ? options.enableConsoleLogging : this.enableConsoleLogging
        });
    }
}

// Export for both ES modules and CommonJS
if (typeof module !== 'undefined' && module.exports) {
    // CommonJS
    module.exports = { CentralizedLogger };
} else if (typeof define === 'function' && define.amd) {
    // AMD/RequireJS
    define([], function() {
        return { CentralizedLogger };
    });
} else if (typeof window !== 'undefined') {
    // Browser global
    window.CentralizedLogger = CentralizedLogger;
}

// ES Module export
try {
    if (typeof exports !== 'undefined' && !exports.nodeType) {
        if (typeof module !== 'undefined' && !module.nodeType && module.exports) {
            exports = module.exports = { CentralizedLogger };
        }
        exports.CentralizedLogger = CentralizedLogger;
    } else if (typeof define === 'function' && define.amd) {
        // Already handled by AMD above
    } else if (typeof window !== 'undefined') {
        // Already handled by browser global above
    } else {
        // Fallback for other environments
        var root = typeof global !== 'undefined' ? global : window || {};
        root.CentralizedLogger = CentralizedLogger;
    }
} catch (e) {
    // Silent catch for environments where exports/define might not be available
    if (typeof console !== 'undefined' && console.warn) {
        console.warn('CentralizedLogger export failed:', e);
    }
}

// ES Module export only if in module context
if (typeof window === 'undefined' && typeof exports !== 'undefined') {
    // Node.js environment
    try {
        exports.CentralizedLogger = CentralizedLogger;
    } catch (e) {
        // Silent catch
    }
}



/* From: public/js/utils/error-handler.js */
/**
 * Standardized Error Handling Utility
 * 
 * Provides consistent error handling patterns, error wrapping for async operations,
 * and standardized error reporting across the application.
 */

class ErrorHandler {
    constructor(logger = null) {
        this.logger = logger || {
            error: (msg, data) => console.error(msg, data),
            warn: (msg, data) => console.warn(msg, data),
            debug: (msg, data) => console.debug(msg, data)
        };
    }

    /**
     * Wrap async functions with standardized error handling
     * @param {Function} asyncFn - The async function to wrap
     * @param {string} context - Context description for error reporting
     * @param {Object} options - Options for error handling
     * @returns {Function} Wrapped function with error handling
     */
    wrapAsync(asyncFn, context = 'Unknown operation', userMessage = null, options = {}) {
        const { 
            retries = 0, 
            retryDelay = 1000, 
            fallbackValue = null,
            suppressErrors = false,
            rethrow = false
        } = options;

        return async (...args) => {
            for (let attempt = 0; attempt <= retries; attempt++) {
                try {
                    return await asyncFn(...args);
                } catch (error) {
                    if (attempt < retries) {
                        this.logger.warn(`${context} failed (attempt ${attempt + 1}/${retries + 1}), retrying...`, {
                            error: error.message,
                            args: this._sanitizeArgs(args)
                        });
                        await this._delay(retryDelay * (attempt + 1));
                        continue;
                    }
                    
                    // Final attempt failed
                    this.handleError(error, context, { 
                        userMessage: userMessage || 'An unexpected error occurred.',
                        retries, 
                        suppress: suppressErrors 
                    });

                    if (rethrow) {
                        throw error;
                    }

                    return fallbackValue;
                }
            }
            return fallbackValue; // Should be unreachable if rethrow is false
        };
    }

    /**
     * Wrap synchronous functions with standardized error handling
     * @param {Function} syncFn - The synchronous function to wrap
     * @param {string} context - Context description for error reporting
     * @param {Object} options - Options for error handling
     * @returns {Function} Wrapped function with error handling
     */
    wrapSync(syncFn, context = 'Unknown operation', userMessage = null, options = {}) {
        const {
            fallbackValue = null,
            suppressErrors = false,
            rethrow = false
        } = options;

        return (...args) => {
            try {
                return syncFn(...args);
            } catch (error) {
                this.handleError(error, context, {
                    userMessage: userMessage || 'An unexpected error occurred.',
                    suppress: suppressErrors,
                    args: this._sanitizeArgs(args)
                });

                if (rethrow) {
                    throw error;
                }

                return fallbackValue;
            }
        };
    }

    /**
     * Create a standardized error object
     * @param {string} message - Error message
     * @param {string} code - Error code
     * @param {Object} context - Additional context
     * @param {Error} originalError - Original error if wrapping
     * @returns {Error} Standardized error object
     */
    createError(message, code = 'UNKNOWN_ERROR', context = {}, originalError = null) {
        const error = new Error(message);
        error.code = code;
        error.context = context;
        error.timestamp = new Date().toISOString();
        
        if (originalError) {
            error.originalError = originalError;
            error.originalStack = originalError.stack;
        }
        
        return error;
    }

    /**
     * Handle and report errors with context
     * @param {Error} error - The error to handle
     * @param {string} context - Context description
     * @param {Object} options - Additional data for error reporting
     */
    handleError(error, context = 'Unknown context', options = {}) {
        const { userMessage, suppress, ...additionalData } = options;

        if (suppress) return; // Do not log or show UI error if suppressed

        const errorData = {
            message: error.message,
            code: error.code || 'UNHANDLED_EXCEPTION',
            context: context,
            timestamp: new Date().toISOString(),
            stack: error.stack,
            ...additionalData
        };
        
        this.logger.error(`Error in ${context}:`, errorData);
        
        // Report to external service if configured
        this._reportToErrorService(errorData);
        
        // Show UI notification if UI manager is available
        if (typeof window !== 'undefined' && window.app && window.app.uiManager) {
            const uiManager = window.app.uiManager;
            // Prioritize the user-friendly message for the UI
            const displayMessage = userMessage || error.message;
            uiManager.showError(
                `Error: ${context}`,
                displayMessage
            );
        }
    }

    /**
     * Wrap DOM event handlers with error handling
     * @param {Function} handler - The event handler function
     * @param {string} context - Context description
     * @returns {Function} Wrapped event handler
     */
    wrapEventHandler(handler, context = 'Event handler') {
        return (event) => {
            try {
                return handler(event);
            } catch (error) {
                this.logger.error(`${context} failed`, {
                    error: error.message,
                    eventType: event?.type,
                    target: event?.target?.tagName || 'unknown'
                });
                
                // Prevent error from bubbling up and breaking the UI
                event?.preventDefault?.();
                event?.stopPropagation?.();
            }
        };
    }

    /**
     * Create a safe function that never throws
     * @param {Function} fn - Function to make safe
     * @param {string} context - Context description
     * @param {*} fallbackValue - Value to return on error
     * @returns {Function} Safe function
     */
    makeSafe(fn, context = 'Safe function', fallbackValue = null) {
        return (...args) => {
            try {
                return fn(...args);
            } catch (error) {
                this.logger.warn(`${context} failed safely`, {
                    error: error.message,
                    args: this._sanitizeArgs(args)
                });
                return fallbackValue;
            }
        };
    }

    /**
     * Validate and handle API responses
     * @param {Response} response - Fetch response object
     * @param {string} context - Context description
     * @returns {Promise<Object>} Parsed response data
     */
    async handleApiResponse(response, context = 'API call') {
        try {
            if (!response.ok) {
                const errorData = {
                    status: response.status,
                    statusText: response.statusText,
                    url: response.url
                };
                
                let errorMessage = `${context} failed with status ${response.status}`;
                
                try {
                    const errorBody = await response.text();
                    errorData.body = errorBody;
                    
                    // Try to parse as JSON for more details
                    try {
                        const jsonError = JSON.parse(errorBody);
                        if (jsonError.message) {
                            errorMessage = jsonError.message;
                        }
                    } catch (e) {
                        // Not JSON, use text as is
                    }
                } catch (e) {
                    // Could not read response body
                }
                
                throw this.createError(errorMessage, `HTTP_${response.status}`, errorData);
            }
            
            const data = await response.json();
            return data;
        } catch (error) {
            if (error.code && error.code.startsWith('HTTP_')) {
                throw error; // Re-throw our custom HTTP errors
            }
            
            // Handle JSON parsing or other errors
            throw this.createError(
                `${context} response parsing failed`,
                'RESPONSE_PARSE_ERROR',
                { originalError: error.message }
            );
        }
    }

    // Private helper methods
    _sanitizeArgs(args) {
        return args.map(arg => {
            if (typeof arg === 'string' && arg.length > 100) {
                return arg.substring(0, 100) + '...';
            }
            if (typeof arg === 'object' && arg !== null) {
                return { ...arg, _truncated: true };
            }
            return arg;
        });
    }

    _delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    _reportToErrorService(errorData) {
        // Placeholder for error reporting service integration
        // Could send to external service, local storage, etc.
        if (typeof window !== 'undefined' && window.errorReportingEnabled) {
            // Example: send to error reporting service
            // fetch('/api/errors', { method: 'POST', body: JSON.stringify(errorData) });
        }
    }
}

// Export for both ES modules and CommonJS

if (typeof module !== 'undefined' && module.exports) {
    module.exports = { ErrorHandler };
} else if (typeof window !== 'undefined') {
    window.ErrorHandler = ErrorHandler;
}

// Add ES module export for compatibility with Jest and modern imports
export { ErrorHandler };
export default ErrorHandler;



/* From: public/js/utils/safe-dom.js */
/**
 * ðŸ›¡ï¸ BULLETPROOF SAFE DOM UTILITY
 * 
 * Provides ultra-safe DOM element selection and manipulation with multiple
 * layers of error handling and fallbacks. This utility CANNOT fail under
 * any circumstances and will always provide safe operations.
 */

class SafeDOM {
    constructor(logger = null) {
        // Create bulletproof logger that cannot fail
        this.logger = this.createBulletproofLogger(logger);
        
        // Track operations for debugging
        this.operationCount = 0;
        this.failureCount = 0;
        this.lastOperation = null;
        
        // Initialize immediately
        this.initialize();
    }
    
    /**
     * Initialize SafeDOM - CANNOT FAIL
     */
    initialize() {
        try {
            // Verify DOM is available
            if (typeof document === 'undefined') {
                this.logger.warn('SafeDOM: Document not available, creating mock');
                this.createMockDocument();
            }
            
            this.logger.debug('SafeDOM: Initialized successfully');
        } catch (error) {
            // Even initialization errors are handled
            this.emergencyLog('SafeDOM initialization failed', error);
        }
    }
    
    /**
     * Create bulletproof logger - CANNOT FAIL
     */
    createBulletproofLogger(logger) {
        try {
            if (logger && typeof logger === 'object') {
                return {
                    warn: this.safeLogMethod(logger.warn || console.warn),
                    error: this.safeLogMethod(logger.error || console.error),
                    debug: this.safeLogMethod(logger.debug || console.debug),
                    info: this.safeLogMethod(logger.info || console.info)
                };
            }
        } catch (e) {
            // Fallback to console
        }
        
        // Ultimate fallback logger
        return {
            warn: this.safeLogMethod(console.warn),
            error: this.safeLogMethod(console.error),
            debug: this.safeLogMethod(console.debug),
            info: this.safeLogMethod(console.info)
        };
    }
    
    /**
     * Create safe log method - CANNOT FAIL
     */
    safeLogMethod(originalMethod) {
        return (message, data) => {
            try {
                if (originalMethod && typeof originalMethod === 'function') {
                    originalMethod.call(console, message, data);
                } else {
                    console.log(message, data);
                }
            } catch (e) {
                // Even logging can fail - use emergency logging
                this.emergencyLog(message, data);
            }
        };
    }
    
    /**
     * Create mock document for testing - CANNOT FAIL
     */
    createMockDocument() {
        try {
            window.document = {
                getElementById: () => null,
                querySelector: () => null,
                querySelectorAll: () => [],
                createElement: (tag) => ({ tagName: tag, style: {}, innerHTML: '', textContent: '' }),
                body: { appendChild: () => {}, style: {} },
                head: { appendChild: () => {} }
            };
        } catch (e) {
            // Mock creation failed - continue without it
        }
    }

    /**
     * Safely select a single element - BULLETPROOF - CANNOT FAIL
     */
    select(selector, context = document) {
        return this.executeWithProtection('select', () => {
            // Validate inputs with multiple checks
            if (!this.validateSelector(selector)) {
                return null;
            }
            
            // Validate context
            const safeContext = this.validateContext(context);
            if (!safeContext) {
                return null;
            }
            
            // Multiple selection attempts with fallbacks
            let element = null;
            
            // Attempt 1: Standard querySelector
            try {
                element = safeContext.querySelector(selector);
                if (element) {
                    this.logger.debug(`SafeDOM: Element found for selector: ${selector}`);
                    return element;
                }
            } catch (e) {
                this.logger.debug(`SafeDOM: querySelector failed for ${selector}, trying alternatives`);
            }
            
            // Attempt 2: Try with getElementById if selector looks like an ID
            if (selector.startsWith('#')) {
                try {
                    const id = selector.substring(1);
                    element = safeContext.getElementById ? safeContext.getElementById(id) : null;
                    if (element) {
                        this.logger.debug(`SafeDOM: Element found by ID: ${id}`);
                        return element;
                    }
                } catch (e) {
                    // Continue to next attempt
                }
            }
            
            // Attempt 3: Try with getElementsByClassName if selector looks like a class
            if (selector.startsWith('.')) {
                try {
                    const className = selector.substring(1);
                    const elements = safeContext.getElementsByClassName ? safeContext.getElementsByClassName(className) : [];
                    if (elements && elements.length > 0) {
                        this.logger.debug(`SafeDOM: Element found by class: ${className}`);
                        return elements[0];
                    }
                } catch (e) {
                    // Continue to next attempt
                }
            }
            
            // Attempt 4: Try with getElementsByTagName if selector looks like a tag
            if (selector && !selector.includes('.') && !selector.includes('#') && !selector.includes('[')) {
                try {
                    const elements = safeContext.getElementsByTagName ? safeContext.getElementsByTagName(selector) : [];
                    if (elements && elements.length > 0) {
                        this.logger.debug(`SafeDOM: Element found by tag: ${selector}`);
                        return elements[0];
                    }
                } catch (e) {
                    // Final attempt failed
                }
            }
            
            this.logger.debug(`SafeDOM: Element not found for selector: ${selector}`);
            return null;
        }, selector, context);
    }

    /**
     * Safely select multiple elements
     */
    selectAll(selector, context = document) {
        try {
            if (!selector) {
                this.logger.warn('SafeDOM: Empty selector provided');
                return [];
            }

            const elements = context.querySelectorAll(selector);
            return Array.from(elements);
        } catch (error) {
            this.logger.error('SafeDOM: Error selecting elements', { selector, error: error.message });
            return [];
        }
    }

    /**
     * Safely get element by ID
     */
    getElementById(id) {
        try {
            if (!id || id === '') {
                // Get stack trace to identify caller
                const stack = new Error().stack;
                const caller = stack ? stack.split('\n')[2] : 'unknown';
                this.logger.warn('SafeDOM: Empty ID provided', { caller: caller.trim() });
                return null;
            }

            const element = document.getElementById(id);
            if (!element) {
                this.logger.debug(`SafeDOM: Element not found for ID: ${id}`);
            }
            
            return element;
        } catch (error) {
            this.logger.error('SafeDOM: Error getting element by ID', { id, error: error.message });
            return null;
        }
    }

    /**
     * Alias for getElementById for backward compatibility
     */
    selectById(id) {
        return this.getElementById(id);
    }

    /**
     * Safely set text content
     */
    setText(element, text) {
        try {
            if (!element) {
                this.logger.warn('SafeDOM: Null element provided to setText');
                return false;
            }

            element.textContent = text || '';
            return true;
        } catch (error) {
            this.logger.error('SafeDOM: Error setting text content', { text, error: error.message });
            return false;
        }
    }

    /**
     * Safely set HTML content (with sanitization warning)
     */
    setHTML(element, html) {
        try {
            if (!element) {
                this.logger.warn('SafeDOM: Null element provided to setHTML');
                return false;
            }

            // Warning about potential XSS
            if (html && typeof html === 'string' && (html.includes('<script') || html.includes('javascript:'))) {
                this.logger.warn('SafeDOM: Potentially unsafe HTML detected', { html: html.substring(0, 100) });
            }

            element.innerHTML = html || '';
            return true;
        } catch (error) {
            this.logger.error('SafeDOM: Error setting HTML content', { error: error.message });
            return false;
        }
    }

    /**
     * Safely add event listener
     */
    addEventListener(element, event, handler, options = {}) {
        try {
            if (!element) {
                this.logger.warn('SafeDOM: Null element provided to addEventListener');
                return false;
            }

            if (typeof handler !== 'function') {
                this.logger.warn('SafeDOM: Non-function handler provided to addEventListener');
                return false;
            }

            element.addEventListener(event, handler, options);
            return true;
        } catch (error) {
            this.logger.error('SafeDOM: Error adding event listener', { event, error: error.message });
            return false;
        }
    }

    /**
     * Safely remove event listener
     */
    removeEventListener(element, event, handler, options = {}) {
        try {
            if (!element) {
                this.logger.warn('SafeDOM: Null element provided to removeEventListener');
                return false;
            }

            element.removeEventListener(event, handler, options);
            return true;
        } catch (error) {
            this.logger.error('SafeDOM: Error removing event listener', { event, error: error.message });
            return false;
        }
    }

    /**
     * Safely add CSS class
     */
    addClass(element, className) {
        try {
            if (!element) {
                this.logger.warn('SafeDOM: Null element provided to addClass');
                return false;
            }

            if (!className) {
                this.logger.warn('SafeDOM: Empty className provided to addClass');
                return false;
            }

            element.classList.add(className);
            return true;
        } catch (error) {
            this.logger.error('SafeDOM: Error adding CSS class', { className, error: error.message });
            return false;
        }
    }

    /**
     * Safely remove CSS class
     */
    removeClass(element, className) {
        try {
            if (!element) {
                this.logger.warn('SafeDOM: Null element provided to removeClass');
                return false;
            }

            if (!className) {
                this.logger.warn('SafeDOM: Empty className provided to removeClass');
                return false;
            }

            element.classList.remove(className);
            return true;
        } catch (error) {
            this.logger.error('SafeDOM: Error removing CSS class', { className, error: error.message });
            return false;
        }
    }

    /**
     * Safely toggle CSS class
     */
    toggleClass(element, className) {
        try {
            if (!element) {
                this.logger.warn('SafeDOM: Null element provided to toggleClass');
                return false;
            }

            if (!className) {
                this.logger.warn('SafeDOM: Empty className provided to toggleClass');
                return false;
            }

            element.classList.toggle(className);
            return true;
        } catch (error) {
            this.logger.error('SafeDOM: Error toggling CSS class', { className, error: error.message });
            return false;
        }
    }

    /**
     * Safely show element
     */
    show(element) {
        try {
            if (!element) {
                this.logger.warn('SafeDOM: Null element provided to show');
                return false;
            }

            element.style.display = '';
            return true;
        } catch (error) {
            this.logger.error('SafeDOM: Error showing element', { error: error.message });
            return false;
        }
    }

    /**
     * Safely hide element
     */
    hide(element) {
        try {
            if (!element) {
                this.logger.warn('SafeDOM: Null element provided to hide');
                return false;
            }

            element.style.display = 'none';
            return true;
        } catch (error) {
            this.logger.error('SafeDOM: Error hiding element', { error: error.message });
            return false;
        }
    }
    
    /**
     * Execute operation with bulletproof protection - CANNOT FAIL
     */
    executeWithProtection(operationName, operation, ...args) {
        try {
            this.operationCount++;
            this.lastOperation = { name: operationName, args, timestamp: Date.now() };
            
            const result = operation();
            return result;
        } catch (error) {
            this.failureCount++;
            this.logger.error(`SafeDOM: ${operationName} failed`, {
                error: error.message,
                args,
                operationCount: this.operationCount,
                failureCount: this.failureCount
            });
            return null;
        }
    }
    
    /**
     * Validate selector - CANNOT FAIL
     */
    validateSelector(selector) {
        try {
            if (!selector || selector === '' || typeof selector !== 'string') {
                const stack = new Error().stack;
                const caller = stack ? stack.split('\n')[3] : 'unknown';
                this.logger.warn('SafeDOM: Invalid selector provided', {
                    selector,
                    type: typeof selector,
                    caller: caller.trim()
                });
                return false;
            }
            
            // Check for dangerous selectors
            if (selector.includes('<script') || selector.includes('javascript:')) {
                this.logger.warn('SafeDOM: Potentially dangerous selector blocked', { selector });
                return false;
            }
            
            return true;
        } catch (e) {
            this.emergencyLog('Selector validation failed', e);
            return false;
        }
    }
    
    /**
     * Validate context - CANNOT FAIL
     */
    validateContext(context) {
        try {
            if (!context) {
                return document || this.createMockDocument();
            }
            
            // Check if context has required methods
            if (typeof context.querySelector === 'function') {
                return context;
            }
            
            // Fallback to document
            this.logger.debug('SafeDOM: Invalid context, using document');
            return document || this.createMockDocument();
        } catch (e) {
            this.emergencyLog('Context validation failed', e);
            return document || this.createMockDocument();
        }
    }
    
    /**
     * Emergency logging when everything else fails - CANNOT FAIL
     */
    emergencyLog(message, error) {
        try {
            const timestamp = new Date().toISOString();
            const logMessage = `[${timestamp}] SafeDOM EMERGENCY: ${message}`;
            
            // Try multiple logging methods
            if (console) {
                if (console.error) console.error(logMessage, error);
                else if (console.warn) console.warn(logMessage, error);
                else if (console.log) console.log(logMessage, error);
            }
            
            // Store in global emergency logs
            if (!window.safeDOMEmergencyLogs) window.safeDOMEmergencyLogs = [];
            window.safeDOMEmergencyLogs.push({ timestamp, message, error });
        } catch (e) {
            // Absolute last resort - do nothing but don't crash
        }
    }
    
    /**
     * Get SafeDOM statistics - CANNOT FAIL
     */
    getStats() {
        try {
            return {
                operationCount: this.operationCount,
                failureCount: this.failureCount,
                successRate: this.operationCount > 0 ? ((this.operationCount - this.failureCount) / this.operationCount * 100).toFixed(2) + '%' : '100%',
                lastOperation: this.lastOperation
            };
        } catch (e) {
            return { error: 'Stats unavailable' };
        }
    }
}

// Export for both ES modules and CommonJS
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { SafeDOM };
} else if (typeof window !== 'undefined') {
    window.SafeDOM = SafeDOM;
}

export { SafeDOM };



/* From: public/js/modules/utils/safe-dom.js */
/**
 * Safe DOM Utilities
 * 
 * Provides safe DOM manipulation methods with error handling and validation.
 * Used throughout the application for robust DOM operations.
 */

class SafeDOM {
    constructor(logger = console) {
        this.logger = logger;
    }

    /**
     * Safely get an element by ID
     * @param {string} id - Element ID
     * @returns {Element|null} Element or null if not found
     */
    getElementById(id) {
        try {
            return document.getElementById(id);
        } catch (error) {
            this.logger.error('Error getting element by ID:', { id, error: error.message });
            return null;
        }
    }

    /**
     * Safely query selector
     * @param {string} selector - CSS selector
     * @returns {Element|null} Element or null if not found
     */
    querySelector(selector) {
        try {
            return document.querySelector(selector);
        } catch (error) {
            this.logger.error('Error with querySelector:', { selector, error: error.message });
            return null;
        }
    }

    /**
     * Safely query all selectors
     * @param {string} selector - CSS selector
     * @returns {NodeList|Array} NodeList or empty array if error
     */
    querySelectorAll(selector) {
        try {
            return document.querySelectorAll(selector);
        } catch (error) {
            this.logger.error('Error with querySelectorAll:', { selector, error: error.message });
            return [];
        }
    }

    /**
     * Safely set text content
     * @param {Element} element - DOM element
     * @param {string} text - Text to set
     */
    setText(element, text) {
        try {
            if (element && typeof element.textContent !== 'undefined') {
                element.textContent = text;
            }
        } catch (error) {
            this.logger.error('Error setting text content:', { text, error: error.message });
        }
    }

    /**
     * Safely set HTML content
     * @param {Element} element - DOM element
     * @param {string} html - HTML to set
     */
    setHTML(element, html) {
        try {
            if (element && typeof element.innerHTML !== 'undefined') {
                element.innerHTML = html;
            }
        } catch (error) {
            this.logger.error('Error setting HTML content:', { html, error: error.message });
        }
    }

    /**
     * Safely show element
     * @param {Element} element - DOM element
     */
    show(element) {
        try {
            if (element && element.style) {
                element.style.display = 'block';
            }
        } catch (error) {
            this.logger.error('Error showing element:', { error: error.message });
        }
    }

    /**
     * Safely hide element
     * @param {Element} element - DOM element
     */
    hide(element) {
        try {
            if (element && element.style) {
                element.style.display = 'none';
            }
        } catch (error) {
            this.logger.error('Error hiding element:', { error: error.message });
        }
    }

    /**
     * Safely add class
     * @param {Element} element - DOM element
     * @param {string} className - Class name to add
     */
    addClass(element, className) {
        try {
            if (element && element.classList) {
                element.classList.add(className);
            }
        } catch (error) {
            this.logger.error('Error adding class:', { className, error: error.message });
        }
    }

    /**
     * Safely remove class
     * @param {Element} element - DOM element
     * @param {string} className - Class name to remove
     */
    removeClass(element, className) {
        try {
            if (element && element.classList) {
                element.classList.remove(className);
            }
        } catch (error) {
            this.logger.error('Error removing class:', { className, error: error.message });
        }
    }

    /**
     * Safely set attribute
     * @param {Element} element - DOM element
     * @param {string} name - Attribute name
     * @param {string} value - Attribute value
     */
    setAttribute(element, name, value) {
        try {
            if (element && typeof element.setAttribute === 'function') {
                element.setAttribute(name, value);
            }
        } catch (error) {
            this.logger.error('Error setting attribute:', { name, value, error: error.message });
        }
    }

    /**
     * Safely get attribute
     * @param {Element} element - DOM element
     * @param {string} name - Attribute name
     * @returns {string|null} Attribute value or null
     */
    getAttribute(element, name) {
        try {
            if (element && typeof element.getAttribute === 'function') {
                return element.getAttribute(name);
            }
            return null;
        } catch (error) {
            this.logger.error('Error getting attribute:', { name, error: error.message });
            return null;
        }
    }

    /**
     * Safely add event listener
     * @param {Element} element - DOM element
     * @param {string} event - Event name
     * @param {Function} handler - Event handler
     */
    addEventListener(element, event, handler) {
        try {
            if (element && typeof element.addEventListener === 'function') {
                element.addEventListener(event, handler);
            }
        } catch (error) {
            this.logger.error('Error adding event listener:', { event, error: error.message });
        }
    }

    /**
     * Safely remove event listener
     * @param {Element} element - DOM element
     * @param {string} event - Event name
     * @param {Function} handler - Event handler
     */
    removeEventListener(element, event, handler) {
        try {
            if (element && typeof element.removeEventListener === 'function') {
                element.removeEventListener(event, handler);
            }
        } catch (error) {
            this.logger.error('Error removing event listener:', { event, error: error.message });
        }
    }
}

// Create global instance
// Export for ES modules only
export { SafeDOM };
export default SafeDOM;



/* From: public/js/utils/config-constants.js */
/**
 * Configuration Constants for PingOne Import Tool
 * Centralizes hardcoded values: timeouts, URLs, selectors, messages
 */

// API Configuration
export const API_CONFIG = {
    ENDPOINTS: {
        SETTINGS: '/api/settings',
        IMPORT: '/api/import',
        EXPORT: '/api/export',
        POPULATIONS: '/api/populations',
        TEST_CONNECTION: '/api/pingone/test-connection',
        LOGS: '/api/logs'
    },
    
    TIMEOUTS: {
        DEFAULT: 10000,
        LONG_OPERATION: 30000,
        FILE_UPLOAD: 60000,
        CONNECTION_TEST: 5000
    },
    
    RETRY: {
        MAX_ATTEMPTS: 3,
        DELAYS: [1000, 2000, 5000]
    }
};

// UI Configuration
export const UI_CONFIG = {
    SELECTORS: {
        APP_CONTAINER: '.app-container',
        NAV_ITEMS: '[data-view]',
        SETTINGS_FORM: '#settings-form',
        PROGRESS_BAR: '.progress-bar',
        STATUS_INDICATOR: '.status-indicator',
        MODAL_BACKDROP: '.modal-backdrop'
    },
    
    CLASSES: {
        HIDDEN: 'hidden',
        ACTIVE: 'active',
        LOADING: 'loading',
        ERROR: 'error',
        SUCCESS: 'success'
    }
};

// Messages
export const MESSAGES = {
    SUCCESS: {
        SETTINGS_SAVED: 'Settings saved successfully',
        FILE_UPLOADED: 'File uploaded successfully',
        CONNECTION_SUCCESS: 'Connection test successful'
    },
    
    ERROR: {
        NETWORK_ERROR: 'Network connection error',
        FILE_TOO_LARGE: 'File size exceeds 10MB limit',
        SETTINGS_SAVE_FAILED: 'Failed to save settings',
        CONNECTION_FAILED: 'Connection test failed'
    }
};

// Business Config
export const BUSINESS_CONFIG = {
    FILE_UPLOAD: {
        MAX_SIZE: 10 * 1024 * 1024, // 10MB
        ALLOWED_TYPES: ['.csv', '.txt']
    },
    
    IMPORT: {
        BATCH_SIZE: 100,
        MAX_CONCURRENT: 5
    }
};

// Make available globally
if (typeof window !== 'undefined') {
    window.API_CONFIG = API_CONFIG;
    window.UI_CONFIG = UI_CONFIG;
    window.MESSAGES = MESSAGES;
    window.BUSINESS_CONFIG = BUSINESS_CONFIG;
}


