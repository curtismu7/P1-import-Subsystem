(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
var toPropertyKey = require("./toPropertyKey.js");
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./toPropertyKey.js":4}],2:[function(require,module,exports){
function _interopRequireDefault(e) {
  return e && e.__esModule ? e : {
    "default": e
  };
}
module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],3:[function(require,module,exports){
var _typeof = require("./typeof.js")["default"];
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./typeof.js":5}],4:[function(require,module,exports){
var _typeof = require("./typeof.js")["default"];
var toPrimitive = require("./toPrimitive.js");
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./toPrimitive.js":3,"./typeof.js":5}],5:[function(require,module,exports){
function _typeof(o) {
  "@babel/helpers - typeof";

  return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],6:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

exports.Emitter = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

// alias used for reserved events (protected method)
Emitter.prototype.emitReserved = Emitter.prototype.emit;

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasCORS = void 0;
// imported from https://github.com/component/has-cors
let value = false;
try {
    value = typeof XMLHttpRequest !== 'undefined' &&
        'withCredentials' in new XMLHttpRequest();
}
catch (err) {
    // if XMLHttp support is disabled in IE then it will throw
    // when trying to create
}
exports.hasCORS = value;

},{}],8:[function(require,module,exports){
"use strict";
// imported from https://github.com/galkn/querystring
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.encode = encode;
exports.decode = decode;
function encode(obj) {
    let str = '';
    for (let i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (str.length)
                str += '&';
            str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
        }
    }
    return str;
}
/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */
function decode(qs) {
    let qry = {};
    let pairs = qs.split('&');
    for (let i = 0, l = pairs.length; i < l; i++) {
        let pair = pairs[i].split('=');
        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
    }
    return qry;
}

},{}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = parse;
// imported from https://github.com/galkn/parseuri
/**
 * Parses a URI
 *
 * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.
 *
 * See:
 * - https://developer.mozilla.org/en-US/docs/Web/API/URL
 * - https://caniuse.com/url
 * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B
 *
 * History of the parse() method:
 * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c
 * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3
 * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */
const re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
const parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];
function parse(str) {
    if (str.length > 8000) {
        throw "URI too long";
    }
    const src = str, b = str.indexOf('['), e = str.indexOf(']');
    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }
    let m = re.exec(str || ''), uri = {}, i = 14;
    while (i--) {
        uri[parts[i]] = m[i] || '';
    }
    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }
    uri.pathNames = pathNames(uri, uri['path']);
    uri.queryKey = queryKey(uri, uri['query']);
    return uri;
}
function pathNames(obj, path) {
    const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
    if (path.slice(0, 1) == '/' || path.length === 0) {
        names.splice(0, 1);
    }
    if (path.slice(-1) == '/') {
        names.splice(names.length - 1, 1);
    }
    return names;
}
function queryKey(uri, query) {
    const data = {};
    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
        if ($1) {
            data[$1] = $2;
        }
    });
    return data;
}

},{}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultBinaryType = exports.globalThisShim = exports.nextTick = void 0;
exports.createCookieJar = createCookieJar;
exports.nextTick = (() => {
    const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
    if (isPromiseAvailable) {
        return (cb) => Promise.resolve().then(cb);
    }
    else {
        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
    }
})();
exports.globalThisShim = (() => {
    if (typeof self !== "undefined") {
        return self;
    }
    else if (typeof window !== "undefined") {
        return window;
    }
    else {
        return Function("return this")();
    }
})();
exports.defaultBinaryType = "arraybuffer";
function createCookieJar() { }

},{}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebTransport = exports.WebSocket = exports.NodeWebSocket = exports.XHR = exports.NodeXHR = exports.Fetch = exports.nextTick = exports.parse = exports.installTimerFunctions = exports.transports = exports.TransportError = exports.Transport = exports.protocol = exports.SocketWithUpgrade = exports.SocketWithoutUpgrade = exports.Socket = void 0;
const socket_js_1 = require("./socket.js");
Object.defineProperty(exports, "Socket", { enumerable: true, get: function () { return socket_js_1.Socket; } });
var socket_js_2 = require("./socket.js");
Object.defineProperty(exports, "SocketWithoutUpgrade", { enumerable: true, get: function () { return socket_js_2.SocketWithoutUpgrade; } });
Object.defineProperty(exports, "SocketWithUpgrade", { enumerable: true, get: function () { return socket_js_2.SocketWithUpgrade; } });
exports.protocol = socket_js_1.Socket.protocol;
var transport_js_1 = require("./transport.js");
Object.defineProperty(exports, "Transport", { enumerable: true, get: function () { return transport_js_1.Transport; } });
Object.defineProperty(exports, "TransportError", { enumerable: true, get: function () { return transport_js_1.TransportError; } });
var index_js_1 = require("./transports/index.js");
Object.defineProperty(exports, "transports", { enumerable: true, get: function () { return index_js_1.transports; } });
var util_js_1 = require("./util.js");
Object.defineProperty(exports, "installTimerFunctions", { enumerable: true, get: function () { return util_js_1.installTimerFunctions; } });
var parseuri_js_1 = require("./contrib/parseuri.js");
Object.defineProperty(exports, "parse", { enumerable: true, get: function () { return parseuri_js_1.parse; } });
var globals_node_js_1 = require("./globals.node.js");
Object.defineProperty(exports, "nextTick", { enumerable: true, get: function () { return globals_node_js_1.nextTick; } });
var polling_fetch_js_1 = require("./transports/polling-fetch.js");
Object.defineProperty(exports, "Fetch", { enumerable: true, get: function () { return polling_fetch_js_1.Fetch; } });
var polling_xhr_node_js_1 = require("./transports/polling-xhr.node.js");
Object.defineProperty(exports, "NodeXHR", { enumerable: true, get: function () { return polling_xhr_node_js_1.XHR; } });
var polling_xhr_js_1 = require("./transports/polling-xhr.js");
Object.defineProperty(exports, "XHR", { enumerable: true, get: function () { return polling_xhr_js_1.XHR; } });
var websocket_node_js_1 = require("./transports/websocket.node.js");
Object.defineProperty(exports, "NodeWebSocket", { enumerable: true, get: function () { return websocket_node_js_1.WS; } });
var websocket_js_1 = require("./transports/websocket.js");
Object.defineProperty(exports, "WebSocket", { enumerable: true, get: function () { return websocket_js_1.WS; } });
var webtransport_js_1 = require("./transports/webtransport.js");
Object.defineProperty(exports, "WebTransport", { enumerable: true, get: function () { return webtransport_js_1.WT; } });

},{"./contrib/parseuri.js":9,"./globals.node.js":10,"./socket.js":12,"./transport.js":13,"./transports/index.js":14,"./transports/polling-fetch.js":15,"./transports/polling-xhr.js":16,"./transports/polling-xhr.node.js":16,"./transports/websocket.js":18,"./transports/websocket.node.js":18,"./transports/webtransport.js":19,"./util.js":20}],12:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Socket = exports.SocketWithUpgrade = exports.SocketWithoutUpgrade = void 0;
const index_js_1 = require("./transports/index.js");
const util_js_1 = require("./util.js");
const parseqs_js_1 = require("./contrib/parseqs.js");
const parseuri_js_1 = require("./contrib/parseuri.js");
const component_emitter_1 = require("@socket.io/component-emitter");
const engine_io_parser_1 = require("engine.io-parser");
const globals_node_js_1 = require("./globals.node.js");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("engine.io-client:socket"); // debug()
const withEventListeners = typeof addEventListener === "function" &&
    typeof removeEventListener === "function";
const OFFLINE_EVENT_LISTENERS = [];
if (withEventListeners) {
    // within a ServiceWorker, any event handler for the 'offline' event must be added on the initial evaluation of the
    // script, so we create one single event listener here which will forward the event to the socket instances
    addEventListener("offline", () => {
        debug("closing %d connection(s) because the network was lost", OFFLINE_EVENT_LISTENERS.length);
        OFFLINE_EVENT_LISTENERS.forEach((listener) => listener());
    }, false);
}
/**
 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
 *
 * This class comes without upgrade mechanism, which means that it will keep the first low-level transport that
 * successfully establishes the connection.
 *
 * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.
 *
 * @example
 * import { SocketWithoutUpgrade, WebSocket } from "engine.io-client";
 *
 * const socket = new SocketWithoutUpgrade({
 *   transports: [WebSocket]
 * });
 *
 * socket.on("open", () => {
 *   socket.send("hello");
 * });
 *
 * @see SocketWithUpgrade
 * @see Socket
 */
class SocketWithoutUpgrade extends component_emitter_1.Emitter {
    /**
     * Socket constructor.
     *
     * @param {String|Object} uri - uri or options
     * @param {Object} opts - options
     */
    constructor(uri, opts) {
        super();
        this.binaryType = globals_node_js_1.defaultBinaryType;
        this.writeBuffer = [];
        this._prevBufferLen = 0;
        this._pingInterval = -1;
        this._pingTimeout = -1;
        this._maxPayload = -1;
        /**
         * The expiration timestamp of the {@link _pingTimeoutTimer} object is tracked, in case the timer is throttled and the
         * callback is not fired on time. This can happen for example when a laptop is suspended or when a phone is locked.
         */
        this._pingTimeoutTime = Infinity;
        if (uri && "object" === typeof uri) {
            opts = uri;
            uri = null;
        }
        if (uri) {
            const parsedUri = (0, parseuri_js_1.parse)(uri);
            opts.hostname = parsedUri.host;
            opts.secure =
                parsedUri.protocol === "https" || parsedUri.protocol === "wss";
            opts.port = parsedUri.port;
            if (parsedUri.query)
                opts.query = parsedUri.query;
        }
        else if (opts.host) {
            opts.hostname = (0, parseuri_js_1.parse)(opts.host).host;
        }
        (0, util_js_1.installTimerFunctions)(this, opts);
        this.secure =
            null != opts.secure
                ? opts.secure
                : typeof location !== "undefined" && "https:" === location.protocol;
        if (opts.hostname && !opts.port) {
            // if no port is specified manually, use the protocol default
            opts.port = this.secure ? "443" : "80";
        }
        this.hostname =
            opts.hostname ||
                (typeof location !== "undefined" ? location.hostname : "localhost");
        this.port =
            opts.port ||
                (typeof location !== "undefined" && location.port
                    ? location.port
                    : this.secure
                        ? "443"
                        : "80");
        this.transports = [];
        this._transportsByName = {};
        opts.transports.forEach((t) => {
            const transportName = t.prototype.name;
            this.transports.push(transportName);
            this._transportsByName[transportName] = t;
        });
        this.opts = Object.assign({
            path: "/engine.io",
            agent: false,
            withCredentials: false,
            upgrade: true,
            timestampParam: "t",
            rememberUpgrade: false,
            addTrailingSlash: true,
            rejectUnauthorized: true,
            perMessageDeflate: {
                threshold: 1024,
            },
            transportOptions: {},
            closeOnBeforeunload: false,
        }, opts);
        this.opts.path =
            this.opts.path.replace(/\/$/, "") +
                (this.opts.addTrailingSlash ? "/" : "");
        if (typeof this.opts.query === "string") {
            this.opts.query = (0, parseqs_js_1.decode)(this.opts.query);
        }
        if (withEventListeners) {
            if (this.opts.closeOnBeforeunload) {
                // Firefox closes the connection when the "beforeunload" event is emitted but not Chrome. This event listener
                // ensures every browser behaves the same (no "disconnect" event at the Socket.IO level when the page is
                // closed/reloaded)
                this._beforeunloadEventListener = () => {
                    if (this.transport) {
                        // silently close the transport
                        this.transport.removeAllListeners();
                        this.transport.close();
                    }
                };
                addEventListener("beforeunload", this._beforeunloadEventListener, false);
            }
            if (this.hostname !== "localhost") {
                debug("adding listener for the 'offline' event");
                this._offlineEventListener = () => {
                    this._onClose("transport close", {
                        description: "network connection lost",
                    });
                };
                OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);
            }
        }
        if (this.opts.withCredentials) {
            this._cookieJar = (0, globals_node_js_1.createCookieJar)();
        }
        this._open();
    }
    /**
     * Creates transport of the given type.
     *
     * @param {String} name - transport name
     * @return {Transport}
     * @private
     */
    createTransport(name) {
        debug('creating transport "%s"', name);
        const query = Object.assign({}, this.opts.query);
        // append engine.io protocol identifier
        query.EIO = engine_io_parser_1.protocol;
        // transport name
        query.transport = name;
        // session id if we already have one
        if (this.id)
            query.sid = this.id;
        const opts = Object.assign({}, this.opts, {
            query,
            socket: this,
            hostname: this.hostname,
            secure: this.secure,
            port: this.port,
        }, this.opts.transportOptions[name]);
        debug("options: %j", opts);
        return new this._transportsByName[name](opts);
    }
    /**
     * Initializes transport to use and starts probe.
     *
     * @private
     */
    _open() {
        if (this.transports.length === 0) {
            // Emit error on next tick so it can be listened to
            this.setTimeoutFn(() => {
                this.emitReserved("error", "No transports available");
            }, 0);
            return;
        }
        const transportName = this.opts.rememberUpgrade &&
            SocketWithoutUpgrade.priorWebsocketSuccess &&
            this.transports.indexOf("websocket") !== -1
            ? "websocket"
            : this.transports[0];
        this.readyState = "opening";
        const transport = this.createTransport(transportName);
        transport.open();
        this.setTransport(transport);
    }
    /**
     * Sets the current transport. Disables the existing one (if any).
     *
     * @private
     */
    setTransport(transport) {
        debug("setting transport %s", transport.name);
        if (this.transport) {
            debug("clearing existing transport %s", this.transport.name);
            this.transport.removeAllListeners();
        }
        // set up transport
        this.transport = transport;
        // set up transport listeners
        transport
            .on("drain", this._onDrain.bind(this))
            .on("packet", this._onPacket.bind(this))
            .on("error", this._onError.bind(this))
            .on("close", (reason) => this._onClose("transport close", reason));
    }
    /**
     * Called when connection is deemed open.
     *
     * @private
     */
    onOpen() {
        debug("socket open");
        this.readyState = "open";
        SocketWithoutUpgrade.priorWebsocketSuccess =
            "websocket" === this.transport.name;
        this.emitReserved("open");
        this.flush();
    }
    /**
     * Handles a packet.
     *
     * @private
     */
    _onPacket(packet) {
        if ("opening" === this.readyState ||
            "open" === this.readyState ||
            "closing" === this.readyState) {
            debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
            this.emitReserved("packet", packet);
            // Socket is live - any packet counts
            this.emitReserved("heartbeat");
            switch (packet.type) {
                case "open":
                    this.onHandshake(JSON.parse(packet.data));
                    break;
                case "ping":
                    this._sendPacket("pong");
                    this.emitReserved("ping");
                    this.emitReserved("pong");
                    this._resetPingTimeout();
                    break;
                case "error":
                    const err = new Error("server error");
                    // @ts-ignore
                    err.code = packet.data;
                    this._onError(err);
                    break;
                case "message":
                    this.emitReserved("data", packet.data);
                    this.emitReserved("message", packet.data);
                    break;
            }
        }
        else {
            debug('packet received with socket readyState "%s"', this.readyState);
        }
    }
    /**
     * Called upon handshake completion.
     *
     * @param {Object} data - handshake obj
     * @private
     */
    onHandshake(data) {
        this.emitReserved("handshake", data);
        this.id = data.sid;
        this.transport.query.sid = data.sid;
        this._pingInterval = data.pingInterval;
        this._pingTimeout = data.pingTimeout;
        this._maxPayload = data.maxPayload;
        this.onOpen();
        // In case open handler closes socket
        if ("closed" === this.readyState)
            return;
        this._resetPingTimeout();
    }
    /**
     * Sets and resets ping timeout timer based on server pings.
     *
     * @private
     */
    _resetPingTimeout() {
        this.clearTimeoutFn(this._pingTimeoutTimer);
        const delay = this._pingInterval + this._pingTimeout;
        this._pingTimeoutTime = Date.now() + delay;
        this._pingTimeoutTimer = this.setTimeoutFn(() => {
            this._onClose("ping timeout");
        }, delay);
        if (this.opts.autoUnref) {
            this._pingTimeoutTimer.unref();
        }
    }
    /**
     * Called on `drain` event
     *
     * @private
     */
    _onDrain() {
        this.writeBuffer.splice(0, this._prevBufferLen);
        // setting prevBufferLen = 0 is very important
        // for example, when upgrading, upgrade packet is sent over,
        // and a nonzero prevBufferLen could cause problems on `drain`
        this._prevBufferLen = 0;
        if (0 === this.writeBuffer.length) {
            this.emitReserved("drain");
        }
        else {
            this.flush();
        }
    }
    /**
     * Flush write buffers.
     *
     * @private
     */
    flush() {
        if ("closed" !== this.readyState &&
            this.transport.writable &&
            !this.upgrading &&
            this.writeBuffer.length) {
            const packets = this._getWritablePackets();
            debug("flushing %d packets in socket", packets.length);
            this.transport.send(packets);
            // keep track of current length of writeBuffer
            // splice writeBuffer and callbackBuffer on `drain`
            this._prevBufferLen = packets.length;
            this.emitReserved("flush");
        }
    }
    /**
     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
     * long-polling)
     *
     * @private
     */
    _getWritablePackets() {
        const shouldCheckPayloadSize = this._maxPayload &&
            this.transport.name === "polling" &&
            this.writeBuffer.length > 1;
        if (!shouldCheckPayloadSize) {
            return this.writeBuffer;
        }
        let payloadSize = 1; // first packet type
        for (let i = 0; i < this.writeBuffer.length; i++) {
            const data = this.writeBuffer[i].data;
            if (data) {
                payloadSize += (0, util_js_1.byteLength)(data);
            }
            if (i > 0 && payloadSize > this._maxPayload) {
                debug("only send %d out of %d packets", i, this.writeBuffer.length);
                return this.writeBuffer.slice(0, i);
            }
            payloadSize += 2; // separator + packet type
        }
        debug("payload size is %d (max: %d)", payloadSize, this._maxPayload);
        return this.writeBuffer;
    }
    /**
     * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
     *
     * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
     * `write()` method then the message would not be buffered by the Socket.IO client.
     *
     * @return {boolean}
     * @private
     */
    /* private */ _hasPingExpired() {
        if (!this._pingTimeoutTime)
            return true;
        const hasExpired = Date.now() > this._pingTimeoutTime;
        if (hasExpired) {
            debug("throttled timer detected, scheduling connection close");
            this._pingTimeoutTime = 0;
            (0, globals_node_js_1.nextTick)(() => {
                this._onClose("ping timeout");
            }, this.setTimeoutFn);
        }
        return hasExpired;
    }
    /**
     * Sends a message.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @return {Socket} for chaining.
     */
    write(msg, options, fn) {
        this._sendPacket("message", msg, options, fn);
        return this;
    }
    /**
     * Sends a message. Alias of {@link Socket#write}.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @return {Socket} for chaining.
     */
    send(msg, options, fn) {
        this._sendPacket("message", msg, options, fn);
        return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} type: packet type.
     * @param {String} data.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @private
     */
    _sendPacket(type, data, options, fn) {
        if ("function" === typeof data) {
            fn = data;
            data = undefined;
        }
        if ("function" === typeof options) {
            fn = options;
            options = null;
        }
        if ("closing" === this.readyState || "closed" === this.readyState) {
            return;
        }
        options = options || {};
        options.compress = false !== options.compress;
        const packet = {
            type: type,
            data: data,
            options: options,
        };
        this.emitReserved("packetCreate", packet);
        this.writeBuffer.push(packet);
        if (fn)
            this.once("flush", fn);
        this.flush();
    }
    /**
     * Closes the connection.
     */
    close() {
        const close = () => {
            this._onClose("forced close");
            debug("socket closing - telling transport to close");
            this.transport.close();
        };
        const cleanupAndClose = () => {
            this.off("upgrade", cleanupAndClose);
            this.off("upgradeError", cleanupAndClose);
            close();
        };
        const waitForUpgrade = () => {
            // wait for upgrade to finish since we can't send packets while pausing a transport
            this.once("upgrade", cleanupAndClose);
            this.once("upgradeError", cleanupAndClose);
        };
        if ("opening" === this.readyState || "open" === this.readyState) {
            this.readyState = "closing";
            if (this.writeBuffer.length) {
                this.once("drain", () => {
                    if (this.upgrading) {
                        waitForUpgrade();
                    }
                    else {
                        close();
                    }
                });
            }
            else if (this.upgrading) {
                waitForUpgrade();
            }
            else {
                close();
            }
        }
        return this;
    }
    /**
     * Called upon transport error
     *
     * @private
     */
    _onError(err) {
        debug("socket error %j", err);
        SocketWithoutUpgrade.priorWebsocketSuccess = false;
        if (this.opts.tryAllTransports &&
            this.transports.length > 1 &&
            this.readyState === "opening") {
            debug("trying next transport");
            this.transports.shift();
            return this._open();
        }
        this.emitReserved("error", err);
        this._onClose("transport error", err);
    }
    /**
     * Called upon transport close.
     *
     * @private
     */
    _onClose(reason, description) {
        if ("opening" === this.readyState ||
            "open" === this.readyState ||
            "closing" === this.readyState) {
            debug('socket close with reason: "%s"', reason);
            // clear timers
            this.clearTimeoutFn(this._pingTimeoutTimer);
            // stop event from firing again for transport
            this.transport.removeAllListeners("close");
            // ensure transport won't stay open
            this.transport.close();
            // ignore further transport communication
            this.transport.removeAllListeners();
            if (withEventListeners) {
                if (this._beforeunloadEventListener) {
                    removeEventListener("beforeunload", this._beforeunloadEventListener, false);
                }
                if (this._offlineEventListener) {
                    const i = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
                    if (i !== -1) {
                        debug("removing listener for the 'offline' event");
                        OFFLINE_EVENT_LISTENERS.splice(i, 1);
                    }
                }
            }
            // set ready state
            this.readyState = "closed";
            // clear session id
            this.id = null;
            // emit close event
            this.emitReserved("close", reason, description);
            // clean buffers after, so users can still
            // grab the buffers on `close` event
            this.writeBuffer = [];
            this._prevBufferLen = 0;
        }
    }
}
exports.SocketWithoutUpgrade = SocketWithoutUpgrade;
SocketWithoutUpgrade.protocol = engine_io_parser_1.protocol;
/**
 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
 *
 * This class comes with an upgrade mechanism, which means that once the connection is established with the first
 * low-level transport, it will try to upgrade to a better transport.
 *
 * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.
 *
 * @example
 * import { SocketWithUpgrade, WebSocket } from "engine.io-client";
 *
 * const socket = new SocketWithUpgrade({
 *   transports: [WebSocket]
 * });
 *
 * socket.on("open", () => {
 *   socket.send("hello");
 * });
 *
 * @see SocketWithoutUpgrade
 * @see Socket
 */
class SocketWithUpgrade extends SocketWithoutUpgrade {
    constructor() {
        super(...arguments);
        this._upgrades = [];
    }
    onOpen() {
        super.onOpen();
        if ("open" === this.readyState && this.opts.upgrade) {
            debug("starting upgrade probes");
            for (let i = 0; i < this._upgrades.length; i++) {
                this._probe(this._upgrades[i]);
            }
        }
    }
    /**
     * Probes a transport.
     *
     * @param {String} name - transport name
     * @private
     */
    _probe(name) {
        debug('probing transport "%s"', name);
        let transport = this.createTransport(name);
        let failed = false;
        SocketWithoutUpgrade.priorWebsocketSuccess = false;
        const onTransportOpen = () => {
            if (failed)
                return;
            debug('probe transport "%s" opened', name);
            transport.send([{ type: "ping", data: "probe" }]);
            transport.once("packet", (msg) => {
                if (failed)
                    return;
                if ("pong" === msg.type && "probe" === msg.data) {
                    debug('probe transport "%s" pong', name);
                    this.upgrading = true;
                    this.emitReserved("upgrading", transport);
                    if (!transport)
                        return;
                    SocketWithoutUpgrade.priorWebsocketSuccess =
                        "websocket" === transport.name;
                    debug('pausing current transport "%s"', this.transport.name);
                    this.transport.pause(() => {
                        if (failed)
                            return;
                        if ("closed" === this.readyState)
                            return;
                        debug("changing transport and sending upgrade packet");
                        cleanup();
                        this.setTransport(transport);
                        transport.send([{ type: "upgrade" }]);
                        this.emitReserved("upgrade", transport);
                        transport = null;
                        this.upgrading = false;
                        this.flush();
                    });
                }
                else {
                    debug('probe transport "%s" failed', name);
                    const err = new Error("probe error");
                    // @ts-ignore
                    err.transport = transport.name;
                    this.emitReserved("upgradeError", err);
                }
            });
        };
        function freezeTransport() {
            if (failed)
                return;
            // Any callback called by transport should be ignored since now
            failed = true;
            cleanup();
            transport.close();
            transport = null;
        }
        // Handle any error that happens while probing
        const onerror = (err) => {
            const error = new Error("probe error: " + err);
            // @ts-ignore
            error.transport = transport.name;
            freezeTransport();
            debug('probe transport "%s" failed because of error: %s', name, err);
            this.emitReserved("upgradeError", error);
        };
        function onTransportClose() {
            onerror("transport closed");
        }
        // When the socket is closed while we're probing
        function onclose() {
            onerror("socket closed");
        }
        // When the socket is upgraded while we're probing
        function onupgrade(to) {
            if (transport && to.name !== transport.name) {
                debug('"%s" works - aborting "%s"', to.name, transport.name);
                freezeTransport();
            }
        }
        // Remove all listeners on the transport and on self
        const cleanup = () => {
            transport.removeListener("open", onTransportOpen);
            transport.removeListener("error", onerror);
            transport.removeListener("close", onTransportClose);
            this.off("close", onclose);
            this.off("upgrading", onupgrade);
        };
        transport.once("open", onTransportOpen);
        transport.once("error", onerror);
        transport.once("close", onTransportClose);
        this.once("close", onclose);
        this.once("upgrading", onupgrade);
        if (this._upgrades.indexOf("webtransport") !== -1 &&
            name !== "webtransport") {
            // favor WebTransport
            this.setTimeoutFn(() => {
                if (!failed) {
                    transport.open();
                }
            }, 200);
        }
        else {
            transport.open();
        }
    }
    onHandshake(data) {
        this._upgrades = this._filterUpgrades(data.upgrades);
        super.onHandshake(data);
    }
    /**
     * Filters upgrades, returning only those matching client transports.
     *
     * @param {Array} upgrades - server upgrades
     * @private
     */
    _filterUpgrades(upgrades) {
        const filteredUpgrades = [];
        for (let i = 0; i < upgrades.length; i++) {
            if (~this.transports.indexOf(upgrades[i]))
                filteredUpgrades.push(upgrades[i]);
        }
        return filteredUpgrades;
    }
}
exports.SocketWithUpgrade = SocketWithUpgrade;
/**
 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
 *
 * This class comes with an upgrade mechanism, which means that once the connection is established with the first
 * low-level transport, it will try to upgrade to a better transport.
 *
 * @example
 * import { Socket } from "engine.io-client";
 *
 * const socket = new Socket();
 *
 * socket.on("open", () => {
 *   socket.send("hello");
 * });
 *
 * @see SocketWithoutUpgrade
 * @see SocketWithUpgrade
 */
class Socket extends SocketWithUpgrade {
    constructor(uri, opts = {}) {
        const o = typeof uri === "object" ? uri : opts;
        if (!o.transports ||
            (o.transports && typeof o.transports[0] === "string")) {
            o.transports = (o.transports || ["polling", "websocket", "webtransport"])
                .map((transportName) => index_js_1.transports[transportName])
                .filter((t) => !!t);
        }
        super(uri, o);
    }
}
exports.Socket = Socket;

},{"./contrib/parseqs.js":8,"./contrib/parseuri.js":9,"./globals.node.js":10,"./transports/index.js":14,"./util.js":20,"@socket.io/component-emitter":6,"debug":21,"engine.io-parser":27}],13:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transport = exports.TransportError = void 0;
const engine_io_parser_1 = require("engine.io-parser");
const component_emitter_1 = require("@socket.io/component-emitter");
const util_js_1 = require("./util.js");
const parseqs_js_1 = require("./contrib/parseqs.js");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("engine.io-client:transport"); // debug()
class TransportError extends Error {
    constructor(reason, description, context) {
        super(reason);
        this.description = description;
        this.context = context;
        this.type = "TransportError";
    }
}
exports.TransportError = TransportError;
class Transport extends component_emitter_1.Emitter {
    /**
     * Transport abstract constructor.
     *
     * @param {Object} opts - options
     * @protected
     */
    constructor(opts) {
        super();
        this.writable = false;
        (0, util_js_1.installTimerFunctions)(this, opts);
        this.opts = opts;
        this.query = opts.query;
        this.socket = opts.socket;
        this.supportsBinary = !opts.forceBase64;
    }
    /**
     * Emits an error.
     *
     * @param {String} reason
     * @param description
     * @param context - the error context
     * @return {Transport} for chaining
     * @protected
     */
    onError(reason, description, context) {
        super.emitReserved("error", new TransportError(reason, description, context));
        return this;
    }
    /**
     * Opens the transport.
     */
    open() {
        this.readyState = "opening";
        this.doOpen();
        return this;
    }
    /**
     * Closes the transport.
     */
    close() {
        if (this.readyState === "opening" || this.readyState === "open") {
            this.doClose();
            this.onClose();
        }
        return this;
    }
    /**
     * Sends multiple packets.
     *
     * @param {Array} packets
     */
    send(packets) {
        if (this.readyState === "open") {
            this.write(packets);
        }
        else {
            // this might happen if the transport was silently closed in the beforeunload event handler
            debug("transport is not open, discarding packets");
        }
    }
    /**
     * Called upon open
     *
     * @protected
     */
    onOpen() {
        this.readyState = "open";
        this.writable = true;
        super.emitReserved("open");
    }
    /**
     * Called with data.
     *
     * @param {String} data
     * @protected
     */
    onData(data) {
        const packet = (0, engine_io_parser_1.decodePacket)(data, this.socket.binaryType);
        this.onPacket(packet);
    }
    /**
     * Called with a decoded packet.
     *
     * @protected
     */
    onPacket(packet) {
        super.emitReserved("packet", packet);
    }
    /**
     * Called upon close.
     *
     * @protected
     */
    onClose(details) {
        this.readyState = "closed";
        super.emitReserved("close", details);
    }
    /**
     * Pauses the transport, in order not to lose packets during an upgrade.
     *
     * @param onPause
     */
    pause(onPause) { }
    createUri(schema, query = {}) {
        return (schema +
            "://" +
            this._hostname() +
            this._port() +
            this.opts.path +
            this._query(query));
    }
    _hostname() {
        const hostname = this.opts.hostname;
        return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
    }
    _port() {
        if (this.opts.port &&
            ((this.opts.secure && Number(this.opts.port !== 443)) ||
                (!this.opts.secure && Number(this.opts.port) !== 80))) {
            return ":" + this.opts.port;
        }
        else {
            return "";
        }
    }
    _query(query) {
        const encodedQuery = (0, parseqs_js_1.encode)(query);
        return encodedQuery.length ? "?" + encodedQuery : "";
    }
}
exports.Transport = Transport;

},{"./contrib/parseqs.js":8,"./util.js":20,"@socket.io/component-emitter":6,"debug":21,"engine.io-parser":27}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transports = void 0;
const polling_xhr_node_js_1 = require("./polling-xhr.node.js");
const websocket_node_js_1 = require("./websocket.node.js");
const webtransport_js_1 = require("./webtransport.js");
exports.transports = {
    websocket: websocket_node_js_1.WS,
    webtransport: webtransport_js_1.WT,
    polling: polling_xhr_node_js_1.XHR,
};

},{"./polling-xhr.node.js":16,"./websocket.node.js":18,"./webtransport.js":19}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Fetch = void 0;
const polling_js_1 = require("./polling.js");
/**
 * HTTP long-polling based on the built-in `fetch()` method.
 *
 * Usage: browser, Node.js (since v18), Deno, Bun
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/fetch
 * @see https://caniuse.com/fetch
 * @see https://nodejs.org/api/globals.html#fetch
 */
class Fetch extends polling_js_1.Polling {
    doPoll() {
        this._fetch()
            .then((res) => {
            if (!res.ok) {
                return this.onError("fetch read error", res.status, res);
            }
            res.text().then((data) => this.onData(data));
        })
            .catch((err) => {
            this.onError("fetch read error", err);
        });
    }
    doWrite(data, callback) {
        this._fetch(data)
            .then((res) => {
            if (!res.ok) {
                return this.onError("fetch write error", res.status, res);
            }
            callback();
        })
            .catch((err) => {
            this.onError("fetch write error", err);
        });
    }
    _fetch(data) {
        var _a;
        const isPost = data !== undefined;
        const headers = new Headers(this.opts.extraHeaders);
        if (isPost) {
            headers.set("content-type", "text/plain;charset=UTF-8");
        }
        (_a = this.socket._cookieJar) === null || _a === void 0 ? void 0 : _a.appendCookies(headers);
        return fetch(this.uri(), {
            method: isPost ? "POST" : "GET",
            body: isPost ? data : null,
            headers,
            credentials: this.opts.withCredentials ? "include" : "omit",
        }).then((res) => {
            var _a;
            // @ts-ignore getSetCookie() was added in Node.js v19.7.0
            (_a = this.socket._cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(res.headers.getSetCookie());
            return res;
        });
    }
}
exports.Fetch = Fetch;

},{"./polling.js":17}],16:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XHR = exports.Request = exports.BaseXHR = void 0;
const polling_js_1 = require("./polling.js");
const component_emitter_1 = require("@socket.io/component-emitter");
const util_js_1 = require("../util.js");
const globals_node_js_1 = require("../globals.node.js");
const has_cors_js_1 = require("../contrib/has-cors.js");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("engine.io-client:polling"); // debug()
function empty() { }
class BaseXHR extends polling_js_1.Polling {
    /**
     * XHR Polling constructor.
     *
     * @param {Object} opts
     * @package
     */
    constructor(opts) {
        super(opts);
        if (typeof location !== "undefined") {
            const isSSL = "https:" === location.protocol;
            let port = location.port;
            // some user agents have empty `location.port`
            if (!port) {
                port = isSSL ? "443" : "80";
            }
            this.xd =
                (typeof location !== "undefined" &&
                    opts.hostname !== location.hostname) ||
                    port !== opts.port;
        }
    }
    /**
     * Sends data.
     *
     * @param {String} data to send.
     * @param {Function} called upon flush.
     * @private
     */
    doWrite(data, fn) {
        const req = this.request({
            method: "POST",
            data: data,
        });
        req.on("success", fn);
        req.on("error", (xhrStatus, context) => {
            this.onError("xhr post error", xhrStatus, context);
        });
    }
    /**
     * Starts a poll cycle.
     *
     * @private
     */
    doPoll() {
        debug("xhr poll");
        const req = this.request();
        req.on("data", this.onData.bind(this));
        req.on("error", (xhrStatus, context) => {
            this.onError("xhr poll error", xhrStatus, context);
        });
        this.pollXhr = req;
    }
}
exports.BaseXHR = BaseXHR;
class Request extends component_emitter_1.Emitter {
    /**
     * Request constructor
     *
     * @param {Object} options
     * @package
     */
    constructor(createRequest, uri, opts) {
        super();
        this.createRequest = createRequest;
        (0, util_js_1.installTimerFunctions)(this, opts);
        this._opts = opts;
        this._method = opts.method || "GET";
        this._uri = uri;
        this._data = undefined !== opts.data ? opts.data : null;
        this._create();
    }
    /**
     * Creates the XHR object and sends the request.
     *
     * @private
     */
    _create() {
        var _a;
        const opts = (0, util_js_1.pick)(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
        opts.xdomain = !!this._opts.xd;
        const xhr = (this._xhr = this.createRequest(opts));
        try {
            debug("xhr open %s: %s", this._method, this._uri);
            xhr.open(this._method, this._uri, true);
            try {
                if (this._opts.extraHeaders) {
                    // @ts-ignore
                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
                    for (let i in this._opts.extraHeaders) {
                        if (this._opts.extraHeaders.hasOwnProperty(i)) {
                            xhr.setRequestHeader(i, this._opts.extraHeaders[i]);
                        }
                    }
                }
            }
            catch (e) { }
            if ("POST" === this._method) {
                try {
                    xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
                }
                catch (e) { }
            }
            try {
                xhr.setRequestHeader("Accept", "*/*");
            }
            catch (e) { }
            (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);
            // ie6 check
            if ("withCredentials" in xhr) {
                xhr.withCredentials = this._opts.withCredentials;
            }
            if (this._opts.requestTimeout) {
                xhr.timeout = this._opts.requestTimeout;
            }
            xhr.onreadystatechange = () => {
                var _a;
                if (xhr.readyState === 3) {
                    (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(
                    // @ts-ignore
                    xhr.getResponseHeader("set-cookie"));
                }
                if (4 !== xhr.readyState)
                    return;
                if (200 === xhr.status || 1223 === xhr.status) {
                    this._onLoad();
                }
                else {
                    // make sure the `error` event handler that's user-set
                    // does not throw in the same tick and gets caught here
                    this.setTimeoutFn(() => {
                        this._onError(typeof xhr.status === "number" ? xhr.status : 0);
                    }, 0);
                }
            };
            debug("xhr data %s", this._data);
            xhr.send(this._data);
        }
        catch (e) {
            // Need to defer since .create() is called directly from the constructor
            // and thus the 'error' event can only be only bound *after* this exception
            // occurs.  Therefore, also, we cannot throw here at all.
            this.setTimeoutFn(() => {
                this._onError(e);
            }, 0);
            return;
        }
        if (typeof document !== "undefined") {
            this._index = Request.requestsCount++;
            Request.requests[this._index] = this;
        }
    }
    /**
     * Called upon error.
     *
     * @private
     */
    _onError(err) {
        this.emitReserved("error", err, this._xhr);
        this._cleanup(true);
    }
    /**
     * Cleans up house.
     *
     * @private
     */
    _cleanup(fromError) {
        if ("undefined" === typeof this._xhr || null === this._xhr) {
            return;
        }
        this._xhr.onreadystatechange = empty;
        if (fromError) {
            try {
                this._xhr.abort();
            }
            catch (e) { }
        }
        if (typeof document !== "undefined") {
            delete Request.requests[this._index];
        }
        this._xhr = null;
    }
    /**
     * Called upon load.
     *
     * @private
     */
    _onLoad() {
        const data = this._xhr.responseText;
        if (data !== null) {
            this.emitReserved("data", data);
            this.emitReserved("success");
            this._cleanup();
        }
    }
    /**
     * Aborts the request.
     *
     * @package
     */
    abort() {
        this._cleanup();
    }
}
exports.Request = Request;
Request.requestsCount = 0;
Request.requests = {};
/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */
if (typeof document !== "undefined") {
    // @ts-ignore
    if (typeof attachEvent === "function") {
        // @ts-ignore
        attachEvent("onunload", unloadHandler);
    }
    else if (typeof addEventListener === "function") {
        const terminationEvent = "onpagehide" in globals_node_js_1.globalThisShim ? "pagehide" : "unload";
        addEventListener(terminationEvent, unloadHandler, false);
    }
}
function unloadHandler() {
    for (let i in Request.requests) {
        if (Request.requests.hasOwnProperty(i)) {
            Request.requests[i].abort();
        }
    }
}
const hasXHR2 = (function () {
    const xhr = newRequest({
        xdomain: false,
    });
    return xhr && xhr.responseType !== null;
})();
/**
 * HTTP long-polling based on the built-in `XMLHttpRequest` object.
 *
 * Usage: browser
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest
 */
class XHR extends BaseXHR {
    constructor(opts) {
        super(opts);
        const forceBase64 = opts && opts.forceBase64;
        this.supportsBinary = hasXHR2 && !forceBase64;
    }
    request(opts = {}) {
        Object.assign(opts, { xd: this.xd }, this.opts);
        return new Request(newRequest, this.uri(), opts);
    }
}
exports.XHR = XHR;
function newRequest(opts) {
    const xdomain = opts.xdomain;
    // XMLHttpRequest can be disabled on IE
    try {
        if ("undefined" !== typeof XMLHttpRequest && (!xdomain || has_cors_js_1.hasCORS)) {
            return new XMLHttpRequest();
        }
    }
    catch (e) { }
    if (!xdomain) {
        try {
            return new globals_node_js_1.globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
        }
        catch (e) { }
    }
}

},{"../contrib/has-cors.js":7,"../globals.node.js":10,"../util.js":20,"./polling.js":17,"@socket.io/component-emitter":6,"debug":21}],17:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Polling = void 0;
const transport_js_1 = require("../transport.js");
const util_js_1 = require("../util.js");
const engine_io_parser_1 = require("engine.io-parser");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("engine.io-client:polling"); // debug()
class Polling extends transport_js_1.Transport {
    constructor() {
        super(...arguments);
        this._polling = false;
    }
    get name() {
        return "polling";
    }
    /**
     * Opens the socket (triggers polling). We write a PING message to determine
     * when the transport is open.
     *
     * @protected
     */
    doOpen() {
        this._poll();
    }
    /**
     * Pauses polling.
     *
     * @param {Function} onPause - callback upon buffers are flushed and transport is paused
     * @package
     */
    pause(onPause) {
        this.readyState = "pausing";
        const pause = () => {
            debug("paused");
            this.readyState = "paused";
            onPause();
        };
        if (this._polling || !this.writable) {
            let total = 0;
            if (this._polling) {
                debug("we are currently polling - waiting to pause");
                total++;
                this.once("pollComplete", function () {
                    debug("pre-pause polling complete");
                    --total || pause();
                });
            }
            if (!this.writable) {
                debug("we are currently writing - waiting to pause");
                total++;
                this.once("drain", function () {
                    debug("pre-pause writing complete");
                    --total || pause();
                });
            }
        }
        else {
            pause();
        }
    }
    /**
     * Starts polling cycle.
     *
     * @private
     */
    _poll() {
        debug("polling");
        this._polling = true;
        this.doPoll();
        this.emitReserved("poll");
    }
    /**
     * Overloads onData to detect payloads.
     *
     * @protected
     */
    onData(data) {
        debug("polling got data %s", data);
        const callback = (packet) => {
            // if its the first message we consider the transport open
            if ("opening" === this.readyState && packet.type === "open") {
                this.onOpen();
            }
            // if its a close packet, we close the ongoing requests
            if ("close" === packet.type) {
                this.onClose({ description: "transport closed by the server" });
                return false;
            }
            // otherwise bypass onData and handle the message
            this.onPacket(packet);
        };
        // decode payload
        (0, engine_io_parser_1.decodePayload)(data, this.socket.binaryType).forEach(callback);
        // if an event did not trigger closing
        if ("closed" !== this.readyState) {
            // if we got data we're not polling
            this._polling = false;
            this.emitReserved("pollComplete");
            if ("open" === this.readyState) {
                this._poll();
            }
            else {
                debug('ignoring poll - transport state "%s"', this.readyState);
            }
        }
    }
    /**
     * For polling, send a close packet.
     *
     * @protected
     */
    doClose() {
        const close = () => {
            debug("writing close packet");
            this.write([{ type: "close" }]);
        };
        if ("open" === this.readyState) {
            debug("transport open - closing");
            close();
        }
        else {
            // in case we're trying to close while
            // handshaking is in progress (GH-164)
            debug("transport not open - deferring close");
            this.once("open", close);
        }
    }
    /**
     * Writes a packets payload.
     *
     * @param {Array} packets - data packets
     * @protected
     */
    write(packets) {
        this.writable = false;
        (0, engine_io_parser_1.encodePayload)(packets, (data) => {
            this.doWrite(data, () => {
                this.writable = true;
                this.emitReserved("drain");
            });
        });
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */
    uri() {
        const schema = this.opts.secure ? "https" : "http";
        const query = this.query || {};
        // cache busting is forced
        if (false !== this.opts.timestampRequests) {
            query[this.opts.timestampParam] = (0, util_js_1.randomString)();
        }
        if (!this.supportsBinary && !query.sid) {
            query.b64 = 1;
        }
        return this.createUri(schema, query);
    }
}
exports.Polling = Polling;

},{"../transport.js":13,"../util.js":20,"debug":21,"engine.io-parser":27}],18:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WS = exports.BaseWS = void 0;
const transport_js_1 = require("../transport.js");
const util_js_1 = require("../util.js");
const engine_io_parser_1 = require("engine.io-parser");
const globals_node_js_1 = require("../globals.node.js");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("engine.io-client:websocket"); // debug()
// detect ReactNative environment
const isReactNative = typeof navigator !== "undefined" &&
    typeof navigator.product === "string" &&
    navigator.product.toLowerCase() === "reactnative";
class BaseWS extends transport_js_1.Transport {
    get name() {
        return "websocket";
    }
    doOpen() {
        const uri = this.uri();
        const protocols = this.opts.protocols;
        // React Native only supports the 'headers' option, and will print a warning if anything else is passed
        const opts = isReactNative
            ? {}
            : (0, util_js_1.pick)(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
        if (this.opts.extraHeaders) {
            opts.headers = this.opts.extraHeaders;
        }
        try {
            this.ws = this.createSocket(uri, protocols, opts);
        }
        catch (err) {
            return this.emitReserved("error", err);
        }
        this.ws.binaryType = this.socket.binaryType;
        this.addEventListeners();
    }
    /**
     * Adds event listeners to the socket
     *
     * @private
     */
    addEventListeners() {
        this.ws.onopen = () => {
            if (this.opts.autoUnref) {
                this.ws._socket.unref();
            }
            this.onOpen();
        };
        this.ws.onclose = (closeEvent) => this.onClose({
            description: "websocket connection closed",
            context: closeEvent,
        });
        this.ws.onmessage = (ev) => this.onData(ev.data);
        this.ws.onerror = (e) => this.onError("websocket error", e);
    }
    write(packets) {
        this.writable = false;
        // encodePacket efficient as it uses WS framing
        // no need for encodePayload
        for (let i = 0; i < packets.length; i++) {
            const packet = packets[i];
            const lastPacket = i === packets.length - 1;
            (0, engine_io_parser_1.encodePacket)(packet, this.supportsBinary, (data) => {
                // Sometimes the websocket has already been closed but the browser didn't
                // have a chance of informing us about it yet, in that case send will
                // throw an error
                try {
                    this.doWrite(packet, data);
                }
                catch (e) {
                    debug("websocket closed before onclose event");
                }
                if (lastPacket) {
                    // fake drain
                    // defer to next tick to allow Socket to clear writeBuffer
                    (0, globals_node_js_1.nextTick)(() => {
                        this.writable = true;
                        this.emitReserved("drain");
                    }, this.setTimeoutFn);
                }
            });
        }
    }
    doClose() {
        if (typeof this.ws !== "undefined") {
            this.ws.onerror = () => { };
            this.ws.close();
            this.ws = null;
        }
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */
    uri() {
        const schema = this.opts.secure ? "wss" : "ws";
        const query = this.query || {};
        // append timestamp to URI
        if (this.opts.timestampRequests) {
            query[this.opts.timestampParam] = (0, util_js_1.randomString)();
        }
        // communicate binary support capabilities
        if (!this.supportsBinary) {
            query.b64 = 1;
        }
        return this.createUri(schema, query);
    }
}
exports.BaseWS = BaseWS;
const WebSocketCtor = globals_node_js_1.globalThisShim.WebSocket || globals_node_js_1.globalThisShim.MozWebSocket;
/**
 * WebSocket transport based on the built-in `WebSocket` object.
 *
 * Usage: browser, Node.js (since v21), Deno, Bun
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
 * @see https://caniuse.com/mdn-api_websocket
 * @see https://nodejs.org/api/globals.html#websocket
 */
class WS extends BaseWS {
    createSocket(uri, protocols, opts) {
        return !isReactNative
            ? protocols
                ? new WebSocketCtor(uri, protocols)
                : new WebSocketCtor(uri)
            : new WebSocketCtor(uri, protocols, opts);
    }
    doWrite(_packet, data) {
        this.ws.send(data);
    }
}
exports.WS = WS;

},{"../globals.node.js":10,"../transport.js":13,"../util.js":20,"debug":21,"engine.io-parser":27}],19:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WT = void 0;
const transport_js_1 = require("../transport.js");
const globals_node_js_1 = require("../globals.node.js");
const engine_io_parser_1 = require("engine.io-parser");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("engine.io-client:webtransport"); // debug()
/**
 * WebTransport transport based on the built-in `WebTransport` object.
 *
 * Usage: browser, Node.js (with the `@fails-components/webtransport` package)
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebTransport
 * @see https://caniuse.com/webtransport
 */
class WT extends transport_js_1.Transport {
    get name() {
        return "webtransport";
    }
    doOpen() {
        try {
            // @ts-ignore
            this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
        }
        catch (err) {
            return this.emitReserved("error", err);
        }
        this._transport.closed
            .then(() => {
            debug("transport closed gracefully");
            this.onClose();
        })
            .catch((err) => {
            debug("transport closed due to %s", err);
            this.onError("webtransport error", err);
        });
        // note: we could have used async/await, but that would require some additional polyfills
        this._transport.ready.then(() => {
            this._transport.createBidirectionalStream().then((stream) => {
                const decoderStream = (0, engine_io_parser_1.createPacketDecoderStream)(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
                const reader = stream.readable.pipeThrough(decoderStream).getReader();
                const encoderStream = (0, engine_io_parser_1.createPacketEncoderStream)();
                encoderStream.readable.pipeTo(stream.writable);
                this._writer = encoderStream.writable.getWriter();
                const read = () => {
                    reader
                        .read()
                        .then(({ done, value }) => {
                        if (done) {
                            debug("session is closed");
                            return;
                        }
                        debug("received chunk: %o", value);
                        this.onPacket(value);
                        read();
                    })
                        .catch((err) => {
                        debug("an error occurred while reading: %s", err);
                    });
                };
                read();
                const packet = { type: "open" };
                if (this.query.sid) {
                    packet.data = `{"sid":"${this.query.sid}"}`;
                }
                this._writer.write(packet).then(() => this.onOpen());
            });
        });
    }
    write(packets) {
        this.writable = false;
        for (let i = 0; i < packets.length; i++) {
            const packet = packets[i];
            const lastPacket = i === packets.length - 1;
            this._writer.write(packet).then(() => {
                if (lastPacket) {
                    (0, globals_node_js_1.nextTick)(() => {
                        this.writable = true;
                        this.emitReserved("drain");
                    }, this.setTimeoutFn);
                }
            });
        }
    }
    doClose() {
        var _a;
        (_a = this._transport) === null || _a === void 0 ? void 0 : _a.close();
    }
}
exports.WT = WT;

},{"../globals.node.js":10,"../transport.js":13,"debug":21,"engine.io-parser":27}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pick = pick;
exports.installTimerFunctions = installTimerFunctions;
exports.byteLength = byteLength;
exports.randomString = randomString;
const globals_node_js_1 = require("./globals.node.js");
function pick(obj, ...attr) {
    return attr.reduce((acc, k) => {
        if (obj.hasOwnProperty(k)) {
            acc[k] = obj[k];
        }
        return acc;
    }, {});
}
// Keep a reference to the real timeout functions so they can be used when overridden
const NATIVE_SET_TIMEOUT = globals_node_js_1.globalThisShim.setTimeout;
const NATIVE_CLEAR_TIMEOUT = globals_node_js_1.globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
    if (opts.useNativeTimers) {
        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globals_node_js_1.globalThisShim);
        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globals_node_js_1.globalThisShim);
    }
    else {
        obj.setTimeoutFn = globals_node_js_1.globalThisShim.setTimeout.bind(globals_node_js_1.globalThisShim);
        obj.clearTimeoutFn = globals_node_js_1.globalThisShim.clearTimeout.bind(globals_node_js_1.globalThisShim);
    }
}
// base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)
const BASE64_OVERHEAD = 1.33;
// we could also have used `new Blob([obj]).size`, but it isn't supported in IE9
function byteLength(obj) {
    if (typeof obj === "string") {
        return utf8Length(obj);
    }
    // arraybuffer or blob
    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
    let c = 0, length = 0;
    for (let i = 0, l = str.length; i < l; i++) {
        c = str.charCodeAt(i);
        if (c < 0x80) {
            length += 1;
        }
        else if (c < 0x800) {
            length += 2;
        }
        else if (c < 0xd800 || c >= 0xe000) {
            length += 3;
        }
        else {
            i++;
            length += 4;
        }
    }
    return length;
}
/**
 * Generates a random 8-characters string.
 */
function randomString() {
    return (Date.now().toString(36).substring(3) +
        Math.random().toString(36).substring(2, 5));
}

},{"./globals.node.js":10}],21:[function(require,module,exports){
(function (process){(function (){
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	let m;

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = require('./common')(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};

}).call(this)}).call(this,require('_process'))
},{"./common":22,"_process":29}],22:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = require('ms');
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;

},{"ms":28}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERROR_PACKET = exports.PACKET_TYPES_REVERSE = exports.PACKET_TYPES = void 0;
const PACKET_TYPES = Object.create(null); // no Map = no polyfill
exports.PACKET_TYPES = PACKET_TYPES;
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = Object.create(null);
exports.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;
Object.keys(PACKET_TYPES).forEach((key) => {
    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };
exports.ERROR_PACKET = ERROR_PACKET;

},{}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode = exports.encode = void 0;
// imported from https://github.com/socketio/base64-arraybuffer
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
// Use a lookup table to find the index.
const lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
for (let i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
}
const encode = (arraybuffer) => {
    let bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';
    for (i = 0; i < len; i += 3) {
        base64 += chars[bytes[i] >> 2];
        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
        base64 += chars[bytes[i + 2] & 63];
    }
    if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + '=';
    }
    else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + '==';
    }
    return base64;
};
exports.encode = encode;
const decode = (base64) => {
    let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
    if (base64[base64.length - 1] === '=') {
        bufferLength--;
        if (base64[base64.length - 2] === '=') {
            bufferLength--;
        }
    }
    const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
    for (i = 0; i < len; i += 4) {
        encoded1 = lookup[base64.charCodeAt(i)];
        encoded2 = lookup[base64.charCodeAt(i + 1)];
        encoded3 = lookup[base64.charCodeAt(i + 2)];
        encoded4 = lookup[base64.charCodeAt(i + 3)];
        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }
    return arraybuffer;
};
exports.decode = decode;

},{}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodePacket = void 0;
const commons_js_1 = require("./commons.js");
const base64_arraybuffer_js_1 = require("./contrib/base64-arraybuffer.js");
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType) => {
    if (typeof encodedPacket !== "string") {
        return {
            type: "message",
            data: mapBinary(encodedPacket, binaryType),
        };
    }
    const type = encodedPacket.charAt(0);
    if (type === "b") {
        return {
            type: "message",
            data: decodeBase64Packet(encodedPacket.substring(1), binaryType),
        };
    }
    const packetType = commons_js_1.PACKET_TYPES_REVERSE[type];
    if (!packetType) {
        return commons_js_1.ERROR_PACKET;
    }
    return encodedPacket.length > 1
        ? {
            type: commons_js_1.PACKET_TYPES_REVERSE[type],
            data: encodedPacket.substring(1),
        }
        : {
            type: commons_js_1.PACKET_TYPES_REVERSE[type],
        };
};
exports.decodePacket = decodePacket;
const decodeBase64Packet = (data, binaryType) => {
    if (withNativeArrayBuffer) {
        const decoded = (0, base64_arraybuffer_js_1.decode)(data);
        return mapBinary(decoded, binaryType);
    }
    else {
        return { base64: true, data }; // fallback for old browsers
    }
};
const mapBinary = (data, binaryType) => {
    switch (binaryType) {
        case "blob":
            if (data instanceof Blob) {
                // from WebSocket + binaryType "blob"
                return data;
            }
            else {
                // from HTTP long-polling or WebTransport
                return new Blob([data]);
            }
        case "arraybuffer":
        default:
            if (data instanceof ArrayBuffer) {
                // from HTTP long-polling (base64) or WebSocket + binaryType "arraybuffer"
                return data;
            }
            else {
                // from WebTransport (Uint8Array)
                return data.buffer;
            }
    }
};

},{"./commons.js":23,"./contrib/base64-arraybuffer.js":24}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodePacket = void 0;
exports.encodePacketToBinary = encodePacketToBinary;
const commons_js_1 = require("./commons.js");
const withNativeBlob = typeof Blob === "function" ||
    (typeof Blob !== "undefined" &&
        Object.prototype.toString.call(Blob) === "[object BlobConstructor]");
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
// ArrayBuffer.isView method is not defined in IE10
const isView = (obj) => {
    return typeof ArrayBuffer.isView === "function"
        ? ArrayBuffer.isView(obj)
        : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket = ({ type, data }, supportsBinary, callback) => {
    if (withNativeBlob && data instanceof Blob) {
        if (supportsBinary) {
            return callback(data);
        }
        else {
            return encodeBlobAsBase64(data, callback);
        }
    }
    else if (withNativeArrayBuffer &&
        (data instanceof ArrayBuffer || isView(data))) {
        if (supportsBinary) {
            return callback(data);
        }
        else {
            return encodeBlobAsBase64(new Blob([data]), callback);
        }
    }
    // plain string
    return callback(commons_js_1.PACKET_TYPES[type] + (data || ""));
};
exports.encodePacket = encodePacket;
const encodeBlobAsBase64 = (data, callback) => {
    const fileReader = new FileReader();
    fileReader.onload = function () {
        const content = fileReader.result.split(",")[1];
        callback("b" + (content || ""));
    };
    return fileReader.readAsDataURL(data);
};
function toArray(data) {
    if (data instanceof Uint8Array) {
        return data;
    }
    else if (data instanceof ArrayBuffer) {
        return new Uint8Array(data);
    }
    else {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    }
}
let TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
    if (withNativeBlob && packet.data instanceof Blob) {
        return packet.data.arrayBuffer().then(toArray).then(callback);
    }
    else if (withNativeArrayBuffer &&
        (packet.data instanceof ArrayBuffer || isView(packet.data))) {
        return callback(toArray(packet.data));
    }
    encodePacket(packet, false, (encoded) => {
        if (!TEXT_ENCODER) {
            TEXT_ENCODER = new TextEncoder();
        }
        callback(TEXT_ENCODER.encode(encoded));
    });
}

},{"./commons.js":23}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodePayload = exports.decodePacket = exports.encodePayload = exports.encodePacket = exports.protocol = void 0;
exports.createPacketEncoderStream = createPacketEncoderStream;
exports.createPacketDecoderStream = createPacketDecoderStream;
const encodePacket_js_1 = require("./encodePacket.js");
Object.defineProperty(exports, "encodePacket", { enumerable: true, get: function () { return encodePacket_js_1.encodePacket; } });
const decodePacket_js_1 = require("./decodePacket.js");
Object.defineProperty(exports, "decodePacket", { enumerable: true, get: function () { return decodePacket_js_1.decodePacket; } });
const commons_js_1 = require("./commons.js");
const SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
const encodePayload = (packets, callback) => {
    // some packets may be added to the array while encoding, so the initial length must be saved
    const length = packets.length;
    const encodedPackets = new Array(length);
    let count = 0;
    packets.forEach((packet, i) => {
        // force base64 encoding for binary packets
        (0, encodePacket_js_1.encodePacket)(packet, false, (encodedPacket) => {
            encodedPackets[i] = encodedPacket;
            if (++count === length) {
                callback(encodedPackets.join(SEPARATOR));
            }
        });
    });
};
exports.encodePayload = encodePayload;
const decodePayload = (encodedPayload, binaryType) => {
    const encodedPackets = encodedPayload.split(SEPARATOR);
    const packets = [];
    for (let i = 0; i < encodedPackets.length; i++) {
        const decodedPacket = (0, decodePacket_js_1.decodePacket)(encodedPackets[i], binaryType);
        packets.push(decodedPacket);
        if (decodedPacket.type === "error") {
            break;
        }
    }
    return packets;
};
exports.decodePayload = decodePayload;
function createPacketEncoderStream() {
    return new TransformStream({
        transform(packet, controller) {
            (0, encodePacket_js_1.encodePacketToBinary)(packet, (encodedPacket) => {
                const payloadLength = encodedPacket.length;
                let header;
                // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length
                if (payloadLength < 126) {
                    header = new Uint8Array(1);
                    new DataView(header.buffer).setUint8(0, payloadLength);
                }
                else if (payloadLength < 65536) {
                    header = new Uint8Array(3);
                    const view = new DataView(header.buffer);
                    view.setUint8(0, 126);
                    view.setUint16(1, payloadLength);
                }
                else {
                    header = new Uint8Array(9);
                    const view = new DataView(header.buffer);
                    view.setUint8(0, 127);
                    view.setBigUint64(1, BigInt(payloadLength));
                }
                // first bit indicates whether the payload is plain text (0) or binary (1)
                if (packet.data && typeof packet.data !== "string") {
                    header[0] |= 0x80;
                }
                controller.enqueue(header);
                controller.enqueue(encodedPacket);
            });
        },
    });
}
let TEXT_DECODER;
function totalLength(chunks) {
    return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size) {
    if (chunks[0].length === size) {
        return chunks.shift();
    }
    const buffer = new Uint8Array(size);
    let j = 0;
    for (let i = 0; i < size; i++) {
        buffer[i] = chunks[0][j++];
        if (j === chunks[0].length) {
            chunks.shift();
            j = 0;
        }
    }
    if (chunks.length && j < chunks[0].length) {
        chunks[0] = chunks[0].slice(j);
    }
    return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
    if (!TEXT_DECODER) {
        TEXT_DECODER = new TextDecoder();
    }
    const chunks = [];
    let state = 0 /* State.READ_HEADER */;
    let expectedLength = -1;
    let isBinary = false;
    return new TransformStream({
        transform(chunk, controller) {
            chunks.push(chunk);
            while (true) {
                if (state === 0 /* State.READ_HEADER */) {
                    if (totalLength(chunks) < 1) {
                        break;
                    }
                    const header = concatChunks(chunks, 1);
                    isBinary = (header[0] & 0x80) === 0x80;
                    expectedLength = header[0] & 0x7f;
                    if (expectedLength < 126) {
                        state = 3 /* State.READ_PAYLOAD */;
                    }
                    else if (expectedLength === 126) {
                        state = 1 /* State.READ_EXTENDED_LENGTH_16 */;
                    }
                    else {
                        state = 2 /* State.READ_EXTENDED_LENGTH_64 */;
                    }
                }
                else if (state === 1 /* State.READ_EXTENDED_LENGTH_16 */) {
                    if (totalLength(chunks) < 2) {
                        break;
                    }
                    const headerArray = concatChunks(chunks, 2);
                    expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
                    state = 3 /* State.READ_PAYLOAD */;
                }
                else if (state === 2 /* State.READ_EXTENDED_LENGTH_64 */) {
                    if (totalLength(chunks) < 8) {
                        break;
                    }
                    const headerArray = concatChunks(chunks, 8);
                    const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
                    const n = view.getUint32(0);
                    if (n > Math.pow(2, 53 - 32) - 1) {
                        // the maximum safe integer in JavaScript is 2^53 - 1
                        controller.enqueue(commons_js_1.ERROR_PACKET);
                        break;
                    }
                    expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
                    state = 3 /* State.READ_PAYLOAD */;
                }
                else {
                    if (totalLength(chunks) < expectedLength) {
                        break;
                    }
                    const data = concatChunks(chunks, expectedLength);
                    controller.enqueue((0, decodePacket_js_1.decodePacket)(isBinary ? data : TEXT_DECODER.decode(data), binaryType));
                    state = 0 /* State.READ_HEADER */;
                }
                if (expectedLength === 0 || expectedLength > maxPayload) {
                    controller.enqueue(commons_js_1.ERROR_PACKET);
                    break;
                }
            }
        },
    });
}
exports.protocol = 4;

},{"./commons.js":23,"./decodePacket.js":25,"./encodePacket.js":26}],28:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],29:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],30:[function(require,module,exports){
"use strict";
/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Backoff = Backoff;
function Backoff(opts) {
    opts = opts || {};
    this.ms = opts.min || 100;
    this.max = opts.max || 10000;
    this.factor = opts.factor || 2;
    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
    this.attempts = 0;
}
/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */
Backoff.prototype.duration = function () {
    var ms = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
        var rand = Math.random();
        var deviation = Math.floor(rand * this.jitter * ms);
        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
    }
    return Math.min(ms, this.max) | 0;
};
/**
 * Reset the number of attempts.
 *
 * @api public
 */
Backoff.prototype.reset = function () {
    this.attempts = 0;
};
/**
 * Set the minimum duration
 *
 * @api public
 */
Backoff.prototype.setMin = function (min) {
    this.ms = min;
};
/**
 * Set the maximum duration
 *
 * @api public
 */
Backoff.prototype.setMax = function (max) {
    this.max = max;
};
/**
 * Set the jitter
 *
 * @api public
 */
Backoff.prototype.setJitter = function (jitter) {
    this.jitter = jitter;
};

},{}],31:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebTransport = exports.WebSocket = exports.NodeWebSocket = exports.XHR = exports.NodeXHR = exports.Fetch = exports.Socket = exports.Manager = exports.protocol = void 0;
exports.io = lookup;
exports.connect = lookup;
exports.default = lookup;
const url_js_1 = require("./url.js");
const manager_js_1 = require("./manager.js");
Object.defineProperty(exports, "Manager", { enumerable: true, get: function () { return manager_js_1.Manager; } });
const socket_js_1 = require("./socket.js");
Object.defineProperty(exports, "Socket", { enumerable: true, get: function () { return socket_js_1.Socket; } });
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("socket.io-client"); // debug()
/**
 * Managers cache.
 */
const cache = {};
function lookup(uri, opts) {
    if (typeof uri === "object") {
        opts = uri;
        uri = undefined;
    }
    opts = opts || {};
    const parsed = (0, url_js_1.url)(uri, opts.path || "/socket.io");
    const source = parsed.source;
    const id = parsed.id;
    const path = parsed.path;
    const sameNamespace = cache[id] && path in cache[id]["nsps"];
    const newConnection = opts.forceNew ||
        opts["force new connection"] ||
        false === opts.multiplex ||
        sameNamespace;
    let io;
    if (newConnection) {
        debug("ignoring socket cache for %s", source);
        io = new manager_js_1.Manager(source, opts);
    }
    else {
        if (!cache[id]) {
            debug("new io instance for %s", source);
            cache[id] = new manager_js_1.Manager(source, opts);
        }
        io = cache[id];
    }
    if (parsed.query && !opts.query) {
        opts.query = parsed.queryKey;
    }
    return io.socket(parsed.path, opts);
}
// so that "lookup" can be used both as a function (e.g. `io(...)`) and as a
// namespace (e.g. `io.connect(...)`), for backward compatibility
Object.assign(lookup, {
    Manager: manager_js_1.Manager,
    Socket: socket_js_1.Socket,
    io: lookup,
    connect: lookup,
});
/**
 * Protocol version.
 *
 * @public
 */
var socket_io_parser_1 = require("socket.io-parser");
Object.defineProperty(exports, "protocol", { enumerable: true, get: function () { return socket_io_parser_1.protocol; } });
var engine_io_client_1 = require("engine.io-client");
Object.defineProperty(exports, "Fetch", { enumerable: true, get: function () { return engine_io_client_1.Fetch; } });
Object.defineProperty(exports, "NodeXHR", { enumerable: true, get: function () { return engine_io_client_1.NodeXHR; } });
Object.defineProperty(exports, "XHR", { enumerable: true, get: function () { return engine_io_client_1.XHR; } });
Object.defineProperty(exports, "NodeWebSocket", { enumerable: true, get: function () { return engine_io_client_1.NodeWebSocket; } });
Object.defineProperty(exports, "WebSocket", { enumerable: true, get: function () { return engine_io_client_1.WebSocket; } });
Object.defineProperty(exports, "WebTransport", { enumerable: true, get: function () { return engine_io_client_1.WebTransport; } });

module.exports = lookup;

},{"./manager.js":32,"./socket.js":34,"./url.js":35,"debug":36,"engine.io-client":11,"socket.io-parser":39}],32:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Manager = void 0;
const engine_io_client_1 = require("engine.io-client");
const socket_js_1 = require("./socket.js");
const parser = __importStar(require("socket.io-parser"));
const on_js_1 = require("./on.js");
const backo2_js_1 = require("./contrib/backo2.js");
const component_emitter_1 = require("@socket.io/component-emitter");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("socket.io-client:manager"); // debug()
class Manager extends component_emitter_1.Emitter {
    constructor(uri, opts) {
        var _a;
        super();
        this.nsps = {};
        this.subs = [];
        if (uri && "object" === typeof uri) {
            opts = uri;
            uri = undefined;
        }
        opts = opts || {};
        opts.path = opts.path || "/socket.io";
        this.opts = opts;
        (0, engine_io_client_1.installTimerFunctions)(this, opts);
        this.reconnection(opts.reconnection !== false);
        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
        this.reconnectionDelay(opts.reconnectionDelay || 1000);
        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
        this.backoff = new backo2_js_1.Backoff({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor(),
        });
        this.timeout(null == opts.timeout ? 20000 : opts.timeout);
        this._readyState = "closed";
        this.uri = uri;
        const _parser = opts.parser || parser;
        this.encoder = new _parser.Encoder();
        this.decoder = new _parser.Decoder();
        this._autoConnect = opts.autoConnect !== false;
        if (this._autoConnect)
            this.open();
    }
    reconnection(v) {
        if (!arguments.length)
            return this._reconnection;
        this._reconnection = !!v;
        if (!v) {
            this.skipReconnect = true;
        }
        return this;
    }
    reconnectionAttempts(v) {
        if (v === undefined)
            return this._reconnectionAttempts;
        this._reconnectionAttempts = v;
        return this;
    }
    reconnectionDelay(v) {
        var _a;
        if (v === undefined)
            return this._reconnectionDelay;
        this._reconnectionDelay = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
        return this;
    }
    randomizationFactor(v) {
        var _a;
        if (v === undefined)
            return this._randomizationFactor;
        this._randomizationFactor = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
        return this;
    }
    reconnectionDelayMax(v) {
        var _a;
        if (v === undefined)
            return this._reconnectionDelayMax;
        this._reconnectionDelayMax = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
        return this;
    }
    timeout(v) {
        if (!arguments.length)
            return this._timeout;
        this._timeout = v;
        return this;
    }
    /**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @private
     */
    maybeReconnectOnOpen() {
        // Only try to reconnect if it's the first time we're connecting
        if (!this._reconnecting &&
            this._reconnection &&
            this.backoff.attempts === 0) {
            // keeps reconnection from firing twice for the same reconnection loop
            this.reconnect();
        }
    }
    /**
     * Sets the current transport `socket`.
     *
     * @param {Function} fn - optional, callback
     * @return self
     * @public
     */
    open(fn) {
        debug("readyState %s", this._readyState);
        if (~this._readyState.indexOf("open"))
            return this;
        debug("opening %s", this.uri);
        this.engine = new engine_io_client_1.Socket(this.uri, this.opts);
        const socket = this.engine;
        const self = this;
        this._readyState = "opening";
        this.skipReconnect = false;
        // emit `open`
        const openSubDestroy = (0, on_js_1.on)(socket, "open", function () {
            self.onopen();
            fn && fn();
        });
        const onError = (err) => {
            debug("error");
            this.cleanup();
            this._readyState = "closed";
            this.emitReserved("error", err);
            if (fn) {
                fn(err);
            }
            else {
                // Only do this if there is no fn to handle the error
                this.maybeReconnectOnOpen();
            }
        };
        // emit `error`
        const errorSub = (0, on_js_1.on)(socket, "error", onError);
        if (false !== this._timeout) {
            const timeout = this._timeout;
            debug("connect attempt will timeout after %d", timeout);
            // set timer
            const timer = this.setTimeoutFn(() => {
                debug("connect attempt timed out after %d", timeout);
                openSubDestroy();
                onError(new Error("timeout"));
                socket.close();
            }, timeout);
            if (this.opts.autoUnref) {
                timer.unref();
            }
            this.subs.push(() => {
                this.clearTimeoutFn(timer);
            });
        }
        this.subs.push(openSubDestroy);
        this.subs.push(errorSub);
        return this;
    }
    /**
     * Alias for open()
     *
     * @return self
     * @public
     */
    connect(fn) {
        return this.open(fn);
    }
    /**
     * Called upon transport open.
     *
     * @private
     */
    onopen() {
        debug("open");
        // clear old subs
        this.cleanup();
        // mark as open
        this._readyState = "open";
        this.emitReserved("open");
        // add new subs
        const socket = this.engine;
        this.subs.push((0, on_js_1.on)(socket, "ping", this.onping.bind(this)), (0, on_js_1.on)(socket, "data", this.ondata.bind(this)), (0, on_js_1.on)(socket, "error", this.onerror.bind(this)), (0, on_js_1.on)(socket, "close", this.onclose.bind(this)), 
        // @ts-ignore
        (0, on_js_1.on)(this.decoder, "decoded", this.ondecoded.bind(this)));
    }
    /**
     * Called upon a ping.
     *
     * @private
     */
    onping() {
        this.emitReserved("ping");
    }
    /**
     * Called with data.
     *
     * @private
     */
    ondata(data) {
        try {
            this.decoder.add(data);
        }
        catch (e) {
            this.onclose("parse error", e);
        }
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */
    ondecoded(packet) {
        // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a "parse error"
        (0, engine_io_client_1.nextTick)(() => {
            this.emitReserved("packet", packet);
        }, this.setTimeoutFn);
    }
    /**
     * Called upon socket error.
     *
     * @private
     */
    onerror(err) {
        debug("error", err);
        this.emitReserved("error", err);
    }
    /**
     * Creates a new socket for the given `nsp`.
     *
     * @return {Socket}
     * @public
     */
    socket(nsp, opts) {
        let socket = this.nsps[nsp];
        if (!socket) {
            socket = new socket_js_1.Socket(this, nsp, opts);
            this.nsps[nsp] = socket;
        }
        else if (this._autoConnect && !socket.active) {
            socket.connect();
        }
        return socket;
    }
    /**
     * Called upon a socket close.
     *
     * @param socket
     * @private
     */
    _destroy(socket) {
        const nsps = Object.keys(this.nsps);
        for (const nsp of nsps) {
            const socket = this.nsps[nsp];
            if (socket.active) {
                debug("socket %s is still active, skipping close", nsp);
                return;
            }
        }
        this._close();
    }
    /**
     * Writes a packet.
     *
     * @param packet
     * @private
     */
    _packet(packet) {
        debug("writing packet %j", packet);
        const encodedPackets = this.encoder.encode(packet);
        for (let i = 0; i < encodedPackets.length; i++) {
            this.engine.write(encodedPackets[i], packet.options);
        }
    }
    /**
     * Clean up transport subscriptions and packet buffer.
     *
     * @private
     */
    cleanup() {
        debug("cleanup");
        this.subs.forEach((subDestroy) => subDestroy());
        this.subs.length = 0;
        this.decoder.destroy();
    }
    /**
     * Close the current socket.
     *
     * @private
     */
    _close() {
        debug("disconnect");
        this.skipReconnect = true;
        this._reconnecting = false;
        this.onclose("forced close");
    }
    /**
     * Alias for close()
     *
     * @private
     */
    disconnect() {
        return this._close();
    }
    /**
     * Called when:
     *
     * - the low-level engine is closed
     * - the parser encountered a badly formatted packet
     * - all sockets are disconnected
     *
     * @private
     */
    onclose(reason, description) {
        var _a;
        debug("closed due to %s", reason);
        this.cleanup();
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();
        this.backoff.reset();
        this._readyState = "closed";
        this.emitReserved("close", reason, description);
        if (this._reconnection && !this.skipReconnect) {
            this.reconnect();
        }
    }
    /**
     * Attempt a reconnection.
     *
     * @private
     */
    reconnect() {
        if (this._reconnecting || this.skipReconnect)
            return this;
        const self = this;
        if (this.backoff.attempts >= this._reconnectionAttempts) {
            debug("reconnect failed");
            this.backoff.reset();
            this.emitReserved("reconnect_failed");
            this._reconnecting = false;
        }
        else {
            const delay = this.backoff.duration();
            debug("will wait %dms before reconnect attempt", delay);
            this._reconnecting = true;
            const timer = this.setTimeoutFn(() => {
                if (self.skipReconnect)
                    return;
                debug("attempting reconnect");
                this.emitReserved("reconnect_attempt", self.backoff.attempts);
                // check again for the case socket closed in above events
                if (self.skipReconnect)
                    return;
                self.open((err) => {
                    if (err) {
                        debug("reconnect attempt error");
                        self._reconnecting = false;
                        self.reconnect();
                        this.emitReserved("reconnect_error", err);
                    }
                    else {
                        debug("reconnect success");
                        self.onreconnect();
                    }
                });
            }, delay);
            if (this.opts.autoUnref) {
                timer.unref();
            }
            this.subs.push(() => {
                this.clearTimeoutFn(timer);
            });
        }
    }
    /**
     * Called upon successful reconnect.
     *
     * @private
     */
    onreconnect() {
        const attempt = this.backoff.attempts;
        this._reconnecting = false;
        this.backoff.reset();
        this.emitReserved("reconnect", attempt);
    }
}
exports.Manager = Manager;

},{"./contrib/backo2.js":30,"./on.js":33,"./socket.js":34,"@socket.io/component-emitter":6,"debug":36,"engine.io-client":11,"socket.io-parser":39}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.on = on;
function on(obj, ev, fn) {
    obj.on(ev, fn);
    return function subDestroy() {
        obj.off(ev, fn);
    };
}

},{}],34:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Socket = void 0;
const socket_io_parser_1 = require("socket.io-parser");
const on_js_1 = require("./on.js");
const component_emitter_1 = require("@socket.io/component-emitter");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("socket.io-client:socket"); // debug()
/**
 * Internal events.
 * These events can't be emitted by the user.
 */
const RESERVED_EVENTS = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
    newListener: 1,
    removeListener: 1,
});
/**
 * A Socket is the fundamental class for interacting with the server.
 *
 * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.
 *
 * @example
 * const socket = io();
 *
 * socket.on("connect", () => {
 *   console.log("connected");
 * });
 *
 * // send an event to the server
 * socket.emit("foo", "bar");
 *
 * socket.on("foobar", () => {
 *   // an event was received from the server
 * });
 *
 * // upon disconnection
 * socket.on("disconnect", (reason) => {
 *   console.log(`disconnected due to ${reason}`);
 * });
 */
class Socket extends component_emitter_1.Emitter {
    /**
     * `Socket` constructor.
     */
    constructor(io, nsp, opts) {
        super();
        /**
         * Whether the socket is currently connected to the server.
         *
         * @example
         * const socket = io();
         *
         * socket.on("connect", () => {
         *   console.log(socket.connected); // true
         * });
         *
         * socket.on("disconnect", () => {
         *   console.log(socket.connected); // false
         * });
         */
        this.connected = false;
        /**
         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will
         * be transmitted by the server.
         */
        this.recovered = false;
        /**
         * Buffer for packets received before the CONNECT packet
         */
        this.receiveBuffer = [];
        /**
         * Buffer for packets that will be sent once the socket is connected
         */
        this.sendBuffer = [];
        /**
         * The queue of packets to be sent with retry in case of failure.
         *
         * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.
         * @private
         */
        this._queue = [];
        /**
         * A sequence to generate the ID of the {@link QueuedPacket}.
         * @private
         */
        this._queueSeq = 0;
        this.ids = 0;
        /**
         * A map containing acknowledgement handlers.
         *
         * The `withError` attribute is used to differentiate handlers that accept an error as first argument:
         *
         * - `socket.emit("test", (err, value) => { ... })` with `ackTimeout` option
         * - `socket.timeout(5000).emit("test", (err, value) => { ... })`
         * - `const value = await socket.emitWithAck("test")`
         *
         * From those that don't:
         *
         * - `socket.emit("test", (value) => { ... });`
         *
         * In the first case, the handlers will be called with an error when:
         *
         * - the timeout is reached
         * - the socket gets disconnected
         *
         * In the second case, the handlers will be simply discarded upon disconnection, since the client will never receive
         * an acknowledgement from the server.
         *
         * @private
         */
        this.acks = {};
        this.flags = {};
        this.io = io;
        this.nsp = nsp;
        if (opts && opts.auth) {
            this.auth = opts.auth;
        }
        this._opts = Object.assign({}, opts);
        if (this.io._autoConnect)
            this.open();
    }
    /**
     * Whether the socket is currently disconnected
     *
     * @example
     * const socket = io();
     *
     * socket.on("connect", () => {
     *   console.log(socket.disconnected); // false
     * });
     *
     * socket.on("disconnect", () => {
     *   console.log(socket.disconnected); // true
     * });
     */
    get disconnected() {
        return !this.connected;
    }
    /**
     * Subscribe to open, close and packet events
     *
     * @private
     */
    subEvents() {
        if (this.subs)
            return;
        const io = this.io;
        this.subs = [
            (0, on_js_1.on)(io, "open", this.onopen.bind(this)),
            (0, on_js_1.on)(io, "packet", this.onpacket.bind(this)),
            (0, on_js_1.on)(io, "error", this.onerror.bind(this)),
            (0, on_js_1.on)(io, "close", this.onclose.bind(this)),
        ];
    }
    /**
     * Whether the Socket will try to reconnect when its Manager connects or reconnects.
     *
     * @example
     * const socket = io();
     *
     * console.log(socket.active); // true
     *
     * socket.on("disconnect", (reason) => {
     *   if (reason === "io server disconnect") {
     *     // the disconnection was initiated by the server, you need to manually reconnect
     *     console.log(socket.active); // false
     *   }
     *   // else the socket will automatically try to reconnect
     *   console.log(socket.active); // true
     * });
     */
    get active() {
        return !!this.subs;
    }
    /**
     * "Opens" the socket.
     *
     * @example
     * const socket = io({
     *   autoConnect: false
     * });
     *
     * socket.connect();
     */
    connect() {
        if (this.connected)
            return this;
        this.subEvents();
        if (!this.io["_reconnecting"])
            this.io.open(); // ensure open
        if ("open" === this.io._readyState)
            this.onopen();
        return this;
    }
    /**
     * Alias for {@link connect()}.
     */
    open() {
        return this.connect();
    }
    /**
     * Sends a `message` event.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * socket.send("hello");
     *
     * // this is equivalent to
     * socket.emit("message", "hello");
     *
     * @return self
     */
    send(...args) {
        args.unshift("message");
        this.emit.apply(this, args);
        return this;
    }
    /**
     * Override `emit`.
     * If the event is in `events`, it's emitted normally.
     *
     * @example
     * socket.emit("hello", "world");
     *
     * // all serializable datastructures are supported (no need to call JSON.stringify)
     * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
     *
     * // with an acknowledgement from the server
     * socket.emit("hello", "world", (val) => {
     *   // ...
     * });
     *
     * @return self
     */
    emit(ev, ...args) {
        var _a, _b, _c;
        if (RESERVED_EVENTS.hasOwnProperty(ev)) {
            throw new Error('"' + ev.toString() + '" is a reserved event name');
        }
        args.unshift(ev);
        if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
            this._addToQueue(args);
            return this;
        }
        const packet = {
            type: socket_io_parser_1.PacketType.EVENT,
            data: args,
        };
        packet.options = {};
        packet.options.compress = this.flags.compress !== false;
        // event ack callback
        if ("function" === typeof args[args.length - 1]) {
            const id = this.ids++;
            debug("emitting packet with ack id %d", id);
            const ack = args.pop();
            this._registerAckCallback(id, ack);
            packet.id = id;
        }
        const isTransportWritable = (_b = (_a = this.io.engine) === null || _a === void 0 ? void 0 : _a.transport) === null || _b === void 0 ? void 0 : _b.writable;
        const isConnected = this.connected && !((_c = this.io.engine) === null || _c === void 0 ? void 0 : _c._hasPingExpired());
        const discardPacket = this.flags.volatile && !isTransportWritable;
        if (discardPacket) {
            debug("discard packet as the transport is not currently writable");
        }
        else if (isConnected) {
            this.notifyOutgoingListeners(packet);
            this.packet(packet);
        }
        else {
            this.sendBuffer.push(packet);
        }
        this.flags = {};
        return this;
    }
    /**
     * @private
     */
    _registerAckCallback(id, ack) {
        var _a;
        const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
        if (timeout === undefined) {
            this.acks[id] = ack;
            return;
        }
        // @ts-ignore
        const timer = this.io.setTimeoutFn(() => {
            delete this.acks[id];
            for (let i = 0; i < this.sendBuffer.length; i++) {
                if (this.sendBuffer[i].id === id) {
                    debug("removing packet with ack id %d from the buffer", id);
                    this.sendBuffer.splice(i, 1);
                }
            }
            debug("event with ack id %d has timed out after %d ms", id, timeout);
            ack.call(this, new Error("operation has timed out"));
        }, timeout);
        const fn = (...args) => {
            // @ts-ignore
            this.io.clearTimeoutFn(timer);
            ack.apply(this, args);
        };
        fn.withError = true;
        this.acks[id] = fn;
    }
    /**
     * Emits an event and waits for an acknowledgement
     *
     * @example
     * // without timeout
     * const response = await socket.emitWithAck("hello", "world");
     *
     * // with a specific timeout
     * try {
     *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
     * } catch (err) {
     *   // the server did not acknowledge the event in the given delay
     * }
     *
     * @return a Promise that will be fulfilled when the server acknowledges the event
     */
    emitWithAck(ev, ...args) {
        return new Promise((resolve, reject) => {
            const fn = (arg1, arg2) => {
                return arg1 ? reject(arg1) : resolve(arg2);
            };
            fn.withError = true;
            args.push(fn);
            this.emit(ev, ...args);
        });
    }
    /**
     * Add the packet to the queue.
     * @param args
     * @private
     */
    _addToQueue(args) {
        let ack;
        if (typeof args[args.length - 1] === "function") {
            ack = args.pop();
        }
        const packet = {
            id: this._queueSeq++,
            tryCount: 0,
            pending: false,
            args,
            flags: Object.assign({ fromQueue: true }, this.flags),
        };
        args.push((err, ...responseArgs) => {
            if (packet !== this._queue[0]) {
                // the packet has already been acknowledged
                return;
            }
            const hasError = err !== null;
            if (hasError) {
                if (packet.tryCount > this._opts.retries) {
                    debug("packet [%d] is discarded after %d tries", packet.id, packet.tryCount);
                    this._queue.shift();
                    if (ack) {
                        ack(err);
                    }
                }
            }
            else {
                debug("packet [%d] was successfully sent", packet.id);
                this._queue.shift();
                if (ack) {
                    ack(null, ...responseArgs);
                }
            }
            packet.pending = false;
            return this._drainQueue();
        });
        this._queue.push(packet);
        this._drainQueue();
    }
    /**
     * Send the first packet of the queue, and wait for an acknowledgement from the server.
     * @param force - whether to resend a packet that has not been acknowledged yet
     *
     * @private
     */
    _drainQueue(force = false) {
        debug("draining queue");
        if (!this.connected || this._queue.length === 0) {
            return;
        }
        const packet = this._queue[0];
        if (packet.pending && !force) {
            debug("packet [%d] has already been sent and is waiting for an ack", packet.id);
            return;
        }
        packet.pending = true;
        packet.tryCount++;
        debug("sending packet [%d] (try n%d)", packet.id, packet.tryCount);
        this.flags = packet.flags;
        this.emit.apply(this, packet.args);
    }
    /**
     * Sends a packet.
     *
     * @param packet
     * @private
     */
    packet(packet) {
        packet.nsp = this.nsp;
        this.io._packet(packet);
    }
    /**
     * Called upon engine `open`.
     *
     * @private
     */
    onopen() {
        debug("transport is open - connecting");
        if (typeof this.auth == "function") {
            this.auth((data) => {
                this._sendConnectPacket(data);
            });
        }
        else {
            this._sendConnectPacket(this.auth);
        }
    }
    /**
     * Sends a CONNECT packet to initiate the Socket.IO session.
     *
     * @param data
     * @private
     */
    _sendConnectPacket(data) {
        this.packet({
            type: socket_io_parser_1.PacketType.CONNECT,
            data: this._pid
                ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data)
                : data,
        });
    }
    /**
     * Called upon engine or manager `error`.
     *
     * @param err
     * @private
     */
    onerror(err) {
        if (!this.connected) {
            this.emitReserved("connect_error", err);
        }
    }
    /**
     * Called upon engine `close`.
     *
     * @param reason
     * @param description
     * @private
     */
    onclose(reason, description) {
        debug("close (%s)", reason);
        this.connected = false;
        delete this.id;
        this.emitReserved("disconnect", reason, description);
        this._clearAcks();
    }
    /**
     * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
     * the server.
     *
     * @private
     */
    _clearAcks() {
        Object.keys(this.acks).forEach((id) => {
            const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);
            if (!isBuffered) {
                // note: handlers that do not accept an error as first argument are ignored here
                const ack = this.acks[id];
                delete this.acks[id];
                if (ack.withError) {
                    ack.call(this, new Error("socket has been disconnected"));
                }
            }
        });
    }
    /**
     * Called with socket packet.
     *
     * @param packet
     * @private
     */
    onpacket(packet) {
        const sameNamespace = packet.nsp === this.nsp;
        if (!sameNamespace)
            return;
        switch (packet.type) {
            case socket_io_parser_1.PacketType.CONNECT:
                if (packet.data && packet.data.sid) {
                    this.onconnect(packet.data.sid, packet.data.pid);
                }
                else {
                    this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                }
                break;
            case socket_io_parser_1.PacketType.EVENT:
            case socket_io_parser_1.PacketType.BINARY_EVENT:
                this.onevent(packet);
                break;
            case socket_io_parser_1.PacketType.ACK:
            case socket_io_parser_1.PacketType.BINARY_ACK:
                this.onack(packet);
                break;
            case socket_io_parser_1.PacketType.DISCONNECT:
                this.ondisconnect();
                break;
            case socket_io_parser_1.PacketType.CONNECT_ERROR:
                this.destroy();
                const err = new Error(packet.data.message);
                // @ts-ignore
                err.data = packet.data.data;
                this.emitReserved("connect_error", err);
                break;
        }
    }
    /**
     * Called upon a server event.
     *
     * @param packet
     * @private
     */
    onevent(packet) {
        const args = packet.data || [];
        debug("emitting event %j", args);
        if (null != packet.id) {
            debug("attaching ack callback to event");
            args.push(this.ack(packet.id));
        }
        if (this.connected) {
            this.emitEvent(args);
        }
        else {
            this.receiveBuffer.push(Object.freeze(args));
        }
    }
    emitEvent(args) {
        if (this._anyListeners && this._anyListeners.length) {
            const listeners = this._anyListeners.slice();
            for (const listener of listeners) {
                listener.apply(this, args);
            }
        }
        super.emit.apply(this, args);
        if (this._pid && args.length && typeof args[args.length - 1] === "string") {
            this._lastOffset = args[args.length - 1];
        }
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @private
     */
    ack(id) {
        const self = this;
        let sent = false;
        return function (...args) {
            // prevent double callbacks
            if (sent)
                return;
            sent = true;
            debug("sending ack %j", args);
            self.packet({
                type: socket_io_parser_1.PacketType.ACK,
                id: id,
                data: args,
            });
        };
    }
    /**
     * Called upon a server acknowledgement.
     *
     * @param packet
     * @private
     */
    onack(packet) {
        const ack = this.acks[packet.id];
        if (typeof ack !== "function") {
            debug("bad ack %s", packet.id);
            return;
        }
        delete this.acks[packet.id];
        debug("calling ack %s with %j", packet.id, packet.data);
        // @ts-ignore FIXME ack is incorrectly inferred as 'never'
        if (ack.withError) {
            packet.data.unshift(null);
        }
        // @ts-ignore
        ack.apply(this, packet.data);
    }
    /**
     * Called upon server connect.
     *
     * @private
     */
    onconnect(id, pid) {
        debug("socket connected with id %s", id);
        this.id = id;
        this.recovered = pid && this._pid === pid;
        this._pid = pid; // defined only if connection state recovery is enabled
        this.connected = true;
        this.emitBuffered();
        this.emitReserved("connect");
        this._drainQueue(true);
    }
    /**
     * Emit buffered events (received and emitted).
     *
     * @private
     */
    emitBuffered() {
        this.receiveBuffer.forEach((args) => this.emitEvent(args));
        this.receiveBuffer = [];
        this.sendBuffer.forEach((packet) => {
            this.notifyOutgoingListeners(packet);
            this.packet(packet);
        });
        this.sendBuffer = [];
    }
    /**
     * Called upon server disconnect.
     *
     * @private
     */
    ondisconnect() {
        debug("server disconnect (%s)", this.nsp);
        this.destroy();
        this.onclose("io server disconnect");
    }
    /**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @private
     */
    destroy() {
        if (this.subs) {
            // clean subscriptions to avoid reconnections
            this.subs.forEach((subDestroy) => subDestroy());
            this.subs = undefined;
        }
        this.io["_destroy"](this);
    }
    /**
     * Disconnects the socket manually. In that case, the socket will not try to reconnect.
     *
     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
     *
     * @example
     * const socket = io();
     *
     * socket.on("disconnect", (reason) => {
     *   // console.log(reason); prints "io client disconnect"
     * });
     *
     * socket.disconnect();
     *
     * @return self
     */
    disconnect() {
        if (this.connected) {
            debug("performing disconnect (%s)", this.nsp);
            this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });
        }
        // remove socket from pool
        this.destroy();
        if (this.connected) {
            // fire events
            this.onclose("io client disconnect");
        }
        return this;
    }
    /**
     * Alias for {@link disconnect()}.
     *
     * @return self
     */
    close() {
        return this.disconnect();
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * socket.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     */
    compress(compress) {
        this.flags.compress = compress;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
     * ready to send messages.
     *
     * @example
     * socket.volatile.emit("hello"); // the server may or may not receive it
     *
     * @returns self
     */
    get volatile() {
        this.flags.volatile = true;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
     * given number of milliseconds have elapsed without an acknowledgement from the server:
     *
     * @example
     * socket.timeout(5000).emit("my-event", (err) => {
     *   if (err) {
     *     // the server did not acknowledge the event in the given delay
     *   }
     * });
     *
     * @returns self
     */
    timeout(timeout) {
        this.flags.timeout = timeout;
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * @example
     * socket.onAny((event, ...args) => {
     *   console.log(`got ${event}`);
     * });
     *
     * @param listener
     */
    onAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @example
     * socket.prependAny((event, ...args) => {
     *   console.log(`got event ${event}`);
     * });
     *
     * @param listener
     */
    prependAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`got event ${event}`);
     * }
     *
     * socket.onAny(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAny(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAny();
     *
     * @param listener
     */
    offAny(listener) {
        if (!this._anyListeners) {
            return this;
        }
        if (listener) {
            const listeners = this._anyListeners;
            for (let i = 0; i < listeners.length; i++) {
                if (listener === listeners[i]) {
                    listeners.splice(i, 1);
                    return this;
                }
            }
        }
        else {
            this._anyListeners = [];
        }
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
    listenersAny() {
        return this._anyListeners || [];
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.onAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */
    onAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.prependAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */
    prependAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`sent event ${event}`);
     * }
     *
     * socket.onAnyOutgoing(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAnyOutgoing(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAnyOutgoing();
     *
     * @param [listener] - the catch-all listener (optional)
     */
    offAnyOutgoing(listener) {
        if (!this._anyOutgoingListeners) {
            return this;
        }
        if (listener) {
            const listeners = this._anyOutgoingListeners;
            for (let i = 0; i < listeners.length; i++) {
                if (listener === listeners[i]) {
                    listeners.splice(i, 1);
                    return this;
                }
            }
        }
        else {
            this._anyOutgoingListeners = [];
        }
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
    listenersAnyOutgoing() {
        return this._anyOutgoingListeners || [];
    }
    /**
     * Notify the listeners for each packet sent
     *
     * @param packet
     *
     * @private
     */
    notifyOutgoingListeners(packet) {
        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
            const listeners = this._anyOutgoingListeners.slice();
            for (const listener of listeners) {
                listener.apply(this, packet.data);
            }
        }
    }
}
exports.Socket = Socket;

},{"./on.js":33,"@socket.io/component-emitter":6,"debug":36,"socket.io-parser":39}],35:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.url = url;
const engine_io_client_1 = require("engine.io-client");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("socket.io-client:url"); // debug()
/**
 * URL parser.
 *
 * @param uri - url
 * @param path - the request path of the connection
 * @param loc - An object meant to mimic window.location.
 *        Defaults to window.location.
 * @public
 */
function url(uri, path = "", loc) {
    let obj = uri;
    // default to window.location
    loc = loc || (typeof location !== "undefined" && location);
    if (null == uri)
        uri = loc.protocol + "//" + loc.host;
    // relative path support
    if (typeof uri === "string") {
        if ("/" === uri.charAt(0)) {
            if ("/" === uri.charAt(1)) {
                uri = loc.protocol + uri;
            }
            else {
                uri = loc.host + uri;
            }
        }
        if (!/^(https?|wss?):\/\//.test(uri)) {
            debug("protocol-less url %s", uri);
            if ("undefined" !== typeof loc) {
                uri = loc.protocol + "//" + uri;
            }
            else {
                uri = "https://" + uri;
            }
        }
        // parse
        debug("parse %s", uri);
        obj = (0, engine_io_client_1.parse)(uri);
    }
    // make sure we treat `localhost:80` and `localhost` equally
    if (!obj.port) {
        if (/^(http|ws)$/.test(obj.protocol)) {
            obj.port = "80";
        }
        else if (/^(http|ws)s$/.test(obj.protocol)) {
            obj.port = "443";
        }
    }
    obj.path = obj.path || "/";
    const ipv6 = obj.host.indexOf(":") !== -1;
    const host = ipv6 ? "[" + obj.host + "]" : obj.host;
    // define unique id
    obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
    // define href
    obj.href =
        obj.protocol +
            "://" +
            host +
            (loc && loc.port === obj.port ? "" : ":" + obj.port);
    return obj;
}

},{"debug":36,"engine.io-client":11}],36:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"./common":37,"_process":29,"dup":21}],37:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22,"ms":28}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reconstructPacket = exports.deconstructPacket = void 0;
const is_binary_js_1 = require("./is-binary.js");
/**
 * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @public
 */
function deconstructPacket(packet) {
    const buffers = [];
    const packetData = packet.data;
    const pack = packet;
    pack.data = _deconstructPacket(packetData, buffers);
    pack.attachments = buffers.length; // number of binary 'attachments'
    return { packet: pack, buffers: buffers };
}
exports.deconstructPacket = deconstructPacket;
function _deconstructPacket(data, buffers) {
    if (!data)
        return data;
    if ((0, is_binary_js_1.isBinary)(data)) {
        const placeholder = { _placeholder: true, num: buffers.length };
        buffers.push(data);
        return placeholder;
    }
    else if (Array.isArray(data)) {
        const newData = new Array(data.length);
        for (let i = 0; i < data.length; i++) {
            newData[i] = _deconstructPacket(data[i], buffers);
        }
        return newData;
    }
    else if (typeof data === "object" && !(data instanceof Date)) {
        const newData = {};
        for (const key in data) {
            if (Object.prototype.hasOwnProperty.call(data, key)) {
                newData[key] = _deconstructPacket(data[key], buffers);
            }
        }
        return newData;
    }
    return data;
}
/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @public
 */
function reconstructPacket(packet, buffers) {
    packet.data = _reconstructPacket(packet.data, buffers);
    delete packet.attachments; // no longer useful
    return packet;
}
exports.reconstructPacket = reconstructPacket;
function _reconstructPacket(data, buffers) {
    if (!data)
        return data;
    if (data && data._placeholder === true) {
        const isIndexValid = typeof data.num === "number" &&
            data.num >= 0 &&
            data.num < buffers.length;
        if (isIndexValid) {
            return buffers[data.num]; // appropriate buffer (should be natural order anyway)
        }
        else {
            throw new Error("illegal attachments");
        }
    }
    else if (Array.isArray(data)) {
        for (let i = 0; i < data.length; i++) {
            data[i] = _reconstructPacket(data[i], buffers);
        }
    }
    else if (typeof data === "object") {
        for (const key in data) {
            if (Object.prototype.hasOwnProperty.call(data, key)) {
                data[key] = _reconstructPacket(data[key], buffers);
            }
        }
    }
    return data;
}

},{"./is-binary.js":40}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;
const component_emitter_1 = require("@socket.io/component-emitter");
const binary_js_1 = require("./binary.js");
const is_binary_js_1 = require("./is-binary.js");
const debug_1 = require("debug"); // debug()
const debug = (0, debug_1.default)("socket.io-parser"); // debug()
/**
 * These strings must not be used as event names, as they have a special meaning.
 */
const RESERVED_EVENTS = [
    "connect",
    "connect_error",
    "disconnect",
    "disconnecting",
    "newListener",
    "removeListener", // used by the Node.js EventEmitter
];
/**
 * Protocol version.
 *
 * @public
 */
exports.protocol = 5;
var PacketType;
(function (PacketType) {
    PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
    PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
    PacketType[PacketType["EVENT"] = 2] = "EVENT";
    PacketType[PacketType["ACK"] = 3] = "ACK";
    PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
    PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
    PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType = exports.PacketType || (exports.PacketType = {}));
/**
 * A socket.io Encoder instance
 */
class Encoder {
    /**
     * Encoder constructor
     *
     * @param {function} replacer - custom replacer to pass down to JSON.parse
     */
    constructor(replacer) {
        this.replacer = replacer;
    }
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */
    encode(obj) {
        debug("encoding packet %j", obj);
        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
            if ((0, is_binary_js_1.hasBinary)(obj)) {
                return this.encodeAsBinary({
                    type: obj.type === PacketType.EVENT
                        ? PacketType.BINARY_EVENT
                        : PacketType.BINARY_ACK,
                    nsp: obj.nsp,
                    data: obj.data,
                    id: obj.id,
                });
            }
        }
        return [this.encodeAsString(obj)];
    }
    /**
     * Encode packet as string.
     */
    encodeAsString(obj) {
        // first is type
        let str = "" + obj.type;
        // attachments if we have them
        if (obj.type === PacketType.BINARY_EVENT ||
            obj.type === PacketType.BINARY_ACK) {
            str += obj.attachments + "-";
        }
        // if we have a namespace other than `/`
        // we append it followed by a comma `,`
        if (obj.nsp && "/" !== obj.nsp) {
            str += obj.nsp + ",";
        }
        // immediately followed by the id
        if (null != obj.id) {
            str += obj.id;
        }
        // json data
        if (null != obj.data) {
            str += JSON.stringify(obj.data, this.replacer);
        }
        debug("encoded %j as %s", obj, str);
        return str;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */
    encodeAsBinary(obj) {
        const deconstruction = (0, binary_js_1.deconstructPacket)(obj);
        const pack = this.encodeAsString(deconstruction.packet);
        const buffers = deconstruction.buffers;
        buffers.unshift(pack); // add packet info to beginning of data list
        return buffers; // write all the buffers
    }
}
exports.Encoder = Encoder;
// see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript
function isObject(value) {
    return Object.prototype.toString.call(value) === "[object Object]";
}
/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 */
class Decoder extends component_emitter_1.Emitter {
    /**
     * Decoder constructor
     *
     * @param {function} reviver - custom reviver to pass down to JSON.stringify
     */
    constructor(reviver) {
        super();
        this.reviver = reviver;
    }
    /**
     * Decodes an encoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     */
    add(obj) {
        let packet;
        if (typeof obj === "string") {
            if (this.reconstructor) {
                throw new Error("got plaintext data when reconstructing a packet");
            }
            packet = this.decodeString(obj);
            const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
            if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
                packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
                // binary packet's json
                this.reconstructor = new BinaryReconstructor(packet);
                // no attachments, labeled binary but no binary data to follow
                if (packet.attachments === 0) {
                    super.emitReserved("decoded", packet);
                }
            }
            else {
                // non-binary full packet
                super.emitReserved("decoded", packet);
            }
        }
        else if ((0, is_binary_js_1.isBinary)(obj) || obj.base64) {
            // raw binary data
            if (!this.reconstructor) {
                throw new Error("got binary data when not reconstructing a packet");
            }
            else {
                packet = this.reconstructor.takeBinaryData(obj);
                if (packet) {
                    // received final buffer
                    this.reconstructor = null;
                    super.emitReserved("decoded", packet);
                }
            }
        }
        else {
            throw new Error("Unknown type: " + obj);
        }
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */
    decodeString(str) {
        let i = 0;
        // look up type
        const p = {
            type: Number(str.charAt(0)),
        };
        if (PacketType[p.type] === undefined) {
            throw new Error("unknown packet type " + p.type);
        }
        // look up attachments if type binary
        if (p.type === PacketType.BINARY_EVENT ||
            p.type === PacketType.BINARY_ACK) {
            const start = i + 1;
            while (str.charAt(++i) !== "-" && i != str.length) { }
            const buf = str.substring(start, i);
            if (buf != Number(buf) || str.charAt(i) !== "-") {
                throw new Error("Illegal attachments");
            }
            p.attachments = Number(buf);
        }
        // look up namespace (if any)
        if ("/" === str.charAt(i + 1)) {
            const start = i + 1;
            while (++i) {
                const c = str.charAt(i);
                if ("," === c)
                    break;
                if (i === str.length)
                    break;
            }
            p.nsp = str.substring(start, i);
        }
        else {
            p.nsp = "/";
        }
        // look up id
        const next = str.charAt(i + 1);
        if ("" !== next && Number(next) == next) {
            const start = i + 1;
            while (++i) {
                const c = str.charAt(i);
                if (null == c || Number(c) != c) {
                    --i;
                    break;
                }
                if (i === str.length)
                    break;
            }
            p.id = Number(str.substring(start, i + 1));
        }
        // look up json data
        if (str.charAt(++i)) {
            const payload = this.tryParse(str.substr(i));
            if (Decoder.isPayloadValid(p.type, payload)) {
                p.data = payload;
            }
            else {
                throw new Error("invalid payload");
            }
        }
        debug("decoded %s as %j", str, p);
        return p;
    }
    tryParse(str) {
        try {
            return JSON.parse(str, this.reviver);
        }
        catch (e) {
            return false;
        }
    }
    static isPayloadValid(type, payload) {
        switch (type) {
            case PacketType.CONNECT:
                return isObject(payload);
            case PacketType.DISCONNECT:
                return payload === undefined;
            case PacketType.CONNECT_ERROR:
                return typeof payload === "string" || isObject(payload);
            case PacketType.EVENT:
            case PacketType.BINARY_EVENT:
                return (Array.isArray(payload) &&
                    (typeof payload[0] === "number" ||
                        (typeof payload[0] === "string" &&
                            RESERVED_EVENTS.indexOf(payload[0]) === -1)));
            case PacketType.ACK:
            case PacketType.BINARY_ACK:
                return Array.isArray(payload);
        }
    }
    /**
     * Deallocates a parser's resources
     */
    destroy() {
        if (this.reconstructor) {
            this.reconstructor.finishedReconstruction();
            this.reconstructor = null;
        }
    }
}
exports.Decoder = Decoder;
/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 */
class BinaryReconstructor {
    constructor(packet) {
        this.packet = packet;
        this.buffers = [];
        this.reconPack = packet;
    }
    /**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     */
    takeBinaryData(binData) {
        this.buffers.push(binData);
        if (this.buffers.length === this.reconPack.attachments) {
            // done with buffer list
            const packet = (0, binary_js_1.reconstructPacket)(this.reconPack, this.buffers);
            this.finishedReconstruction();
            return packet;
        }
        return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */
    finishedReconstruction() {
        this.reconPack = null;
        this.buffers = [];
    }
}

},{"./binary.js":38,"./is-binary.js":40,"@socket.io/component-emitter":6,"debug":41}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasBinary = exports.isBinary = void 0;
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj) => {
    return typeof ArrayBuffer.isView === "function"
        ? ArrayBuffer.isView(obj)
        : obj.buffer instanceof ArrayBuffer;
};
const toString = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" ||
    (typeof Blob !== "undefined" &&
        toString.call(Blob) === "[object BlobConstructor]");
const withNativeFile = typeof File === "function" ||
    (typeof File !== "undefined" &&
        toString.call(File) === "[object FileConstructor]");
/**
 * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
 *
 * @private
 */
function isBinary(obj) {
    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||
        (withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File));
}
exports.isBinary = isBinary;
function hasBinary(obj, toJSON) {
    if (!obj || typeof obj !== "object") {
        return false;
    }
    if (Array.isArray(obj)) {
        for (let i = 0, l = obj.length; i < l; i++) {
            if (hasBinary(obj[i])) {
                return true;
            }
        }
        return false;
    }
    if (isBinary(obj)) {
        return true;
    }
    if (obj.toJSON &&
        typeof obj.toJSON === "function" &&
        arguments.length === 1) {
        return hasBinary(obj.toJSON(), true);
    }
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
            return true;
        }
    }
    return false;
}
exports.hasBinary = hasBinary;

},{}],41:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"./common":42,"_process":29,"dup":21}],42:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22,"ms":28}],43:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCircularProgress = createCircularProgress;
/**
 * Circular Progress Spinner Component
 * Usage: createCircularProgress({ value, label, state, id })
 * - value: 0-100 (percent)
 * - label: status message (optional)
 * - state: '', 'error', 'warning', 'complete', 'ready' (optional)
 * - id: DOM id (optional)
 * 
 * Fixes visual duplication and rendering bugs in progress spinner during async operations
 */
function createCircularProgress() {
  let {
    value = 0,
    label = '',
    state = '',
    id = ''
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  // Ensure proper sizing and rendering calculations
  const size = 80;
  const stroke = 8;
  const radius = (size - stroke) / 2;
  const circumference = 2 * Math.PI * radius;

  // Clamp value between 0 and 100
  const percent = Math.max(0, Math.min(100, value));

  // Calculate stroke dash array for proper circular progress
  const dashOffset = circumference - percent / 100 * circumference;

  // Generate unique ID if not provided
  const elementId = id || `circular-progress-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

  // Create wrapper element with proper state management
  const wrapper = document.createElement('div');
  wrapper.className = `circular-progress${state ? ' ' + state : ''}`;
  wrapper.id = elementId;
  wrapper.setAttribute('role', 'progressbar');
  wrapper.setAttribute('aria-valuenow', percent);
  wrapper.setAttribute('aria-valuemin', 0);
  wrapper.setAttribute('aria-valuemax', 100);
  wrapper.setAttribute('aria-label', label ? `${label} ${percent}%` : `${percent}%`);

  // Add data attributes for debugging and state tracking
  wrapper.setAttribute('data-percent', percent);
  wrapper.setAttribute('data-state', state);
  wrapper.setAttribute('data-created', new Date().toISOString());

  // Create SVG with proper viewBox and dimensions
  wrapper.innerHTML = `
    <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg">
      <!-- Background circle -->
      <circle 
        class="circular-bg" 
        cx="${size / 2}" 
        cy="${size / 2}" 
        r="${radius}" 
        fill="none"
        stroke="#e0e0e0"
        stroke-width="${stroke}"
      />
      <!-- Foreground progress circle -->
      <circle 
        class="circular-fg" 
        cx="${size / 2}" 
        cy="${size / 2}" 
        r="${radius}" 
        fill="none"
        stroke="var(--brand-color, #7c3aed)"
        stroke-width="${stroke}"
        stroke-linecap="round"
        stroke-dasharray="${circumference}"
        stroke-dashoffset="${dashOffset}"
        transform="rotate(-90 ${size / 2} ${size / 2})"
      />
    </svg>
    <!-- Percentage label -->
    <span class="circular-label">${Math.round(percent)}%</span>
    ${label ? `<span class="circular-status">${label}</span>` : ''}
  `;

  // Add debug logging for spinner creation
  console.debug('Circular Progress Created:', {
    id: elementId,
    percent,
    state,
    size,
    stroke,
    radius,
    circumference,
    dashOffset,
    label
  });
  return wrapper;
}

},{}],44:[function(require,module,exports){
"use strict";

/**
 * Credentials Modal Module
 * Shows current PingOne credentials and asks user if they want to use them or configure new ones
 */
class CredentialsModal {
  constructor() {
    this.isActive = false;
    this.focusableElements = [];
    this.firstFocusableElement = null;
    this.lastFocusableElement = null;
    this.previousActiveElement = null;
    this.credentials = null;
    this.init();
  }
  async init() {
    await this.loadCredentials();
    this.createModal();
    this.bindEvents();
    this.showModal();
  }
  async loadCredentials() {
    try {
      const response = await fetch('/api/settings');
      if (response.ok) {
        const data = await response.json();
        // The API returns data in data.data structure
        const settings = data.data || data.settings || {};
        this.credentials = {
          environmentId: settings.environmentId || settings['environment-id'] || '',
          clientId: settings.apiClientId || settings['api-client-id'] || '',
          clientSecret: settings.apiSecret || settings['api-secret'] || '',
          region: settings.region || 'NorthAmerica',
          populationId: settings.populationId || settings['population-id'] || '',
          rateLimit: settings.rateLimit || settings['rate-limit'] || 90
        };
        console.log('Credentials loaded from server:', {
          hasEnvironmentId: !!this.credentials.environmentId,
          hasClientId: !!this.credentials.clientId,
          hasClientSecret: !!this.credentials.clientSecret,
          region: this.credentials.region
        });
      } else {
        console.warn('Failed to load credentials from settings');
        this.credentials = null;
      }
    } catch (error) {
      console.error('Error loading credentials:', error);
      this.credentials = null;
    }
  }
  createModal() {
    // Create modal overlay
    const overlay = document.createElement('div');
    overlay.className = 'credentials-modal-overlay';
    overlay.setAttribute('role', 'dialog');
    overlay.setAttribute('aria-modal', 'true');
    overlay.setAttribute('aria-labelledby', 'credentials-title');
    overlay.setAttribute('aria-describedby', 'credentials-content');
    const hasCredentials = this.credentials && this.credentials.environmentId && this.credentials.clientId;

    // Create modal content
    overlay.innerHTML = `
            <div class="credentials-modal" tabindex="-1">
                <div class="credentials-modal-header">
                    <h2 id="credentials-title">
                        <span class="credentials-icon" aria-hidden="true"></span>
                        <span>PingOne Credentials</span>
                    </h2>
                </div>
                
                <div class="credentials-modal-body">
                    <div id="credentials-content" class="credentials-content">
                        ${hasCredentials ? this.createCredentialsContent() : this.createNoCredentialsContent()}
                    </div>
                </div>
                
                <div class="credentials-modal-footer">
                    <div class="credentials-actions">
                        ${hasCredentials ? this.createCredentialsActions() : this.createNoCredentialsActions()}
                    </div>
                </div>
            </div>
        `;
    document.body.appendChild(overlay);
    this.overlay = overlay;
    this.modal = overlay.querySelector('.credentials-modal');
    this.useCredentialsBtn = overlay.querySelector('#use-credentials-btn');
    this.configureBtn = overlay.querySelector('#configure-credentials-btn');
    this.skipBtn = overlay.querySelector('#skip-credentials-btn');
  }
  createCredentialsContent() {
    return `
            <h3> PingOne Credentials Found</h3>
            <p>The following PingOne credentials are available. Would you like to use them or configure new ones?</p>
            
            <div class="credentials-display">
                <div class="credential-item">
                    <label>Environment ID:</label>
                    <div class="credential-value">
                        <code class="credential-visible">${this.credentials.environmentId}</code>
                        <button class="btn btn-sm btn-outline-secondary copy-btn" data-value="${this.credentials.environmentId}" title="Copy Environment ID">
                            <i class="fas fa-copy"></i>
                        </button>
                    </div>
                </div>
                
                <div class="credential-item">
                    <label>Client ID:</label>
                    <div class="credential-value">
                        <code class="credential-visible">${this.credentials.clientId}</code>
                        <button class="btn btn-sm btn-outline-secondary copy-btn" data-value="${this.credentials.clientId}" title="Copy Client ID">
                            <i class="fas fa-copy"></i>
                        </button>
                    </div>
                </div>
                
                <div class="credential-item">
                    <label>Client Secret:</label>
                    <div class="credential-value">
                        <code class="credential-masked">${this.credentials.clientSecret ? this.credentials.clientSecret.substring(0, 5) + ''.repeat(Math.max(0, 15)) : ''}</code>
                        <span class="credential-status"> Configured</span>
                    </div>
                </div>
                
                <div class="credential-item">
                    <label>Region:</label>
                    <div class="credential-value">
                        <code class="credential-visible">${this.credentials.region}</code>
                    </div>
                </div>
            </div>
            
            <div class="credentials-info">
                <h4> What would you like to do?</h4>
                <ul>
                    <li><strong>Use These Credentials:</strong> Continue with the stored credentials</li>
                    <li><strong>Go to Settings:</strong> Configure new or different credentials</li>
                </ul>
            </div>
        `;
  }
  createNoCredentialsContent() {
    return `
            <h3> No Credentials Found</h3>
            <p>No PingOne credentials were found in your settings. You'll need to configure them to use this tool.</p>
            
            <div class="credentials-info">
                <h4> Required Information:</h4>
                <ul>
                    <li><strong>Environment ID:</strong> Your PingOne environment identifier</li>
                    <li><strong>Client ID:</strong> Your PingOne API client identifier</li>
                    <li><strong>Client Secret:</strong> Your PingOne API client secret</li>
                    <li><strong>Region:</strong> Your PingOne environment region</li>
                </ul>
            </div>
            
            <div class="credentials-help">
                <h4> How to Get Credentials:</h4>
                <ol>
                    <li>Log into your PingOne Admin Console</li>
                    <li>Navigate to Applications  Applications</li>
                    <li>Create a new application or use an existing one</li>
                    <li>Copy the Environment ID, Client ID, and Client Secret</li>
                    <li>Configure them in the Settings page</li>
                </ol>
            </div>
        `;
  }
  createCredentialsActions() {
    return `
            <button type="button" class="credentials-btn credentials-btn-primary" id="use-credentials-btn">
                <i class="fas fa-play"></i>
                Use These Credentials
            </button>
            <button type="button" class="credentials-btn credentials-btn-secondary" id="configure-credentials-btn">
                <i class="fas fa-cog"></i>
                Go to Settings
            </button>
            <button type="button" class="credentials-btn credentials-btn-outline" id="skip-credentials-btn">
                <i class="fas fa-times"></i>
                Skip for Now
            </button>
        `;
  }
  createNoCredentialsActions() {
    return `
            <button type="button" class="credentials-btn credentials-btn-primary" id="configure-credentials-btn">
                <i class="fas fa-cog"></i>
                Go to Settings
            </button>
            <button type="button" class="credentials-btn credentials-btn-secondary" id="skip-credentials-btn">
                <i class="fas fa-times"></i>
                Skip for Now
            </button>
        `;
  }
  maskCredential(value) {
    if (!value) return 'Not set';
    if (value.length <= 8) return value;
    return value.substring(0, 8) + '...' + value.substring(value.length - 4);
  }
  bindEvents() {
    // Use credentials button
    if (this.useCredentialsBtn) {
      this.useCredentialsBtn.addEventListener('click', async () => {
        await this.useCurrentCredentials();
      });
    }

    // Configure credentials button
    if (this.configureBtn) {
      this.configureBtn.addEventListener('click', () => {
        this.goToSettings();
      });
    }

    // Skip button
    if (this.skipBtn) {
      this.skipBtn.addEventListener('click', () => {
        this.skipCredentials();
      });
    }

    // Copy buttons
    this.modal.querySelectorAll('.copy-btn').forEach(btn => {
      btn.addEventListener('click', e => {
        const value = e.target.closest('.copy-btn').dataset.value;
        this.copyToClipboard(value, e.target.closest('.copy-btn'));
      });
    });

    // Keyboard events for accessibility
    this.overlay.addEventListener('keydown', e => {
      this.handleKeyboardNavigation(e);
    });

    // Prevent clicks outside modal from closing it
    this.overlay.addEventListener('click', e => {
      if (e.target === this.overlay) {
        // Don't close on outside click - require explicit action
        this.logEvent('credentials_outside_click_prevented');
      }
    });

    // Escape key handling
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape' && this.isActive) {
        e.preventDefault();
        this.skipCredentials();
      }
    });
  }
  handleKeyboardNavigation(e) {
    if (!this.isActive) return;
    const focusableElements = this.getFocusableElements();
    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];

    // Tab key navigation with focus trapping
    if (e.key === 'Tab') {
      if (e.shiftKey) {
        if (document.activeElement === firstElement) {
          e.preventDefault();
          lastElement.focus();
        }
      } else {
        if (document.activeElement === lastElement) {
          e.preventDefault();
          firstElement.focus();
        }
      }
    }
  }
  getFocusableElements() {
    const focusableSelectors = ['button:not([disabled])', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'a[href]', '[tabindex]:not([tabindex="-1"])'];
    return Array.from(this.modal.querySelectorAll(focusableSelectors.join(', ')));
  }
  showModal() {
    this.isActive = true;
    this.previousActiveElement = document.activeElement;

    // Add classes to body and app container
    document.body.classList.add('credentials-modal-open');
    const appContainer = document.querySelector('.app-container');
    if (appContainer) {
      appContainer.classList.add('credentials-modal-active');
    }

    // Show modal with animation
    this.overlay.classList.add('active');

    // Focus management
    this.modal.focus();
    this.setupFocusTrap();
    this.logEvent('credentials_modal_shown');

    // Announce to screen readers
    this.announceToScreenReader('Credentials configuration modal opened. Please review your PingOne credentials and choose an action.');
  }
  setupFocusTrap() {
    this.focusableElements = this.getFocusableElements();
    this.firstFocusableElement = this.focusableElements[0];
    this.lastFocusableElement = this.focusableElements[this.focusableElements.length - 1];
  }
  async useCurrentCredentials() {
    this.logEvent('credentials_used', {
      hasCredentials: !!this.credentials,
      environmentId: this.credentials?.environmentId ? 'set' : 'not_set',
      clientId: this.credentials?.clientId ? 'set' : 'not_set'
    });

    // Show loading state on button
    const useButton = document.getElementById('use-credentials-btn');
    if (useButton) {
      useButton.disabled = true;
      useButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Validating Credentials...';
    }
    try {
      // Just save credentials without trying to get a token
      await this.saveCredentialsOnly();

      // Mark modal as shown since credentials are now saved
      CredentialsModal.setCredentialsModalShown();
      this.hideModal();
      this.enableApplication();

      // Update token status to reflect that credentials are now being used
      this.updateTokenStatusAfterCredentialsUse();

      // Show success message
      this.showSuccessMessage('Credentials saved successfully!');
    } catch (error) {
      // Restore button state on error
      const useButton = document.getElementById('use-credentials-btn');
      if (useButton) {
        useButton.disabled = false;
        useButton.innerHTML = '<i class="fas fa-play"></i> Use These Credentials';
      }
      console.error('Error using credentials:', error);

      // Show user-friendly error messages
      let userMessage = '';
      let userTitle = 'Credentials Error';
      if (error.message.includes('PingOne client not available')) {
        userTitle = 'Authentication System Not Ready';
        userMessage = 'The PingOne authentication system is not fully initialized. Please refresh the page and try again, or go to Settings to configure credentials manually.';
      } else if (error.message.includes('Missing required credentials')) {
        userTitle = 'Incomplete Credentials';
        userMessage = 'Some required credential fields are missing. Please go to Settings to complete your PingOne configuration.';
      } else if (error.message.includes('Failed to get token')) {
        userTitle = 'Authentication Failed';
        userMessage = 'Unable to authenticate with PingOne using these credentials. Please verify your credentials in Settings.';
      } else if (error.message.includes('Failed to save credentials')) {
        userTitle = 'Save Failed';
        userMessage = 'Unable to save credentials to the server. Please try again or go to Settings to configure manually.';
      } else {
        userTitle = 'Credentials Error';
        userMessage = 'There was a problem using these credentials. Please go to Settings to verify your PingOne configuration.';
      }

      // Show the user-friendly error in the modal
      this.showModalError(userTitle, userMessage);
    }
  }
  async saveCredentialsAndGetToken() {
    if (!this.credentials) {
      throw new Error('No credentials available to save');
    }

    // Convert credentials to settings format
    const settings = {
      environmentId: this.credentials.environmentId,
      apiClientId: this.credentials.clientId,
      apiSecret: this.credentials.clientSecret,
      populationId: this.credentials.populationId || '',
      region: this.credentials.region || 'NorthAmerica',
      rateLimit: this.credentials.rateLimit || 90
    };

    // Validate required fields before saving
    if (!settings.environmentId || !settings.apiClientId || !settings.apiSecret) {
      throw new Error('Missing required credentials: Environment ID, Client ID, and Client Secret are required');
    }

    // Save to server via API endpoint - this is the critical fix
    try {
      console.log('Saving credentials to server...', {
        hasEnvironmentId: !!settings.environmentId,
        hasApiClientId: !!settings.apiClientId,
        hasApiSecret: !!settings.apiSecret,
        region: settings.region
      });
      const response = await fetch('/api/settings', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(settings)
      });
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`Failed to save credentials to server: ${errorData.error || response.statusText}`);
      }
      const result = await response.json();
      console.log('Credentials saved to server successfully:', result);

      // Verify the save was successful by reading back the settings
      const verifyResponse = await fetch('/api/settings');
      if (verifyResponse.ok) {
        const verifyData = await verifyResponse.json();
        const savedSettings = verifyData.data || verifyData.settings || {};
        console.log('Verified credentials saved to server:', {
          hasEnvironmentId: !!savedSettings.environmentId,
          hasApiClientId: !!savedSettings.apiClientId,
          hasApiSecret: !!savedSettings.apiSecret
        });
      }
    } catch (error) {
      console.error('Failed to save credentials to server:', error);
      throw new Error(`Failed to save credentials: ${error.message}`);
    }

    // Save to credentials manager if available
    if (window.credentialsManager) {
      try {
        window.credentialsManager.saveCredentials(settings);
        console.log('Credentials saved to credentials manager');
      } catch (error) {
        console.warn('Failed to save to credentials manager:', error);
      }
    }

    // Save to localStorage as backup
    try {
      localStorage.setItem('pingone_credentials', JSON.stringify(settings));
      console.log('Credentials saved to localStorage as backup');
    } catch (error) {
      console.warn('Failed to save to localStorage:', error);
    }

    // Update settings form if on settings page
    if (window.app && window.app.populateSettingsForm) {
      try {
        window.app.populateSettingsForm(settings);
        console.log('Settings form updated with credentials');
      } catch (error) {
        console.warn('Failed to update settings form:', error);
      }
    }

    // Get a new token with the saved credentials - with retry logic
    let tokenResult = null;
    let lastError = null;

    // Wait a moment for credentials to be processed by the server
    await new Promise(resolve => setTimeout(resolve, 1000));

    // Try multiple approaches to get a token
    for (let attempt = 1; attempt <= 3; attempt++) {
      console.log(`Token acquisition attempt ${attempt}/3`);

      // First try: Direct API call (most reliable)
      try {
        console.log('Trying direct API call approach...');
        const response = await fetch('/api/pingone/token', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });
        if (response.ok) {
          const tokenData = await response.json();
          if (tokenData.access_token) {
            console.log('Token acquired via direct API call');
            tokenResult = tokenData.access_token;
            break; // Success!
          }
        } else {
          const errorData = await response.json().catch(() => ({}));
          lastError = new Error(errorData.error || 'Failed to get token from API');
          console.error(`Direct API approach failed (attempt ${attempt}):`, lastError.message);
        }
      } catch (apiError) {
        console.error(`Direct API approach failed (attempt ${attempt}):`, apiError);
        lastError = apiError;
      }

      // Second try: Use PingOne client if available (fallback)
      if (!tokenResult && window.app && window.app.pingOneClient) {
        try {
          console.log('Trying PingOne client approach as fallback...');
          // Update the PingOne client with new credentials
          if (typeof window.app.pingOneClient.updateCredentials === 'function') {
            window.app.pingOneClient.updateCredentials(settings);
          }

          // Get a new token
          const token = await window.app.pingOneClient.getAccessToken();
          console.log('New token acquired with saved credentials via PingOne client');
          tokenResult = token;
          break; // Success!
        } catch (error) {
          console.error(`PingOne client approach failed (attempt ${attempt}):`, error);
          lastError = error;
        }
      } else if (!tokenResult) {
        console.log('PingOne client not available, skipping client approach');
      }

      // Third try: Enhanced server auth endpoint
      if (!tokenResult) {
        try {
          console.log('Trying enhanced server auth approach...');
          const response = await fetch('/api/v1/auth/token', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              environmentId: settings.environmentId,
              clientId: settings.apiClientId,
              clientSecret: settings.apiSecret,
              region: settings.region
            })
          });
          if (response.ok) {
            const tokenData = await response.json();
            if (tokenData.access_token || tokenData.token) {
              console.log('Token acquired via enhanced server auth');
              tokenResult = tokenData.access_token || tokenData.token;
              break; // Success!
            }
          } else {
            const errorData = await response.json().catch(() => ({}));
            lastError = new Error(errorData.error || 'Failed to get token from enhanced auth');
            console.error(`Enhanced server auth approach failed (attempt ${attempt}):`, lastError.message);
          }
        } catch (authError) {
          console.error(`Enhanced server auth approach failed (attempt ${attempt}):`, authError);
          lastError = authError;
        }
      }

      // Wait before retry (exponential backoff)
      if (attempt < 3 && !tokenResult) {
        const waitTime = 1000 * attempt;
        console.log(`Waiting ${waitTime}ms before retry...`);
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
    }

    // Check if we got a token
    if (!tokenResult) {
      console.error('All token acquisition attempts failed');

      // Provide helpful error message based on the last error
      let errorMessage = 'Unable to acquire PingOne access token after multiple attempts.';
      if (lastError) {
        if (lastError.message.includes('401') || lastError.message.includes('unauthorized')) {
          errorMessage = 'Invalid credentials. Please verify your PingOne Client ID and Secret are correct.';
        } else if (lastError.message.includes('404') || lastError.message.includes('not found')) {
          errorMessage = 'PingOne environment not found. Please verify your Environment ID is correct.';
        } else if (lastError.message.includes('network') || lastError.message.includes('fetch')) {
          errorMessage = 'Network error connecting to PingOne. Please check your internet connection.';
        } else if (lastError.message.includes('PingOne client not available')) {
          errorMessage = 'PingOne authentication system is not properly initialized. Please refresh the page and try again.';
        } else {
          errorMessage = `Authentication failed: ${lastError.message}`;
        }
      }
      throw new Error(errorMessage);
    }
    console.log('Token acquisition successful');
    return tokenResult;
  }
  async saveCredentialsOnly() {
    if (!this.credentials) {
      throw new Error('No credentials available to save');
    }

    // Convert credentials to settings format
    const settings = {
      environmentId: this.credentials.environmentId,
      apiClientId: this.credentials.clientId,
      apiSecret: this.credentials.clientSecret,
      populationId: this.credentials.populationId || '',
      region: this.credentials.region || 'NorthAmerica',
      rateLimit: this.credentials.rateLimit || 90
    };

    // Validate required fields before saving
    if (!settings.environmentId || !settings.apiClientId || !settings.apiSecret) {
      throw new Error('Missing required credentials: Environment ID, Client ID, and Client Secret are required');
    }

    // Save to server via API endpoint
    try {
      console.log('Saving credentials to server...', {
        hasEnvironmentId: !!settings.environmentId,
        hasApiClientId: !!settings.apiClientId,
        hasApiSecret: !!settings.apiSecret,
        region: settings.region
      });
      const response = await fetch('/api/settings', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(settings)
      });
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`Failed to save credentials to server: ${errorData.error || response.statusText}`);
      }
      const result = await response.json();
      console.log('Credentials saved to server successfully:', result);
    } catch (error) {
      console.error('Failed to save credentials to server:', error);
      throw new Error(`Failed to save credentials: ${error.message}`);
    }

    // Save to credentials manager if available
    if (window.credentialsManager) {
      try {
        window.credentialsManager.saveCredentials(settings);
        console.log('Credentials saved to credentials manager');
      } catch (error) {
        console.warn('Failed to save to credentials manager:', error);
      }
    }

    // Save to localStorage as backup
    try {
      localStorage.setItem('pingone_credentials', JSON.stringify(settings));
      console.log('Credentials saved to localStorage as backup');
    } catch (error) {
      console.warn('Failed to save to localStorage:', error);
    }

    // Update settings form if on settings page
    if (window.app && window.app.populateSettingsForm) {
      try {
        window.app.populateSettingsForm(settings);
        console.log('Settings form updated with credentials');
      } catch (error) {
        console.warn('Failed to update settings form:', error);
      }
    }
    console.log('Credentials saved successfully without token acquisition');
    return true;
  }
  showError(title, message) {
    // Create and show an error notification
    const notification = document.createElement('div');
    notification.className = 'notification notification-error';
    notification.innerHTML = `
            <i class="fas fa-exclamation-circle"></i>
            <span><strong>${title}:</strong> ${message}</span>
        `;
    const notificationArea = document.getElementById('notification-area');
    if (notificationArea) {
      notificationArea.appendChild(notification);
      setTimeout(() => {
        notification.remove();
      }, 8000);
    }
  }
  showModalError(title, message) {
    // Show error directly in the modal
    const modal = document.querySelector('.credentials-modal');
    if (!modal) return;

    // Remove any existing error messages
    const existingError = modal.querySelector('.credentials-error-message');
    if (existingError) {
      existingError.remove();
    }

    // Create error message element
    const errorDiv = document.createElement('div');
    errorDiv.className = 'credentials-error-message';
    errorDiv.innerHTML = `
            <div class="error-content">
                <i class="fas fa-exclamation-triangle error-icon"></i>
                <div class="error-text">
                    <h4>${title}</h4>
                    <p>${message}</p>
                </div>
            </div>
            <div class="error-actions">
                <button type="button" class="btn btn-primary" onclick="this.closest('.credentials-modal-overlay').querySelector('#configure-credentials-btn').click()">
                    <i class="fas fa-cog"></i> Go to Settings
                </button>
                <button type="button" class="btn btn-secondary" onclick="this.closest('.credentials-error-message').remove()">
                    <i class="fas fa-times"></i> Dismiss
                </button>
            </div>
        `;

    // Insert error message after the modal body
    const modalBody = modal.querySelector('.credentials-modal-body');
    if (modalBody) {
      modalBody.insertAdjacentElement('afterend', errorDiv);
    }

    // Also call the regular showError for notifications
    this.showError(title, message);
  }
  updateTokenStatusAfterCredentialsUse() {
    try {
      console.log('Credentials Modal: Updating token status after credentials use');

      // Force a token refresh to get current status
      if (window.app && window.app.pingOneClient) {
        // Clear any existing token to force refresh
        window.app.pingOneClient.clearToken();

        // Get a fresh token
        window.app.pingOneClient.getAccessToken().then(token => {
          console.log('Credentials Modal: Fresh token acquired');

          // Update the universal token status
          if (typeof window.app.updateUniversalTokenStatus === 'function') {
            window.app.updateUniversalTokenStatus();
          }
        }).catch(error => {
          console.warn('Credentials Modal: Could not get fresh token:', error);
        });
      }

      // Also try to update status directly
      if (window.app && typeof window.app.updateUniversalTokenStatus === 'function') {
        setTimeout(() => {
          window.app.updateUniversalTokenStatus();
        }, 1000);
      }
    } catch (error) {
      console.error('Credentials Modal: Error updating token status:', error);
    }
  }
  goToSettings() {
    this.logEvent('credentials_configure_clicked');
    this.hideModal();
    this.enableApplication();

    // Navigate to settings
    setTimeout(() => {
      const settingsNav = document.querySelector('[data-view="settings"]');
      if (settingsNav) {
        settingsNav.click();
      }
    }, 100);
  }
  skipCredentials() {
    this.logEvent('credentials_skipped');
    this.hideModal();
    this.enableApplication();

    // Show info message
    this.showInfoMessage('You can configure credentials later in the Settings page.');
  }
  hideModal() {
    this.isActive = false;

    // Remove classes
    document.body.classList.remove('credentials-modal-open');
    const appContainer = document.querySelector('.app-container');
    if (appContainer) {
      appContainer.classList.remove('credentials-modal-active');
    }

    // Hide modal with animation
    this.overlay.classList.remove('active');

    // Restore focus
    if (this.previousActiveElement) {
      this.previousActiveElement.focus();
    }

    // Clean up
    setTimeout(() => {
      if (this.overlay && this.overlay.parentNode) {
        this.overlay.parentNode.removeChild(this.overlay);
      }
    }, 300);
    this.logEvent('credentials_modal_hidden');
  }
  enableApplication() {
    // Enable the application
    const appContainer = document.querySelector('.app-container');
    if (appContainer) {
      appContainer.classList.remove('credentials-modal-active');
    }
    this.logEvent('application_enabled_after_credentials');
  }
  copyToClipboard(text, button) {
    navigator.clipboard.writeText(text).then(() => {
      // Show success feedback
      const originalIcon = button.innerHTML;
      button.innerHTML = '<i class="fas fa-check"></i>';
      button.classList.add('copied');
      setTimeout(() => {
        button.innerHTML = originalIcon;
        button.classList.remove('copied');
      }, 2000);
      this.logEvent('credential_copied');
    }).catch(err => {
      console.error('Failed to copy to clipboard:', err);
      this.logEvent('credential_copy_failed', {
        error: err.message
      });
    });
  }
  showSuccessMessage(message) {
    // Create and show a success notification
    const notification = document.createElement('div');
    notification.className = 'notification notification-success';
    notification.innerHTML = `
            <i class="fas fa-check-circle"></i>
            <span>${message}</span>
        `;
    const notificationArea = document.getElementById('notification-area');
    if (notificationArea) {
      notificationArea.appendChild(notification);
      setTimeout(() => {
        notification.remove();
      }, 5000);
    }
  }
  showInfoMessage(message) {
    // Create and show an info notification
    const notification = document.createElement('div');
    notification.className = 'notification notification-info';
    notification.innerHTML = `
            <i class="fas fa-info-circle"></i>
            <span>${message}</span>
        `;
    const notificationArea = document.getElementById('notification-area');
    if (notificationArea) {
      notificationArea.appendChild(notification);
      setTimeout(() => {
        notification.remove();
      }, 5000);
    }
  }
  announceToScreenReader(message) {
    // Create a temporary element for screen reader announcements
    const announcement = document.createElement('div');
    announcement.setAttribute('aria-live', 'polite');
    announcement.setAttribute('aria-atomic', 'true');
    announcement.style.position = 'absolute';
    announcement.style.left = '-10000px';
    announcement.style.width = '1px';
    announcement.style.height = '1px';
    announcement.style.overflow = 'hidden';
    announcement.textContent = message;
    document.body.appendChild(announcement);
    setTimeout(() => {
      document.body.removeChild(announcement);
    }, 1000);
  }
  logEvent(eventName) {
    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const eventData = {
      event: eventName,
      timestamp: new Date().toISOString(),
      hasCredentials: !!this.credentials,
      environmentId: this.credentials?.environmentId ? 'set' : 'not_set',
      clientId: this.credentials?.clientId ? 'set' : 'not_set',
      ...data
    };
    console.log('Credentials Modal Event:', eventData);

    // You can also send this to your logging system
    // fetch('/api/logs', { method: 'POST', body: JSON.stringify(eventData) });
  }

  /**
   * Check if credentials are already properly saved and working
   * @returns {Promise<boolean>} True if credentials are saved and working
   */
  static async areCredentialsSaved() {
    try {
      const response = await fetch('/api/settings');
      if (!response.ok) {
        return false;
      }
      const data = await response.json();
      const settings = data.data || data.settings || {};

      // Check if we have all required credentials
      const hasRequiredCredentials = settings.environmentId && settings.apiClientId && settings.apiSecret;
      if (!hasRequiredCredentials) {
        return false;
      }

      // Try to get a token to verify credentials work
      if (window.app && window.app.pingOneClient) {
        try {
          const token = await window.app.pingOneClient.getAccessToken();
          return !!token;
        } catch (error) {
          console.warn('Credentials exist but token acquisition failed:', error);
          return false;
        }
      }
      return true;
    } catch (error) {
      console.error('Error checking if credentials are saved:', error);
      return false;
    }
  }

  /**
   * Check if the credentials modal should be shown
   * @returns {Promise<boolean>} True if modal should be shown
   */
  static async shouldShowCredentialsModal() {
    // TEMPORARY: Force credentials modal to always show for debugging
    console.log('DEBUGGING: Forcing credentials modal to show');
    return true;

    // Original logic (commented out for debugging):
    // try {
    //     // Check if modal was already shown in this session
    //     const modalShown = sessionStorage.getItem('credentials_modal_shown');
    //     if (modalShown === 'true') {
    //         console.log('Credentials modal already shown in this session');
    //         return false;
    //     }
    //     
    //     // Always show modal on startup to ask user about stored credentials
    //     // This gives users the choice to use stored credentials or configure new ones
    //     console.log('Showing credentials modal on startup to ask about stored credentials');
    //     return true;
    //     
    // } catch (error) {
    //     console.error('Error checking if credentials modal should be shown:', error);
    //     return true; // Show modal on error to be safe
    // }
  }

  /**
   * Mark that the credentials modal has been shown
   */
  static setCredentialsModalShown() {
    sessionStorage.setItem('credentials_modal_shown', 'true');
    console.log('Credentials modal marked as shown for this session');
  }

  /**
   * Reset the credentials modal state (for testing or re-showing)
   */
  static resetCredentialsModal() {
    sessionStorage.removeItem('credentials_modal_shown');
    console.log('Credentials modal state reset');
  }

  // Static method to check if there's a valid token
  static hasValidToken() {
    try {
      const token = localStorage.getItem('pingone_worker_token');
      const expiry = localStorage.getItem('pingone_token_expiry');
      if (!token || !expiry) {
        return false;
      }
      const expiryTime = parseInt(expiry, 10);
      const now = Date.now();
      const timeRemaining = expiryTime - now;
      return timeRemaining > 0;
    } catch (error) {
      console.error('Error checking token validity:', error);
      return false;
    }
  }
}

// Initialize credentials modal when DOM is loaded
document.addEventListener('DOMContentLoaded', async () => {
  console.log('Credentials Modal: DOMContentLoaded event fired');
  console.log('Disclaimer accepted:', DisclaimerModal.isDisclaimerAccepted());
  console.log('Credentials modal shown:', sessionStorage.getItem('credentials_modal_shown'));

  // Check if disclaimer is already accepted (user returning)
  if (DisclaimerModal.isDisclaimerAccepted()) {
    const shouldShow = await CredentialsModal.shouldShowCredentialsModal();
    console.log('Should show credentials modal:', shouldShow);
    if (shouldShow) {
      console.log('Credentials Modal: Showing modal for returning user');
      // Small delay to ensure disclaimer modal is fully closed
      setTimeout(() => {
        new CredentialsModal();
        CredentialsModal.setCredentialsModalShown();
      }, 1000);
    }
  }
});

// Listen for disclaimer completion events
document.addEventListener('disclaimerAccepted', async event => {
  console.log('Credentials Modal: Disclaimer accepted event received', event.detail);
  // Wait a bit longer for disclaimer modal to fully close
  setTimeout(async () => {
    console.log('Credentials Modal: Checking if should show after disclaimer');
    const shouldShow = await CredentialsModal.shouldShowCredentialsModal();
    console.log('Should show credentials modal:', shouldShow);
    if (shouldShow) {
      console.log('Credentials Modal: Creating modal after disclaimer acceptance');
      new CredentialsModal();
      CredentialsModal.setCredentialsModalShown();
    }
  }, 1500);
});

// Listen for token status changes
document.addEventListener('token-updated', async event => {
  console.log('Credentials Modal: Token updated event received', event.detail);
  // Check if we should show credentials modal when token changes
  setTimeout(async () => {
    const shouldShow = await CredentialsModal.shouldShowCredentialsModal();
    console.log('Should show credentials modal after token update:', shouldShow);
    if (shouldShow) {
      console.log('Credentials Modal: Creating modal after token update');
      new CredentialsModal();
      CredentialsModal.setCredentialsModalShown();
    }
  }, 1000);
});

// Periodic check for token status (every 5 minutes)
setInterval(async () => {
  if (DisclaimerModal.isDisclaimerAccepted()) {
    const shouldShow = await CredentialsModal.shouldShowCredentialsModal();
    if (shouldShow) {
      console.log('Credentials Modal: Periodic check - showing modal');
      new CredentialsModal();
      CredentialsModal.setCredentialsModalShown();
    }
  }
}, 5 * 60 * 1000); // 5 minutes

// Export for testing
if (typeof module !== 'undefined' && module.exports) {
  module.exports = CredentialsModal;
}

},{}],45:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cryptoUtils = exports.CryptoUtils = void 0;
// File: crypto-utils.js
// Description: Cryptographic utilities for secure data handling
// 
// This module provides encryption and decryption functionality for
// sensitive data like API secrets and user credentials. Uses the
// Web Crypto API for secure cryptographic operations.
// 
// Features:
// - PBKDF2 key derivation for secure key generation
// - AES-GCM encryption for authenticated encryption
// - Base64 encoding for storage compatibility
// - Error handling for decryption failures

/**
 * Cryptographic Utilities Class
 * 
 * Provides secure encryption and decryption using the Web Crypto API.
 * Uses PBKDF2 for key derivation and AES-GCM for authenticated encryption.
 * All methods are static for easy use throughout the application.
 */
class CryptoUtils {
  /**
   * Generate a cryptographic key for encryption/decryption
   * 
   * Uses PBKDF2 key derivation to create a secure key from a password.
   * The key is suitable for AES-GCM encryption operations.
   * 
   * @param {string} password - The password to derive the key from
   * @returns {Promise<CryptoKey>} A CryptoKey object for encryption/decryption
   */
  static async generateKey(password) {
    // Convert password to key material using PBKDF2
    const encoder = new TextEncoder();
    const keyMaterial = await window.crypto.subtle.importKey('raw', encoder.encode(password), 'PBKDF2', false, ['deriveBits', 'deriveKey']);

    // Derive the actual encryption key using PBKDF2
    return window.crypto.subtle.deriveKey({
      name: 'PBKDF2',
      salt: new TextEncoder().encode('PingOneImportSalt'),
      // Should be unique per user in production
      iterations: 100000,
      hash: 'SHA-256'
    }, keyMaterial, {
      name: 'AES-GCM',
      length: 256
    }, false, ['encrypt', 'decrypt']);
  }

  /**
   * Encrypt a string using AES-GCM
   * 
   * Encrypts text using AES-GCM with a random initialization vector (IV).
   * The IV is prepended to the encrypted data for secure storage.
   * Returns the result as base64-encoded string.
   * 
   * @param {string} text - The text to encrypt
   * @param {CryptoKey} key - The encryption key
   * @returns {Promise<string>} Encrypted text as base64 string
   */
  static async encrypt(text, key) {
    // Convert text to UTF-8 bytes
    const encoder = new TextEncoder();
    const data = encoder.encode(text);

    // Generate a random IV (Initialization Vector) for security
    const iv = window.crypto.getRandomValues(new Uint8Array(12));

    // Encrypt the data using AES-GCM
    const encrypted = await window.crypto.subtle.encrypt({
      name: 'AES-GCM',
      iv
    }, key, data);

    // Combine IV and encrypted data into a single array
    // IV is prepended for secure storage and retrieval
    const result = new Uint8Array(iv.length + encrypted.byteLength);
    result.set(iv, 0);
    result.set(new Uint8Array(encrypted), iv.length);

    // Convert to base64 for storage compatibility
    return btoa(String.fromCharCode(...result));
  }

  /**
   * Decrypt a string
   * @param {string} encryptedBase64 - The encrypted text in base64 format
   * @param {CryptoKey} key - The decryption key
   * @returns {Promise<string>} Decrypted text
   */
  static async decrypt(encryptedBase64, key) {
    try {
      // Convert from base64 to Uint8Array
      const encryptedData = Uint8Array.from(atob(encryptedBase64), c => c.charCodeAt(0));

      // Extract the IV (first 12 bytes)
      const iv = encryptedData.slice(0, 12);
      const data = encryptedData.slice(12);
      const decrypted = await window.crypto.subtle.decrypt({
        name: 'AES-GCM',
        iv
      }, key, data);
      return new TextDecoder().decode(decrypted);
    } catch (error) {
      // Don't log the error here - let the calling code handle it
      throw error;
    }
  }
}

// Export the class and a singleton instance
exports.CryptoUtils = CryptoUtils;
const cryptoUtils = exports.cryptoUtils = new CryptoUtils();

},{}],46:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
/**
 * Disclaimer Modal Module
 * Enforces user acknowledgment before allowing access to the application
 */
class DisclaimerModal {
  constructor() {
    this.isActive = false;
    this.focusableElements = [];
    this.firstFocusableElement = null;
    this.lastFocusableElement = null;
    this.previousActiveElement = null;
    this.init();
  }
  init() {
    this.createModal();
    this.bindEvents();
    this.showModal();
  }
  createModal() {
    // Create modal overlay
    const overlay = document.createElement('div');
    overlay.className = 'disclaimer-modal-overlay';
    overlay.setAttribute('role', 'dialog');
    overlay.setAttribute('aria-modal', 'true');
    overlay.setAttribute('aria-labelledby', 'disclaimer-title');
    overlay.setAttribute('aria-describedby', 'disclaimer-content');

    // Create modal content
    overlay.innerHTML = `
            <div class="disclaimer-modal" tabindex="-1">
                <div class="disclaimer-modal-header">
                    <h2 id="disclaimer-title">
                        <span class="warning-icon" aria-hidden="true"></span>
                        <span>Important Disclaimer</span>
                    </h2>
                </div>
                
                <div class="disclaimer-modal-body">
                    <div id="disclaimer-content" class="disclaimer-content">
                        <h3> UNSUPPORTED TOOL WARNING</h3>
                        <p>
                            <strong>This tool is NOT an official Ping Identity product</strong> and is provided 
                            <span class="highlight">without any warranty or support</span>. Use at your own risk.
                        </p>
                        
                        <h3> CRITICAL DISCLAIMERS:</h3>
                        <ul>
                            <li><strong>No technical support</strong> is available from Ping Identity</li>
                            <li><strong>No updates or bug fixes</strong> are guaranteed</li>
                            <li><strong>No compatibility</strong> with future PingOne versions is assured</li>
                            <li><strong>No documentation or training</strong> is provided by Ping Identity</li>
                            <li>This tool may <strong>stop working at any time</strong> without notice</li>
                            <li>Use of this tool is <strong>not recommended for production environments</strong></li>
                            <li>You are <strong>responsible for testing and validating</strong> all operations</li>
                            <li><strong>Backup your PingOne account</strong> before using this tool</li>
                            <li><strong>Test in non-production environments</strong> only</li>
                        </ul>
                        
                        <p>
                            <strong>By continuing, you acknowledge that:</strong>
                        </p>
                        <ul>
                            <li>You understand this tool is unsupported and use it at your own risk</li>
                            <li>You have backed up your PingOne account data</li>
                            <li>You will test operations in non-production environments first</li>
                            <li>You accept full responsibility for any data loss or issues</li>
                        </ul>
                    </div>
                </div>
                
                <div class="disclaimer-modal-footer">
                    <div class="disclaimer-agreement">
                        <div class="disclaimer-checkbox">
                            <input type="checkbox" id="disclaimer-agreement-checkbox" required>
                            <label for="disclaimer-agreement-checkbox">
                                <span class="required-indicator">*</span>
                                I acknowledge and accept the above disclaimer. I understand this tool is unsupported and I use it at my own risk.
                            </label>
                        </div>
                    </div>
                    
                    <div class="disclaimer-actions">
                        <button type="button" class="disclaimer-btn disclaimer-btn-secondary" id="disclaimer-cancel">
                            Cancel
                        </button>
                        <button type="button" class="disclaimer-btn disclaimer-btn-primary" id="disclaimer-continue" disabled>
                            Continue
                        </button>
                    </div>
                </div>
            </div>
        `;
    document.body.appendChild(overlay);
    this.overlay = overlay;
    this.modal = overlay.querySelector('.disclaimer-modal');
    this.checkbox = overlay.querySelector('#disclaimer-agreement-checkbox');
    this.continueBtn = overlay.querySelector('#disclaimer-continue');
    this.cancelBtn = overlay.querySelector('#disclaimer-cancel');
  }
  bindEvents() {
    // Checkbox change event
    this.checkbox.addEventListener('change', e => {
      this.continueBtn.disabled = !e.target.checked;
      this.logEvent('disclaimer_checkbox_changed', {
        checked: e.target.checked
      });
    });

    // Continue button click
    this.continueBtn.addEventListener('click', () => {
      this.acceptDisclaimer();
    });

    // Cancel button click
    this.cancelBtn.addEventListener('click', () => {
      this.cancelDisclaimer();
    });

    // Keyboard events for accessibility
    this.overlay.addEventListener('keydown', e => {
      this.handleKeyboardNavigation(e);
    });

    // Prevent clicks outside modal from closing it
    this.overlay.addEventListener('click', e => {
      if (e.target === this.overlay) {
        // Don't close on outside click - require explicit action
        this.logEvent('disclaimer_outside_click_prevented');
      }
    });

    // Escape key handling
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape' && this.isActive) {
        e.preventDefault();
        this.cancelDisclaimer();
      }
    });
  }
  handleKeyboardNavigation(e) {
    if (!this.isActive) return;
    const focusableElements = this.getFocusableElements();
    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];

    // Tab key navigation with focus trapping
    if (e.key === 'Tab') {
      if (e.shiftKey) {
        if (document.activeElement === firstElement) {
          e.preventDefault();
          lastElement.focus();
        }
      } else {
        if (document.activeElement === lastElement) {
          e.preventDefault();
          firstElement.focus();
        }
      }
    }
  }
  getFocusableElements() {
    const focusableSelectors = ['button:not([disabled])', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'a[href]', '[tabindex]:not([tabindex="-1"])'];
    return Array.from(this.modal.querySelectorAll(focusableSelectors.join(', ')));
  }
  showModal() {
    this.isActive = true;
    this.previousActiveElement = document.activeElement;

    // Add classes to body and app container
    document.body.classList.add('disclaimer-modal-open');
    const appContainer = document.querySelector('.app-container');
    if (appContainer) {
      appContainer.classList.add('disclaimer-modal-active');
    }

    // Show modal with animation
    this.overlay.classList.add('active');

    // Focus management
    this.modal.focus();
    this.setupFocusTrap();
    this.logEvent('disclaimer_modal_shown');

    // Announce to screen readers
    this.announceToScreenReader('Disclaimer modal opened. You must read and accept the disclaimer to continue.');
  }
  setupFocusTrap() {
    this.focusableElements = this.getFocusableElements();
    this.firstFocusableElement = this.focusableElements[0];
    this.lastFocusableElement = this.focusableElements[this.focusableElements.length - 1];
  }
  acceptDisclaimer() {
    if (!this.checkbox.checked) {
      this.logEvent('disclaimer_acceptance_attempted_without_checkbox');
      return;
    }
    this.logEvent('disclaimer_accepted');
    this.hideModal();

    // Enable application functionality
    this.enableApplication();

    // Call the app's enableToolAfterDisclaimer function to show startup screen
    if (typeof window.enableToolAfterDisclaimer === 'function') {
      console.log('[STARTUP] [DEBUG] Disclaimer accepted, calling enableToolAfterDisclaimer');
      window.enableToolAfterDisclaimer();
    } else {
      console.warn('[STARTUP] [DEBUG] enableToolAfterDisclaimer function not found');
    }

    // Dispatch custom event for other components to listen to
    document.dispatchEvent(new CustomEvent('disclaimerAccepted', {
      detail: {
        timestamp: new Date().toISOString()
      }
    }));

    // Announce to screen readers
    this.announceToScreenReader('Disclaimer accepted. Application is now enabled.');
  }
  cancelDisclaimer() {
    this.logEvent('disclaimer_cancelled');
    this.hideModal();

    // Show warning that application cannot be used without accepting
    this.showCancellationWarning();
  }
  hideModal() {
    this.isActive = false;

    // Remove classes
    document.body.classList.remove('disclaimer-modal-open');
    const appContainer = document.querySelector('.app-container');
    if (appContainer) {
      appContainer.classList.remove('disclaimer-modal-active');
    }

    // Hide modal with animation
    this.overlay.classList.remove('active');

    // Restore focus
    if (this.previousActiveElement) {
      this.previousActiveElement.focus();
    }

    // Announce to screen readers
    this.announceToScreenReader('Disclaimer modal closed.');
  }
  enableApplication() {
    // Remove disabled state from all interactive elements
    const disabledElements = document.querySelectorAll('[disabled]');
    disabledElements.forEach(el => {
      if (el.classList.contains('disclaimer-disabled')) {
        el.disabled = false;
        el.classList.remove('disclaimer-disabled');
      }
    });

    // Enable navigation
    const navItems = document.querySelectorAll('.nav-item');
    navItems.forEach(item => {
      item.style.pointerEvents = 'auto';
      item.style.opacity = '1';
    });

    // Enable feature cards
    const featureCards = document.querySelectorAll('.feature-card');
    featureCards.forEach(card => {
      card.style.pointerEvents = 'auto';
      card.style.opacity = '1';
    });

    // Store acceptance
    DisclaimerModal.setDisclaimerAccepted();
    this.logEvent('application_enabled_after_disclaimer');
  }
  showCancellationWarning() {
    // Create a temporary warning message
    const warning = document.createElement('div');
    warning.className = 'alert alert-warning alert-dismissible fade show';
    warning.style.position = 'fixed';
    warning.style.top = '20px';
    warning.style.left = '50%';
    warning.style.transform = 'translateX(-50%)';
    warning.style.zIndex = '10000';
    warning.style.maxWidth = '500px';
    warning.innerHTML = `
            <strong> Disclaimer Required</strong>
            <br>You must accept the disclaimer to use this tool. The application will remain disabled until you acknowledge the terms.
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        `;
    document.body.appendChild(warning);

    // Auto-remove after 10 seconds
    setTimeout(() => {
      if (warning.parentNode) {
        warning.remove();
      }
    }, 10000);
    this.logEvent('disclaimer_cancellation_warning_shown');
  }
  announceToScreenReader(message) {
    // Create temporary element for screen reader announcement
    const announcement = document.createElement('div');
    announcement.setAttribute('aria-live', 'polite');
    announcement.setAttribute('aria-atomic', 'true');
    announcement.className = 'sr-only';
    announcement.textContent = message;
    document.body.appendChild(announcement);

    // Remove after announcement
    setTimeout(() => {
      if (announcement.parentNode) {
        announcement.remove();
      }
    }, 1000);
  }
  logEvent(eventName) {
    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    // Log to console for debugging
    console.log(`[DisclaimerModal] ${eventName}:`, data);

    // Send to server if logging is available and properly initialized
    try {
      // Check if logManager exists and has the log method
      if (window.logManager && typeof window.logManager.log === 'function') {
        window.logManager.log('info', `Disclaimer modal: ${eventName}`, {
          source: 'disclaimer-modal',
          type: 'ui',
          ...data
        });
      } else if (window.logManager) {
        // logManager exists but doesn't have log method - initialize it
        if (typeof window.logManager.log !== 'function') {
          window.logManager.log = function (level, message, data) {
            const timestamp = new Date().toISOString();
            const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message}`;
            if (data) {
              console.log(logMessage, data);
            } else {
              console.log(logMessage);
            }
          };
          // Now try logging again
          window.logManager.log('info', `Disclaimer modal: ${eventName}`, {
            source: 'disclaimer-modal',
            type: 'ui',
            ...data
          });
        }
      } else {
        // logManager not available - create a basic one
        window.logManager = {
          log: function (level, message, data) {
            const timestamp = new Date().toISOString();
            const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message}`;
            if (data) {
              console.log(logMessage, data);
            } else {
              console.log(logMessage);
            }
          }
        };
        // Now try logging
        window.logManager.log('info', `Disclaimer modal: ${eventName}`, {
          source: 'disclaimer-modal',
          type: 'ui',
          ...data
        });
      }
    } catch (error) {
      // Graceful fallback if logging fails
      console.warn('[DisclaimerModal] Logging failed:', error);
    }
  }

  // === CONFIGURATION ===
  // Set to true for session-only disclaimer (shows once per browser session)

  // e.g. 7 days, or 0 for no expiry

  // Static method to check if disclaimer was previously accepted (with expiry/session logic)
  static isDisclaimerAccepted() {
    // TEMPORARY: Force disclaimer to always show for debugging
    return false;

    // Original logic (commented out for debugging):
    // if (DisclaimerModal.DISCLAIMER_SESSION_ONLY) {
    //     return sessionStorage.getItem('disclaimerAccepted') === 'true';
    // }
    // // Expiry logic
    // const accepted = localStorage.getItem('disclaimerAccepted') === 'true';
    // if (!accepted) return false;
    // if (DisclaimerModal.DISCLAIMER_EXPIRY_DAYS > 0) {
    //     const acceptedAt = localStorage.getItem('disclaimerAcceptedAt');
    //     if (!acceptedAt) return false;
    //     const acceptedDate = new Date(acceptedAt);
    //     const now = new Date();
    //     const diffDays = (now - acceptedDate) / (1000 * 60 * 60 * 24);
    //     if (diffDays > DisclaimerModal.DISCLAIMER_EXPIRY_DAYS) {
    //         // Expired, reset
    //         DisclaimerModal.resetDisclaimerAcceptance();
    //         return false;
    //     }
    // }
    // return true;
  }

  // Static method to set acceptance (handles session/local/expiry)
  static setDisclaimerAccepted() {
    if (DisclaimerModal.DISCLAIMER_SESSION_ONLY) {
      sessionStorage.setItem('disclaimerAccepted', 'true');
    } else {
      localStorage.setItem('disclaimerAccepted', 'true');
      localStorage.setItem('disclaimerAcceptedAt', new Date().toISOString());
    }
  }

  // Static method to reset disclaimer acceptance
  static resetDisclaimerAcceptance() {
    if (DisclaimerModal.DISCLAIMER_SESSION_ONLY) {
      sessionStorage.removeItem('disclaimerAccepted');
    } else {
      localStorage.removeItem('disclaimerAccepted');
      localStorage.removeItem('disclaimerAcceptedAt');
    }
  }
}

// Initialize disclaimer modal immediately (DOM is already loaded when bundle executes)
(0, _defineProperty2.default)(DisclaimerModal, "DISCLAIMER_SESSION_ONLY", false);
// set true for sessionStorage, false for localStorage
// Set expiry in days (set to 0 for no expiry)
(0, _defineProperty2.default)(DisclaimerModal, "DISCLAIMER_EXPIRY_DAYS", 7);
(function () {
  console.log('[DISCLAIMER DEBUG] Modal initialization starting immediately');

  // Wait for app to be fully initialized before showing disclaimer
  let disclaimerInitialized = false;
  const initializeDisclaimer = () => {
    console.log('[DISCLAIMER DEBUG] initializeDisclaimer called, disclaimerInitialized:', disclaimerInitialized);
    if (disclaimerInitialized) return;

    // Ensure logManager is available before proceeding
    if (!window.logManager) {
      console.log('[DISCLAIMER DEBUG] Creating logManager');
      window.logManager = {
        log: function (level, message, data) {
          const timestamp = new Date().toISOString();
          const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message}`;
          if (data) {
            console.log(logMessage, data);
          } else {
            console.log(logMessage);
          }
        }
      };
    }

    // Check disclaimer acceptance status
    const isAccepted = DisclaimerModal.isDisclaimerAccepted();
    console.log('[DISCLAIMER DEBUG] isDisclaimerAccepted():', isAccepted);

    // Only show disclaimer if not previously accepted (with expiry/session logic)
    if (!isAccepted) {
      console.log('[DISCLAIMER DEBUG] Creating new DisclaimerModal');
      new DisclaimerModal();
      disclaimerInitialized = true;
    } else {
      console.log('[DISCLAIMER DEBUG] Disclaimer previously accepted, not showing modal');
      // If previously accepted, just enable the application (no modal)
      if (typeof window.enableToolAfterDisclaimer === 'function') {
        console.log('[STARTUP] [DEBUG] Disclaimer previously accepted, calling enableToolAfterDisclaimer');
        window.enableToolAfterDisclaimer();
      } else {
        console.warn('[STARTUP] [DEBUG] enableToolAfterDisclaimer function not found');
      }
      disclaimerInitialized = true;
    }
  };

  // Try to initialize immediately
  initializeDisclaimer();
  // Also try after a short delay to ensure app components are loaded
  setTimeout(initializeDisclaimer, 100);
  // Final attempt after longer delay to ensure logManager is available
  setTimeout(initializeDisclaimer, 1000);
  // Additional attempt after app initialization
  setTimeout(initializeDisclaimer, 2000);
})();

// Export for global access
window.DisclaimerModal = DisclaimerModal;

},{"@babel/runtime/helpers/defineProperty":1,"@babel/runtime/helpers/interopRequireDefault":2}],47:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ElementRegistry = void 0;
// ElementRegistry: Centralized DOM element lookup utility
// Provides safe, memoized access to all required UI elements with logging for missing elements
// Usage: import { ElementRegistry } from './element-registry.js';

const elementCache = {};
function getElement(selector, description) {
  let required = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  // Input validation
  if (!selector || typeof selector !== 'string') {
    console.error(`[ElementRegistry] Invalid selector provided: ${selector}`);
    return null;
  }

  // Security: Prevent potential XSS through selector injection
  // Allow valid attribute selectors with quotes but prevent script injection
  if (selector.includes('<') || selector.includes('>') || selector.includes('"') && !selector.includes('[') && !selector.includes(']') || selector.includes("'") && !selector.includes('[') && !selector.includes(']')) {
    console.error(`[ElementRegistry] Potentially unsafe selector detected: ${selector}`);
    return null;
  }

  // Check cache first
  if (elementCache[selector]) {
    return elementCache[selector];
  }
  try {
    const el = document.querySelector(selector);
    if (!el && required) {
      console.warn(`[ElementRegistry] Missing required element: ${description} (${selector})`);
    } else if (!el) {
      console.info(`[ElementRegistry] Optional element not found: ${description} (${selector})`);
    } else {
      // Validate element is still in DOM
      if (!document.contains(el)) {
        console.warn(`[ElementRegistry] Element found but not in DOM: ${description} (${selector})`);
        elementCache[selector] = null;
        return null;
      }
    }
    elementCache[selector] = el;
    return el;
  } catch (error) {
    console.error(`[ElementRegistry] Error finding element: ${description} (${selector})`, error);
    elementCache[selector] = null;
    return null;
  }
}
const ElementRegistry = exports.ElementRegistry = {
  // Main UI elements
  importButton: () => getElement('#import-btn', 'Import Button'),
  fileInput: () => getElement('#csv-file', 'File Input'),
  dashboardTab: () => getElement('#dashboard-tab', 'Dashboard Tab'),
  dragDropArea: () => getElement('#drag-drop-area', 'Drag-and-Drop Area', false),
  // Notification and progress containers
  notificationContainer: () => getElement('#notification-area', 'Notification Container'),
  progressContainer: () => getElement('#progress-container', 'Progress Container'),
  // Token and connection status elements
  tokenStatus: () => getElement('#token-status-indicator', 'Token Status'),
  connectionStatus: () => getElement('#connection-status', 'Connection Status'),
  currentTokenStatus: () => getElement('#current-token-status', 'Current Token Status'),
  homeTokenStatus: () => getElement('#home-token-status', 'Home Token Status'),
  // File handling elements
  fileInfo: () => getElement('#file-info', 'File Info'),
  previewContainer: () => getElement('#dashboard-preview', 'Preview Container'),
  fileInputLabel: () => getElement('label[for="csv-file"]', 'File Input Label'),
  deleteFileInput: () => getElement('#delete-csv-file', 'Delete File Input'),
  deleteFileInputLabel: () => getElement('label[for="delete-csv-file"]', 'Delete File Input Label'),
  modifyFileInput: () => getElement('#modify-csv-file', 'Modify File Input'),
  modifyFileInputLabel: () => getElement('label[for="modify-csv-file"]', 'Modify File Input Label'),
  // Population selection elements
  importPopulationSelect: () => getElement('#import-population-select', 'Import Population Select'),
  deletePopulationSelect: () => getElement('#delete-population-select', 'Delete Population Select'),
  modifyPopulationSelect: () => getElement('#modify-population-select', 'Modify Population Select'),
  dashboardPopulationSelect: () => getElement('#dashboard-population-select', 'Dashboard Population Select'),
  // Import buttons
  startImportBtn: () => getElement('#start-import', 'Start Import Button'),
  startImportBtnBottom: () => getElement('#bottom-start-import', 'Bottom Start Import Button'),
  // Settings elements
  settingsSaveStatus: () => getElement('#settings-save-status', 'Settings Save Status'),
  // Import status elements
  importStatus: () => getElement('#import-status', 'Import Status'),
  // Population checkboxes
  useDefaultPopulationCheckbox: () => getElement('#use-default-population', 'Use Default Population Checkbox'),
  useCsvPopulationIdCheckbox: () => getElement('#use-csv-population-id', 'Use CSV Population ID Checkbox'),
  // Get Token button
  getTokenBtn: () => getElement('#get-token-quick', 'Get Token Button'),
  // Population ID form field
  populationIdField: () => getElement('#population-id', 'Population ID Field')
};

},{}],48:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ErrorTypes = exports.ErrorSeverity = exports.ErrorMetadata = exports.ErrorMessages = exports.ErrorCodes = void 0;
exports.createError = createError;
exports.getDefaultMessage = getDefaultMessage;
exports.getDefaultSeverity = getDefaultSeverity;
exports.isErrorType = isErrorType;
/**
 * Error Types
 * 
 * Defines standard error types and severities for consistent error handling
 */

/**
 * Standard error types
 */
const ErrorTypes = exports.ErrorTypes = Object.freeze({
  // Client-side errors
  VALIDATION: 'VALIDATION',
  // Data validation failed
  AUTHENTICATION: 'AUTHENTICATION',
  // Authentication/authorization issues
  AUTHORIZATION: 'AUTHORIZATION',
  // Permission issues
  NETWORK: 'NETWORK',
  // Network connectivity issues
  TIMEOUT: 'TIMEOUT',
  // Request timeouts

  // Server-side errors
  SERVER: 'SERVER',
  // Generic server error (500)
  SERVICE_UNAVAILABLE: 'SERVICE_UNAVAILABLE',
  // Service unavailable (503)
  NOT_FOUND: 'NOT_FOUND',
  // Resource not found (404)
  CONFLICT: 'CONFLICT',
  // Resource conflict (409)

  // Application-specific errors
  CONFIGURATION: 'CONFIGURATION',
  // Configuration errors
  INTEGRATION: 'INTEGRATION',
  // Third-party service integration errors

  // Fallback
  UNKNOWN: 'UNKNOWN' // Unclassified errors
});

/**
 * Error severity levels
 */
const ErrorSeverity = exports.ErrorSeverity = Object.freeze({
  FATAL: 'FATAL',
  // Application cannot continue
  ERROR: 'ERROR',
  // Operation failed, but application can continue
  WARNING: 'WARNING',
  // Operation completed with issues
  INFO: 'INFO',
  // Informational message
  DEBUG: 'DEBUG' // Debug information
});

/**
 * Standard error codes
 */
const ErrorCodes = exports.ErrorCodes = Object.freeze({
  // Authentication (1000-1099)
  INVALID_CREDENTIALS: 1001,
  SESSION_EXPIRED: 1002,
  INVALID_TOKEN: 1003,
  // Validation (2000-2099)
  INVALID_INPUT: 2001,
  MISSING_REQUIRED_FIELD: 2002,
  INVALID_FORMAT: 2003,
  // Authorization (3000-3099)
  PERMISSION_DENIED: 3001,
  INSUFFICIENT_PERMISSIONS: 3002,
  // Network (4000-4099)
  NETWORK_ERROR: 4001,
  REQUEST_TIMEOUT: 4002,
  // Server (5000-5099)
  INTERNAL_SERVER_ERROR: 5001,
  SERVICE_UNAVAILABLE: 5002,
  // Business Logic (6000-6099)
  DUPLICATE_ENTRY: 6001,
  RESOURCE_NOT_FOUND: 6002,
  // Integration (7000-7099)
  EXTERNAL_SERVICE_ERROR: 7001,
  API_RATE_LIMIT_EXCEEDED: 7002
});

/**
 * Standard error messages
 */
const ErrorMessages = exports.ErrorMessages = Object.freeze({
  [ErrorTypes.VALIDATION]: 'Validation failed',
  [ErrorTypes.AUTHENTICATION]: 'Authentication required',
  [ErrorTypes.AUTHORIZATION]: 'Permission denied',
  [ErrorTypes.NETWORK]: 'Network error occurred',
  [ErrorTypes.TIMEOUT]: 'Request timed out',
  [ErrorTypes.SERVER]: 'Internal server error',
  [ErrorTypes.SERVICE_UNAVAILABLE]: 'Service unavailable',
  [ErrorTypes.NOT_FOUND]: 'Resource not found',
  [ErrorTypes.CONFLICT]: 'Resource conflict',
  [ErrorTypes.CONFIGURATION]: 'Configuration error',
  [ErrorTypes.INTEGRATION]: 'Integration error',
  [ErrorTypes.UNKNOWN]: 'An unexpected error occurred'
});

/**
 * Error metadata
 * Maps error types to their default properties
 */
const ErrorMetadata = exports.ErrorMetadata = Object.freeze({
  [ErrorTypes.VALIDATION]: {
    severity: ErrorSeverity.WARNING,
    isRecoverable: true,
    userMessage: 'Please check your input and try again.'
  },
  [ErrorTypes.AUTHENTICATION]: {
    severity: ErrorSeverity.ERROR,
    isRecoverable: true,
    userMessage: 'Your session has expired. Please log in again.'
  },
  [ErrorTypes.AUTHORIZATION]: {
    severity: ErrorSeverity.ERROR,
    isRecoverable: false,
    userMessage: 'You do not have permission to perform this action.'
  },
  [ErrorTypes.NETWORK]: {
    severity: ErrorSeverity.WARNING,
    isRecoverable: true,
    userMessage: 'Unable to connect to the server. Please check your internet connection.'
  },
  [ErrorTypes.SERVER]: {
    severity: ErrorSeverity.ERROR,
    isRecoverable: false,
    userMessage: 'An unexpected server error occurred. Please try again later.'
  },
  [ErrorTypes.UNKNOWN]: {
    severity: ErrorSeverity.ERROR,
    isRecoverable: false,
    userMessage: 'An unexpected error occurred. Please try again.'
  }
});

/**
 * Creates a standard error object
 * @param {string} type - Error type from ErrorTypes
 * @param {string} message - Error message
 * @param {Object} details - Additional error details
 * @returns {Error} Standardized error object
 */
function createError(type, message) {
  let details = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const error = new Error(message || ErrorMessages[type] || 'An unknown error occurred');
  error.type = type;
  error.code = details.code || ErrorCodes[type] || 0;
  error.details = details;
  error.timestamp = new Date().toISOString();

  // Add metadata if available
  const metadata = ErrorMetadata[type];
  if (metadata) {
    error.severity = metadata.severity;
    error.isRecoverable = metadata.isRecoverable;
    error.userMessage = metadata.userMessage;
  }
  return error;
}

/**
 * Checks if an error is of a specific type
 * @param {Error} error - The error to check
 * @param {string} type - The error type to check against
 * @returns {boolean} True if the error is of the specified type
 */
function isErrorType(error, type) {
  return error && error.type === type;
}

/**
 * Gets the default error message for an error type
 * @param {string} type - The error type
 * @returns {string} The default error message
 */
function getDefaultMessage(type) {
  return ErrorMessages[type] || 'An unknown error occurred';
}

/**
 * Gets the default severity for an error type
 * @param {string} type - The error type
 * @returns {string} The default severity
 */
function getDefaultSeverity(type) {
  const metadata = ErrorMetadata[type];
  return metadata ? metadata.severity : ErrorSeverity.ERROR;
}

},{}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.eventBus = exports.default = exports.EventBus = void 0;
// event-bus.js
// Simple EventBus utility for cross-subsystem communication

class EventBus {
  constructor() {
    this.events = {};
  }
  on(event, handler) {
    (this.events[event] = this.events[event] || []).push(handler);
  }
  off(event, handler) {
    if (!this.events[event]) return;
    this.events[event] = this.events[event].filter(h => h !== handler);
  }
  emit(event, data) {
    (this.events[event] || []).forEach(h => h(data));
  }
}

// Create and export a default instance
exports.EventBus = EventBus;
const eventBus = exports.eventBus = new EventBus();

// Export both the class and the default instance
var _default = exports.default = eventBus; // Browser global fallback for legacy compatibility
if (typeof window !== 'undefined') {
  window.EventBus = EventBus;
  window.eventBus = eventBus;
}

},{}],50:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FileHandler = void 0;
var _elementRegistry = require("./element-registry.js");
// File: file-handler.js
// Description: CSV file processing and validation for PingOne user import
// 
// This module handles all file-related operations including:
// - CSV file reading and parsing
// - User data validation and error checking
// - File preview generation
// - File information display and management
// - Folder path tracking for better UX
// - Validation summary and error reporting
// 
// Provides comprehensive CSV processing with detailed validation feedback.

/**
 * File Handler Class
 * 
 * Manages CSV file processing, validation, and user data preparation
 * for the PingOne import tool. Handles file selection, parsing,
 * validation, and preview generation.
 * 
 * @param {Object} logger - Logger instance for debugging
 * @param {Object} uiManager - UI manager for status updates
 */
class FileHandler {
  /**
   * Create a new FileHandler instance
   * @param {Object} logger - Logger instance for debugging
   * @param {Object} uiManager - UI manager for status updates
   */
  constructor(logger, uiManager) {
    if (!logger) {
      throw new Error('Logger is required for FileHandler');
    }
    this.logger = logger;
    this.uiManager = uiManager;

    // Required fields for user validation
    this.requiredFields = ['username'];

    // Validation tracking for processed files
    this.validationResults = {
      total: 0,
      valid: 0,
      errors: 0,
      warnings: 0
    };

    // File processing state
    this.lastParsedUsers = [];
    this.currentFile = null;

    // Initialize UI elements for file handling
    this.fileInput = _elementRegistry.ElementRegistry.fileInput ? _elementRegistry.ElementRegistry.fileInput() : null;
    this.fileInfo = _elementRegistry.ElementRegistry.fileInfo ? _elementRegistry.ElementRegistry.fileInfo() : null;
    this.previewContainer = _elementRegistry.ElementRegistry.previewContainer ? _elementRegistry.ElementRegistry.previewContainer() : null;

    // Load last file info from localStorage for better UX
    this.lastFileInfo = this.loadLastFileInfo();

    // Initialize event listeners for file input
    this.initializeFileInput();
  }

  // ======================
  // File Info Management
  // ======================

  /**
   * Load last file info from localStorage
   * @returns {Object|null} Last file info or null if not found
   */
  loadLastFileInfo() {
    try {
      const savedFile = localStorage.getItem('lastSelectedFile');
      return savedFile ? JSON.parse(savedFile) : null;
    } catch (error) {
      this.logger.error('Error loading last file info:', error);
      return null;
    }
  }

  /**
   * Get the current file being processed
   * 
   * Returns the File object that is currently loaded and ready for processing.
   * Used by other modules to access the file for upload operations.
   * 
   * @returns {File|null} The current file or null if none is loaded
   */
  getCurrentFile() {
    return this.currentFile;
  }

  /**
   * Set a file and process it for import
   * 
   * Validates the file, processes its contents, and prepares it for
   * import operations. Updates UI with file information and validation results.
   * 
   * @param {File} file - The file to set and process
   * @param {string} operationType - The operation type ('import', 'delete', 'modify')
   * @returns {Promise<Object>} Promise that resolves with processing result
   */
  async setFile(file) {
    let operationType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'import';
    if (!file) {
      throw new Error('File is required for setFile operation');
    }
    try {
      this.logger.info('Setting file', {
        fileName: file.name,
        fileSize: file.size,
        operationType
      });

      // Store the current file reference for later use
      this.currentFile = file;

      // Process the file using the existing internal method
      // This includes validation, parsing, and UI updates
      await this._handleFileInternal(file, null, operationType);
      return {
        success: true,
        file
      };
    } catch (error) {
      this.logger.error('Failed to set file', {
        error: error.message,
        fileName: file.name,
        operationType
      });
      throw error;
    }
  }

  /**
   * Get the list of parsed users from the current file
   * 
   * Returns the array of user objects that were successfully parsed
   * from the CSV file. Each user object contains validated data.
   * 
   * @returns {Array} Array of user objects with validated data
   */
  getUsers() {
    return this.lastParsedUsers || [];
  }

  /**
   * Get the total number of users parsed from the CSV file
   * 
   * Returns the total count of users found in the processed CSV file.
   * This count includes all rows, regardless of validation status.
   * 
   * @returns {number} Total number of users in the CSV file
   */
  getTotalUsers() {
    const totalUsers = this.validationResults.total || 0;
    console.log('[CSV] getTotalUsers() called, returning:', totalUsers, 'validationResults:', this.validationResults);
    return totalUsers;
  }

  /**
   * Read file as text using FileReader API
   * 
   * Asynchronously reads a file and returns its contents as a string.
   * Used for processing CSV files and other text-based formats.
   * 
   * @param {File} file - The file to read
   * @returns {Promise<string>} Promise that resolves with file content as string
   */
  readFileAsText(file) {
    if (!file) {
      throw new Error('File is required for reading');
    }
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = event => resolve(event.target.result);
      reader.onerror = () => reject(new Error('Failed to read file'));
      reader.readAsText(file);
    });
  }

  /**
   * Save the last folder path that was used
   * @param {File} file - The selected file
   * @param {string} operationType - The operation type ('import', 'delete', 'modify')
   */
  saveLastFolderPath(file) {
    let operationType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'import';
    if (!file) {
      return;
    }
    try {
      let folderPath = null;

      // Try to extract folder path from different sources
      if (file.webkitRelativePath) {
        // For webkitRelativePath, get the directory part
        const pathParts = file.webkitRelativePath.split('/');
        if (pathParts.length > 1) {
          folderPath = pathParts.slice(0, -1).join('/');
        }
      } else if (file.name) {
        // For regular files, try to extract from the file name
        // This is a fallback since we can't get the full path due to security restrictions
        const fileName = file.name;
        const lastSlashIndex = fileName.lastIndexOf('/');
        if (lastSlashIndex !== -1) {
          folderPath = fileName.substring(0, lastSlashIndex);
        }
      }
      if (folderPath) {
        // Save with operation-specific key
        const storageKey = `lastFolderPath_${operationType}`;
        localStorage.setItem(storageKey, folderPath);
        this.logger.info(`Saved last folder path for ${operationType}:`, folderPath);
      }

      // Also save a general last folder path
      if (folderPath) {
        localStorage.setItem('lastFolderPath', folderPath);
      }
    } catch (error) {
      this.logger.warn('Could not save folder path:', error.message);
    }
  }

  /**
   * Get the last folder path that was used
   * @param {string} operationType - The operation type ('import', 'delete', 'modify')
   * @returns {string|null} The last folder path or null if not available
   */
  getLastFolderPath() {
    let operationType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'import';
    try {
      // First try to get operation-specific folder path
      const operationKey = `lastFolderPath_${operationType}`;
      let folderPath = localStorage.getItem(operationKey);

      // Fall back to general last folder path
      if (!folderPath) {
        folderPath = localStorage.getItem('lastFolderPath');
      }
      return folderPath;
    } catch (error) {
      this.logger.warn('Could not get last folder path:', error.message);
      return null;
    }
  }

  /**
   * Update the file input label to show last folder path
   * @param {string} operationType - The operation type ('import', 'delete', 'modify')
   */
  updateFileLabel() {
    let operationType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'import';
    try {
      // Find the appropriate file label based on operation type
      let fileLabel = null;
      let fileInput = null;
      switch (operationType) {
        case 'import':
          fileLabel = _elementRegistry.ElementRegistry.fileInputLabel ? _elementRegistry.ElementRegistry.fileInputLabel() : null;
          fileInput = _elementRegistry.ElementRegistry.fileInput ? _elementRegistry.ElementRegistry.fileInput() : null;
          break;
        case 'delete':
          fileLabel = _elementRegistry.ElementRegistry.deleteFileInputLabel ? _elementRegistry.ElementRegistry.deleteFileInputLabel() : null;
          fileInput = _elementRegistry.ElementRegistry.deleteFileInput ? _elementRegistry.ElementRegistry.deleteFileInput() : null;
          break;
        case 'modify':
          fileLabel = _elementRegistry.ElementRegistry.modifyFileInputLabel ? _elementRegistry.ElementRegistry.modifyFileInputLabel() : null;
          fileInput = _elementRegistry.ElementRegistry.modifyFileInput ? _elementRegistry.ElementRegistry.modifyFileInput() : null;
          break;
        default:
          fileLabel = _elementRegistry.ElementRegistry.fileInputLabel ? _elementRegistry.ElementRegistry.fileInputLabel() : null;
          break;
      }
      if (fileLabel) {
        const lastFolderPath = this.getLastFolderPath(operationType);
        if (lastFolderPath) {
          // Show a shortened version of the path for better UI
          const shortPath = this.shortenPath(lastFolderPath);
          fileLabel.textContent = `Choose CSV File (Last: ${shortPath})`;
          fileLabel.title = `Last used folder: ${lastFolderPath}`;
        } else {
          fileLabel.textContent = 'Choose CSV File';
          fileLabel.title = 'Select a CSV file to process';
        }
      }
    } catch (error) {
      this.logger.warn('Could not update file label:', error.message);
    }
  }

  /**
   * Shorten a file path for display in the UI
   * @param {string} path - The full path
   * @returns {string} The shortened path
   */
  shortenPath(path) {
    if (!path) {
      return '';
    }
    const maxLength = 30;
    if (path.length <= maxLength) {
      return path;
    }

    // Try to keep the most relevant parts
    const parts = path.split('/');
    if (parts.length <= 2) {
      return path.length > maxLength ? '...' + path.slice(-maxLength + 3) : path;
    }

    // Keep first and last parts, add ellipsis in middle
    const firstPart = parts[0];
    const lastPart = parts[parts.length - 1];
    const middleParts = parts.slice(1, -1);
    let result = firstPart;
    if (middleParts.length > 0) {
      result += '/.../' + lastPart;
    } else {
      result += '/' + lastPart;
    }
    return result.length > maxLength ? '...' + result.slice(-maxLength + 3) : result;
  }

  /**
   * Save file info to localStorage
   * @param {Object} fileInfo - File information object
   */
  saveFileInfo(fileInfo) {
    if (!fileInfo) {
      return;
    }
    try {
      const fileData = {
        name: fileInfo.name,
        size: fileInfo.size,
        lastModified: fileInfo.lastModified,
        type: fileInfo.type
      };
      localStorage.setItem('lastSelectedFile', JSON.stringify(fileData));
      this.lastFileInfo = fileData;
    } catch (error) {
      this.logger.error('Error saving file info:', error);
    }
  }

  /**
   * Clear file info from localStorage
   */
  clearFileInfo() {
    try {
      localStorage.removeItem('lastSelectedFile');
      this.lastFileInfo = null;
      if (this.fileInfo) {
        this.fileInfo.innerHTML = 'No file selected';
      }
    } catch (error) {
      this.logger.error('Error clearing file info:', error);
    }
  }

  /**
   * Clear the last folder path
   */
  clearLastFolderPath() {
    try {
      localStorage.removeItem('lastFolderPath');
      this.updateFileLabel();
      this.logger.info('Cleared last folder path');
    } catch (error) {
      this.logger.warn('Could not clear last folder path:', error.message);
    }
  }

  // ======================
  // File Handling
  // ======================

  /**
   * Initialize file input event listeners
   */
  initializeFileInput() {
    if (!this.fileInput) {
      return;
    }

    // Remove existing event listeners
    const newFileInput = this.fileInput.cloneNode(true);
    this.fileInput.parentNode.replaceChild(newFileInput, this.fileInput);
    this.fileInput = newFileInput;

    // Add new event listener
    this.fileInput.addEventListener('change', event => this.handleFileSelect(event));

    // Update file label to show last folder path if available
    this.updateFileLabel();
  }

  /**
   * Handle a File object directly (not an event)
   * @param {File} file - The file to handle
   */
  async handleFileObject(file) {
    if (!file) {
      throw new Error('File is required for handleFileObject');
    }
    await this._handleFileInternal(file);
  }

  /**
   * Handle file selection from an input event
   * @param {Event} event - The file selection event
   */
  async handleFileSelect(event) {
    if (!event || !event.target) {
      this.logger.warn('Invalid file selection event');
      return;
    }
    const file = event.target.files[0];
    if (!file) {
      this.logger.warn('No file selected');
      return;
    }

    // Save the folder path for next time
    this.saveLastFolderPath(file, 'import');
    await this._handleFileInternal(file, event);
  }

  /**
   * Shared internal file handling logic
   * @param {File} file - The file to process
   * @param {Event} [event] - The file selection event (optional)
   * @param {string} operationType - The operation type ('import', 'delete', 'modify')
   * @private
   */
  async _handleFileInternal(file, event) {
    let operationType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'import';
    if (!file) {
      throw new Error('File is required for internal file handling');
    }
    console.log('[CSV] _handleFileInternal called with file:', file.name, 'size:', file.size, 'operationType:', operationType);
    try {
      this.logger.info('Processing file', {
        fileName: file.name,
        fileSize: file.size,
        operationType
      });

      // Validate file type - allow files without extensions or with any extension except known bad ones
      const fileName = file.name || '';
      const fileExt = this.getFileExtension(fileName).toLowerCase();
      const knownBadExts = ['exe', 'js', 'png', 'jpg', 'jpeg', 'gif', 'pdf', 'zip', 'tar', 'gz'];
      if (fileExt && knownBadExts.includes(fileExt)) {
        const errorMsg = `Unsupported file type: ${fileExt}. Please upload a CSV or text file.`;
        this.logger.error(errorMsg, {
          fileName,
          fileExt
        });
        throw new Error(errorMsg);
      }
      // Accept all other extensions and blank/unknown types (including files with no extension)

      // Validate file size (10MB limit)
      const maxSize = 10 * 1024 * 1024; // 10MB
      if (file.size > maxSize) {
        throw new Error('File too large. Please select a file smaller than 10MB.');
      }

      // Read file content
      const content = await this.readFileAsText(file);
      console.log('[CSV] _handleFileInternal: About to parse CSV content, length:', content.length);
      // Parse CSV with enhanced validation
      const parseResults = this.parseCSV(content);
      console.log('[CSV] _handleFileInternal: parseCSV completed, parseResults:', parseResults);

      // Store parsed users
      this.parsedUsers = parseResults.users;
      this.lastParsedUsers = [...parseResults.users];

      // Update validation results for getTotalUsers() method
      this.validationResults = {
        total: parseResults.users.length,
        valid: parseResults.validUsers || parseResults.users.length,
        errors: parseResults.errors.length,
        warnings: parseResults.warnings.length
      };

      // Add debug logging
      console.log('[CSV] File parsed successfully:', {
        totalUsers: this.validationResults.total,
        validUsers: this.validationResults.valid,
        errors: this.validationResults.errors,
        warnings: this.validationResults.warnings
      });

      // Update UI with results
      const message = `File processed: ${parseResults.validUsers} valid users, ${parseResults.invalidRows} invalid rows`;
      this.uiManager.showNotification(message, parseResults.invalidRows > 0 ? 'warning' : 'success');

      // Update UI with enhanced file info display based on operation type
      const fileInfoContainerId = operationType === 'modify' ? 'modify-file-info' : 'file-info';
      this.updateFileInfoForElement(file, fileInfoContainerId, parseResults.validUsers);

      // Update file label to show last folder path
      this.updateFileLabel(operationType);

      // Log detailed errors for debugging
      if (parseResults.errors.length > 0) {
        this.logger.warn('CSV parsing errors', {
          errorCount: parseResults.errors.length,
          errors: parseResults.errors.slice(0, 10) // Log first 10 errors
        });
      }

      // Update button state based on operation type
      if (window.app) {
        if (operationType === 'modify' && window.app.updateModifyButtonState) {
          window.app.updateModifyButtonState();
        } else if (operationType === 'import' && window.app.updateImportButtonState) {
          window.app.updateImportButtonState();
        }
      }
    } catch (error) {
      this.logger.error('Failed to process CSV file', {
        error: error.message,
        fileName: file.name,
        operationType
      });
      console.error('Error in _handleFileInternal:', error);
      let errorMessage = 'Failed to process CSV file. ';
      if (error.message.includes('Missing required headers')) {
        errorMessage = `CSV file is missing required columns. ${error.message} Please ensure your CSV file has a 'username' column.`;
      } else if (error.message.includes('Invalid file type')) {
        errorMessage += 'Please select a valid CSV file.';
      } else if (error.message.includes('File too large')) {
        errorMessage += 'Please select a smaller file (max 10MB).';
      } else {
        errorMessage += error.message;
      }
      this.uiManager.showNotification(errorMessage, 'error');

      // Clear file input
      if (event && event.target && event.target.value) {
        event.target.value = '';
      }
    }
  }

  /**
   * Process a CSV file for user import
   * 
   * Validates the file format, reads its contents, parses CSV data,
   * and prepares user objects for import. Handles file validation,
   * CSV parsing, and error reporting.
   * 
   * @param {File} file - The CSV file to process
   * @returns {Promise<Object>} Promise that resolves with parsing results
   */
  async processCSV(file) {
    // Log file object for debugging
    this.logger.log('Processing file object:', 'debug', file);

    // Validate file exists and is not empty
    if (!file) {
      this.logger.error('No file provided to processCSV');
      throw new Error('No file selected');
    }
    if (file.size === 0) {
      this.logger.error('Empty file provided', {
        fileName: file.name,
        size: file.size
      });
      throw new Error('File is empty');
    }

    // Only block known bad extensions, allow all others
    const fileName = file.name || '';
    const fileExt = this.getFileExtension(fileName).toLowerCase();
    const knownBadExts = ['exe', 'js', 'png', 'jpg', 'jpeg', 'gif', 'pdf', 'zip', 'tar', 'gz'];
    if (fileExt && knownBadExts.includes(fileExt)) {
      const errorMsg = `Unsupported file type: ${fileExt}. Please upload a CSV or text file.`;
      this.logger.error(errorMsg, {
        fileName,
        fileExt
      });
      throw new Error(errorMsg);
    }
    // Accept all other extensions and blank/unknown types
    // Check file size (max 10MB)
    const maxSize = 10 * 1024 * 1024; // 10MB
    if (file.size > maxSize) {
      throw new Error(`File is too large. Maximum size is ${this.formatFileSize(maxSize)}`);
    }

    // Update UI
    this.saveFileInfo(file);
    this.updateFileInfo(file);

    // Store the current file reference
    this.currentFile = file;
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = event => {
        try {
          const text = event.target.result;
          if (!text || text.trim() === '') {
            throw new Error('File is empty or contains no text');
          }
          console.log('[CSV] About to parse CSV text, length:', text.length);
          const {
            headers,
            rows
          } = this.parseCSV(text);
          console.log('[CSV] parseCSV completed, headers:', headers, 'rows count:', rows.length);

          // Validate required fields
          const missingHeaders = this.requiredFields.filter(field => !headers.includes(field));
          if (missingHeaders.length > 0) {
            throw new Error(`Missing required columns: ${missingHeaders.join(', ')}`);
          }

          // Convert rows to user objects and store them
          this.lastParsedUsers = rows.map(row => {
            const user = {};
            headers.forEach((header, index) => {
              user[header] = row[header] || '';
            });
            return user;
          });

          // Also store in parsedUsers for compatibility with getParsedUsers
          this.parsedUsers = this.lastParsedUsers;

          // Update validation results for getTotalUsers() method
          this.validationResults = {
            total: this.lastParsedUsers.length,
            valid: this.lastParsedUsers.length,
            errors: 0,
            warnings: 0
          };

          // Add debug logging
          console.log('[CSV] File parsed successfully (processCSV):', {
            totalUsers: this.validationResults.total,
            validUsers: this.validationResults.valid,
            errors: this.validationResults.errors,
            warnings: this.validationResults.warnings
          });
          resolve({
            success: true,
            headers,
            rows: this.lastParsedUsers,
            userCount: this.lastParsedUsers.length
          });
        } catch (error) {
          reject(error);
        }
      };
      reader.onerror = () => {
        reject(new Error('Error reading file'));
      };
      reader.readAsText(file);
    });
  }

  // ======================
  // CSV Parsing Methods
  // ======================

  /**
   * Parse CSV content into headers and data rows
   * 
   * Splits CSV content into lines, extracts headers, and validates
   * required and recommended columns. Handles header mapping for
   * different naming conventions.
   * 
   * @param {string} content - Raw CSV content as string
   * @returns {Object} Object containing headers and parsed rows
   */
  parseCSV(content) {
    // Split content into lines and filter out empty lines
    const lines = content.split('\n').filter(line => line.trim());
    if (lines.length < 2) {
      throw new Error('CSV file must have at least a header row and one data row');
    }

    // Parse headers from first line
    const headers = this.parseCSVLine(lines[0]);

    // Define required and recommended headers for validation
    const requiredHeaders = ['username'];
    const recommendedHeaders = ['firstName', 'lastName', 'email'];

    // Log all headers for debugging
    console.log('[CSV] All headers:', headers);
    console.log('[CSV] Required headers:', requiredHeaders);
    console.log('[CSV] Recommended headers:', recommendedHeaders);

    // Validate headers
    const missingRequired = requiredHeaders.filter(h => {
      const hasHeader = headers.some(header => {
        const headerLower = header.toLowerCase();
        const mappedHeader = this.getHeaderMapping(headerLower);
        const matches = headerLower === h.toLowerCase() || mappedHeader === h;
        console.log(`[CSV] Checking header "${header}" (${headerLower}) -> "${mappedHeader}" for required "${h}": ${matches}`);
        return matches;
      });
      console.log(`[CSV] Required header "${h}" found: ${hasHeader}`);
      return !hasHeader;
    });
    const missingRecommended = recommendedHeaders.filter(h => {
      const hasHeader = headers.some(header => {
        const headerLower = header.toLowerCase();
        const mappedHeader = this.getHeaderMapping(headerLower);
        const matches = headerLower === h.toLowerCase() || mappedHeader === h;
        console.log(`[CSV] Checking header "${header}" (${headerLower}) -> "${mappedHeader}" for recommended "${h}": ${matches}`);
        return matches;
      });
      console.log(`[CSV] Recommended header "${h}" found: ${hasHeader}`);
      return !hasHeader;
    });
    if (missingRequired.length > 0) {
      const errorMsg = `Missing required headers: ${missingRequired.join(', ')}. At minimum, you need a 'username' column.`;
      this.logger.error('CSV validation failed - missing required headers', {
        missingRequired,
        availableHeaders: headers,
        errorMsg
      });
      throw new Error(errorMsg);
    }
    if (missingRecommended.length > 0) {
      const warningMsg = `Missing recommended headers: ${missingRecommended.join(', ')}. These are not required but recommended for better user data.`;
      this.logger.warn('CSV validation warning - missing recommended headers', {
        missingRecommended,
        availableHeaders: headers,
        warningMsg
      });
      // Show warning but don't throw error
      if (window.app && window.app.uiManager) {
        window.app.uiManager.showNotification(warningMsg, 'warning');
      }
    }
    const users = [];
    const errors = [];
    const warnings = [];
    let rowNumber = 1; // Start from 1 since 0 is header

    for (let i = 1; i < lines.length; i++) {
      rowNumber = i + 1; // +1 because we start from header row
      const line = lines[i].trim();
      if (!line) continue; // Skip empty lines

      try {
        const user = this.parseUserRow(line, headers, rowNumber);

        // Validate user data
        const validationResult = this.validateUserData(user, rowNumber);
        if (validationResult.isValid) {
          users.push(user);
        } else {
          errors.push({
            row: rowNumber,
            user: user,
            errors: validationResult.errors,
            warnings: validationResult.warnings
          });

          // Add warnings to warnings array
          warnings.push(...validationResult.warnings.map(w => ({
            row: rowNumber,
            ...w
          })));
        }
      } catch (error) {
        errors.push({
          row: rowNumber,
          error: error.message,
          line: line
        });
      }
    }

    // Log comprehensive validation results
    const validationSummary = {
      totalRows: lines.length - 1,
      validUsers: users.length,
      invalidRows: errors.length,
      warnings: warnings.length,
      missingRequiredHeaders: missingRequired,
      missingRecommendedHeaders: missingRecommended,
      availableHeaders: headers
    };
    this.logger.info('CSV parsing completed', validationSummary);
    if (errors.length > 0) {
      const errorDetails = errors.map(e => ({
        row: e.row,
        errors: e.errors || [e.error],
        warnings: e.warnings || []
      }));
      this.logger.warn('CSV validation issues found', {
        totalErrors: errors.length,
        errorDetails: errorDetails.slice(0, 10) // Log first 10 errors
      });
    }

    // Show user-friendly summary
    this.showValidationSummary(validationSummary, errors, warnings);
    return {
      users,
      errors,
      warnings,
      totalRows: lines.length - 1,
      validUsers: users.length,
      invalidRows: errors.length,
      headerCount: headers.length,
      availableHeaders: headers
    };
  }

  /**
   * Parse a single CSV line
   * @param {string} line - CSV line to parse
   * @param {string} delimiter - Delimiter character
   * @returns {Array<string>} Array of field values
   */
  parseCSVLine(line) {
    let delimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ',';
    const result = [];
    let current = '';
    let inQuotes = false;
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      const nextChar = line[i + 1];
      if (char === '"') {
        if (nextChar === '"') {
          current += '"';
          i++;
        } else {
          inQuotes = !inQuotes;
        }
      } else if (char === delimiter && !inQuotes) {
        result.push(current);
        current = '';
      } else {
        current += char;
      }
    }
    result.push(current);
    return result.map(field => field.trim());
  }

  /**
   * Parse a user row from CSV
   * @param {string} line - CSV line to parse
   * @param {Array<string>} headers - Header row
   * @param {number} rowNumber - Row number for error reporting
   * @returns {Object} Parsed user object
   */
  parseUserRow(line, headers, rowNumber) {
    const values = this.parseCSVLine(line);
    if (values.length !== headers.length) {
      throw new Error(`Row ${rowNumber}: Number of columns (${values.length}) doesn't match headers (${headers.length})`);
    }
    const user = {};
    for (let i = 0; i < headers.length; i++) {
      const header = headers[i].toLowerCase().trim();
      let value = values[i].trim();

      // Handle boolean values
      if (header === 'enabled') {
        const valueLower = value.toLowerCase();
        if (valueLower === 'true' || value === '1') {
          value = true;
        } else if (valueLower === 'false' || value === '0') {
          value = false;
        } else if (value === '') {
          value = true; // Default to enabled
        } else {
          throw new Error(`Row ${rowNumber}: Invalid enabled value '${value}'. Must be true/false or 1/0`);
        }
      }

      // Map common header variations
      const mappedHeader = this.getHeaderMapping(header);
      console.log(`[CSV] Mapping header: "${header}" -> "${mappedHeader}"`);
      user[mappedHeader] = value;
    }

    // Set default username if not provided
    if (!user.username && user.email) {
      user.username = user.email;
    }
    return user;
  }

  /**
   * Validate user data for a specific row
   * @param {Object} user - User object to validate
   * @param {number} rowNumber - Row number for error reporting
   * @returns {Object} Validation result with isValid, errors, and warnings
   */
  validateUserData(user, rowNumber) {
    const errors = [];
    const warnings = [];

    // Check required fields
    if (!user.username || user.username.trim() === '') {
      errors.push('Username is required and cannot be empty');
    }

    // Check recommended fields
    if (!user.firstName || user.firstName.trim() === '') {
      warnings.push('firstName is recommended for better user data');
    }
    if (!user.lastName || user.lastName.trim() === '') {
      warnings.push('lastName is recommended for better user data');
    }
    if (!user.email || user.email.trim() === '') {
      warnings.push('email is recommended for better user data');
    }

    // Validate email format if provided
    if (user.email && user.email.trim() !== '' && !this.isValidEmail(user.email)) {
      errors.push('Invalid email format');
    }

    // Validate username format if provided
    if (user.username && !this.isValidUsername(user.username)) {
      errors.push('Username contains invalid characters (no spaces or special characters allowed)');
    }
    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }

  /**
   * Show validation summary to user
   * @param {Object} summary - Validation summary
   * @param {Array} errors - Array of errors
   * @param {Array} warnings - Array of warnings
   */
  showValidationSummary(summary, errors, warnings) {
    let message = '';
    let type = 'success';
    if (summary.invalidRows > 0) {
      type = 'error';
      message = `File validation failed!\n\n`;
      message += ` Total rows: ${summary.totalRows}\n`;
      message += ` Valid users: ${summary.validUsers}\n`;
      message += ` Invalid rows: ${summary.invalidRows}\n`;
      message += ` Warnings: ${warnings.length}\n\n`;
      if (summary.missingRequiredHeaders.length > 0) {
        message += ` Missing required headers: ${summary.missingRequiredHeaders.join(', ')}\n`;
      }
      if (errors.length > 0) {
        message += ` Data errors found in ${errors.length} row(s)\n`;
        // Show first few specific errors
        const firstErrors = errors.slice(0, 3);
        firstErrors.forEach(error => {
          if (error.errors) {
            message += `  Row ${error.row}: ${error.errors.join(', ')}\n`;
          } else if (error.error) {
            message += `  Row ${error.row}: ${error.error}\n`;
          }
        });
        if (errors.length > 3) {
          message += `  ... and ${errors.length - 3} more errors\n`;
        }
      }
    } else if (warnings.length > 0) {
      type = 'warning';
      message = `File loaded with warnings:\n\n`;
      message += ` Total rows: ${summary.totalRows}\n`;
      message += ` Valid users: ${summary.validUsers}\n`;
      message += ` Warnings: ${warnings.length}\n\n`;
      if (summary.missingRecommendedHeaders.length > 0) {
        message += ` Missing recommended headers: ${summary.missingRecommendedHeaders.join(', ')}\n`;
      }

      // Show first few warnings
      const firstWarnings = warnings.slice(0, 3);
      firstWarnings.forEach(warning => {
        message += `  Row ${warning.row}: ${warning.message || warning}\n`;
      });
      if (warnings.length > 3) {
        message += `  ... and ${warnings.length - 3} more warnings\n`;
      }
    } else {
      message = `File loaded successfully!\n\n`;
      message += ` Total rows: ${summary.totalRows}\n`;
      message += ` Valid users: ${summary.validUsers}\n`;
      message += ` Headers found: ${summary.availableHeaders.join(', ')}`;
    }

    // Show notification to user
    if (window.app && window.app.uiManager) {
      window.app.uiManager.showNotification(message, type);
    }

    // Log to server
    this.logger.info('CSV validation summary shown to user', {
      summary,
      message,
      type
    });
  }

  /**
   * Get header mapping for common variations
   * @param {string} header - Header to map
   * @returns {string} Mapped header name
   */
  getHeaderMapping(header) {
    const headerMap = {
      'firstname': 'firstName',
      'first_name': 'firstName',
      'givenname': 'firstName',
      'given_name': 'firstName',
      'lastname': 'lastName',
      'last_name': 'lastName',
      'familyname': 'lastName',
      'family_name': 'lastName',
      'surname': 'lastName',
      'emailaddress': 'email',
      'email_address': 'email',
      'userid': 'username',
      'user_id': 'username',
      'login': 'username',
      'user': 'username',
      'populationid': 'populationId',
      'population_id': 'populationId',
      'popid': 'populationId',
      'pop_id': 'populationId'
    };
    return headerMap[header] || header;
  }

  /**
   * Check if email is valid
   * @param {string} email - Email to validate
   * @returns {boolean} True if valid
   */
  isValidEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  /**
   * Check if username is valid
   * @param {string} username - Username to validate
   * @returns {boolean} True if valid
   */
  isValidUsername(username) {
    // Username should not contain spaces or special characters
    const usernameRegex = /^[a-zA-Z0-9._-]+$/;
    return usernameRegex.test(username);
  }

  // ======================
  // UI Updates
  // ======================

  /**
   * Update file info for any file info container element
   * @param {File} file - The file object
   * @param {string} containerId - The ID of the container element to update
   */
  updateFileInfoForElement(file, containerId) {
    let recordCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    const container = document.getElementById(containerId);
    console.log('updateFileInfoForElement called:', {
      containerId,
      container: !!container,
      file: !!file,
      recordCount
    });
    if (!container || !file) {
      console.warn('updateFileInfoForElement: container or file is null', {
        containerId,
        hasContainer: !!container,
        hasFile: !!file
      });
      return;
    }
    const fileSize = this.formatFileSize(file.size);
    const lastModified = new Date(file.lastModified).toLocaleString();
    const fileType = file.type || this.getFileExtension(file.name);
    const fileExtension = this.getFileExtension(file.name);

    // Get file path information (if available)
    let filePath = 'Unknown';
    if (file.webkitRelativePath) {
      filePath = file.webkitRelativePath;
    } else if (file.name) {
      // Try to extract directory from file name if it contains path separators
      const pathParts = file.name.split(/[\/\\]/);
      if (pathParts.length > 1) {
        filePath = pathParts.slice(0, -1).join('/');
      } else {
        filePath = 'Current Directory';
      }
    }

    // Calculate additional file properties
    const isCSV = fileExtension === 'csv';
    const isText = fileExtension === 'txt';
    const isValidType = isCSV || isText || fileType === 'text/csv' || fileType === 'text/plain';
    const fileSizeInKB = Math.round(file.size / 1024);
    const fileSizeInMB = Math.round(file.size / 1024 / 1024 * 100) / 100;

    // Determine record count display
    let recordCountHTML = '';
    if (isValidType && recordCount !== null) {
      if (typeof recordCount === 'number') {
        if (recordCount > 0) {
          recordCountHTML = `<div class="file-info-item" style="background: white; padding: 8px; border-radius: 4px; border: 1px solid #e9ecef;"><strong style="color: #495057; display: block; margin-bottom: 3px; font-size: 0.85rem;"> Records</strong><span style="color: #0073C8; font-size: 0.8rem; font-weight: bold;">${recordCount}</span></div>`;
        } else {
          recordCountHTML = `<div class="file-info-item" style="background: white; padding: 8px; border-radius: 4px; border: 1px solid #e9ecef;"><strong style="color: #495057; display: block; margin-bottom: 3px; font-size: 0.85rem;"> Records</strong><span style="color: #dc3545; font-size: 0.8rem; font-weight: bold;">No user records found</span></div>`;
        }
      }
    }

    // Create compact file info display with reduced footprint
    const fileInfoHTML = `
            <div class="file-info-details" style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 6px; padding: 12px; margin: 8px 0; box-shadow: 0 1px 4px rgba(0,0,0,0.08);">
                
                <!-- Compact File Name Section -->
                <div class="file-name-section" style="text-align: center; margin-bottom: 12px; padding: 8px; background: #e6f4ff; border-radius: 4px; color: #1a237e; font-weight: bold; font-size: 1.1rem;">
                    <div style="font-size: 1.3rem; font-weight: 600; margin-bottom: 3px; color: #1a237e; text-shadow: none; word-break: break-word; overflow-wrap: break-word;">
                        <i class="fas fa-file-csv" style="margin-right: 6px; font-size: 1.2rem; color: #1976d2;"></i>
                        ${file.name}
                    </div>
                    <div style="font-size: 0.85rem; opacity: 0.9; font-weight: 500; color: #1976d2;">
                        File Selected Successfully
                    </div>
                </div>
                
                <!-- Compact File Information Grid -->
                <div class="file-info-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 8px; font-size: 0.8em; margin-bottom: 10px;">
                    <div class="file-info-item" style="background: white; padding: 8px; border-radius: 4px; border: 1px solid #e9ecef;">
                        <strong style="color: #495057; display: block; margin-bottom: 3px; font-size: 0.85rem;"> File Size</strong>
                        <span style="color: #6c757d; font-size: 0.8rem;">${fileSize} (${fileSizeInKB} KB, ${fileSizeInMB} MB)</span>
                    </div>
                    
                    <div class="file-info-item" style="background: white; padding: 8px; border-radius: 4px; border: 1px solid #e9ecef;">
                        <strong style="color: #495057; display: block; margin-bottom: 3px; font-size: 0.85rem;"> Directory</strong>
                        <span style="color: #6c757d; word-break: break-all; font-size: 0.8rem;">${filePath}</span>
                    </div>
                    
                    <div class="file-info-item" style="background: white; padding: 8px; border-radius: 4px; border: 1px solid #e9ecef;">
                        <strong style="color: #495057; display: block; margin-bottom: 3px; font-size: 0.85rem;"> Last Modified</strong>
                        <span style="color: #6c757d; font-size: 0.8rem;">${lastModified}</span>
                    </div>
                    
                    <div class="file-info-item" style="background: white; padding: 8px; border-radius: 4px; border: 1px solid #e9ecef;">
                        <strong style="color: #495057; display: block; margin-bottom: 3px; font-size: 0.85rem;"> File Type</strong>
                        <span style="color: #6c757d; font-size: 0.8rem;">${fileType || 'Unknown'}</span>
                    </div>
                    
                    <div class="file-info-item" style="background: white; padding: 8px; border-radius: 4px; border: 1px solid #e9ecef;">
                        <strong style="color: #495057; display: block; margin-bottom: 3px; font-size: 0.85rem;"> Extension</strong>
                        <span style="color: ${isValidType ? '#28a745' : '#dc3545'}; font-weight: bold; font-size: 0.8rem;">
                            ${fileExtension ? '.' + fileExtension : 'None'}
                        </span>
                    </div>
                    ${recordCountHTML}
                </div>
                
                <!-- Compact File Status Section -->
                <div class="file-info-status" style="margin-top: 8px; padding: 8px; border-radius: 4px; background: ${isValidType ? '#d4edda' : '#f8d7da'}; border: 1px solid ${isValidType ? '#c3e6cb' : '#f5c6cb'}; display: flex; align-items: center; gap: 6px;">
                    <i class="fas ${isValidType ? 'fa-check-circle' : 'fa-exclamation-triangle'}" style="color: ${isValidType ? '#155724' : '#721c24'}; font-size: 1rem;"></i>
                    <span style="color: ${isValidType ? '#155724' : '#721c24'}; font-weight: bold; font-size: 0.85rem;">
                        ${isValidType ? ' File type is supported and ready for processing' : ' Warning: File type may not be optimal for import'}
                    </span>
                </div>
                
                ${file.size > 5 * 1024 * 1024 ? `
                <div class="file-info-warning" style="margin-top: 8px; padding: 8px; border-radius: 4px; background: #fff3cd; border: 1px solid #ffeaa7; display: flex; align-items: center; gap: 6px;">
                    <i class="fas fa-exclamation-triangle" style="color: #856404; font-size: 1rem;"></i>
                    <span style="color: #856404; font-weight: bold; font-size: 0.85rem;">Large file detected - processing may take longer than usual</span>
                </div>
                ` : ''}
                
                <!-- Responsive Design -->
                <style>
                    @media (max-width: 768px) {
                        .file-info-details .file-name-section div:first-child {
                            font-size: 1.1rem !important;
                        }
                        .file-info-grid {
                            grid-template-columns: 1fr !important;
                            gap: 6px !important;
                        }
                        .file-info-item {
                            padding: 6px !important;
                        }
                    }
                    @media (max-width: 480px) {
                        .file-info-details .file-name-section div:first-child {
                            font-size: 0.95rem !important;
                        }
                        .file-info-details {
                            padding: 8px !important;
                        }
                    }
                </style>
            </div>
        `;
    container.innerHTML = fileInfoHTML;
  }
  updateFileInfo(file) {
    let recordCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    this.updateFileInfoForElement(file, 'file-info', recordCount);
  }
  showPreview(rows) {
    if (!this.previewContainer) return;
    if (!rows || rows.length === 0) {
      this.previewContainer.innerHTML = '<div class="alert alert-info">No data to display</div>';
      // Disable import button if no rows
      const importBtnBottom = _elementRegistry.ElementRegistry.startImportBtnBottom ? _elementRegistry.ElementRegistry.startImportBtnBottom() : null;
      if (importBtnBottom) {
        importBtnBottom.disabled = true;
      }
      return;
    }
    const headers = Object.keys(rows[0]);
    const previewRows = rows.slice(0, 5); // Show first 5 rows

    let html = `
            <div class="table-responsive">
                <table class="table table-sm table-striped">
                    <thead>
                        <tr>
                            ${headers.map(h => `<th>${h}</th>`).join('')}
                        </tr>
                    </thead>
                    <tbody>
                        ${previewRows.map(row => `
                            <tr>
                                ${headers.map(h => `<td>${row[h] || ''}</td>`).join('')}
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
                ${rows.length > 5 ? `<small class="text-muted">Showing 5 of ${rows.length} rows</small>` : ''}
            </div>
        `;
    this.previewContainer.innerHTML = html;

    // Check if population choice has been made
    const hasPopulationChoice = this.checkPopulationChoice();

    // Enable import button after showing preview (only if population choice is made)
    const importBtnBottom = _elementRegistry.ElementRegistry.startImportBtnBottom ? _elementRegistry.ElementRegistry.startImportBtnBottom() : null;
    if (importBtnBottom) {
      importBtnBottom.disabled = !hasPopulationChoice;
      this.logger.log(`Import button ${hasPopulationChoice ? 'enabled' : 'disabled'}`, 'debug');
    } else {
      this.logger.warn('Could not find import button to enable', 'warn');
    }
  }

  /**
   * Check if user has made a population choice
   * @returns {boolean} True if a population choice has been made
   */
  checkPopulationChoice() {
    const selectedPopulationId = _elementRegistry.ElementRegistry.importPopulationSelect ? _elementRegistry.ElementRegistry.importPopulationSelect().value || '' : '';
    const useDefaultPopulation = _elementRegistry.ElementRegistry.useDefaultPopulationCheckbox ? _elementRegistry.ElementRegistry.useDefaultPopulationCheckbox().checked || false : false;
    const useCsvPopulationId = _elementRegistry.ElementRegistry.useCsvPopulationIdCheckbox ? _elementRegistry.ElementRegistry.useCsvPopulationIdCheckbox().checked || false : false;
    const hasSelectedPopulation = selectedPopulationId && selectedPopulationId.trim() !== '';
    return hasSelectedPopulation || useDefaultPopulation || useCsvPopulationId;
  }

  // ======================
  // Utility Methods
  // ======================

  getFileExtension(filename) {
    if (!filename || typeof filename !== 'string') return '';

    // Handle cases where filename might be a path
    const lastDot = filename.lastIndexOf('.');
    const lastSlash = Math.max(filename.lastIndexOf('/'), filename.lastIndexOf('\\'));

    // If there's no dot, or the dot is before the last slash, return empty string
    if (lastDot === -1 || lastSlash > lastDot) return '';

    // Extract and return the extension (without the dot)
    return filename.slice(lastDot + 1).toLowerCase().trim();
  }
  formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }
  generateTemporaryPassword() {
    const length = 16;
    const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+~`|}{[]\\:;?><,./-';
    let password = '';

    // Ensure at least one of each character type
    password += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'[Math.floor(Math.random() * 26)];
    password += 'abcdefghijklmnopqrstuvwxyz'[Math.floor(Math.random() * 26)];
    password += '0123456789'[Math.floor(Math.random() * 10)];
    password += '!@#$%^&*'[Math.floor(Math.random() * 8)];

    // Fill the rest of the password
    for (let i = password.length; i < length; i++) {
      password += charset[Math.floor(Math.random() * charset.length)];
    }

    // Shuffle the password
    return password.split('').sort(() => Math.random() - 0.5).join('');
  }

  /**
   * Get parsed users for import
   * @returns {Array<Object>} Array of validated user objects
   */
  getParsedUsers() {
    this.logger.info('getParsedUsers called', {
      hasParsedUsers: !!this.parsedUsers,
      parsedUsersType: typeof this.parsedUsers,
      parsedUsersLength: this.parsedUsers ? this.parsedUsers.length : 0,
      hasLastParsedUsers: !!this.lastParsedUsers,
      lastParsedUsersType: typeof this.lastParsedUsers,
      lastParsedUsersLength: this.lastParsedUsers ? this.lastParsedUsers.length : 0
    });
    if (!this.parsedUsers || !Array.isArray(this.parsedUsers)) {
      this.logger.warn('No parsed users available');

      // Show user-friendly notification
      if (this.uiManager && this.uiManager.showNotification) {
        this.uiManager.showNotification('No CSV file has been uploaded yet. Please upload a CSV file first.', 'info');
      }
      return [];
    }
    this.logger.info('Retrieving parsed users for import', {
      userCount: this.parsedUsers.length,
      hasUsers: this.parsedUsers.length > 0
    });
    return this.parsedUsers;
  }

  /**
   * Get parsing results for debugging
   * @returns {Object|null} Parsing results or null if not available
   */
  getParseResults() {
    return this.parseResults || null;
  }

  /**
   * Initialize drag-and-drop support for a drop zone element
   * @param {HTMLElement} dropZone - The drop zone element
   */
  initializeDropZone(dropZone) {
    if (!dropZone) return;

    // Remove any previous listeners
    dropZone.removeEventListener('dragenter', this._onDragEnter);
    dropZone.removeEventListener('dragover', this._onDragOver);
    dropZone.removeEventListener('dragleave', this._onDragLeave);
    dropZone.removeEventListener('drop', this._onDrop);

    // Bind event handlers to this instance
    this._onDragEnter = e => {
      e.preventDefault();
      e.stopPropagation();
      dropZone.classList.add('drag-over');
    };
    this._onDragOver = e => {
      e.preventDefault();
      e.stopPropagation();
      dropZone.classList.add('drag-over');
    };
    this._onDragLeave = e => {
      e.preventDefault();
      e.stopPropagation();
      dropZone.classList.remove('drag-over');
    };
    this._onDrop = async e => {
      e.preventDefault();
      e.stopPropagation();
      dropZone.classList.remove('drag-over');
      const files = e.dataTransfer.files;
      if (files && files.length > 0) {
        try {
          await this.setFile(files[0]);
        } catch (error) {
          this.logger.error('Drag-and-drop file error', {
            error: error.message
          });
          this.uiManager.showNotification('Failed to process dropped file: ' + error.message, 'error');
        }
      }
    };

    // Attach listeners
    dropZone.addEventListener('dragenter', this._onDragEnter);
    dropZone.addEventListener('dragover', this._onDragOver);
    dropZone.addEventListener('dragleave', this._onDragLeave);
    dropZone.addEventListener('drop', this._onDrop);
  }

  /**
   * Initialize global drag-and-drop prevention and routing
   * This prevents the browser from trying to open files and routes them to the app
   */
  initializeGlobalDragAndDrop() {
    // Prevent browser default behavior for file drops anywhere on the page
    const preventDefaultDragEvents = e => {
      e.preventDefault();
      e.stopPropagation();
    };

    // Handle file drops anywhere on the document
    const handleGlobalDrop = async e => {
      e.preventDefault();
      e.stopPropagation();

      // Remove body drag-over class
      document.body.classList.remove('drag-over');
      const files = e.dataTransfer.files;
      if (files && files.length > 0) {
        const file = files[0];

        // Check if it's a supported file type
        const fileName = file.name || '';
        const fileExt = this.getFileExtension(fileName).toLowerCase();
        const supportedExts = ['csv', 'txt'];
        const knownBadExts = ['exe', 'js', 'png', 'jpg', 'jpeg', 'gif', 'pdf', 'zip', 'tar', 'gz'];
        if (fileExt && knownBadExts.includes(fileExt)) {
          this.uiManager.showNotification(`Unsupported file type: ${fileExt}. Please upload a CSV or text file.`, 'error');
          return;
        }

        // Route to appropriate handler based on current view
        const currentView = this.getCurrentView();
        let targetDropZone = null;
        switch (currentView) {
          case 'import':
            targetDropZone = document.getElementById('import-drop-zone');
            break;
          case 'modify':
            targetDropZone = document.getElementById('modify-drop-zone');
            break;
          case 'import-dashboard':
            targetDropZone = document.getElementById('upload-zone');
            break;
          default:
            // Default to import view if no specific view is active
            targetDropZone = document.getElementById('import-drop-zone');
            break;
        }

        // Show visual feedback on the target drop zone
        if (targetDropZone) {
          targetDropZone.classList.add('drag-over');
          setTimeout(() => {
            targetDropZone.classList.remove('drag-over');
          }, 2000);
        }
        try {
          await this.setFile(file);
          this.uiManager.showNotification(`File "${file.name}" processed successfully`, 'success');
        } catch (error) {
          this.logger.error('Global drag-and-drop file error', {
            error: error.message
          });
          this.uiManager.showNotification('Failed to process dropped file: ' + error.message, 'error');
        }
      }
    };

    // Add visual feedback when dragging files over the document
    const handleGlobalDragEnter = e => {
      e.preventDefault();
      e.stopPropagation();

      // Only add visual feedback if dragging files
      if (e.dataTransfer.types.includes('Files')) {
        document.body.classList.add('drag-over');
      }
    };
    const handleGlobalDragLeave = e => {
      e.preventDefault();
      e.stopPropagation();

      // Only remove visual feedback if leaving the document entirely
      if (e.target === document || e.target === document.body) {
        document.body.classList.remove('drag-over');
      }
    };

    // Add global event listeners
    document.addEventListener('dragover', preventDefaultDragEvents);
    document.addEventListener('dragenter', handleGlobalDragEnter);
    document.addEventListener('dragleave', handleGlobalDragLeave);
    document.addEventListener('drop', handleGlobalDrop);

    // Store references for cleanup
    this._globalDragHandlers = {
      preventDefaultDragEvents,
      handleGlobalDragEnter,
      handleGlobalDragLeave,
      handleGlobalDrop
    };
    this.logger.info('Global drag-and-drop prevention initialized');
  }

  /**
   * Clean up global drag-and-drop event listeners
   */
  cleanupGlobalDragAndDrop() {
    if (this._globalDragHandlers) {
      document.removeEventListener('dragover', this._globalDragHandlers.preventDefaultDragEvents);
      document.removeEventListener('dragenter', this._globalDragHandlers.handleGlobalDragEnter);
      document.removeEventListener('dragleave', this._globalDragHandlers.handleGlobalDragLeave);
      document.removeEventListener('drop', this._globalDragHandlers.handleGlobalDrop);
      this._globalDragHandlers = null;
    }

    // Remove any remaining visual feedback
    document.body.classList.remove('drag-over');
  }

  /**
   * Get the current active view
   * @returns {string} The current view name
   */
  getCurrentView() {
    const activeView = document.querySelector('.view[style*="block"]') || document.querySelector('.view:not([style*="none"])');
    if (!activeView) return 'import';
    const viewId = activeView.id;
    if (viewId === 'import-dashboard-view') return 'import-dashboard';
    if (viewId === 'modify-csv-view') return 'modify';
    if (viewId === 'delete-csv-view') return 'delete';
    if (viewId === 'export-view') return 'export';
    if (viewId === 'settings-view') return 'settings';
    if (viewId === 'logs-view') return 'logs';
    return 'import'; // Default to import view
  }
}
exports.FileHandler = FileHandler;

},{"./element-registry.js":47}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FileLogger = void 0;
/**
 * FileLogger - Handles writing logs to a client.log file using the File System Access API
 */
class FileLogger {
  /**
   * Create a new FileLogger instance
   * @param {string} filename - Name of the log file (default: 'client.log')
   */
  constructor() {
    let filename = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'client.log';
    this.filename = filename;
    this.fileHandle = null;
    this.writableStream = null;
    this.initialized = false;
    this.logQueue = [];
    this.initializationPromise = null;
  }

  /**
   * Initialize the file logger
   * @private
   */
  async _initialize() {
    if (this.initialized) return true;
    if (this.initializationPromise) {
      return this.initializationPromise;
    }
    this.initializationPromise = (async () => {
      try {
        // Check if we're in a secure context and the API is available
        if (!window.isSecureContext || !window.showSaveFilePicker) {
          throw new Error('File System Access API not available in this context');
        }

        // Only proceed if we're handling a user gesture
        if (!window.__fileLoggerUserGesture) {
          // Set up event listeners
          window.addEventListener('online', () => this.handleOnline());
          window.addEventListener('offline', () => this.handleOffline());

          // Set up user gesture detection for file logger
          const handleUserGesture = () => {
            window.__fileLoggerUserGesture = true;
            window.removeEventListener('click', handleUserGesture);
            window.removeEventListener('keydown', handleUserGesture);

            // Try to initialize the file logger if it hasn't been initialized yet
            if (this.fileLogger && !this.fileLogger._initialized && this.fileLogger._logger === null) {
              this.fileLogger._ensureInitialized().catch(console.warn);
            }
          };
          window.addEventListener('click', handleUserGesture, {
            once: true,
            passive: true
          });
          window.addEventListener('keydown', handleUserGesture, {
            once: true,
            passive: true
          });
          throw new Error('Waiting for user gesture to initialize file logger');
        }
        try {
          this.fileHandle = await window.showSaveFilePicker({
            suggestedName: this.filename,
            types: [{
              description: 'Log File',
              accept: {
                'text/plain': ['.log']
              }
            }],
            excludeAcceptAllOption: true
          });
          this.writableStream = await this.fileHandle.createWritable({
            keepExistingData: true
          });
          this.initialized = true;
          await this._processQueue();
          return true;
        } catch (error) {
          console.warn('File System Access API not available:', error);
          this.initialized = false;
          return false;
        }
      } catch (error) {
        console.warn('File logger initialization deferred:', error.message);
        this.initialized = false;
        return false;
      }
    })();
    return this.initializationPromise;
  }

  /**
   * Process any queued log messages
   * @private
   */
  async _processQueue() {
    if (this.logQueue.length === 0) return;
    const queue = [...this.logQueue];
    this.logQueue = [];
    for (const {
      level,
      message,
      timestamp
    } of queue) {
      await this._writeLog(level, message, timestamp);
    }
  }

  /**
   * Write a log message to the file
   * @private
   */
  async _writeLog(level, message, timestamp) {
    if (!this.initialized) {
      await this._initialize();
    }
    const logEntry = `[${timestamp}] [${level.toUpperCase()}] ${message}\n`;
    if (this.writableStream) {
      try {
        await this.writableStream.write(logEntry);
      } catch (error) {
        console.error('Error writing to log file:', error);
        this.initialized = false;
        await this._initialize();
        await this.writableStream.write(logEntry);
      }
    } else {
      console[level](`[FileLogger] ${logEntry}`);
    }
  }

  /**
   * Log a message
   * @param {string} level - Log level (info, warn, error, debug)
   * @param {string} message - The message to log
   */
  async log(level, message) {
    const timestamp = new Date().toISOString();
    if (!this.initialized) {
      this.logQueue.push({
        level,
        message,
        timestamp
      });
      await this._initialize();
    } else {
      await this._writeLog(level, message, timestamp);
    }
  }

  /**
   * Log an info message
   * @param {string} message - The message to log
   */
  info(message) {
    return this.log('info', message);
  }

  /**
   * Log a warning message
   * @param {string} message - The message to log
   */
  warn(message) {
    return this.log('warn', message);
  }

  /**
   * Log an error message
   * @param {string} message - The message to log
   */
  error(message) {
    return this.log('error', message);
  }

  /**
   * Log a debug message
   * @param {string} message - The message to log
   */
  debug(message) {
    return this.log('debug', message);
  }

  /**
   * Close the log file
   */
  async close() {
    if (this.writableStream) {
      try {
        await this.writableStream.close();
      } catch (error) {
        console.error('Error closing log file:', error);
      } finally {
        this.initialized = false;
        this.writableStream = null;
        this.fileHandle = null;
      }
    }
  }
}
exports.FileLogger = FileLogger;

},{}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.HistorySubsystem = void 0;
/**
 * History Subsystem
 * Centralized history management system that replaces legacy HistoryManager
 * Provides operation history tracking, filtering, and event integration
 */

class HistorySubsystem {
  constructor(eventBus, settingsSubsystem, loggingSubsystem) {
    this.eventBus = eventBus;
    this.settingsSubsystem = settingsSubsystem;
    this.loggingSubsystem = loggingSubsystem;

    // History storage
    this.history = [];
    this.maxHistorySize = 500;

    // History categories
    this.categories = {
      IMPORT: 'import',
      EXPORT: 'export',
      DELETE: 'delete',
      MODIFY: 'modify',
      SETTINGS: 'settings',
      AUTH: 'auth',
      SYSTEM: 'system'
    };

    // History status types
    this.statusTypes = {
      STARTED: 'started',
      IN_PROGRESS: 'in_progress',
      COMPLETED: 'completed',
      FAILED: 'failed',
      CANCELLED: 'cancelled',
      PARTIAL: 'partial'
    };

    // Current filter settings
    this.currentFilter = {
      category: null,
      status: null,
      dateRange: null,
      search: null
    };

    // Initialize subsystem
    this.init();
    if (this.loggingSubsystem) {
      this.loggingSubsystem.info('HistorySubsystem initialized successfully', {}, 'system');
    }
  }

  /**
   * Initialize the history subsystem
   */
  async init() {
    try {
      // Load history settings
      await this.loadSettings();

      // Set up event listeners
      this.setupEventListeners();

      // Load existing history from storage
      await this.loadHistoryFromStorage();
      if (this.loggingSubsystem) {
        this.loggingSubsystem.info('HistorySubsystem initialization complete', {
          historyCount: this.history.length
        }, 'system');
      }
    } catch (error) {
      if (this.loggingSubsystem) {
        this.loggingSubsystem.error('Failed to initialize HistorySubsystem', error, 'system');
      }
      throw error;
    }
  }

  /**
   * Load history settings from SettingsSubsystem
   */
  async loadSettings() {
    try {
      if (this.settingsSubsystem) {
        // Access the current settings from the SettingsSubsystem
        // The SettingsSubsystem stores settings in currentSettings property
        const settings = this.settingsSubsystem.currentSettings;

        // Set max history size from settings
        if (settings && settings.maxHistorySize) {
          this.maxHistorySize = settings.maxHistorySize;
        }
      }
    } catch (error) {
      if (this.loggingSubsystem) {
        this.loggingSubsystem.warn('Could not load history settings, using defaults', error, 'system');
      }
    }
  }

  /**
   * Set up event listeners for cross-subsystem communication
   */
  setupEventListeners() {
    if (this.eventBus) {
      // Listen for operation events to automatically track history
      this.eventBus.on('importStarted', data => {
        this.addHistoryEntry('import', 'Import operation started', 'started', data);
      });
      this.eventBus.on('importCompleted', data => {
        this.updateHistoryEntry(data.sessionId, 'completed', 'Import operation completed', data);
      });
      this.eventBus.on('importFailed', data => {
        this.updateHistoryEntry(data.sessionId, 'failed', 'Import operation failed', data);
      });
      this.eventBus.on('exportStarted', data => {
        this.addHistoryEntry('export', 'Export operation started', 'started', data);
      });
      this.eventBus.on('exportCompleted', data => {
        this.updateHistoryEntry(data.sessionId, 'completed', 'Export operation completed', data);
      });
      this.eventBus.on('exportFailed', data => {
        this.updateHistoryEntry(data.sessionId, 'failed', 'Export operation failed', data);
      });
      this.eventBus.on('deleteOperationStarted', data => {
        this.addHistoryEntry('delete', 'Delete operation started', 'started', data);
      });
      this.eventBus.on('deleteOperationCompleted', data => {
        this.updateHistoryEntry(data.sessionId, 'completed', 'Delete operation completed', data);
      });
      this.eventBus.on('deleteOperationFailed', data => {
        this.updateHistoryEntry(data.sessionId, 'failed', 'Delete operation failed', data);
      });
      this.eventBus.on('modifyOperationStarted', data => {
        this.addHistoryEntry('modify', 'Modify operation started', 'started', data);
      });
      this.eventBus.on('modifyOperationCompleted', data => {
        this.updateHistoryEntry(data.sessionId, 'completed', 'Modify operation completed', data);
      });
      this.eventBus.on('modifyOperationFailed', data => {
        this.updateHistoryEntry(data.sessionId, 'failed', 'Modify operation failed', data);
      });

      // Listen for history management events
      this.eventBus.on('clearHistory', () => {
        this.clearHistory();
      });
      this.eventBus.on('exportHistory', data => {
        this.exportHistory(data.options);
      });
      this.eventBus.on('filterHistory', data => {
        this.setFilter(data.filter);
      });
    }
  }

  /**
   * Add a new history entry
   */
  addHistoryEntry(category, description, status) {
    let data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    const entry = {
      id: this.generateHistoryId(),
      timestamp: new Date().toISOString(),
      category,
      description,
      status,
      data: this.sanitizeHistoryData(data),
      sessionId: data.sessionId || this.generateSessionId(),
      duration: null,
      startTime: new Date().toISOString()
    };

    // Add to beginning of history array
    this.history.unshift(entry);

    // Maintain history size limit
    if (this.history.length > this.maxHistorySize) {
      this.history = this.history.slice(0, this.maxHistorySize);
    }

    // Save to storage
    this.saveHistoryToStorage();

    // Log the history entry
    if (this.loggingSubsystem) {
      this.loggingSubsystem.info('History entry added', {
        category,
        description,
        status,
        sessionId: entry.sessionId
      }, 'system');
    }

    // Emit event for UI updates
    if (this.eventBus) {
      this.eventBus.emit('historyEntryAdded', entry);
    }
    return entry.id;
  }

  /**
   * Update an existing history entry
   */
  updateHistoryEntry(sessionId, status) {
    let description = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    let data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    const entry = this.history.find(h => h.sessionId === sessionId);
    if (entry) {
      entry.status = status;
      entry.timestamp = new Date().toISOString();
      if (description) {
        entry.description = description;
      }

      // Calculate duration if operation is complete
      if (['completed', 'failed', 'cancelled'].includes(status) && entry.startTime) {
        entry.duration = new Date() - new Date(entry.startTime);
      }

      // Merge additional data
      if (data && Object.keys(data).length > 0) {
        entry.data = {
          ...entry.data,
          ...this.sanitizeHistoryData(data)
        };
      }

      // Save to storage
      this.saveHistoryToStorage();

      // Log the update
      if (this.loggingSubsystem) {
        this.loggingSubsystem.info('History entry updated', {
          sessionId,
          status,
          description,
          duration: entry.duration
        }, 'system');
      }

      // Emit event for UI updates
      if (this.eventBus) {
        this.eventBus.emit('historyEntryUpdated', entry);
      }
      return true;
    }
    if (this.loggingSubsystem) {
      this.loggingSubsystem.warn('History entry not found for update', {
        sessionId
      }, 'system');
    }
    return false;
  }

  /**
   * Get filtered history entries
   */
  async getHistory() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    try {
      const {
        limit = 50,
        offset = 0,
        category = null,
        status = null,
        search = null,
        startDate = null,
        endDate = null,
        sortBy = 'timestamp',
        sortOrder = 'desc'
      } = options;
      let filteredHistory = [...this.history];

      // Apply filters
      if (category) {
        filteredHistory = filteredHistory.filter(entry => entry.category === category);
      }
      if (status) {
        filteredHistory = filteredHistory.filter(entry => entry.status === status);
      }
      if (search) {
        const searchLower = search.toLowerCase();
        filteredHistory = filteredHistory.filter(entry => entry.description.toLowerCase().includes(searchLower) || JSON.stringify(entry.data).toLowerCase().includes(searchLower));
      }
      if (startDate) {
        filteredHistory = filteredHistory.filter(entry => new Date(entry.timestamp) >= new Date(startDate));
      }
      if (endDate) {
        filteredHistory = filteredHistory.filter(entry => new Date(entry.timestamp) <= new Date(endDate));
      }

      // Apply sorting
      filteredHistory.sort((a, b) => {
        const aValue = a[sortBy];
        const bValue = b[sortBy];
        if (sortOrder === 'asc') {
          return aValue < bValue ? -1 : aValue > bValue ? 1 : 0;
        } else {
          return aValue > bValue ? -1 : aValue < bValue ? 1 : 0;
        }
      });

      // Apply pagination
      const paginatedHistory = filteredHistory.slice(offset, offset + limit);
      const result = {
        history: paginatedHistory,
        total: filteredHistory.length,
        hasMore: offset + limit < filteredHistory.length,
        stats: this.getHistoryStats(filteredHistory)
      };
      if (this.loggingSubsystem) {
        this.loggingSubsystem.debug('History retrieved', {
          requested: limit,
          returned: paginatedHistory.length,
          total: result.total,
          filters: {
            category,
            status,
            search
          }
        }, 'system');
      }
      return result;
    } catch (error) {
      if (this.loggingSubsystem) {
        this.loggingSubsystem.error('Failed to get history', error, 'system');
      }
      throw error;
    }
  }

  /**
   * Get history statistics
   */
  getHistoryStats() {
    let historyData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    const data = historyData || this.history;
    const stats = {
      total: data.length,
      categories: {},
      statuses: {},
      recentActivity: data.slice(0, 5),
      averageDuration: 0,
      totalDuration: 0
    };
    let durationCount = 0;
    let totalDuration = 0;
    data.forEach(entry => {
      // Count by category
      stats.categories[entry.category] = (stats.categories[entry.category] || 0) + 1;

      // Count by status
      stats.statuses[entry.status] = (stats.statuses[entry.status] || 0) + 1;

      // Calculate duration stats
      if (entry.duration) {
        totalDuration += entry.duration;
        durationCount++;
      }
    });
    if (durationCount > 0) {
      stats.averageDuration = totalDuration / durationCount;
      stats.totalDuration = totalDuration;
    }
    return stats;
  }

  /**
   * Set history filter
   */
  setFilter(filter) {
    this.currentFilter = {
      ...this.currentFilter,
      ...filter
    };
    if (this.loggingSubsystem) {
      this.loggingSubsystem.debug('History filter updated', this.currentFilter, 'system');
    }

    // Emit event for UI updates
    if (this.eventBus) {
      this.eventBus.emit('historyFilterChanged', this.currentFilter);
    }
  }

  /**
   * Clear all history
   */
  clearHistory() {
    const previousCount = this.history.length;
    this.history = [];

    // Clear from storage
    this.saveHistoryToStorage();
    if (this.loggingSubsystem) {
      this.loggingSubsystem.info('History cleared', {
        previousCount
      }, 'system');
    }

    // Emit event for UI updates
    if (this.eventBus) {
      this.eventBus.emit('historyCleared', {
        previousCount
      });
    }
  }

  /**
   * Export history to file
   */
  async exportHistory() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    try {
      const {
        format = 'json',
        filename = `history_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}`,
        includeData = true
      } = options;
      const historyData = await this.getHistory({
        limit: this.maxHistorySize
      });
      let content;
      let mimeType;
      let extension;

      // Prepare export data
      const exportData = historyData.history.map(entry => ({
        id: entry.id,
        timestamp: entry.timestamp,
        category: entry.category,
        description: entry.description,
        status: entry.status,
        duration: entry.duration,
        ...(includeData && {
          data: entry.data
        })
      }));
      switch (format.toLowerCase()) {
        case 'csv':
          content = this.convertHistoryToCSV(exportData);
          mimeType = 'text/csv';
          extension = 'csv';
          break;
        case 'txt':
          content = this.convertHistoryToText(exportData);
          mimeType = 'text/plain';
          extension = 'txt';
          break;
        case 'json':
        default:
          content = JSON.stringify({
            exportDate: new Date().toISOString(),
            stats: historyData.stats,
            history: exportData
          }, null, 2);
          mimeType = 'application/json';
          extension = 'json';
          break;
      }

      // Create and download file
      const blob = new Blob([content], {
        type: mimeType
      });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `${filename}.${extension}`;
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      if (this.loggingSubsystem) {
        this.loggingSubsystem.info('History exported successfully', {
          format,
          filename: `${filename}.${extension}`,
          entryCount: exportData.length
        }, 'system');
      }
    } catch (error) {
      if (this.loggingSubsystem) {
        this.loggingSubsystem.error('Failed to export history', error, 'system');
      }
      throw error;
    }
  }

  /**
   * Convert history to CSV format
   */
  convertHistoryToCSV(history) {
    const headers = ['ID', 'Timestamp', 'Category', 'Description', 'Status', 'Duration'];
    const csvRows = [headers.join(',')];
    history.forEach(entry => {
      const row = [entry.id, entry.timestamp, entry.category, `"${entry.description.replace(/"/g, '""')}"`, entry.status, entry.duration || ''];
      csvRows.push(row.join(','));
    });
    return csvRows.join('\n');
  }

  /**
   * Convert history to text format
   */
  convertHistoryToText(history) {
    return history.map(entry => {
      const duration = entry.duration ? ` (${Math.round(entry.duration / 1000)}s)` : '';
      return `[${entry.timestamp}] ${entry.category.toUpperCase()} [${entry.status.toUpperCase()}] ${entry.description}${duration}`;
    }).join('\n');
  }

  /**
   * Load history from local storage
   */
  async loadHistoryFromStorage() {
    try {
      const stored = localStorage.getItem('pingone-import-history');
      if (stored) {
        const parsedHistory = JSON.parse(stored);
        if (Array.isArray(parsedHistory)) {
          this.history = parsedHistory;
          if (this.loggingSubsystem) {
            this.loggingSubsystem.info('History loaded from storage', {
              entryCount: this.history.length
            }, 'system');
          }
        }
      }
    } catch (error) {
      if (this.loggingSubsystem) {
        this.loggingSubsystem.warn('Failed to load history from storage', error, 'system');
      }
    }
  }

  /**
   * Save history to local storage
   */
  saveHistoryToStorage() {
    try {
      localStorage.setItem('pingone-import-history', JSON.stringify(this.history));
    } catch (error) {
      if (this.loggingSubsystem) {
        this.loggingSubsystem.warn('Failed to save history to storage', error, 'system');
      }
    }
  }

  /**
   * Sanitize history data to prevent circular references and sensitive data
   */
  sanitizeHistoryData(data) {
    if (!data || typeof data !== 'object') {
      return data;
    }
    try {
      return JSON.parse(JSON.stringify(data, (key, value) => {
        // Remove sensitive fields
        const sensitiveFields = ['password', 'token', 'secret', 'key', 'apiKey', 'clientSecret'];
        if (sensitiveFields.some(field => key.toLowerCase().includes(field))) {
          return '[REDACTED]';
        }

        // Handle circular references and complex objects
        if (typeof value === 'object' && value !== null) {
          if (value.constructor && value.constructor.name === 'HTMLElement') {
            return '[HTMLElement]';
          }
          if (value instanceof Error) {
            return {
              name: value.name,
              message: value.message
            };
          }
        }
        return value;
      }));
    } catch (error) {
      return {
        error: 'Failed to sanitize history data',
        original: String(data)
      };
    }
  }

  /**
   * Generate unique history ID
   */
  generateHistoryId() {
    return `hist_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Generate session ID for operation tracking
   */
  generateSessionId() {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Get a specific history entry by ID
   */
  getHistoryEntry(id) {
    return this.history.find(entry => entry.id === id);
  }

  /**
   * Delete a specific history entry
   */
  deleteHistoryEntry(id) {
    const index = this.history.findIndex(entry => entry.id === id);
    if (index !== -1) {
      const deleted = this.history.splice(index, 1)[0];
      this.saveHistoryToStorage();
      if (this.loggingSubsystem) {
        this.loggingSubsystem.info('History entry deleted', {
          id,
          description: deleted.description
        }, 'system');
      }

      // Emit event for UI updates
      if (this.eventBus) {
        this.eventBus.emit('historyEntryDeleted', {
          id,
          entry: deleted
        });
      }
      return true;
    }
    return false;
  }
}

// Export for use in other modules
exports.HistorySubsystem = HistorySubsystem;
var _default = exports.default = HistorySubsystem;

},{}],53:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.localAPIClient = exports.LocalAPIClient = void 0;
/**
 * Local API Client
 * Handles all API calls to the local server (localhost:4000)
 */

class LocalAPIClient {
  /**
   * Create a new LocalAPIClient instance
   * @param {Object} logger - Logger instance
   * @param {string} [baseUrl=''] - Base URL for the API (defaults to relative path)
   */
  constructor(logger) {
    let baseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    this.logger = logger || console;
    this.baseUrl = baseUrl;
    this.serverHealth = {
      lastCheck: 0,
      isHealthy: true,
      consecutiveFailures: 0,
      maxConsecutiveFailures: 3
    };
    this.healthCheckInterval = 30000; // 30 seconds
  }

  /**
   * Check server health before making requests
   * @private
   */
  async _checkServerHealth() {
    const now = Date.now();

    // Only check health if enough time has passed since last check
    if (now - this.serverHealth.lastCheck < this.healthCheckInterval) {
      return this.serverHealth.isHealthy;
    }
    try {
      const response = await fetch(`${this.baseUrl}/api/health`, {
        method: 'GET',
        headers: {
          'Accept': 'application/json'
        },
        signal: AbortSignal.timeout(5000) // 5 second timeout
      });
      if (response.ok) {
        this.serverHealth.isHealthy = true;
        this.serverHealth.consecutiveFailures = 0;
        this.logger.debug(' Server health check passed');
      } else {
        this.serverHealth.isHealthy = false;
        this.serverHealth.consecutiveFailures++;
        this.logger.warn(' Server health check failed', {
          status: response.status
        });
      }
    } catch (error) {
      this.serverHealth.isHealthy = false;
      this.serverHealth.consecutiveFailures++;
      this.logger.warn(' Server health check error', {
        error: error.message
      });
    }
    this.serverHealth.lastCheck = now;
    return this.serverHealth.isHealthy;
  }

  /**
   * Calculate exponential backoff delay
   * @private
   */
  _calculateBackoffDelay(attempt, baseDelay, maxDelay) {
    const exponentialDelay = baseDelay * Math.pow(2, attempt - 1);
    const jitter = Math.random() * 0.1 * exponentialDelay; // Add 10% jitter
    return Math.min(exponentialDelay + jitter, maxDelay);
  }

  /**
   * Determine if a request should be retried based on error type
   * @private
   */
  _shouldRetry(error, attempt, maxRetries) {
    // Don't retry if we've reached max attempts
    if (attempt >= maxRetries) {
      return false;
    }

    // Retry on network errors (no status code)
    if (!error.status) {
      return true;
    }

    // Retry on server errors (5xx)
    if (error.status >= 500) {
      return true;
    }

    // Retry on rate limits (429)
    if (error.status === 429) {
      return true;
    }

    // Retry on timeout errors (408)
    if (error.status === 408) {
      return true;
    }

    // Don't retry on client errors (4xx except 429, 408)
    return false;
  }

  /**
   * Make an API request to the local server with enhanced retry logic
   * @param {string} method - HTTP method (GET, POST, PUT, DELETE, etc.)
   * @param {string} endpoint - API endpoint (without base URL)
   * @param {Object} [data] - Request body (for POST/PUT/PATCH)
   * @param {Object} [options] - Additional options
   * @returns {Promise<Object>} Response data
   */
  async request(method, endpoint) {
    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    const url = `${this.baseUrl}${endpoint}`;
    const startTime = Date.now();

    // Enhanced options with retry logic
    const requestOptions = {
      ...options,
      retries: options.retries || 3,
      retryDelay: options.retryDelay || 1000,
      // 1 second base delay
      maxRetryDelay: options.maxRetryDelay || 30000,
      // 30 seconds max delay
      healthCheck: options.healthCheck !== false,
      // Enable health check by default
      timeout: options.timeout || 10000 // 10 second timeout
    };

    // Check server health before making request (if enabled)
    if (requestOptions.healthCheck && endpoint !== '/api/health') {
      const isHealthy = await this._checkServerHealth();
      if (!isHealthy && this.serverHealth.consecutiveFailures >= this.serverHealth.maxConsecutiveFailures) {
        throw new Error('Server is unhealthy and unavailable for requests');
      }
    }

    // Prepare headers
    const headers = {
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    };

    // Add authorization if available
    if (this.accessToken) {
      headers.Authorization = `Bearer ${this.accessToken}`;
    }

    // Prepare request body
    let body = null;
    if (data && method !== 'GET') {
      body = JSON.stringify(data);
    }

    // Log the request with minimal details to avoid rate limiting
    const requestLog = {
      type: 'api_request',
      method,
      url,
      timestamp: new Date().toISOString(),
      source: 'local-api-client'
    };
    this.logger.debug(' Local API Request:', requestLog);

    // Retry logic with exponential backoff
    let lastError = null;
    for (let attempt = 1; attempt <= requestOptions.retries; attempt++) {
      try {
        // Create abort controller for timeout
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), requestOptions.timeout);
        const response = await fetch(url, {
          method,
          headers,
          body,
          signal: controller.signal
        });
        clearTimeout(timeoutId);
        const responseData = await this._handleResponse(response);

        // Log successful response with minimal details
        const responseLog = {
          type: 'api_response',
          status: response.status,
          method,
          duration: Date.now() - startTime,
          attempt: attempt,
          source: 'local-api-client'
        };
        this.logger.debug(' Local API Response:', responseLog);

        // Update server health on success
        if (requestOptions.healthCheck) {
          this.serverHealth.isHealthy = true;
          this.serverHealth.consecutiveFailures = 0;
        }
        return responseData;
      } catch (error) {
        lastError = error;

        // Handle timeout errors
        if (error.name === 'AbortError') {
          error.message = 'Request timeout';
          error.status = 408;
        }
        this.logger.error(`Local API Error (attempt ${attempt}/${requestOptions.retries}):`, error);

        // Get the friendly error message if available
        const friendlyMessage = error.friendlyMessage || error.message;
        const isRateLimit = error.status === 429;

        // Check if we should retry this error
        if (!this._shouldRetry(error, attempt, requestOptions.retries)) {
          throw error;
        }

        // Calculate backoff delay
        const baseDelay = isRateLimit ? requestOptions.retryDelay * 2 : requestOptions.retryDelay;
        const delay = this._calculateBackoffDelay(attempt, baseDelay, requestOptions.maxRetryDelay);

        // Show appropriate UI messages based on error type
        if (window.app && window.app.uiManager) {
          if (isRateLimit) {
            if (attempt < requestOptions.retries) {
              // Use enhanced rate limit warning with retry information
              window.app.uiManager.showRateLimitWarning(friendlyMessage, {
                isRetrying: true,
                retryAttempt: attempt,
                maxRetries: requestOptions.retries,
                retryDelay: delay
              });
            } else {
              window.app.uiManager.showError(friendlyMessage);
            }
          } else if (attempt === requestOptions.retries) {
            // For other errors, show friendly message on final attempt
            window.app.uiManager.showError(friendlyMessage);
          }
        }

        // Update server health on failure
        if (requestOptions.healthCheck) {
          this.serverHealth.isHealthy = false;
          this.serverHealth.consecutiveFailures++;
        }

        // If this is the last attempt, throw with friendly message
        if (attempt === requestOptions.retries) {
          throw error;
        }

        // Log retry attempt
        this.logger.info(`Retrying request in ${delay}ms... (attempt ${attempt + 1}/${requestOptions.retries})`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }

    // If all retries fail, throw the last error
    throw lastError;
  }

  /**
   * Handle API response
   * @private
   */
  async _handleResponse(response) {
    const contentType = response.headers.get('content-type');
    let data;
    if (contentType && contentType.includes('application/json')) {
      data = await response.json();
    } else {
      data = await response.text();
    }
    if (!response.ok) {
      let errorMessage;

      // Provide user-friendly error messages based on status code
      switch (response.status) {
        case 400:
          errorMessage = this._getBadRequestMessage(data, response.url);
          break;
        case 401:
          errorMessage = this._getUnauthorizedMessage();
          break;
        case 403:
          errorMessage = this._getForbiddenMessage(data, response.url);
          break;
        case 404:
          errorMessage = this._getNotFoundMessage(data, response.url);
          break;
        case 429:
          errorMessage = this._getRateLimitMessage();
          break;
        case 500:
        case 501:
        case 502:
        case 503:
        case 504:
          errorMessage = this._getServerErrorMessage(response.status);
          break;
        default:
          errorMessage = data.message || `Request failed with status ${response.status}`;
      }
      const error = new Error(errorMessage);
      error.status = response.status;
      error.details = data;
      error.friendlyMessage = errorMessage;
      throw error;
    }
    return data;
  }

  /**
   * Get user-friendly error message for 400 Bad Request errors
   * @private
   */
  _getBadRequestMessage(data, url) {
    // Check if it's an import endpoint error
    if (url.includes('/import')) {
      if (data && data.error) {
        // Return the specific error message from the server
        return data.error;
      }
      if (data && data.message) {
        return data.message;
      }
      return ' Import failed. Please check your CSV file and settings.';
    }

    // Check if it's a user modification endpoint
    if (url.includes('/users/') && url.includes('PUT')) {
      return ' User data validation failed. Please check the user information and try again.';
    }

    // Check if it's a user creation endpoint
    if (url.includes('/users') && url.includes('POST')) {
      return ' User creation failed due to invalid data. Please check required fields and try again.';
    }

    // Check if it's a population-related error
    if (url.includes('/populations')) {
      return ' Population data is invalid. Please check your population settings.';
    }

    // Generic 400 error
    return ' Request data is invalid. Please check your input and try again.';
  }

  /**
   * Get user-friendly error message for 401 Unauthorized errors
   * @private
   */
  _getUnauthorizedMessage() {
    return ' Authentication failed. Please check your PingOne API credentials in the Settings page.';
  }

  /**
   * Get user-friendly error message for 403 Forbidden errors
   * @private
   */
  _getForbiddenMessage(data, url) {
    // Check if it's a user modification endpoint
    if (url.includes('/users/') && url.includes('PUT')) {
      return ' Permission denied. Your PingOne application may not have permission to modify users.';
    }

    // Check if it's a user creation endpoint
    if (url.includes('/users') && url.includes('POST')) {
      return ' Permission denied. Your PingOne application may not have permission to create users.';
    }

    // Check if it's a user deletion endpoint
    if (url.includes('/users/') && url.includes('DELETE')) {
      return ' Permission denied. Your PingOne application may not have permission to delete users.';
    }

    // Generic 403 error
    return ' Access denied. Your PingOne application may not have the required permissions for this operation.';
  }

  /**
   * Get user-friendly error message for 404 Not Found errors
   * @private
   */
  _getNotFoundMessage(data, url) {
    // Check if it's a user-related endpoint
    if (url.includes('/users/')) {
      return ' User not found. The user may have been deleted or the ID is incorrect.';
    }

    // Check if it's a population-related endpoint
    if (url.includes('/populations')) {
      return ' Population not found. Please check your population settings.';
    }

    // Check if it's an environment-related endpoint
    if (url.includes('/environments/')) {
      return ' PingOne environment not found. Please check your environment ID.';
    }

    // Generic 404 error
    return ' Resource not found. Please check the ID or settings and try again.';
  }

  /**
   * Get user-friendly error message for 429 Too Many Requests errors
   * @private
   */
  _getRateLimitMessage() {
    return ' You are sending requests too quickly. Please wait a moment and try again.';
  }

  /**
   * Get user-friendly error message for 500+ server errors
   * @private
   */
  _getServerErrorMessage(status) {
    if (status >= 500) {
      return ' Server error. Please check your PingOne API credentials in the Settings page.';
    }
    return ' An unexpected error occurred. Please try again.';
  }

  // Convenience methods for common HTTP methods
  get(endpoint) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return this.request('GET', endpoint, null, options);
  }
  post(endpoint, data) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return this.request('POST', endpoint, data, options);
  }

  /**
   * Send a POST request with FormData (for file uploads)
   * @param {string} endpoint - API endpoint
   * @param {FormData} formData - FormData object
   * @param {Object} options - Additional options
   * @returns {Promise<Object>} Response data
   */
  async postFormData(endpoint, formData) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const url = `${this.baseUrl}${endpoint}`;
    const startTime = Date.now();

    // Enhanced options with retry logic
    const requestOptions = {
      ...options,
      retries: options.retries || 3,
      retryDelay: options.retryDelay || 1000 // 1 second base delay
    };

    // Prepare headers for FormData (don't set Content-Type, let browser set it with boundary)
    const headers = {
      'Accept': 'application/json'
    };

    // Add authorization if available
    if (this.accessToken) {
      headers.Authorization = `Bearer ${this.accessToken}`;
    }

    // Log the request with minimal details to avoid rate limiting
    const requestLog = {
      type: 'api_request',
      method: 'POST',
      url,
      timestamp: new Date().toISOString(),
      source: 'local-api-client',
      contentType: 'multipart/form-data'
    };
    this.logger.debug(' Local API FormData Request:', requestLog);

    // Retry logic
    let lastError = null;
    for (let attempt = 1; attempt <= requestOptions.retries; attempt++) {
      try {
        const response = await fetch(url, {
          method: 'POST',
          headers,
          body: formData
        });
        const responseData = await this._handleResponse(response);

        // Log successful response with minimal details
        const responseLog = {
          type: 'api_response',
          status: response.status,
          method: 'POST',
          duration: Date.now() - startTime,
          attempt: attempt,
          source: 'local-api-client'
        };
        this.logger.debug(' Local API FormData Response:', responseLog);
        return responseData;
      } catch (error) {
        lastError = error;
        this.logger.error(`Local API FormData Error (attempt ${attempt}/${requestOptions.retries}):`, error);

        // Get the friendly error message if available
        const friendlyMessage = error.friendlyMessage || error.message;
        const isRateLimit = error.status === 429;

        // Calculate baseDelay and delay here, before using them
        const baseDelay = isRateLimit ? requestOptions.retryDelay * 2 : requestOptions.retryDelay;
        const delay = baseDelay * Math.pow(2, attempt - 1);

        // Show appropriate UI messages based on error type
        if (window.app && window.app.uiManager) {
          if (isRateLimit) {
            if (attempt < requestOptions.retries) {
              // Use enhanced rate limit warning with retry information
              window.app.uiManager.showRateLimitWarning(friendlyMessage, {
                isRetrying: true,
                retryAttempt: attempt,
                maxRetries: requestOptions.retries,
                retryDelay: delay
              });
            } else {
              window.app.uiManager.showError(friendlyMessage);
            }
          } else if (attempt === requestOptions.retries) {
            // For other errors, show friendly message on final attempt
            window.app.uiManager.showError(friendlyMessage);
          }
        }

        // If this is the last attempt, throw with friendly message
        if (attempt === requestOptions.retries) {
          throw error;
        }

        // Only retry for rate limits (429) and server errors (5xx)
        const shouldRetry = isRateLimit || error.status >= 500 || !error.status;
        if (!shouldRetry) {
          // Don't retry for client errors (4xx except 429), throw immediately
          throw error;
        }

        // Use the delay calculated above
        this.logger.info(`Retrying FormData request in ${delay}ms... (attempt ${attempt + 1}/${requestOptions.retries})`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }

    // If all retries fail, throw the last error
    throw lastError;
  }
  put(endpoint, data) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return this.request('PUT', endpoint, data, options);
  }
  delete(endpoint) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return this.request('DELETE', endpoint, null, options);
  }

  // Token Management Methods

  /**
   * Retrieve PingOne worker token
   * @returns {Promise<Object>} Token data with expiration info
   */
  async getWorkerToken() {
    this.logger.debug(' Retrieving PingOne worker token...');
    try {
      const response = await this.post('/api/auth/worker-token', {}, {
        timeout: 15000,
        // 15 second timeout for token retrieval
        retries: 2 // Fewer retries for token operations
      });
      this.logger.debug(' Worker token retrieved successfully');
      return response;
    } catch (error) {
      this.logger.error(' Failed to retrieve worker token:', error);
      throw new Error(`Token retrieval failed: ${error.message}`);
    }
  }

  /**
   * Refresh existing PingOne worker token
   * @param {string} currentToken - Current token for authorization
   * @returns {Promise<Object>} Refreshed token data
   */
  async refreshWorkerToken(currentToken) {
    this.logger.debug(' Refreshing PingOne worker token...');
    if (!currentToken) {
      throw new Error('Current token is required for refresh');
    }
    try {
      const response = await this.post('/api/auth/refresh-token', {}, {
        headers: {
          'Authorization': `Bearer ${currentToken}`
        },
        timeout: 10000,
        // 10 second timeout for refresh
        retries: 1 // Single retry for refresh operations
      });
      this.logger.debug(' Worker token refreshed successfully');
      return response;
    } catch (error) {
      this.logger.error(' Failed to refresh worker token:', error);
      throw new Error(`Token refresh failed: ${error.message}`);
    }
  }

  /**
   * Get current token status without retrieving the actual token
   * @returns {Promise<Object>} Token status information
   */
  async getTokenStatus() {
    this.logger.debug(' Checking worker token status...');
    try {
      const response = await this.get('/api/auth/token-status', {
        timeout: 5000,
        // 5 second timeout for status check
        retries: 1 // Single retry for status check
      });
      this.logger.debug(' Token status retrieved successfully');
      return response;
    } catch (error) {
      this.logger.debug(' Could not retrieve token status:', error.message);
      // Don't throw for status checks - return null status
      return {
        success: false,
        hasToken: false,
        error: error.message
      };
    }
  }

  /**
   * Clear/invalidate current worker token
   * @returns {Promise<Object>} Clear operation result
   */
  async clearWorkerToken() {
    this.logger.debug(' Clearing worker token...');
    try {
      const response = await this.delete('/api/auth/worker-token', {
        timeout: 5000,
        // 5 second timeout for clear operation
        retries: 1 // Single retry for clear operation
      });
      this.logger.debug(' Worker token cleared successfully');
      return response;
    } catch (error) {
      this.logger.error(' Failed to clear worker token:', error);
      throw new Error(`Token clear failed: ${error.message}`);
    }
  }

  /**
   * Validate worker token and get detailed information
   */
  async validateToken() {
    let token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    try {
      const payload = token ? {
        token: token
      } : {};
      const response = await this.post('/api/auth/validate-credentials', payload, {
        timeout: 5000,
        // 5 second timeout for validation
        retries: 1 // Single retry for validation
      });
      return {
        success: true,
        valid: response.valid || false,
        details: response.details || {},
        message: response.message || 'Token validation completed'
      };
    } catch (error) {
      return {
        success: false,
        valid: false,
        error: error.message,
        message: 'Token validation failed'
      };
    }
  }

  /**
   * Test API connection
   * @returns {Promise<Object>} Connection test result
   */
  async testConnection() {
    try {
      const response = await this.post('/api/auth/test-connection', {}, {
        timeout: 10000,
        // 10 second timeout for connection test
        retries: 1 // Single retry for connection test
      });
      return {
        success: true,
        connected: true,
        details: response.details || {},
        message: response.message || 'Connection successful'
      };
    } catch (error) {
      return {
        success: false,
        connected: false,
        error: error.message,
        message: 'Connection test failed'
      };
    }
  }
}

// Export a singleton instance
exports.LocalAPIClient = LocalAPIClient;
const localAPIClient = exports.localAPIClient = new LocalAPIClient(console);

},{}],54:[function(require,module,exports){
(function (process){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Logger = void 0;
var _winstonLogger = require("./winston-logger.js");
var _messageFormatter = _interopRequireDefault(require("./message-formatter.js"));
var _uiManager = require("./ui-manager.js");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); } /**
 * @fileoverview Winston-compatible logger for frontend environment
 * 
 * This module provides a Winston-like logging interface for the frontend
 * that maintains consistency with server-side Winston logging while
 * working within browser constraints.
 * 
 * Features:
 * - Winston-compatible API (info, warn, error, debug)
 * - Structured logging with metadata
 * - Timestamp formatting
 * - Log level filtering
 * - Console and server transport support
 * - Error stack trace handling
 * - Environment-aware configuration
 */
const ui = window.app && window.app.uiManager;

/**
 * Winston-compatible logger for browser environment
 */
class Logger {
  constructor() {
    let logElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    this.logElement = logElement;
    this.logs = [];
    this.validCount = 0;
    this.errorCount = 0;
    this.initialized = false;
    this.serverLoggingEnabled = true;
    this.isLoadingLogs = false;
    this.offlineLogs = [];

    // Initialize Winston-compatible logger
    this.winstonLogger = (0, _winstonLogger.createWinstonLogger)({
      service: 'pingone-import-frontend',
      environment: process.env.NODE_ENV || 'development',
      enableServerLogging: true,
      enableConsoleLogging: true
    });
    this.initialize();
  }

  /**
   * Initialize the logger
   */
  initialize() {
    try {
      this.winstonLogger.info('Logger initialized successfully');
      this.initialized = true;
    } catch (error) {
      console.error('Failed to initialize logger:', error);
    }
  }

  /**
   * Temporarily disable server logging to prevent feedback loops
   */
  disableServerLogging() {
    this.serverLoggingEnabled = false;
    this.winstonLogger.setServerLogging(false);
    this.winstonLogger.debug('Server logging disabled');
  }

  /**
   * Re-enable server logging
   */
  enableServerLogging() {
    this.serverLoggingEnabled = true;
    this.winstonLogger.setServerLogging(true);
    this.winstonLogger.debug('Server logging enabled');
  }

  /**
   * Set flag to indicate we're loading logs (prevents server logging)
   */
  setLoadingLogs(isLoading) {
    this.isLoadingLogs = isLoading;
    this.winstonLogger.debug(`Loading logs flag set to: ${isLoading}`);
  }

  /**
   * Create a safe file logger that handles initialization and errors
   * @private
   */
  _createSafeFileLogger() {
    const logger = {
      _initialized: false,
      _logger: null,
      _queue: [],
      _initializing: false,
      async init() {
        if (this._initialized || this._initializing) return;
        this._initializing = true;
        try {
          // Initialize actual FileLogger for client.log
          const {
            FileLogger
          } = await Promise.resolve().then(() => _interopRequireWildcard(require('./file-logger.js')));
          this._logger = new FileLogger('client.log');
          this._initialized = true;
          this._processQueue();
        } catch (error) {
          console.warn('Failed to initialize file logger, falling back to console:', error.message);
          // Fallback to console logging
          this._logger = {
            log: (level, message, data) => {
              console[level] || console.log(`[${level.toUpperCase()}] ${message}`, data);
            }
          };
          this._initialized = true;
          this._processQueue();
        } finally {
          this._initializing = false;
        }
      },
      _processQueue() {
        while (this._queue.length > 0) {
          const {
            level,
            message,
            data
          } = this._queue.shift();
          if (this._logger && typeof this._logger.log === 'function') {
            this._logger.log(level, message, data);
          }
        }
      },
      log(level, message, data) {
        if (this._initialized && this._logger) {
          this._logger.log(level, message, data);
        } else {
          this._queue.push({
            level,
            message,
            data
          });
          if (!this._initializing) {
            this.init();
          }
        }
      }
    };
    return logger;
  }

  /**
   * Parse log arguments into structured format
   * @private
   */
  _parseLogArgs(args) {
    let message = 'Log message';
    let data = null;
    let context = null;
    if (args.length > 0) {
      if (typeof args[0] === 'string') {
        message = args[0];
        if (args.length > 1 && typeof args[1] === 'object') {
          data = args[1];
          if (args.length > 2 && typeof args[2] === 'object') {
            context = args[2];
          }
        }
      } else if (typeof args[0] === 'object') {
        data = args[0];
        message = 'Log data';
        if (args.length > 1 && typeof args[1] === 'object') {
          context = args[1];
        }
      }
    }
    return [message, data, context];
  }

  /**
   * Main logging method with Winston integration
   */
  log(level, message) {
    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    try {
      // Parse arguments if needed
      if (typeof level === 'string' && typeof message === 'string') {
        // Direct call: log(level, message, data)
        this._logToWinston(level, message, data);
      } else {
        // Legacy call: log(message, level)
        const [parsedMessage, parsedData, context] = this._parseLogArgs(arguments);
        this._logToWinston(level || 'info', parsedMessage, {
          ...parsedData,
          ...context
        });
      }

      // Update UI if log element exists
      this._updateLogUI({
        level,
        message,
        data,
        timestamp: new Date()
      });
    } catch (error) {
      console.error('Error in logger.log:', error);
    }
  }

  /**
   * Log to Winston with proper formatting
   * @private
   */
  _logToWinston(level, message) {
    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const logData = {
      ...data,
      component: 'frontend-logger',
      timestamp: new Date().toISOString()
    };
    this.winstonLogger.log(level, message, logData);
  }

  /**
   * Log info level message
   */
  info(message) {
    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.log('info', message, data);
  }

  /**
   * Log warn level message
   */
  warn(message) {
    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.log('warn', message, data);
  }

  /**
   * Log error level message
   */
  error(message) {
    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.log('error', message, data);
    if (ui) ui.showStatusBar(message, 'error', {
      autoDismiss: false
    });
    this.errorCount++;
    this.updateSummary();
  }

  /**
   * Log debug level message
   */
  debug(message) {
    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.log('debug', message, data);
  }

  /**
   * Log success level message
   */
  success(message) {
    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.log('info', message, {
      ...data,
      type: 'success'
    });
    this.validCount++;
    this.updateSummary();
  }

  /**
   * Log error with stack trace
   */
  errorWithStack(message, error) {
    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    this.winstonLogger.errorWithStack(message, error, data);
    this.errorCount++;
    this.updateSummary();
  }

  /**
   * Update log UI with new entry
   * @private
   */
  _updateLogUI(logEntry) {
    if (!this.logElement) return;
    try {
      const logElement = document.createElement('div');
      logElement.className = `log-entry ${logEntry.level}`;

      // Create timestamp
      const timestamp = document.createElement('span');
      timestamp.className = 'log-timestamp';
      timestamp.textContent = new Date(logEntry.timestamp).toLocaleTimeString();
      logElement.appendChild(timestamp);

      // Create level badge
      const levelBadge = document.createElement('span');
      levelBadge.className = 'log-level';
      levelBadge.textContent = logEntry.level.toUpperCase();
      logElement.appendChild(levelBadge);

      // Create message with formatting
      const message = document.createElement('span');
      message.className = 'log-message';

      // Format the message for better readability
      let formattedMessage = logEntry.message;
      if (logEntry.data && logEntry.data.type) {
        // Format based on message type
        switch (logEntry.data.type) {
          case 'progress':
            formattedMessage = _messageFormatter.default.formatProgressMessage(logEntry.data.operation || 'import', logEntry.data.current || 0, logEntry.data.total || 0, logEntry.message, logEntry.data.counts || {});
            break;
          case 'error':
            formattedMessage = _messageFormatter.default.formatErrorMessage(logEntry.data.operation || 'import', logEntry.message, logEntry.data);
            break;
          case 'completion':
            formattedMessage = _messageFormatter.default.formatCompletionMessage(logEntry.data.operation || 'import', logEntry.data);
            break;
          default:
            // Use original message for other types
            formattedMessage = logEntry.message;
        }
      }
      message.textContent = formattedMessage;
      logElement.appendChild(message);

      // Add details if present
      if (logEntry.data && Object.keys(logEntry.data).length > 0) {
        const detailsElement = document.createElement('div');
        detailsElement.className = 'log-details';
        const detailsTitle = document.createElement('h4');
        detailsTitle.textContent = 'Details';
        detailsElement.appendChild(detailsTitle);
        const detailsContent = document.createElement('pre');
        detailsContent.className = 'log-detail-json';
        detailsContent.textContent = JSON.stringify(logEntry.data, null, 2);
        detailsElement.appendChild(detailsContent);
        logElement.appendChild(detailsElement);
      }

      // Insert at top (newest first)
      if (this.logElement.firstChild) {
        this.logElement.insertBefore(logElement, this.logElement.firstChild);
      } else {
        this.logElement.appendChild(logElement);
      }

      // Auto-scroll to top
      this.logElement.scrollTop = 0;

      // Limit UI logs
      const maxUILogs = 100;
      while (this.logElement.children.length > maxUILogs) {
        this.logElement.removeChild(this.logElement.lastChild);
      }
    } catch (error) {
      console.error('Error updating log UI:', error);
    }
  }

  /**
   * Send log to server
   * @private
   */
  async _sendToServer(logEntry) {
    if (!this.serverLoggingEnabled || this.isLoadingLogs) {
      return;
    }
    try {
      await fetch('/api/logs/ui', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          level: logEntry.level,
          message: logEntry.message,
          data: logEntry.data
        })
      });
    } catch (error) {
      this.winstonLogger.warn('Failed to send log to server', {
        error: error.message
      });
      this.offlineLogs.push(logEntry);
    }
  }

  /**
   * Render all logs to UI
   */
  renderLogs() {
    if (!this.logElement) return;
    this.logElement.innerHTML = '';
    this.logs.forEach(log => this._updateLogUI(log));
    this.logElement.scrollTop = this.logElement.scrollHeight;
  }

  /**
   * Clear all logs
   */
  clearLogs() {
    this.logs = [];
    if (this.logElement) {
      this.logElement.innerHTML = '';
    }
    this.winstonLogger.info('Logs cleared');
  }

  /**
   * Get all logs
   */
  getLogs() {
    return [...this.logs];
  }

  /**
   * Update summary display
   */
  updateSummary() {
    // Implementation depends on UI structure
    this.winstonLogger.debug('Summary updated', {
      validCount: this.validCount,
      errorCount: this.errorCount
    });
  }

  /**
   * Clear summary
   */
  clearSummary() {
    this.validCount = 0;
    this.errorCount = 0;
    this.winstonLogger.debug('Summary cleared');
  }
}

// Export the Logger class
exports.Logger = Logger;

}).call(this)}).call(this,require('_process'))
},{"./file-logger.js":51,"./message-formatter.js":56,"./ui-manager.js":68,"./winston-logger.js":70,"@babel/runtime/helpers/interopRequireDefault":2,"_process":29}],55:[function(require,module,exports){
(function (process){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.LoggingSubsystem = void 0;
var _winstonLogger = require("./winston-logger.js");
/**
 * Logging Subsystem
 * Centralized logging system that replaces legacy window.logManager
 * Provides structured logging with levels, categories, and event integration
 */

class LoggingSubsystem {
  constructor(eventBus, settingsSubsystem) {
    this.eventBus = eventBus;
    this.settingsSubsystem = settingsSubsystem;

    // Initialize Winston logger
    this.logger = (0, _winstonLogger.createWinstonLogger)({
      service: 'logging-subsystem',
      environment: process.env.NODE_ENV || 'development'
    });

    // Log storage for UI display
    this.logHistory = [];
    this.maxHistorySize = 1000;

    // Log levels
    this.levels = {
      ERROR: 0,
      WARN: 1,
      INFO: 2,
      DEBUG: 3,
      TRACE: 4
    };

    // Current log level (configurable)
    this.currentLevel = this.levels.INFO;

    // Log categories for filtering
    this.categories = {
      SYSTEM: 'system',
      AUTH: 'auth',
      IMPORT: 'import',
      EXPORT: 'export',
      DELETE: 'delete',
      MODIFY: 'modify',
      UI: 'ui',
      API: 'api',
      ERROR: 'error'
    };

    // Initialize subsystem
    this.init();
    this.logger.info('LoggingSubsystem initialized successfully');
  }

  /**
   * Initialize the logging subsystem
   */
  async init() {
    try {
      // Load logging settings
      await this.loadSettings();

      // Set up event listeners
      this.setupEventListeners();

      // Replace global logManager if it exists
      this.replaceGlobalLogManager();
      this.logger.info('LoggingSubsystem initialization complete');
    } catch (error) {
      this.logger.error('Failed to initialize LoggingSubsystem', error);
      throw error;
    }
  }

  /**
   * Load logging settings from SettingsSubsystem
   */
  async loadSettings() {
    try {
      if (this.settingsSubsystem) {
        await this.settingsSubsystem.loadCurrentSettings();
        const settings = this.settingsSubsystem.currentSettings;

        // Set log level from settings
        if (settings.logLevel) {
          this.setLogLevel(settings.logLevel);
        }

        // Set max history size from settings
        if (settings.maxLogHistory) {
          this.maxHistorySize = settings.maxLogHistory;
        }
      }
    } catch (error) {
      this.logger.warn('Could not load logging settings, using defaults', error);
    }
  }

  /**
   * Set up event listeners for cross-subsystem communication
   */
  setupEventListeners() {
    if (this.eventBus) {
      // Listen for log level changes
      this.eventBus.on('loggingLevelChanged', data => {
        this.setLogLevel(data.level);
      });

      // Listen for log clear requests
      this.eventBus.on('clearLogs', () => {
        this.clearLogs();
      });

      // Listen for log export requests
      this.eventBus.on('exportLogs', data => {
        this.exportLogs(data.options);
      });
    }
  }

  /**
   * Replace global window.logManager with this subsystem
   */
  replaceGlobalLogManager() {
    // Create a compatibility layer for legacy code
    window.logManager = {
      log: (level, message, data) => this.log(level, message, data),
      error: (message, data) => this.error(message, data),
      warn: (message, data) => this.warn(message, data),
      info: (message, data) => this.info(message, data),
      debug: (message, data) => this.debug(message, data),
      loadLogs: () => this.loadLogs(),
      clearLogs: () => this.clearLogs(),
      exportLogs: options => this.exportLogs(options),
      // Legacy compatibility
      getLogger: name => this.getLogger(name)
    };
    this.logger.info('Global logManager replaced with LoggingSubsystem compatibility layer');
  }

  /**
   * Main logging method
   */
  log(level, message) {
    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    let category = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.categories.SYSTEM;
    const levelValue = typeof level === 'string' ? this.levels[level.toUpperCase()] : level;

    // Check if log level is enabled
    if (levelValue > this.currentLevel) {
      return;
    }
    const logEntry = {
      timestamp: new Date().toISOString(),
      level: level.toLowerCase(),
      message,
      data: this.sanitizeLogData(data),
      category,
      sessionId: this.generateSessionId()
    };

    // Add to history
    this.addToHistory(logEntry);

    // Log to Winston
    this.logger[level.toLowerCase()](message, {
      data: logEntry.data,
      category,
      sessionId: logEntry.sessionId
    });

    // Emit log event for UI updates
    if (this.eventBus) {
      this.eventBus.emit('logEntry', logEntry);
    }

    // Console output for development
    if (process.env.NODE_ENV === 'development') {
      this.consoleLog(logEntry);
    }
  }

  /**
   * Error logging
   */
  error(message) {
    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let category = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.categories.ERROR;
    this.log('ERROR', message, data, category);
  }

  /**
   * Warning logging
   */
  warn(message) {
    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let category = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.categories.SYSTEM;
    this.log('WARN', message, data, category);
  }

  /**
   * Info logging
   */
  info(message) {
    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let category = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.categories.SYSTEM;
    this.log('INFO', message, data, category);
  }

  /**
   * Debug logging
   */
  debug(message) {
    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let category = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.categories.SYSTEM;
    this.log('DEBUG', message, data, category);
  }

  /**
   * Trace logging
   */
  trace(message) {
    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let category = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.categories.SYSTEM;
    this.log('TRACE', message, data, category);
  }

  /**
   * Get a logger instance for a specific component
   */
  getLogger(name) {
    return {
      error: (message, data) => this.error(`[${name}] ${message}`, data),
      warn: (message, data) => this.warn(`[${name}] ${message}`, data),
      info: (message, data) => this.info(`[${name}] ${message}`, data),
      debug: (message, data) => this.debug(`[${name}] ${message}`, data),
      trace: (message, data) => this.trace(`[${name}] ${message}`, data)
    };
  }

  /**
   * Set the current log level
   */
  setLogLevel(level) {
    if (typeof level === 'string') {
      this.currentLevel = this.levels[level.toUpperCase()] || this.levels.INFO;
    } else {
      this.currentLevel = level;
    }
    this.logger.info('Log level changed', {
      newLevel: this.currentLevel
    });

    // Emit event for UI updates
    if (this.eventBus) {
      this.eventBus.emit('logLevelChanged', {
        level: this.currentLevel
      });
    }
  }

  /**
   * Add log entry to history
   */
  addToHistory(logEntry) {
    this.logHistory.unshift(logEntry);

    // Maintain history size limit
    if (this.logHistory.length > this.maxHistorySize) {
      this.logHistory = this.logHistory.slice(0, this.maxHistorySize);
    }
  }

  /**
   * Load logs for UI display
   */
  async loadLogs() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    try {
      const {
        limit = 100,
        offset = 0,
        level = null,
        category = null,
        search = null,
        startDate = null,
        endDate = null
      } = options;
      let filteredLogs = [...this.logHistory];

      // Apply filters
      if (level) {
        filteredLogs = filteredLogs.filter(log => log.level === level.toLowerCase());
      }
      if (category) {
        filteredLogs = filteredLogs.filter(log => log.category === category);
      }
      if (search) {
        const searchLower = search.toLowerCase();
        filteredLogs = filteredLogs.filter(log => log.message.toLowerCase().includes(searchLower) || JSON.stringify(log.data).toLowerCase().includes(searchLower));
      }
      if (startDate) {
        filteredLogs = filteredLogs.filter(log => new Date(log.timestamp) >= new Date(startDate));
      }
      if (endDate) {
        filteredLogs = filteredLogs.filter(log => new Date(log.timestamp) <= new Date(endDate));
      }

      // Apply pagination
      const paginatedLogs = filteredLogs.slice(offset, offset + limit);
      const result = {
        logs: paginatedLogs,
        total: filteredLogs.length,
        hasMore: offset + limit < filteredLogs.length
      };
      this.logger.debug('Logs loaded', {
        requested: limit,
        returned: paginatedLogs.length,
        total: result.total
      });
      return result;
    } catch (error) {
      this.logger.error('Failed to load logs', error);
      throw error;
    }
  }

  /**
   * Clear all logs
   */
  clearLogs() {
    const previousCount = this.logHistory.length;
    this.logHistory = [];
    this.logger.info('Logs cleared', {
      previousCount
    });

    // Emit event for UI updates
    if (this.eventBus) {
      this.eventBus.emit('logsCleared', {
        previousCount
      });
    }
  }

  /**
   * Export logs to file
   */
  async exportLogs() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    try {
      const {
        format = 'json',
        filename = `logs_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}`
      } = options;
      const logs = await this.loadLogs({
        limit: this.maxHistorySize
      });
      let content;
      let mimeType;
      let extension;
      switch (format.toLowerCase()) {
        case 'csv':
          content = this.convertLogsToCSV(logs.logs);
          mimeType = 'text/csv';
          extension = 'csv';
          break;
        case 'txt':
          content = this.convertLogsToText(logs.logs);
          mimeType = 'text/plain';
          extension = 'txt';
          break;
        case 'json':
        default:
          content = JSON.stringify(logs.logs, null, 2);
          mimeType = 'application/json';
          extension = 'json';
          break;
      }

      // Create and download file
      const blob = new Blob([content], {
        type: mimeType
      });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `${filename}.${extension}`;
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      this.logger.info('Logs exported successfully', {
        format,
        filename: `${filename}.${extension}`,
        logCount: logs.logs.length
      });
    } catch (error) {
      this.logger.error('Failed to export logs', error);
      throw error;
    }
  }

  /**
   * Convert logs to CSV format
   */
  convertLogsToCSV(logs) {
    const headers = ['Timestamp', 'Level', 'Category', 'Message', 'Data'];
    const csvRows = [headers.join(',')];
    logs.forEach(log => {
      const row = [log.timestamp, log.level, log.category, `"${log.message.replace(/"/g, '""')}"`, `"${JSON.stringify(log.data).replace(/"/g, '""')}"`];
      csvRows.push(row.join(','));
    });
    return csvRows.join('\n');
  }

  /**
   * Convert logs to text format
   */
  convertLogsToText(logs) {
    return logs.map(log => {
      const dataStr = Object.keys(log.data).length > 0 ? ` | Data: ${JSON.stringify(log.data)}` : '';
      return `[${log.timestamp}] ${log.level.toUpperCase()} [${log.category}] ${log.message}${dataStr}`;
    }).join('\n');
  }

  /**
   * Console logging for development
   */
  consoleLog(logEntry) {
    const {
      level,
      message,
      data,
      category,
      timestamp
    } = logEntry;
    const prefix = `[${timestamp}] [${category}]`;
    switch (level) {
      case 'error':
        console.error(prefix, message, data);
        break;
      case 'warn':
        console.warn(prefix, message, data);
        break;
      case 'debug':
        console.debug(prefix, message, data);
        break;
      case 'trace':
        console.trace(prefix, message, data);
        break;
      default:
        console.log(prefix, message, data);
    }
  }

  /**
   * Sanitize log data to prevent circular references and sensitive data
   */
  sanitizeLogData(data) {
    if (!data || typeof data !== 'object') {
      return data;
    }
    try {
      // Create a deep copy and remove sensitive fields
      const sanitized = JSON.parse(JSON.stringify(data, (key, value) => {
        // Remove sensitive fields
        const sensitiveFields = ['password', 'token', 'secret', 'key', 'apiKey', 'clientSecret'];
        if (sensitiveFields.some(field => key.toLowerCase().includes(field))) {
          return '[REDACTED]';
        }

        // Handle circular references
        if (typeof value === 'object' && value !== null) {
          if (value.constructor && value.constructor.name === 'HTMLElement') {
            return '[HTMLElement]';
          }
          if (value instanceof Error) {
            return {
              name: value.name,
              message: value.message,
              stack: value.stack
            };
          }
        }
        return value;
      }));
      return sanitized;
    } catch (error) {
      return {
        error: 'Failed to sanitize log data',
        original: String(data)
      };
    }
  }

  /**
   * Generate session ID for log tracking
   */
  generateSessionId() {
    return `log_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Get logging statistics
   */
  getStats() {
    const stats = {
      totalLogs: this.logHistory.length,
      levelCounts: {},
      categoryCounts: {},
      recentActivity: this.logHistory.slice(0, 10)
    };

    // Count by level
    this.logHistory.forEach(log => {
      stats.levelCounts[log.level] = (stats.levelCounts[log.level] || 0) + 1;
      stats.categoryCounts[log.category] = (stats.categoryCounts[log.category] || 0) + 1;
    });
    return stats;
  }
}

// Export for use in other modules
exports.LoggingSubsystem = LoggingSubsystem;
var _default = exports.default = LoggingSubsystem;

}).call(this)}).call(this,require('_process'))
},{"./winston-logger.js":70,"_process":29}],56:[function(require,module,exports){
(function (process){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.MessageFormatter = void 0;
var _winstonLogger = require("./winston-logger.js");
/**
 * Enhanced Message Formatter Module
 * 
 * Improves readability of server messages with:
 * - Visual separators and formatting
 * - Structured message blocks
 * - Event grouping and labeling
 * - Timestamp formatting
 * - Color coding and styling
 * 
 * Features:
 * - Message block separation with asterisks
 * - Event start/end markers
 * - Structured formatting with line breaks
 * - Timestamp and label formatting
 * - Consistent styling across all message types
 */

/**
 * Enhanced Message Formatter Class
 * 
 * Formats server messages for improved readability in logs and progress windows
 */
class MessageFormatter {
  constructor() {
    this.logger = (0, _winstonLogger.createWinstonLogger)({
      service: 'pingone-message-formatter',
      environment: process.env.NODE_ENV || 'development'
    });

    // Message formatting options
    this.formattingOptions = {
      showTimestamps: true,
      showEventMarkers: true,
      showSeparators: true,
      maxMessageLength: 200,
      separatorChar: '*',
      separatorLength: 50
    };

    // Event type configurations
    this.eventTypes = {
      import: {
        start: 'IMPORT STARTED',
        end: 'IMPORT COMPLETED',
        error: 'IMPORT ERROR',
        color: '#3498db'
      },
      export: {
        start: 'EXPORT STARTED',
        end: 'EXPORT COMPLETED',
        error: 'EXPORT ERROR',
        color: '#27ae60'
      },
      modify: {
        start: 'MODIFY STARTED',
        end: 'MODIFY COMPLETED',
        error: 'MODIFY ERROR',
        color: '#f39c12'
      },
      delete: {
        start: 'DELETE STARTED',
        end: 'DELETE COMPLETED',
        error: 'DELETE ERROR',
        color: '#e74c3c'
      },
      validation: {
        start: 'VALIDATION STARTED',
        end: 'VALIDATION COMPLETED',
        error: 'VALIDATION ERROR',
        color: '#9b59b6'
      },
      connection: {
        start: 'CONNECTION ESTABLISHED',
        end: 'CONNECTION CLOSED',
        error: 'CONNECTION ERROR',
        color: '#1abc9c'
      }
    };
  }

  /**
   * Format a message block with visual separators
   * @param {string} eventType - Type of event (import, export, etc.)
   * @param {string} eventStage - Stage of the event (start, end, error, progress)
   * @param {string} message - The main message
   * @param {Object} details - Additional details
   * @returns {string} Formatted message block
   */
  formatMessageBlock(eventType, eventStage, message) {
    let details = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    try {
      const eventConfig = this.eventTypes[eventType] || this.eventTypes.import;
      const timestamp = this.formatTimestamp(new Date());
      const separator = this.createSeparator();
      let formattedMessage = '';

      // Add separator at the beginning
      if (this.formattingOptions.showSeparators) {
        formattedMessage += separator + '\n';
      }

      // Add event marker
      if (this.formattingOptions.showEventMarkers) {
        const marker = this.getEventMarker(eventConfig, eventStage);
        formattedMessage += `${marker}\n`;
      }

      // Add timestamp
      if (this.formattingOptions.showTimestamps) {
        formattedMessage += `[${timestamp}] `;
      }

      // Add main message
      formattedMessage += message + '\n';

      // Add details if present
      if (details && Object.keys(details).length > 0) {
        formattedMessage += this.formatDetails(details);
      }

      // Add separator at the end
      if (this.formattingOptions.showSeparators) {
        formattedMessage += separator + '\n';
      }
      this.logger.debug('Message block formatted', {
        eventType,
        eventStage,
        messageLength: message.length
      });
      return formattedMessage;
    } catch (error) {
      this.logger.error('Error formatting message block', {
        error: error.message
      });
      return message; // Fallback to original message
    }
  }

  /**
   * Format a progress update message
   * @param {string} operation - Operation type
   * @param {number} current - Current progress
   * @param {number} total - Total items
   * @param {string} message - Progress message
   * @param {Object} stats - Progress statistics
   * @returns {string} Formatted progress message
   */
  formatProgressMessage(operation, current, total, message) {
    let stats = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    try {
      const timestamp = this.formatTimestamp(new Date());
      const percentage = total > 0 ? Math.round(current / total * 100) : 0;
      let formattedMessage = '';

      // Add timestamp
      if (this.formattingOptions.showTimestamps) {
        formattedMessage += `[${timestamp}] `;
      }

      // Add progress indicator
      formattedMessage += `PROGRESS: ${current}/${total} (${percentage}%)`;

      // Add message if provided
      if (message) {
        formattedMessage += ` - ${message}`;
      }

      // Add stats if available
      if (stats && Object.keys(stats).length > 0) {
        formattedMessage += '\n' + this.formatProgressStats(stats);
      }
      return formattedMessage;
    } catch (error) {
      this.logger.error('Error formatting progress message', {
        error: error.message
      });
      return message || `Progress: ${current}/${total}`;
    }
  }

  /**
   * Format an error message with context
   * @param {string} operation - Operation type
   * @param {string} errorMessage - Error message
   * @param {Object} errorDetails - Error details
   * @returns {string} Formatted error message
   */
  formatErrorMessage(operation, errorMessage) {
    let errorDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    try {
      const eventConfig = this.eventTypes[operation] || this.eventTypes.import;
      const timestamp = this.formatTimestamp(new Date());
      const separator = this.createSeparator();
      let formattedMessage = '';

      // Add separator
      if (this.formattingOptions.showSeparators) {
        formattedMessage += separator + '\n';
      }

      // Add error marker
      formattedMessage += `${eventConfig.error}\n`;

      // Add timestamp and error message
      if (this.formattingOptions.showTimestamps) {
        formattedMessage += `[${timestamp}] `;
      }
      formattedMessage += `ERROR: ${errorMessage}\n`;

      // Add error details if present
      if (errorDetails && Object.keys(errorDetails).length > 0) {
        formattedMessage += this.formatErrorDetails(errorDetails);
      }

      // Add separator
      if (this.formattingOptions.showSeparators) {
        formattedMessage += separator + '\n';
      }
      return formattedMessage;
    } catch (error) {
      this.logger.error('Error formatting error message', {
        error: error.message
      });
      return `ERROR: ${errorMessage}`;
    }
  }

  /**
   * Format a completion message with results
   * @param {string} operation - Operation type
   * @param {Object} results - Operation results
   * @returns {string} Formatted completion message
   */
  formatCompletionMessage(operation) {
    let results = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    try {
      const eventConfig = this.eventTypes[operation] || this.eventTypes.import;
      const timestamp = this.formatTimestamp(new Date());
      const separator = this.createSeparator();
      let formattedMessage = '';

      // Add separator
      if (this.formattingOptions.showSeparators) {
        formattedMessage += separator + '\n';
      }

      // Add completion marker
      formattedMessage += `${eventConfig.end}\n`;

      // Add timestamp
      if (this.formattingOptions.showTimestamps) {
        formattedMessage += `[${timestamp}] `;
      }

      // Add completion message
      formattedMessage += `Operation completed successfully\n`;

      // Add results if present
      if (results && Object.keys(results).length > 0) {
        formattedMessage += this.formatResults(results);
      }

      // Add separator
      if (this.formattingOptions.showSeparators) {
        formattedMessage += separator + '\n';
      }
      return formattedMessage;
    } catch (error) {
      this.logger.error('Error formatting completion message', {
        error: error.message
      });
      return 'Operation completed successfully';
    }
  }

  /**
   * Format SSE event data for display
   * @param {Object} eventData - SSE event data
   * @returns {string} Formatted event message
   */
  formatSSEEvent(eventData) {
    try {
      const {
        type,
        message,
        current,
        total,
        counts,
        error
      } = eventData;
      const timestamp = this.formatTimestamp(new Date());
      let formattedMessage = '';

      // Add timestamp
      if (this.formattingOptions.showTimestamps) {
        formattedMessage += `[${timestamp}] `;
      }

      // Format based on event type
      switch (type) {
        case 'progress':
          formattedMessage += this.formatProgressMessage('import', current, total, message, counts);
          break;
        case 'completion':
          formattedMessage += this.formatCompletionMessage('import', eventData);
          break;
        case 'error':
          formattedMessage += this.formatErrorMessage('import', message, eventData);
          break;
        default:
          formattedMessage += `SSE EVENT [${type.toUpperCase()}]: ${message || 'No message'}`;
      }
      return formattedMessage;
    } catch (error) {
      this.logger.error('Error formatting SSE event', {
        error: error.message
      });
      return eventData.message || 'SSE event received';
    }
  }

  /**
   * Create a visual separator line
   * @returns {string} Separator string
   */
  createSeparator() {
    const char = this.formattingOptions.separatorChar;
    const length = this.formattingOptions.separatorLength;
    return char.repeat(length);
  }

  /**
   * Get event marker based on event type and stage
   * @param {Object} eventConfig - Event configuration
   * @param {string} stage - Event stage
   * @returns {string} Event marker
   */
  getEventMarker(eventConfig, stage) {
    switch (stage) {
      case 'start':
        return eventConfig.start;
      case 'end':
        return eventConfig.end;
      case 'error':
        return eventConfig.error;
      default:
        return eventConfig.start;
    }
  }

  /**
   * Format timestamp for display
   * @param {Date} date - Date to format
   * @returns {string} Formatted timestamp
   */
  formatTimestamp(date) {
    return date.toLocaleTimeString('en-US', {
      hour12: false,
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
  }

  /**
   * Format details object for display
   * @param {Object} details - Details object
   * @returns {string} Formatted details
   */
  formatDetails(details) {
    try {
      let formatted = '';
      for (const [key, value] of Object.entries(details)) {
        if (value !== null && value !== undefined) {
          formatted += `  ${key}: ${value}\n`;
        }
      }
      return formatted;
    } catch (error) {
      this.logger.error('Error formatting details', {
        error: error.message
      });
      return '';
    }
  }

  /**
   * Format progress statistics
   * @param {Object} stats - Progress statistics
   * @returns {string} Formatted statistics
   */
  formatProgressStats(stats) {
    try {
      let formatted = '  Statistics:\n';
      const statLabels = {
        processed: 'Processed',
        success: 'Success',
        failed: 'Failed',
        skipped: 'Skipped',
        duplicates: 'Duplicates'
      };
      for (const [key, value] of Object.entries(stats)) {
        if (value !== null && value !== undefined && statLabels[key]) {
          formatted += `    ${statLabels[key]}: ${value}\n`;
        }
      }
      return formatted;
    } catch (error) {
      this.logger.error('Error formatting progress stats', {
        error: error.message
      });
      return '';
    }
  }

  /**
   * Format error details
   * @param {Object} errorDetails - Error details
   * @returns {string} Formatted error details
   */
  formatErrorDetails(errorDetails) {
    try {
      let formatted = '  Error Details:\n';
      for (const [key, value] of Object.entries(errorDetails)) {
        if (value !== null && value !== undefined) {
          formatted += `    ${key}: ${value}\n`;
        }
      }
      return formatted;
    } catch (error) {
      this.logger.error('Error formatting error details', {
        error: error.message
      });
      return '';
    }
  }

  /**
   * Format operation results
   * @param {Object} results - Operation results
   * @returns {string} Formatted results
   */
  formatResults(results) {
    try {
      let formatted = '  Results:\n';
      const resultLabels = {
        total: 'Total Records',
        success: 'Successful',
        failed: 'Failed',
        skipped: 'Skipped',
        duplicates: 'Duplicates',
        duration: 'Duration'
      };
      for (const [key, value] of Object.entries(results)) {
        if (value !== null && value !== undefined && resultLabels[key]) {
          let displayValue = value;
          if (key === 'duration' && typeof value === 'number') {
            displayValue = this.formatDuration(value);
          }
          formatted += `    ${resultLabels[key]}: ${displayValue}\n`;
        }
      }
      return formatted;
    } catch (error) {
      this.logger.error('Error formatting results', {
        error: error.message
      });
      return '';
    }
  }

  /**
   * Format duration in milliseconds to human readable format
   * @param {number} milliseconds - Duration in milliseconds
   * @returns {string} Formatted duration
   */
  formatDuration(milliseconds) {
    try {
      const seconds = Math.floor(milliseconds / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      if (hours > 0) {
        return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
      } else if (minutes > 0) {
        return `${minutes}m ${seconds % 60}s`;
      } else {
        return `${seconds}s`;
      }
    } catch (error) {
      this.logger.error('Error formatting duration', {
        error: error.message
      });
      return `${milliseconds}ms`;
    }
  }

  /**
   * Update formatting options
   * @param {Object} options - New formatting options
   */
  updateFormattingOptions(options) {
    try {
      this.formattingOptions = {
        ...this.formattingOptions,
        ...options
      };
      this.logger.debug('Formatting options updated', {
        options
      });
    } catch (error) {
      this.logger.error('Error updating formatting options', {
        error: error.message
      });
    }
  }

  /**
   * Get current formatting options
   * @returns {Object} Current formatting options
   */
  getFormattingOptions() {
    return {
      ...this.formattingOptions
    };
  }
}

// Create and export singleton instance
exports.MessageFormatter = MessageFormatter;
const messageFormatter = exports.default = new MessageFormatter();

}).call(this)}).call(this,require('_process'))
},{"./winston-logger.js":70,"_process":29}],57:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pingOneClient = exports.PingOneClient = void 0;
var _winstonLogger = require("./winston-logger.js");
var _uiManager = require("./ui-manager.js");
/**
 * @fileoverview PingOne Client Class
 * 
 * Handles authentication and API communication with PingOne services.
 * Manages token acquisition, caching, and API requests with Winston logging.
 * 
 * Features:
 * - Token management with localStorage caching
 * - Automatic token refresh
 * - API request handling with retry logic
 * - User import and modification operations
 * - Winston logging integration
 */

const ui = window.app && window.app.uiManager;
function handleClientError(error) {
  let userMessage = 'An unexpected error occurred. Please try again.';
  if (error && error.message) {
    if (error.message.includes('Network')) {
      userMessage = 'Network error  check your connection.';
    } else if (error.message.includes('timeout')) {
      userMessage = 'Request timed out  try again.';
    } else if (error.message.includes('401')) {
      userMessage = 'Session expired  please log in again.';
    } else if (error.message.includes('404')) {
      userMessage = 'Resource not found.';
    }
  }
  if (ui) ui.showStatusBar(userMessage, 'error');
}

/**
 * PingOne Client Class
 * 
 * Manages PingOne API authentication and requests with Winston logging.
 */
class PingOneClient {
  constructor() {
    // Initialize browser-compatible logger
    this.logger = {
      info: (msg, data) => console.log(`[PingOneClient] ${msg}`, data || ''),
      debug: (msg, data) => console.debug(`[PingOneClient] ${msg}`, data || ''),
      warn: (msg, data) => console.warn(`[PingOneClient] ${msg}`, data || ''),
      error: (msg, data) => console.error(`[PingOneClient] ${msg}`, data || '')
    };
    this.accessToken = null;
    this.tokenExpiry = null;
    this.baseUrl = '/api/pingone';
    this.initialize();
  }

  /**
   * Initialize the client
   */
  initialize() {
    try {
      this.loadTokenFromStorage();
      this.logger.info('PingOne client initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize PingOne client', {
        error: error.message
      });
    }
  }

  /**
   * Load token from localStorage
   */
  loadTokenFromStorage() {
    try {
      if (typeof localStorage !== 'undefined') {
        const storedToken = localStorage.getItem('pingone_worker_token');
        const storedExpiry = localStorage.getItem('pingone_token_expiry');
        if (storedToken && storedExpiry) {
          const expiryTime = parseInt(storedExpiry, 10);
          const now = Date.now();
          if (expiryTime > now) {
            this.accessToken = storedToken;
            this.tokenExpiry = expiryTime;
            this.logger.info('Token loaded from storage', {
              hasToken: !!this.accessToken,
              expiryTime: new Date(this.tokenExpiry).toISOString()
            });
          } else {
            this.logger.warn('Stored token has expired');
            this.clearToken();
          }
        } else {
          this.logger.debug('No stored token found');
        }
      } else {
        this.logger.warn('localStorage is not available');
      }
    } catch (error) {
      this.logger.error('Error loading token from storage', {
        error: error.message
      });
    }
  }

  /**
   * Save token to localStorage
   */
  saveTokenToStorage(token, expiresIn) {
    try {
      if (typeof localStorage !== 'undefined') {
        const expiryTime = Date.now() + expiresIn * 1000;
        localStorage.setItem('pingone_worker_token', token);
        localStorage.setItem('pingone_token_expiry', expiryTime.toString());
        this.accessToken = token;
        this.tokenExpiry = expiryTime;
        this.logger.info('Token saved to storage', {
          tokenLength: token.length,
          expiresIn,
          expiryTime: new Date(expiryTime).toISOString()
        });
        return true;
      } else {
        this.logger.warn('localStorage is not available, cannot save token');
        return false;
      }
    } catch (error) {
      this.logger.error('Error saving token to storage', {
        error: error.message
      });
      return false;
    }
  }

  /**
   * Clear token from storage
   */
  clearToken() {
    try {
      if (typeof localStorage !== 'undefined') {
        localStorage.removeItem('pingone_worker_token');
        localStorage.removeItem('pingone_token_expiry');
      }
      this.accessToken = null;
      this.tokenExpiry = null;
      this.logger.info('Token cleared from storage');
    } catch (error) {
      this.logger.error('Error clearing token from storage', {
        error: error.message
      });
    }
  }

  /**
   * Update credentials and clear existing token
   * @param {Object} credentials - New credentials object
   */
  updateCredentials(credentials) {
    try {
      this.logger.info('Updating PingOne client credentials');

      // Clear existing token since credentials are changing
      this.clearToken();

      // Store new credentials in localStorage
      if (typeof localStorage !== 'undefined') {
        localStorage.setItem('pingone_credentials', JSON.stringify(credentials));
        this.logger.info('Credentials updated in localStorage');
      }

      // Trigger a custom event to notify other components
      window.dispatchEvent(new CustomEvent('credentials-updated', {
        detail: {
          credentials
        }
      }));
      this.logger.info('Credentials updated successfully');
    } catch (error) {
      this.logger.error('Error updating credentials', {
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Get cached token (alias for getCurrentTokenTimeRemaining for compatibility)
   * Production-ready with comprehensive error handling and validation
   */
  getCachedToken() {
    try {
      // Validate token existence and format
      if (!this.accessToken || typeof this.accessToken !== 'string') {
        this.logger.debug('No valid cached token available');
        return null;
      }

      // Validate expiry timestamp
      if (!this.tokenExpiry || typeof this.tokenExpiry !== 'number') {
        this.logger.warn('Invalid token expiry timestamp');
        this.clearToken(); // Clean up invalid state
        return null;
      }
      const now = Date.now();
      const isExpired = this.tokenExpiry <= now;

      // Add buffer time (5 minutes) to prevent edge cases
      const bufferTime = 5 * 60 * 1000; // 5 minutes in milliseconds
      const isNearExpiry = this.tokenExpiry - now <= bufferTime;
      if (isExpired) {
        this.logger.debug('Cached token is expired');
        this.clearToken(); // Clean up expired token
        return null;
      }
      if (isNearExpiry) {
        this.logger.warn('Token is near expiry, consider refreshing');
      }

      // Validate token format (basic JWT structure check)
      if (!this.accessToken.includes('.') || this.accessToken.split('.').length !== 3) {
        this.logger.error('Invalid token format detected');
        this.clearToken(); // Clean up invalid token
        return null;
      }
      this.logger.debug('Returning valid cached token');
      return this.accessToken;
    } catch (error) {
      this.logger.error('Error getting cached token', {
        error: error.message,
        stack: error.stack,
        tokenLength: this.accessToken ? this.accessToken.length : 0
      });
      // Don't expose token in logs for security
      return null;
    }
  }

  /**
   * Get current token time remaining
   */
  getCurrentTokenTimeRemaining() {
    try {
      if (!this.accessToken || !this.tokenExpiry) {
        return {
          token: null,
          timeRemaining: null,
          isExpired: true
        };
      }
      const now = Date.now();
      const timeRemaining = Math.max(0, this.tokenExpiry - now);
      const isExpired = timeRemaining === 0;
      const timeRemainingFormatted = this.formatDuration(Math.floor(timeRemaining / 1000));

      // Only log debug message every 5 minutes (300000ms) to reduce noise
      const lastLogTime = this.lastTokenTimeLog || 0;
      const timeSinceLastLog = now - lastLogTime;
      if (timeSinceLastLog >= 300000) {
        // 5 minutes
        this.logger.debug('Token time remaining calculated', {
          timeRemaining: timeRemainingFormatted,
          isExpired
        });
        this.lastTokenTimeLog = now;
      }
      return {
        token: this.accessToken,
        timeRemaining: timeRemainingFormatted,
        isExpired
      };
    } catch (error) {
      this.logger.error('Error getting token time remaining', {
        error: error.message
      });
      return {
        token: null,
        timeRemaining: null,
        isExpired: true
      };
    }
  }

  /**
   * Format duration in human-readable format
   */
  formatDuration(seconds) {
    if (seconds <= 0) return 'Expired';
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor(seconds % 3600 / 60);
    const remainingSeconds = seconds % 60;
    if (hours > 0) {
      return `${hours}h ${minutes}m ${remainingSeconds}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${remainingSeconds}s`;
    } else {
      return `${remainingSeconds}s`;
    }
  }

  /**
   * Get an access token using client credentials flow
   * @returns {Promise<string>} Access token
   */
  async getAccessToken() {
    try {
      this.logger.debug('getAccessToken called');

      // Check if we have a valid cached token
      const tokenInfo = this.getCurrentTokenTimeRemaining();
      if (tokenInfo.token && !tokenInfo.isExpired) {
        this.logger.debug('Using cached token', {
          tokenPreview: tokenInfo.token.substring(0, 8) + '...',
          timeRemaining: tokenInfo.timeRemaining
        });
        return tokenInfo.token;
      }
      this.logger.debug('Fetching token from /api/pingone/get-token');

      // Fetch new token from server
      const response = await fetch('/api/pingone/get-token', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          // You can add additional parameters here if needed
          // useOverrideCredentials: false
        })
      });
      this.logger.debug('Fetch response', {
        status: response.status,
        ok: response.ok
      });
      if (!response.ok) {
        const errorMsg = await response.text();
        this.logger.error('Fetch error', {
          status: response.status,
          error: errorMsg
        });
        throw new Error(`Failed to get token: ${response.status} ${errorMsg}`);
      }
      const data = await response.json();
      this.logger.debug('Data received from server', {
        hasAccessToken: !!data.access_token,
        expiresIn: data.expires_in,
        success: data.success
      });
      if (!data.success) {
        this.logger.warn('Server returned error', {
          data
        });
        throw new Error(data.error || 'Failed to get token from server');
      }
      if (!data.access_token) {
        this.logger.warn('No access_token in server response', {
          data
        });
        throw new Error('No access token received from server');
      }

      // Save token to storage
      const tokenSaved = this.saveTokenToStorage(data.access_token, data.expires_in || 3600);
      if (tokenSaved) {
        this.logger.debug('Token saved to localStorage', {
          tokenLength: data.access_token.length,
          expiresIn: data.expires_in || 3600
        });
      } else {
        this.logger.warn('Failed to store token in localStorage');
      }
      return data.access_token;
    } catch (error) {
      this.logger.error('Error in getAccessToken', {
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Make authenticated API request with retry logic
   */
  async makeRequest(method, url) {
    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    let retryAttempts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 3;
    try {
      const token = await this.getAccessToken();
      for (let attempt = 1; attempt <= retryAttempts; attempt++) {
        try {
          this.logger.debug(`Making API request (attempt ${attempt})`, {
            method,
            url,
            hasData: !!data
          });
          const requestOptions = {
            method,
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json'
            }
          };
          if (data) {
            requestOptions.body = JSON.stringify(data);
          }
          const response = await fetch(`${this.baseUrl}${url}`, requestOptions);
          this.logger.debug(`API request completed (attempt ${attempt})`, {
            status: response.status,
            ok: response.ok
          });
          if (response.ok) {
            const responseData = await response.json();
            return responseData;
          } else {
            const errorText = await response.text();
            this.logger.warn(`API request failed (attempt ${attempt})`, {
              status: response.status,
              error: errorText
            });
            if (attempt === retryAttempts) {
              throw new Error(`API request failed: ${response.status} ${errorText}`);
            }
          }
        } catch (error) {
          this.logger.error(`API request error (attempt ${attempt})`, {
            error: error.message
          });
          if (attempt === retryAttempts) {
            throw error;
          }

          // Wait before retry
          await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
        }
      }
    } catch (error) {
      this.logger.error('All API request attempts failed', {
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Import users from CSV data
   */
  async importUsers(csvData) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    try {
      this.logger.info('importUsers method called', {
        userCount: csvData.length,
        options: Object.keys(options)
      });
      const {
        populationId = null,
        batchSize = 10,
        retryAttempts = 3,
        enableUsers = true,
        skipDuplicatesByEmail = false,
        skipDuplicatesByUsername = false
      } = options;
      this.logger.debug('Initial setup completed', {
        batchSize,
        retryAttempts,
        enableUsers,
        skipDuplicatesByEmail,
        skipDuplicatesByUsername
      });

      // Validate input
      if (!csvData || !Array.isArray(csvData) || csvData.length === 0) {
        throw new Error('Invalid CSV data: must be a non-empty array');
      }
      this.logger.debug('Input validation completed');

      // Handle population selection
      let fallbackPopulationId = populationId;
      if (!fallbackPopulationId) {
        const populationSelect = document.getElementById('import-population-select');
        if (populationSelect && populationSelect.value) {
          fallbackPopulationId = populationSelect.value;
          this.logger.debug('Using selected population from dropdown', {
            fallbackPopulationId
          });
        } else {
          // Try to get from settings
          const settings = JSON.parse(localStorage.getItem('pingone-import-settings') || '{}');
          fallbackPopulationId = settings.populationId;
          this.logger.debug('Using default population from settings', {
            fallbackPopulationId
          });
        }
      }

      // Prepare sets for duplicate detection
      const seenEmails = new Set();
      const seenUsernames = new Set();

      // Process users in batches
      const totalUsers = csvData.length;
      const results = {
        success: true,
        processed: 0,
        created: 0,
        skipped: 0,
        failed: 0,
        errors: []
      };
      this.logger.debug('Starting user processing loop...');
      for (let i = 0; i < totalUsers; i += batchSize) {
        const batch = csvData.slice(i, i + batchSize);
        this.logger.debug(`Processing batch ${Math.floor(i / batchSize) + 1}`, {
          users: `${i + 1}-${Math.min(i + batchSize, totalUsers)}`,
          batchSize: batch.length
        });
        for (const user of batch) {
          try {
            const userPopulationId = user.populationId || fallbackPopulationId;
            if (!userPopulationId) {
              const error = `Missing population  user not processed. Username: ${user.email || user.username}`;
              results.errors.push(error);
              results.skipped++;
              continue;
            }

            // Duplicate detection
            if (skipDuplicatesByEmail && user.email) {
              if (seenEmails.has(user.email.toLowerCase())) {
                this.logger.info(`Skipping duplicate user by email: ${user.email}`);
                results.skipped++;
                continue;
              }
              seenEmails.add(user.email.toLowerCase());
            }
            if (skipDuplicatesByUsername && user.username) {
              if (seenUsernames.has(user.username.toLowerCase())) {
                this.logger.info(`Skipping duplicate user by username: ${user.username}`);
                results.skipped++;
                continue;
              }
              seenUsernames.add(user.username.toLowerCase());
            }

            // Create user
            const userData = {
              username: user.username || user.email,
              email: user.email,
              name: {
                given: user.firstName || user.givenName || '',
                family: user.lastName || user.familyName || ''
              },
              enabled: enableUsers,
              population: {
                id: userPopulationId
              }
            };

            // Add optional fields
            if (user.phoneNumber) userData.phoneNumber = user.phoneNumber;
            if (user.company) userData.company = user.company;
            const result = await this.createUser(userData, retryAttempts);
            if (result.success) {
              results.created++;
              // Disable user if requested
              if (!enableUsers && result.userId) {
                this.logger.debug(`Disabling user ${result.userId} after creation`);
                try {
                  await this.makeRequest('PATCH', `/environments/current/users/${result.userId}`, {
                    enabled: false
                  });
                  this.logger.debug(`Successfully disabled user ${result.userId}`);
                } catch (statusError) {
                  this.logger.warn(`Failed to disable user ${result.userId}`, {
                    error: statusError.message
                  });
                }
              }
            } else {
              results.failed++;
              results.errors.push(result.error);
            }
            results.processed++;
          } catch (error) {
            results.failed++;
            results.errors.push(error.message);
          }
        }
      }
      this.logger.info('Batch import summary', {
        total: totalUsers,
        processed: results.processed,
        created: results.created,
        skipped: results.skipped,
        failed: results.failed
      });
      return results;
    } catch (error) {
      this.logger.error('Import users failed', {
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Create a single user
   */
  async createUser(userData) {
    let retryAttempts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
    try {
      for (let attempt = 1; attempt <= retryAttempts; attempt++) {
        try {
          this.logger.debug(`Making API request for user ${userData.email || userData.username} (attempt ${attempt}/${retryAttempts})`);
          const result = await this.makeRequest('POST', '/environments/current/users', userData);
          this.logger.debug(`API request completed for user ${userData.email || userData.username}`);
          if (result.id) {
            const successMessage = `Successfully created user: ${userData.username || userData.email}`;
            this.logger.info(successMessage, {
              userId: result.id,
              populationId: userData.population.id
            });
            return {
              success: true,
              userId: result.id,
              user: result
            };
          } else {
            this.logger.warn('Invalid response structure - no ID found', {
              result
            });
            return {
              success: false,
              error: 'Invalid response structure'
            };
          }
        } catch (error) {
          if (error.message.includes('already exists')) {
            this.logger.debug(`User already exists: ${userData.email || userData.username}`);
            return {
              success: true,
              userId: null,
              user: null,
              message: 'User already exists'
            };
          }
          this.logger.error(`API request failed for user ${userData.email || userData.username} (attempt ${attempt})`, {
            error: error.message
          });
          if (attempt === retryAttempts) {
            return {
              success: false,
              error: error.message
            };
          }

          // Wait before retry
          await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
        }
      }
    } catch (error) {
      this.logger.error('Create user failed', {
        error: error.message,
        userData
      });
      return {
        success: false,
        error: error.message
      };
    }
  }
}

// Create and export default instance
exports.PingOneClient = PingOneClient;
const pingOneClient = exports.pingOneClient = new PingOneClient();

// Export the class and instance

},{"./ui-manager.js":68,"./winston-logger.js":70}],58:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.PopulationSubsystem = void 0;
/**
 * Population Subsystem
 * Centralized population management system for dropdown handling and population operations
 * Provides population loading, caching, filtering, and event integration
 */

class PopulationSubsystem {
  constructor(eventBus, settingsSubsystem, loggingSubsystem, apiClient) {
    this.eventBus = eventBus;
    this.settingsSubsystem = settingsSubsystem;
    this.loggingSubsystem = loggingSubsystem;
    this.apiClient = apiClient;

    // Population cache
    this.populationCache = new Map();
    this.cacheExpiry = 5 * 60 * 1000; // 5 minutes
    this.lastCacheUpdate = null;

    // Population loading state
    this.isLoading = false;
    this.loadingPromise = null;

    // Dropdown management
    this.managedDropdowns = new Set();
    this.dropdownConfigs = new Map();

    // Initialize subsystem
    this.init();
    if (this.loggingSubsystem) {
      this.loggingSubsystem.info('PopulationSubsystem initialized successfully', {}, 'system');
    }
  }

  /**
   * Initialize the population subsystem
   */
  async init() {
    try {
      // Set up event listeners
      this.setupEventListeners();

      // Load cached populations if available
      this.loadCachedPopulations();
      if (this.loggingSubsystem) {
        this.loggingSubsystem.info('PopulationSubsystem initialization complete', {
          cachedPopulations: this.populationCache.size
        }, 'system');
      }
    } catch (error) {
      if (this.loggingSubsystem) {
        this.loggingSubsystem.error('Failed to initialize PopulationSubsystem', error, 'system');
      }
      throw error;
    }
  }

  /**
   * Set up event listeners for cross-subsystem communication
   */
  setupEventListeners() {
    if (this.eventBus) {
      // Listen for settings changes that might affect populations
      this.eventBus.on('settingsChanged', () => {
        this.invalidateCache();
      });

      // Listen for authentication events
      this.eventBus.on('authenticationSuccess', () => {
        this.refreshPopulations();
      });
      this.eventBus.on('authenticationFailed', () => {
        this.clearCache();
      });

      // Listen for population refresh requests
      this.eventBus.on('refreshPopulations', data => {
        this.refreshPopulations(data.force);
      });

      // Listen for dropdown registration
      this.eventBus.on('registerDropdown', data => {
        this.registerDropdown(data.dropdownId, data.config);
      });
    }
  }

  /**
   * Load populations from API with caching
   */
  async loadPopulations() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      force = false,
      useCache = true
    } = options;
    try {
      // Check cache first if not forcing refresh
      if (!force && useCache && this.isCacheValid()) {
        const cached = this.getCachedPopulations();
        if (cached && cached.length > 0) {
          if (this.loggingSubsystem) {
            this.loggingSubsystem.debug('Returning cached populations', {
              count: cached.length
            }, 'system');
          }
          return cached;
        }
      }

      // Prevent multiple simultaneous loads
      if (this.isLoading && this.loadingPromise) {
        return await this.loadingPromise;
      }
      this.isLoading = true;
      this.loadingPromise = this.performPopulationLoad();
      const populations = await this.loadingPromise;

      // Cache the results
      this.cachePopulations(populations);

      // Emit event for UI updates
      if (this.eventBus) {
        this.eventBus.emit('populationsLoaded', {
          populations,
          count: populations.length,
          cached: false
        });
      }
      if (this.loggingSubsystem) {
        this.loggingSubsystem.info('Populations loaded successfully', {
          count: populations.length
        }, 'system');
      }
      return populations;
    } catch (error) {
      if (this.loggingSubsystem) {
        this.loggingSubsystem.error('Failed to load populations', error, 'system');
      }

      // Emit error event
      if (this.eventBus) {
        this.eventBus.emit('populationsLoadFailed', {
          error: error.message
        });
      }
      throw error;
    } finally {
      this.isLoading = false;
      this.loadingPromise = null;
    }
  }

  /**
   * Perform the actual population loading from API
   */
  async performPopulationLoad() {
    if (this.loggingSubsystem) {
      this.loggingSubsystem.debug('Starting performPopulationLoad', {}, 'system');
    }
    if (!this.apiClient) {
      const error = 'API client not available for population loading';
      if (this.loggingSubsystem) {
        this.loggingSubsystem.error(error, {}, 'system');
      }
      throw new Error(error);
    }

    // Check if API client has the required method
    if (typeof this.apiClient.get !== 'function') {
      const error = 'API client does not support HTTP GET requests';
      if (this.loggingSubsystem) {
        this.loggingSubsystem.error(error, {
          apiClientType: typeof this.apiClient
        }, 'system');
      }
      throw new Error(error);
    }
    if (this.loggingSubsystem) {
      this.loggingSubsystem.debug('Making API call to /api/populations', {}, 'system');
    }
    try {
      // Load populations from API using the /api/populations endpoint
      const response = await this.apiClient.get('/api/populations');
      if (this.loggingSubsystem) {
        this.loggingSubsystem.debug('API response received', {
          hasResponse: !!response,
          hasPopulations: !!(response && response.populations),
          populationsIsArray: !!(response && Array.isArray(response.populations)),
          populationCount: response && response.populations ? response.populations.length : 0
        }, 'system');
      }
      if (!response || !Array.isArray(response.populations)) {
        const error = 'Invalid populations response from API';
        if (this.loggingSubsystem) {
          this.loggingSubsystem.error(error, {
            response
          }, 'system');
        }
        throw new Error(error);
      }
      if (this.loggingSubsystem) {
        this.loggingSubsystem.info(`Successfully loaded ${response.populations.length} populations from API`, {}, 'system');
      }
      return response.populations;
    } catch (apiError) {
      if (this.loggingSubsystem) {
        this.loggingSubsystem.error('API call to /api/populations failed', {
          error: apiError.message,
          stack: apiError.stack
        }, 'system');
      }
      throw apiError;
    }
  }

  /**
   * Populate a dropdown with populations
   */
  async populateDropdown(dropdownId) {
    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    try {
      if (this.loggingSubsystem) {
        this.loggingSubsystem.debug(`Starting population dropdown population for: ${dropdownId}`, config, 'system');
      }
      const {
        includeEmpty = true,
        emptyText = 'Select a population',
        emptyValue = '',
        filter = null,
        sortBy = 'name',
        sortOrder = 'asc'
      } = config;

      // Register dropdown for management
      this.registerDropdown(dropdownId, config);
      const dropdown = document.getElementById(dropdownId);
      if (!dropdown) {
        const error = `Dropdown element not found: ${dropdownId}`;
        if (this.loggingSubsystem) {
          this.loggingSubsystem.error(error, {}, 'system');
        }
        throw new Error(error);
      }
      if (this.loggingSubsystem) {
        this.loggingSubsystem.debug(`Dropdown element found, showing loading state for: ${dropdownId}`, {}, 'system');
      }

      // Show loading state
      this.showDropdownLoading(dropdown);
      if (this.loggingSubsystem) {
        this.loggingSubsystem.debug(`Loading populations for dropdown: ${dropdownId}`, {}, 'system');
      }

      // Load populations
      const populations = await this.loadPopulations();

      // Filter populations if needed
      let filteredPopulations = populations;
      if (filter && typeof filter === 'function') {
        filteredPopulations = populations.filter(filter);
      }

      // Sort populations
      filteredPopulations = this.sortPopulations(filteredPopulations, sortBy, sortOrder);

      // Clear existing options
      dropdown.innerHTML = '';

      // Add empty option if requested
      if (includeEmpty) {
        const emptyOption = document.createElement('option');
        emptyOption.value = emptyValue;
        emptyOption.textContent = emptyText;
        dropdown.appendChild(emptyOption);
      }

      // Add population options
      filteredPopulations.forEach(population => {
        const option = document.createElement('option');
        option.value = population.id;
        option.textContent = population.name;
        option.dataset.populationId = population.id;
        option.dataset.populationName = population.name;
        dropdown.appendChild(option);
      });

      // Hide loading state
      this.hideDropdownLoading(dropdown);

      // Emit event for UI updates
      if (this.eventBus) {
        this.eventBus.emit('dropdownPopulated', {
          dropdownId,
          populationCount: filteredPopulations.length
        });
      }
      if (this.loggingSubsystem) {
        this.loggingSubsystem.debug('Dropdown populated successfully', {
          dropdownId,
          populationCount: filteredPopulations.length
        }, 'system');
      }
      return true;
    } catch (error) {
      if (this.loggingSubsystem) {
        this.loggingSubsystem.error('Failed to populate dropdown', {
          dropdownId,
          error: error.message
        }, 'system');
      }

      // Show error state in dropdown
      this.showDropdownError(dropdownId, error.message);

      // Emit error event
      if (this.eventBus) {
        this.eventBus.emit('dropdownPopulationFailed', {
          dropdownId,
          error: error.message
        });
      }
      return false;
    }
  }

  /**
   * Register a dropdown for management
   */
  registerDropdown(dropdownId) {
    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.managedDropdowns.add(dropdownId);
    this.dropdownConfigs.set(dropdownId, config);
    if (this.loggingSubsystem) {
      this.loggingSubsystem.debug('Dropdown registered', {
        dropdownId
      }, 'system');
    }
  }

  /**
   * Refresh all managed dropdowns
   */
  async refreshAllDropdowns() {
    try {
      const refreshPromises = Array.from(this.managedDropdowns).map(dropdownId => {
        const config = this.dropdownConfigs.get(dropdownId) || {};
        return this.populateDropdown(dropdownId, config);
      });
      await Promise.all(refreshPromises);
      if (this.loggingSubsystem) {
        this.loggingSubsystem.info('All dropdowns refreshed', {
          count: this.managedDropdowns.size
        }, 'system');
      }
    } catch (error) {
      if (this.loggingSubsystem) {
        this.loggingSubsystem.error('Failed to refresh all dropdowns', error, 'system');
      }
    }
  }

  /**
   * Refresh populations and update all dropdowns
   */
  async refreshPopulations() {
    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    try {
      // Load fresh populations
      await this.loadPopulations({
        force: true
      });

      // Refresh all managed dropdowns
      await this.refreshAllDropdowns();
      if (this.loggingSubsystem) {
        this.loggingSubsystem.info('Populations refreshed successfully', {}, 'system');
      }
    } catch (error) {
      if (this.loggingSubsystem) {
        this.loggingSubsystem.error('Failed to refresh populations', error, 'system');
      }
    }
  }

  /**
   * Sort populations by specified criteria
   */
  sortPopulations(populations) {
    let sortBy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'name';
    let sortOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'asc';
    return populations.sort((a, b) => {
      let aValue = a[sortBy];
      let bValue = b[sortBy];

      // Handle string comparison
      if (typeof aValue === 'string' && typeof bValue === 'string') {
        aValue = aValue.toLowerCase();
        bValue = bValue.toLowerCase();
      }
      let comparison = 0;
      if (aValue < bValue) {
        comparison = -1;
      } else if (aValue > bValue) {
        comparison = 1;
      }
      return sortOrder === 'desc' ? -comparison : comparison;
    });
  }

  /**
   * Show loading state for dropdown
   */
  showDropdownLoading(dropdown) {
    dropdown.innerHTML = '<option value="">Loading populations...</option>';
    dropdown.disabled = true;
    dropdown.classList.add('loading');
  }

  /**
   * Hide loading state for dropdown
   */
  hideDropdownLoading(dropdown) {
    dropdown.disabled = false;
    dropdown.classList.remove('loading');
  }

  /**
   * Show error state for dropdown
   */
  showDropdownError(dropdownId, errorMessage) {
    const dropdown = document.getElementById(dropdownId);
    if (dropdown) {
      dropdown.innerHTML = `<option value="">Error: ${errorMessage}</option>`;
      dropdown.disabled = false;
      dropdown.classList.add('error');
    }
  }

  /**
   * Cache populations with timestamp
   */
  cachePopulations(populations) {
    this.populationCache.set('populations', populations);
    this.lastCacheUpdate = Date.now();

    // Save to localStorage for persistence
    try {
      localStorage.setItem('pingone-populations-cache', JSON.stringify({
        populations,
        timestamp: this.lastCacheUpdate
      }));
    } catch (error) {
      if (this.loggingSubsystem) {
        this.loggingSubsystem.warn('Failed to save populations to localStorage', error, 'system');
      }
    }
  }

  /**
   * Get cached populations
   */
  getCachedPopulations() {
    return this.populationCache.get('populations') || [];
  }

  /**
   * Check if cache is valid
   */
  isCacheValid() {
    if (!this.lastCacheUpdate) {
      return false;
    }
    const age = Date.now() - this.lastCacheUpdate;
    return age < this.cacheExpiry;
  }

  /**
   * Load cached populations from localStorage
   */
  loadCachedPopulations() {
    try {
      const cached = localStorage.getItem('pingone-populations-cache');
      if (cached) {
        const {
          populations,
          timestamp
        } = JSON.parse(cached);

        // Check if cache is still valid
        const age = Date.now() - timestamp;
        if (age < this.cacheExpiry) {
          this.populationCache.set('populations', populations);
          this.lastCacheUpdate = timestamp;
          if (this.loggingSubsystem) {
            this.loggingSubsystem.debug('Loaded populations from localStorage cache', {
              count: populations.length,
              age: Math.round(age / 1000)
            }, 'system');
          }
        }
      }
    } catch (error) {
      if (this.loggingSubsystem) {
        this.loggingSubsystem.warn('Failed to load populations from localStorage', error, 'system');
      }
    }
  }

  /**
   * Invalidate cache
   */
  invalidateCache() {
    this.populationCache.clear();
    this.lastCacheUpdate = null;

    // Clear localStorage cache
    try {
      localStorage.removeItem('pingone-populations-cache');
    } catch (error) {
      // Ignore localStorage errors
    }
    if (this.loggingSubsystem) {
      this.loggingSubsystem.debug('Population cache invalidated', {}, 'system');
    }
  }

  /**
   * Clear cache completely
   */
  clearCache() {
    this.invalidateCache();
    if (this.loggingSubsystem) {
      this.loggingSubsystem.debug('Population cache cleared', {}, 'system');
    }
  }

  /**
   * Get population by ID
   */
  async getPopulationById(populationId) {
    try {
      const populations = await this.loadPopulations();
      return populations.find(pop => pop.id === populationId) || null;
    } catch (error) {
      if (this.loggingSubsystem) {
        this.loggingSubsystem.error('Failed to get population by ID', {
          populationId,
          error: error.message
        }, 'system');
      }
      return null;
    }
  }

  /**
   * Search populations by name
   */
  async searchPopulations(searchTerm) {
    try {
      const populations = await this.loadPopulations();
      const searchLower = searchTerm.toLowerCase();
      return populations.filter(pop => pop.name.toLowerCase().includes(searchLower) || pop.description && pop.description.toLowerCase().includes(searchLower));
    } catch (error) {
      if (this.loggingSubsystem) {
        this.loggingSubsystem.error('Failed to search populations', {
          searchTerm,
          error: error.message
        }, 'system');
      }
      return [];
    }
  }

  /**
   * Get cache statistics
   */
  getCacheStats() {
    return {
      isValid: this.isCacheValid(),
      lastUpdate: this.lastCacheUpdate,
      age: this.lastCacheUpdate ? Date.now() - this.lastCacheUpdate : null,
      populationCount: this.getCachedPopulations().length,
      managedDropdowns: this.managedDropdowns.size
    };
  }
}

// Export for use in other modules
exports.PopulationSubsystem = PopulationSubsystem;
var _default = exports.default = PopulationSubsystem;

},{}],59:[function(require,module,exports){
(function (process){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ProgressManager = void 0;
var _winstonLogger = require("./winston-logger.js");
var _elementRegistry = require("./element-registry.js");
var _sessionManager = require("./session-manager.js");
var _messageFormatter = _interopRequireDefault(require("./message-formatter.js"));
/**
 * Enhanced Progress Manager Module
 * 
 * Modern, real-time progress UI system with Socket.IO and WebSocket fallback:
 * - Real-time updates via Socket.IO (primary)
 * - WebSocket fallback for reliability
 * - Professional Ping Identity design system
 * - Responsive and accessible
 * - Enhanced visual feedback
 * - Step-by-step progress tracking
 * 
 * Features:
 * - Real-time progress updates via Socket.IO
 * - WebSocket fallback for connection issues
 * - Professional progress indicators
 * - Step-by-step operation tracking
 * - Enhanced error handling and recovery
 * - Accessibility compliance
 * - Production-ready logging
 */

// Enable debug mode for development (set to false in production)
const DEBUG_MODE = process.env.NODE_ENV !== 'production';

/**
 * Enhanced Progress Manager Class
 * 
 * Manages all progress-related UI updates with real-time Socket.IO and WebSocket integration
 */
class ProgressManager {
  constructor() {
    this.logger = (0, _winstonLogger.createWinstonLogger)('pingone-progress');
    this.isEnabled = true; // Will be set to false if progress container is not found
    this.currentOperation = null;
    this.currentSessionId = null;
    this.isActive = false;
    this.startTime = null;
    this.timingInterval = null;
    this.progressCallback = null;
    this.completeCallback = null;
    this.cancelCallback = null;
    this.duplicateHandlingMode = 'skip';

    // Real-time communication
    this.socket = null;
    this.websocket = null;
    this.connectionType = null; // 'socketio' or 'websocket'
    this.connectionRetries = 0;
    this.maxRetries = 3;

    // Stats tracking
    this.stats = {
      processed: 0,
      success: 0,
      failed: 0,
      skipped: 0,
      total: 0
    };
    this.logger.debug('ProgressManager initialized');
  }

  /**
   * Initialize the progress manager and setup core functionality
   */
  initialize() {
    try {
      this.setupElements();
      this.setupEventListeners();
      this.logger.info('Enhanced progress manager initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize progress manager', {
        error: error.message
      });
    }
  }

  /**
   * Setup DOM elements with enhanced design
   */
  setupElements() {
    try {
      // Main progress container - use existing one from HTML or find operation-specific container
      this.progressContainer = document.getElementById('progress-container');

      // If main container not found, we'll dynamically select the appropriate container based on operation
      if (!this.progressContainer) {
        this.logger.info('Main progress container not found - will use operation-specific containers');
        // We'll set isEnabled to true since we'll find the container dynamically when needed
        this.isEnabled = true;
      }

      // Log the progress container details for debugging
      this.logger.info('Progress container found', {
        id: this.progressContainer.id,
        className: this.progressContainer.className,
        display: this.progressContainer.style.display,
        visibility: this.progressContainer.style.visibility,
        offsetParent: this.progressContainer.offsetParent !== null
      });

      // Create enhanced progress content
      this.progressContainer.innerHTML = `
                <div class="progress-overlay">
                    <div class="progress-modal">
                        <div class="progress-header">
                            <div class="operation-info">
                                <h3 class="operation-title">
                                    <i class="fas fa-cog fa-spin"></i>
                                    <span class="title-text">Operation in Progress</span>
                                </h3>
                                <div class="operation-subtitle">Processing your request...</div>
                            </div>
                            <button class="cancel-operation" type="button" aria-label="Cancel operation">
                                <i class="fas fa-times"></i>
                                <span>Cancel</span>
                            </button>
                        </div>
                        
                        <div class="progress-content">
                            <div class="progress-steps">
                                <div class="step active" data-step="init">
                                    <div class="step-icon">
                                        <i class="fas fa-play"></i>
                                    </div>
                                    <div class="step-label">Initializing</div>
                                </div>
                                <div class="step" data-step="validate">
                                    <div class="step-icon">
                                        <i class="fas fa-check"></i>
                                    </div>
                                    <div class="step-label">Validating</div>
                                </div>
                                <div class="step" data-step="process">
                                    <div class="step-icon">
                                        <i class="fas fa-cogs"></i>
                                    </div>
                                    <div class="step-label">Processing</div>
                                </div>
                                <div class="step" data-step="complete">
                                    <div class="step-icon">
                                        <i class="fas fa-check-circle"></i>
                                    </div>
                                    <div class="step-label">Complete</div>
                                </div>
                            </div>
                            
                            <div class="progress-main">
                                <div class="progress-bar-container">
                                    <div class="progress-bar">
                                        <div class="progress-bar-fill"></div>
                                        <div class="progress-bar-glow"></div>
                                    </div>
                                    <div class="progress-percentage">0%</div>
                                </div>
                                
                                <div class="progress-text">Preparing operation...</div>
                                
                                <div class="progress-stats">
                                    <div class="stat-item">
                                        <span class="stat-label">Processed:</span>
                                        <span class="stat-value processed">0</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Success:</span>
                                        <span class="stat-value success">0</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Failed:</span>
                                        <span class="stat-value failed">0</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Skipped:</span>
                                        <span class="stat-value skipped">0</span>
                                    </div>
                                </div>
                                
                                <div class="progress-timing">
                                    <div class="time-elapsed">
                                        <i class="fas fa-clock"></i>
                                        <span>Time: <span class="elapsed-value">00:00</span></span>
                                    </div>
                                    <div class="time-remaining">
                                        <i class="fas fa-hourglass-half"></i>
                                        <span>ETA: <span class="eta-value">Calculating...</span></span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="progress-details">
                                <div class="details-header">
                                    <h4><i class="fas fa-info-circle"></i> Operation Details</h4>
                                </div>
                                <div class="details-content">
                                    <div class="detail-item">
                                        <span class="detail-label">Operation Type:</span>
                                        <span class="detail-value operation-type">-</span>
                                    </div>
                                    <div class="detail-item">
                                        <span class="detail-label">Session ID:</span>
                                        <span class="detail-value session-id">-</span>
                                    </div>
                                    <div class="detail-item">
                                        <span class="detail-label">Population:</span>
                                        <span class="detail-value population-info">-</span>
                                    </div>
                                    <div class="detail-item">
                                        <span class="detail-label">Connection:</span>
                                        <span class="detail-value connection-type">-</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
      this.logger.debug('Progress elements setup completed');
    } catch (error) {
      this.logger.error('Error setting up progress elements', {
        error: error.message
      });
      this.isEnabled = false;
    }
  }

  /**
   * Setup event listeners for progress interactions
   */
  setupEventListeners() {
    if (!this.isEnabled) {
      this.logger.warn('Progress manager not enabled - skipping event listener setup');
      return;
    }
    try {
      // Cancel operation button
      const cancelButton = this.progressContainer.querySelector('.cancel-operation');
      if (cancelButton) {
        cancelButton.addEventListener('click', () => this.cancelOperation());
      }

      // Close progress button (if exists)
      const closeButton = this.progressContainer.querySelector('.close-progress-btn');
      if (closeButton) {
        closeButton.addEventListener('click', () => this.hideProgress());
      }
      this.logger.debug('Progress event listeners setup completed');
    } catch (error) {
      this.logger.error('Error setting up progress event listeners', {
        error: error.message
      });
    }
  }

  /**
   * Start a new operation with progress tracking
   * @param {string} operationType - Type of operation (import, export, delete, modify)
   * @param {Object} options - Operation options
   * @param {number} options.totalUsers - Total number of users
   * @param {string} options.populationName - Population name
   * @param {string} options.populationId - Population ID
   */
  startOperation(operationType) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!this.isEnabled) {
      this.logger.warn('Progress manager not enabled - cannot start operation');
      return;
    }
    this.currentOperation = operationType;
    this.isActive = true;
    this.startTime = Date.now();
    this.resetOperationStats();

    // Select the appropriate progress container based on operation type
    this.selectProgressContainer(operationType);

    // If we still don't have a progress container, try to create one
    if (!this.progressContainer) {
      this.createFallbackProgressContainer(operationType);
    }

    // If we still don't have a container, we can't proceed
    if (!this.progressContainer) {
      this.logger.error('No progress container available for operation', {
        operationType
      });
      return;
    }

    // Initialize the progress container with content if needed
    this.initializeProgressContainer();

    // Update operation details
    this.updateOperationTitle(operationType);
    this.updateOperationDetails(options);

    // Show progress
    this.showProgress();

    // Start timing updates
    this.startTimingUpdates();
    this.logger.info('Operation started', {
      operationType,
      options
    });
  }

  /**
   * Select the appropriate progress container based on operation type
   * @param {string} operationType - Type of operation (import, export, delete, modify)
   */
  selectProgressContainer(operationType) {
    // If we already have a container, keep using it
    if (this.progressContainer && this.progressContainer.parentNode) {
      return;
    }

    // Try to find operation-specific container first
    const containerMap = {
      'import': 'progress-container',
      'delete': 'progress-container-delete',
      'modify': 'progress-container-modify',
      'export': 'progress-container-export'
    };
    const containerId = containerMap[operationType] || 'progress-container';
    this.progressContainer = document.getElementById(containerId);

    // If not found, try the main progress container
    if (!this.progressContainer) {
      this.progressContainer = document.getElementById('progress-container');
    }

    // Log what we found
    if (this.progressContainer) {
      this.logger.info('Selected progress container', {
        id: this.progressContainer.id,
        operationType
      });
    } else {
      this.logger.warn('No progress container found for operation', {
        operationType
      });
    }
  }

  /**
   * Create a fallback progress container if none exists
   * @param {string} operationType - Type of operation
   */
  createFallbackProgressContainer(operationType) {
    try {
      // Create a simple progress container
      const fallbackContainer = document.createElement('div');
      fallbackContainer.id = 'progress-container-fallback';
      fallbackContainer.className = 'progress-container visible';
      fallbackContainer.style.cssText = `
                display: block !important;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.7);
                z-index: 10000;
                display: flex;
                justify-content: center;
                align-items: center;
            `;

      // Add to the document
      document.body.appendChild(fallbackContainer);
      this.progressContainer = fallbackContainer;
      this.logger.info('Created fallback progress container', {
        operationType
      });
    } catch (error) {
      this.logger.error('Failed to create fallback progress container', {
        error: error.message
      });
    }
  }

  /**
   * Initialize the progress container with content if needed
   */
  initializeProgressContainer() {
    // Only initialize if the container is empty
    if (this.progressContainer && !this.progressContainer.querySelector('.progress-overlay')) {
      this.setupElements();
      this.setupEventListeners();
    }
  }

  /**
   * Initialize real-time connection for progress updates
   * @param {string} sessionId - Session ID for tracking
   */
  initializeRealTimeConnection(sessionId) {
    if (!sessionId) {
      this.logger.warn('No session ID provided for real-time connection');
      return;
    }
    this.currentSessionId = sessionId;
    this.connectionRetries = 0;

    // Try Socket.IO first, then fallback to WebSocket
    this.trySocketIOConnection(sessionId);
  }

  /**
   * Try Socket.IO connection for real-time updates
   * @param {string} sessionId - Session ID for tracking
   */
  trySocketIOConnection(sessionId) {
    try {
      // Check if Socket.IO is already loaded globally
      if (typeof io !== 'undefined') {
        this.logger.info('Using global Socket.IO client');
        this.connectWithSocketIO(io, sessionId);
      } else {
        // Try to load Socket.IO dynamically
        this.logger.info('Loading Socket.IO client dynamically');

        // Create a script element to load Socket.IO
        const script = document.createElement('script');
        script.src = '/socket.io/socket.io.js';
        script.async = true;
        script.onload = () => {
          this.logger.info('Socket.IO client loaded successfully');
          if (typeof io !== 'undefined') {
            this.connectWithSocketIO(io, sessionId);
          } else {
            this.logger.warn('Socket.IO loaded but io is undefined, trying WebSocket');
            this.tryWebSocketConnection(sessionId);
          }
        };
        script.onerror = error => {
          this.logger.warn('Failed to load Socket.IO client script', {
            error: error.message
          });
          this.tryWebSocketConnection(sessionId);
        };
        document.head.appendChild(script);
      }
    } catch (error) {
      this.logger.warn('Socket.IO connection setup failed, trying WebSocket', {
        error: error.message
      });
      this.tryWebSocketConnection(sessionId);
    }
  }

  /**
   * Reconnect Socket.IO if connection is lost
   * @param {string} sessionId - Session ID for tracking
   */
  reconnectSocketIO(sessionId) {
    if (this.isReconnecting) return;
    this.isReconnecting = true;
    this.logger.info('Attempting to reconnect Socket.IO', {
      sessionId
    });
    console.log(' [PROGRESS] Attempting to reconnect Socket.IO');

    // Close existing connections
    if (this.socket) {
      this.socket.close();
      this.socket = null;
    }

    // Try to reconnect
    setTimeout(() => {
      this.trySocketIOConnection(sessionId);
      this.isReconnecting = false;
    }, 1000);
  }

  /**
   * Connect with Socket.IO
   * @param {Function} io - Socket.IO client function
   * @param {string} sessionId - Session ID for tracking
   */
  connectWithSocketIO(io, sessionId) {
    try {
      // Create Socket.IO connection
      this.socket = io('/', {
        transports: ['websocket', 'polling'],
        timeout: 5000,
        forceNew: true
      });
      this.socket.on('connect', () => {
        this.connectionType = 'socketio';
        this.updateConnectionType('Socket.IO');
        this.logger.info('Socket.IO connected', {
          sessionId,
          socketId: this.socket.id
        });
        console.log(` [PROGRESS] Socket.IO connected (ID: ${this.socket.id})`);

        // Join session room
        this.socket.emit('registerSession', sessionId);

        // Also try the join-session event for compatibility
        this.socket.emit('join-session', {
          sessionId
        });
      });
      this.socket.on('progress', data => {
        console.log(' [PROGRESS] Received progress event:', data);
        this.handleProgressEvent(data);
      });
      this.socket.on('completion', data => {
        console.log(' [PROGRESS] Received completion event:', data);
        this.handleCompletionEvent(data);
      });

      // Also listen for 'complete' for compatibility
      this.socket.on('complete', data => {
        console.log(' [PROGRESS] Received complete event:', data);
        this.handleCompletionEvent(data);
      });
      this.socket.on('error', data => {
        console.log(' [PROGRESS] Received error event:', data);
        this.handleErrorEvent(data);
      });
      this.socket.on('disconnect', () => {
        console.log(' [PROGRESS] Socket.IO disconnected');
        this.logger.warn('Socket.IO disconnected');
        this.handleConnectionFailure();
      });
      this.socket.on('connect_error', error => {
        console.log(' [PROGRESS] Socket.IO connection error:', error.message);
        this.logger.warn('Socket.IO connection error', {
          error: error.message
        });
        this.handleConnectionFailure();
      });
    } catch (error) {
      this.logger.warn('Socket.IO connection failed, trying WebSocket', {
        error: error.message
      });
      this.tryWebSocketConnection(sessionId);
    }
  }

  /**
   * Try WebSocket connection as fallback
   * @param {string} sessionId - Session ID for tracking
   */
  tryWebSocketConnection(sessionId) {
    try {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/ws`;
      this.websocket = new WebSocket(wsUrl);
      this.websocket.onopen = () => {
        this.connectionType = 'websocket';
        this.updateConnectionType('WebSocket');
        this.logger.info('WebSocket connected', {
          sessionId
        });

        // Send session join message
        this.websocket.send(JSON.stringify({
          type: 'join-session',
          sessionId: sessionId
        }));
      };
      this.websocket.onmessage = event => {
        try {
          const data = JSON.parse(event.data);
          switch (data.type) {
            case 'progress':
              this.handleProgressEvent(data);
              break;
            case 'complete':
              this.handleCompletionEvent(data);
              break;
            case 'error':
              this.handleErrorEvent(data);
              break;
          }
        } catch (error) {
          this.logger.error('Error parsing WebSocket message', {
            error: error.message
          });
        }
      };
      this.websocket.onclose = event => {
        this.logger.warn('WebSocket closed', {
          code: event.code,
          reason: event.reason
        });
        this.handleConnectionFailure();
      };
      this.websocket.onerror = error => {
        this.logger.error('WebSocket error', {
          error: error.message
        });
        this.handleConnectionFailure();
      };
    } catch (error) {
      this.logger.error('WebSocket connection failed', {
        error: error.message
      });
      this.handleConnectionFailure();
    }
  }

  /**
   * Handle connection failure and implement fallback strategy
   */
  handleConnectionFailure() {
    this.connectionRetries++;
    if (this.connectionRetries <= this.maxRetries) {
      this.logger.info('Retrying connection', {
        attempt: this.connectionRetries,
        maxRetries: this.maxRetries
      });
      setTimeout(() => {
        if (this.currentSessionId) {
          this.initializeRealTimeConnection(this.currentSessionId);
        }
      }, 1000 * this.connectionRetries); // Exponential backoff
    } else {
      this.logger.warn('Max connection retries reached, falling back to polling');
      this.updateConnectionType('Polling (Fallback)');
    }
  }

  /**
   * Close all real-time connections
   */
  closeConnections() {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
    }
    if (this.websocket) {
      this.websocket.close(1000, 'Operation completed');
      this.websocket = null;
    }
    this.connectionType = null;
    this.logger.debug('Real-time connections closed');
  }

  /**
   * Update session ID for tracking
   * @param {string} sessionId - New session ID
   */
  updateSessionId(sessionId) {
    if (!sessionId) {
      this.logger.warn('No session ID provided for update');
      return;
    }
    this.currentSessionId = sessionId;

    // Update session ID display
    const sessionElement = this.progressContainer.querySelector('.detail-value.session-id');
    if (sessionElement) {
      sessionElement.textContent = sessionId;
    }
    this.logger.info('Session ID updated', {
      sessionId
    });
  }

  /**
   * Handle progress event from real-time connection
   * @param {Object} data - Progress event data
   */
  handleProgressEvent(data) {
    if (!data) {
      this.logger.warn('No progress data received');
      return;
    }
    const {
      current,
      total,
      message,
      counts
    } = data;
    this.updateProgress(current, total, message, counts);
    this.logger.debug('Progress event handled', {
      current,
      total,
      message
    });
  }

  /**
   * Handle completion event from real-time connection
   * @param {Object} data - Completion event data
   */
  handleCompletionEvent(data) {
    this.completeOperation(data);
    this.logger.info('Completion event handled', {
      data
    });
  }

  /**
   * Handle error event from real-time connection
   * @param {Object} data - Error event data
   */
  handleErrorEvent(data) {
    const {
      message,
      details
    } = data;
    this.handleOperationError(message, details);
    this.logger.error('Error event handled', {
      message,
      details
    });
  }

  /**
   * Update progress display with current values
   * @param {number} current - Current progress value
   * @param {number} total - Total progress value
   * @param {string} message - Progress message
   * @param {Object} details - Additional progress details
   */
  updateProgress(current, total) {
    let message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    let details = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    if (!this.isEnabled || !this.progressContainer) {
      this.logger.warn('Progress manager not enabled or container not found');
      return;
    }

    // Update progress bar
    const progressBar = this.progressContainer.querySelector('.progress-bar-fill');
    if (progressBar) {
      const percentage = total > 0 ? Math.min(100, Math.round(current / total * 100)) : 0;
      progressBar.style.width = `${percentage}%`;
    }

    // Update percentage text
    const percentageElement = this.progressContainer.querySelector('.progress-percentage');
    if (percentageElement) {
      const percentage = total > 0 ? Math.min(100, Math.round(current / total * 100)) : 0;
      percentageElement.textContent = `${percentage}%`;
    }

    // Update progress text
    const progressText = this.progressContainer.querySelector('.progress-text');
    if (progressText && message) {
      progressText.textContent = message;
    }

    // Update step indicator based on progress
    if (total > 0) {
      const percentage = current / total * 100;
      this.updateStepIndicatorBasedOnProgress(percentage);
    }

    // Update statistics if provided
    if (details && typeof details === 'object') {
      this.stats = {
        ...this.stats,
        ...details
      };
      this.updateStatsDisplay();
    }
    this.logger.debug('Progress updated', {
      current,
      total,
      message,
      details
    });
  }

  /**
   * Update statistics display in the UI
   */
  updateStatsDisplay() {
    if (!this.progressContainer) return;
    Object.entries(this.stats).forEach(_ref => {
      let [key, value] = _ref;
      const statElement = this.progressContainer.querySelector(`.stat-value.${key}`);
      if (statElement) {
        statElement.textContent = value || 0;
      }
    });
    this.logger.debug('Statistics display updated', {
      stats: this.stats
    });
  }

  /**
   * Update step indicator based on progress percentage
   * @param {number} percentage - Progress percentage (0-100)
   */
  updateStepIndicatorBasedOnProgress(percentage) {
    let step = 'init';
    if (percentage >= 100) {
      step = 'complete';
    } else if (percentage >= 75) {
      step = 'process';
    } else if (percentage >= 25) {
      step = 'validate';
    }
    this.updateStepIndicator(step);
  }

  /**
   * Update step indicator to show current operation phase
   * @param {string} step - Step name (init, validate, process, complete)
   */
  updateStepIndicator(step) {
    if (!this.progressContainer) return;
    const steps = this.progressContainer.querySelectorAll('.step');
    steps.forEach(stepElement => {
      stepElement.classList.remove('active', 'completed');
    });
    const currentStep = this.progressContainer.querySelector(`[data-step="${step}"]`);
    if (currentStep) {
      currentStep.classList.add('active');
    }

    // Mark previous steps as completed
    const stepOrder = this.getStepOrder(step);
    steps.forEach(stepElement => {
      const stepName = stepElement.getAttribute('data-step');
      const stepIndex = this.getStepOrder(stepName);
      if (stepIndex < stepOrder) {
        stepElement.classList.add('completed');
      }
    });
    this.logger.debug('Step indicator updated', {
      step
    });
  }

  /**
   * Get step order for comparison
   * @param {string} step - Step name
   * @returns {number} Step order (0-3)
   */
  getStepOrder(step) {
    const order = {
      init: 0,
      validate: 1,
      process: 2,
      complete: 3
    };
    return order[step] || 0;
  }

  /**
   * Start timing updates for operation duration
   */
  startTimingUpdates() {
    if (this.timingInterval) {
      clearInterval(this.timingInterval);
    }
    this.timingInterval = setInterval(() => {
      this.updateTiming();
    }, 1000);
    this.logger.debug('Timing updates started');
  }

  /**
   * Update timing display with elapsed time and ETA
   */
  updateTiming() {
    if (!this.startTime || !this.progressContainer) return;
    const elapsed = Date.now() - this.startTime;
    const elapsedElement = this.progressContainer.querySelector('.elapsed-value');
    if (elapsedElement) {
      elapsedElement.textContent = this.formatDuration(elapsed);
    }

    // Calculate ETA if we have progress data
    if (this.stats.total > 0 && this.stats.processed > 0) {
      const progress = this.stats.processed / this.stats.total;
      if (progress > 0) {
        const estimatedTotal = elapsed / progress;
        const remaining = estimatedTotal - elapsed;
        const etaElement = this.progressContainer.querySelector('.eta-value');
        if (etaElement) {
          etaElement.textContent = this.formatDuration(remaining);
        }
      }
    }
    this.logger.debug('Timing updated', {
      elapsed
    });
  }

  /**
   * Complete operation with results
   * @param {Object} results - Operation results
   * @param {number} results.processed - Number of processed items
   * @param {number} results.success - Number of successful items
   * @param {number} results.failed - Number of failed items
   * @param {number} results.skipped - Number of skipped items
   */
  completeOperation() {
    let results = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!this.isEnabled) {
      this.logger.warn('Progress manager not enabled - cannot complete operation');
      return;
    }

    // Stop timing updates
    if (this.timingInterval) {
      clearInterval(this.timingInterval);
      this.timingInterval = null;
    }

    // Close real-time connections
    this.closeConnections();

    // Update final progress
    const {
      processed,
      success,
      failed,
      skipped
    } = results;
    this.updateProgress(processed || 0, processed || 0, 'Operation completed');

    // Update final statistics
    this.stats = {
      ...this.stats,
      ...results
    };
    this.updateStatsDisplay();

    // Mark as complete
    this.updateStepIndicator('complete');

    // Call completion callback if provided
    if (this.completeCallback && typeof this.completeCallback === 'function') {
      this.completeCallback(results);
    }
    this.isActive = false;
    this.logger.info('Operation completed', {
      results
    });
  }

  /**
   * Handle operation error
   * @param {string} message - Error message
   * @param {Object} details - Error details
   */
  handleOperationError(message) {
    let details = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!this.isEnabled) {
      this.logger.warn('Progress manager not enabled - cannot handle error');
      return;
    }

    // Stop timing updates
    if (this.timingInterval) {
      clearInterval(this.timingInterval);
      this.timingInterval = null;
    }

    // Close real-time connections
    this.closeConnections();

    // Update progress text with error
    const progressText = this.progressContainer.querySelector('.progress-text');
    if (progressText) {
      progressText.textContent = `Error: ${message}`;
      progressText.classList.add('error');
    }
    this.isActive = false;
    this.logger.error('Operation error', {
      message,
      details
    });
  }

  /**
   * Cancel current operation
   */
  cancelOperation() {
    if (!this.isEnabled || !this.isActive) {
      this.logger.warn('No active operation to cancel');
      return;
    }

    // Stop timing updates
    if (this.timingInterval) {
      clearInterval(this.timingInterval);
      this.timingInterval = null;
    }

    // Close real-time connections
    this.closeConnections();

    // Call cancel callback if provided
    if (this.cancelCallback && typeof this.cancelCallback === 'function') {
      this.cancelCallback();
    }
    this.isActive = false;
    this.hideProgress();
    this.logger.info('Operation cancelled');
  }

  /**
   * Show progress display
   */
  showProgress() {
    if (!this.isEnabled || !this.progressContainer) {
      this.logger.warn('Progress manager not enabled or container not found');
      return;
    }

    // Make sure the container is visible
    this.progressContainer.style.display = 'block';
    this.progressContainer.classList.add('visible');

    // Force visibility with !important to override any CSS that might hide it
    this.progressContainer.setAttribute('style', 'display: block !important; visibility: visible !important;');

    // Focus management for accessibility
    const cancelButton = this.progressContainer.querySelector('.cancel-operation');
    if (cancelButton) {
      cancelButton.focus();
    }
    this.logger.debug('Progress display shown', {
      containerId: this.progressContainer.id
    });

    // Log to console for debugging
    console.log(` [PROGRESS] Showing progress container: ${this.progressContainer.id}`);
  }

  /**
   * Hide progress display
   */
  hideProgress() {
    if (!this.progressContainer) return;

    // Log before hiding
    this.logger.debug('Hiding progress display', {
      containerId: this.progressContainer.id
    });
    console.log(` [PROGRESS] Hiding progress container: ${this.progressContainer.id}`);
    this.progressContainer.classList.remove('visible');

    // Immediately hide the container
    this.progressContainer.style.display = 'none';
    this.logger.debug('Progress display hidden');
  }

  /**
   * Update operation title
   * @param {string} operationType - Type of operation
   */
  updateOperationTitle(operationType) {
    if (!this.progressContainer) return;
    const titleElement = this.progressContainer.querySelector('.title-text');
    if (titleElement) {
      const titles = {
        import: 'Import Users',
        export: 'Export Users',
        delete: 'Delete Users',
        modify: 'Modify Users'
      };
      titleElement.textContent = titles[operationType] || 'Operation in Progress';
    }
    this.logger.debug('Operation title updated', {
      operationType
    });
  }

  /**
   * Update operation details
   * @param {Object} options - Operation options
   * @param {string} options.populationName - Population name
   * @param {string} options.populationId - Population ID
   * @param {number} options.totalUsers - Total number of users
   */
  updateOperationDetails() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!this.progressContainer) return;
    const {
      populationName,
      populationId,
      totalUsers
    } = options;

    // Update operation type
    const operationTypeElement = this.progressContainer.querySelector('.detail-value.operation-type');
    if (operationTypeElement) {
      operationTypeElement.textContent = this.currentOperation || 'Unknown';
    }

    // Update population info
    const populationElement = this.progressContainer.querySelector('.detail-value.population-info');
    if (populationElement) {
      populationElement.textContent = populationName || populationId || 'Unknown';
    }

    // Update total users in stats
    if (totalUsers) {
      this.stats.total = totalUsers;
      this.updateStatsDisplay();
    }
    this.logger.debug('Operation details updated', {
      options
    });
  }

  /**
   * Update operation status
   * @param {string} status - Operation status
   * @param {string} message - Status message
   */
  updateOperationStatus(status) {
    let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    if (!this.progressContainer) return;
    const subtitleElement = this.progressContainer.querySelector('.operation-subtitle');
    if (subtitleElement) {
      subtitleElement.textContent = message || status;
    }
    this.logger.debug('Operation status updated', {
      status,
      message
    });
  }

  /**
   * Update connection type display
   * @param {string} type - Connection type
   */
  updateConnectionType(type) {
    if (!this.progressContainer) return;
    const connectionElement = this.progressContainer.querySelector('.detail-value.connection-type');
    if (connectionElement) {
      connectionElement.textContent = type;
    }
    this.logger.debug('Connection type updated', {
      type
    });
  }

  /**
   * Reset operation statistics
   */
  resetOperationStats() {
    this.stats = {
      processed: 0,
      success: 0,
      failed: 0,
      skipped: 0,
      total: 0
    };
    this.updateStatsDisplay();
    this.logger.debug('Operation statistics reset');
  }

  /**
   * Format duration in milliseconds to human readable string
   * @param {number} milliseconds - Duration in milliseconds
   * @returns {string} Formatted duration string
   */
  formatDuration(milliseconds) {
    const seconds = Math.floor(milliseconds / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    if (hours > 0) {
      return `${hours}:${String(minutes % 60).padStart(2, '0')}:${String(seconds % 60).padStart(2, '0')}`;
    } else if (minutes > 0) {
      return `${minutes}:${String(seconds % 60).padStart(2, '0')}`;
    } else {
      return `${seconds}s`;
    }
  }

  /**
   * Set progress callback function
   * @param {Function} callback - Progress callback function
   */
  setProgressCallback(callback) {
    this.progressCallback = callback;
    this.logger.debug('Progress callback set');
  }

  /**
   * Set completion callback function
   * @param {Function} callback - Completion callback function
   */
  setCompleteCallback(callback) {
    this.completeCallback = callback;
    this.logger.debug('Completion callback set');
  }

  /**
   * Set cancel callback function
   * @param {Function} callback - Cancel callback function
   */
  setCancelCallback(callback) {
    this.cancelCallback = callback;
    this.logger.debug('Cancel callback set');
  }

  /**
   * Debug logging for development
   * @param {string} area - Debug area
   * @param {string} message - Debug message
   */
  debugLog(area, message) {
    if (DEBUG_MODE) {
      this.logger.debug(`[${area}] ${message}`);
    }
  }

  /**
   * Clean up resources and destroy the progress manager
   */
  destroy() {
    // Stop timing updates
    if (this.timingInterval) {
      clearInterval(this.timingInterval);
      this.timingInterval = null;
    }

    // Close connections
    this.closeConnections();

    // Clear callbacks
    this.progressCallback = null;
    this.completeCallback = null;
    this.cancelCallback = null;

    // Reset state
    this.isActive = false;
    this.currentOperation = null;
    this.currentSessionId = null;
    this.logger.info('Progress manager destroyed');
  }
}

// Create and export default instance
exports.ProgressManager = ProgressManager;
const progressManager = new ProgressManager();

// Export the class and instance
var _default = exports.default = progressManager;

}).call(this)}).call(this,require('_process'))
},{"./element-registry.js":47,"./message-formatter.js":56,"./session-manager.js":61,"./winston-logger.js":70,"@babel/runtime/helpers/interopRequireDefault":2,"_process":29}],60:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ProgressSubsystem = void 0;
/**
 * Progress Management Subsystem
 * Modern replacement for legacy ProgressManager
 * Handles all progress tracking, UI updates, and real-time communication
 */

class ProgressSubsystem {
  constructor(logger, uiManager, eventBus, realtimeComm) {
    this.logger = logger;
    this.uiManager = uiManager;
    this.eventBus = eventBus;
    this.realtimeComm = realtimeComm;

    // Progress state
    this.currentOperation = null;
    this.isActive = false;
    this.stats = {
      processed: 0,
      successful: 0,
      failed: 0,
      total: 0,
      errors: []
    };

    // UI elements
    this.progressContainer = null;
    this.progressBar = null;
    this.statusText = null;
    this.detailsContainer = null;

    // Event listeners
    this.setupEventListeners();
    this.logger.info('Progress Subsystem initialized');
  }

  /**
   * Initialize the progress subsystem
   */
  async init() {
    try {
      this.initializeProgressElements();
      this.setupRealtimeListeners();
      this.logger.info('Progress Subsystem initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize Progress Subsystem', error);
      throw error;
    }
  }

  /**
   * Initialize progress UI elements
   */
  initializeProgressElements() {
    this.progressContainer = document.getElementById('progress-container');
    this.progressBar = document.querySelector('.progress-bar');
    this.statusText = document.querySelector('.progress-status');
    this.detailsContainer = document.querySelector('.progress-details');
    if (!this.progressContainer) {
      this.logger.warn('Progress container not found, creating dynamic elements');
      this.createProgressElements();
    }
  }

  /**
   * Create progress elements dynamically
   */
  createProgressElements() {
    // Create progress container if it doesn't exist
    const container = document.createElement('div');
    container.id = 'progress-container';
    container.className = 'progress-container';
    container.style.display = 'none';
    container.innerHTML = `
            <div class="progress-header">
                <h3 class="progress-title">Operation Progress</h3>
                <button class="progress-close" aria-label="Close progress"></button>
            </div>
            <div class="progress-content">
                <div class="progress-bar-container">
                    <div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                        <div class="progress-fill"></div>
                    </div>
                    <div class="progress-percentage">0%</div>
                </div>
                <div class="progress-status">Ready</div>
                <div class="progress-details">
                    <div class="progress-stats">
                        <span class="stat-item">Processed: <span class="stat-processed">0</span></span>
                        <span class="stat-item">Successful: <span class="stat-successful">0</span></span>
                        <span class="stat-item">Failed: <span class="stat-failed">0</span></span>
                        <span class="stat-item">Total: <span class="stat-total">0</span></span>
                    </div>
                    <div class="progress-errors" style="display: none;">
                        <h4>Errors:</h4>
                        <ul class="error-list"></ul>
                    </div>
                </div>
            </div>
        `;
    document.body.appendChild(container);
    this.progressContainer = container;
    this.progressBar = container.querySelector('.progress-bar');
    this.statusText = container.querySelector('.progress-status');
    this.detailsContainer = container.querySelector('.progress-details');

    // Setup close button
    const closeBtn = container.querySelector('.progress-close');
    closeBtn?.addEventListener('click', () => this.hide());
  }

  /**
   * Setup event listeners
   */
  setupEventListeners() {
    this.eventBus.on('operation:started', data => {
      this.startOperation(data.type, data.options);
    });
    this.eventBus.on('operation:progress', data => {
      this.updateProgress(data);
    });
    this.eventBus.on('operation:completed', data => {
      this.completeOperation(data);
    });
    this.eventBus.on('operation:error', data => {
      this.handleError(data);
    });
  }

  /**
   * Setup real-time listeners
   */
  setupRealtimeListeners() {
    if (this.realtimeComm) {
      this.realtimeComm.on('progress', data => {
        this.updateProgress(data);
      });
      this.realtimeComm.on('operation-complete', data => {
        this.completeOperation(data);
      });
      this.realtimeComm.on('operation-error', data => {
        this.handleError(data);
      });
    }
  }

  /**
   * Start a new operation
   */
  startOperation(operationType) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.currentOperation = operationType;
    this.isActive = true;
    this.stats = {
      processed: 0,
      successful: 0,
      failed: 0,
      total: options.total || 0,
      errors: []
    };
    this.show();
    this.updateOperationDetails(options);
    this.updateStatus(`Starting ${operationType} operation...`);
    this.updateProgressBar(0);
    this.logger.info('Operation started', {
      type: operationType,
      options
    });
    this.eventBus.emit('progress:operation-started', {
      type: operationType,
      options
    });
  }

  /**
   * Update progress
   */
  updateProgress(data) {
    if (!this.isActive) return;

    // Update stats
    if (data.processed !== undefined) this.stats.processed = data.processed;
    if (data.successful !== undefined) this.stats.successful = data.successful;
    if (data.failed !== undefined) this.stats.failed = data.failed;
    if (data.total !== undefined) this.stats.total = data.total;
    if (data.error) this.stats.errors.push(data.error);

    // Update UI
    this.updateProgressBar();
    this.updateStatsDisplay();
    if (data.message) {
      this.updateStatus(data.message);
    }
    this.logger.debug('Progress updated', {
      stats: this.stats,
      message: data.message
    });
    this.eventBus.emit('progress:updated', {
      stats: this.stats,
      data
    });
  }

  /**
   * Update progress bar
   */
  updateProgressBar() {
    let percentage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    if (!this.progressBar) return;
    let percent = percentage;
    if (percent === null && this.stats.total > 0) {
      percent = Math.round(this.stats.processed / this.stats.total * 100);
    }
    if (percent !== null) {
      const fill = this.progressBar.querySelector('.progress-fill');
      const percentageText = this.progressContainer?.querySelector('.progress-percentage');
      if (fill) {
        fill.style.width = `${percent}%`;
      }
      if (percentageText) {
        percentageText.textContent = `${percent}%`;
      }
      this.progressBar.setAttribute('aria-valuenow', percent.toString());
    }
  }

  /**
   * Update stats display
   */
  updateStatsDisplay() {
    if (!this.detailsContainer) return;
    const elements = {
      processed: this.detailsContainer.querySelector('.stat-processed'),
      successful: this.detailsContainer.querySelector('.stat-successful'),
      failed: this.detailsContainer.querySelector('.stat-failed'),
      total: this.detailsContainer.querySelector('.stat-total')
    };
    Object.keys(elements).forEach(key => {
      if (elements[key]) {
        elements[key].textContent = this.stats[key].toString();
      }
    });

    // Update errors display
    if (this.stats.errors.length > 0) {
      this.updateErrorsDisplay();
    }
  }

  /**
   * Update errors display
   */
  updateErrorsDisplay() {
    const errorsContainer = this.detailsContainer?.querySelector('.progress-errors');
    const errorsList = this.detailsContainer?.querySelector('.error-list');
    if (errorsContainer && errorsList) {
      errorsContainer.style.display = 'block';
      errorsList.innerHTML = '';
      this.stats.errors.slice(-5).forEach(error => {
        // Show last 5 errors
        const li = document.createElement('li');
        li.textContent = error.message || error.toString();
        li.className = 'error-item';
        errorsList.appendChild(li);
      });
    }
  }

  /**
   * Update operation details
   */
  updateOperationDetails(options) {
    const title = this.progressContainer?.querySelector('.progress-title');
    if (title) {
      title.textContent = `${this.currentOperation} Operation Progress`;
    }

    // Update any operation-specific details
    if (options.populationName) {
      this.updateStatus(`Processing population: ${options.populationName}`);
    }
  }

  /**
   * Update status text
   */
  updateStatus(message) {
    if (this.statusText) {
      this.statusText.textContent = message;
    }
    this.logger.debug('Status updated', {
      message
    });
  }

  /**
   * Complete operation
   */
  completeOperation(data) {
    this.isActive = false;
    const success = this.stats.failed === 0;
    const message = success ? `${this.currentOperation} completed successfully! Processed ${this.stats.processed} items.` : `${this.currentOperation} completed with ${this.stats.failed} errors. Processed ${this.stats.processed} items.`;
    this.updateStatus(message);
    this.updateProgressBar(100);

    // Auto-hide after delay for successful operations
    if (success) {
      setTimeout(() => this.hide(), 3000);
    }
    this.logger.info('Operation completed', {
      type: this.currentOperation,
      stats: this.stats,
      success
    });
    this.eventBus.emit('progress:operation-completed', {
      type: this.currentOperation,
      stats: this.stats,
      success,
      data
    });
  }

  /**
   * Handle operation error
   */
  handleError(error) {
    this.stats.errors.push(error);
    this.stats.failed++;
    this.updateStatsDisplay();
    this.updateStatus(`Error: ${error.message || error.toString()}`);
    this.logger.error('Operation error', error);
    this.eventBus.emit('progress:error', {
      error,
      stats: this.stats
    });
  }

  /**
   * Show progress container
   */
  show() {
    if (this.progressContainer) {
      this.progressContainer.style.display = 'block';
      this.progressContainer.classList.add('active');
    }
    this.eventBus.emit('progress:shown');
  }

  /**
   * Hide progress container
   */
  hide() {
    if (this.progressContainer) {
      this.progressContainer.style.display = 'none';
      this.progressContainer.classList.remove('active');
    }
    this.isActive = false;
    this.eventBus.emit('progress:hidden');
  }

  /**
   * Reset progress state
   */
  reset() {
    this.currentOperation = null;
    this.isActive = false;
    this.stats = {
      processed: 0,
      successful: 0,
      failed: 0,
      total: 0,
      errors: []
    };
    this.updateProgressBar(0);
    this.updateStatsDisplay();
    this.updateStatus('Ready');
    this.logger.info('Progress subsystem reset');
    this.eventBus.emit('progress:reset');
  }

  /**
   * Get current progress state
   */
  getState() {
    return {
      currentOperation: this.currentOperation,
      isActive: this.isActive,
      stats: {
        ...this.stats
      }
    };
  }

  /**
   * Destroy the progress subsystem
   */
  destroy() {
    this.hide();
    this.isActive = false;
    if (this.progressContainer && this.progressContainer.parentNode) {
      this.progressContainer.parentNode.removeChild(this.progressContainer);
    }
    this.logger.info('Progress Subsystem destroyed');
    this.eventBus.emit('progress:destroyed');
  }
}

// Export for ES modules
exports.ProgressSubsystem = ProgressSubsystem;
var _default = exports.default = ProgressSubsystem;

},{}],61:[function(require,module,exports){
(function (process){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sessionManager = exports.default = void 0;
var _winstonLogger = require("./winston-logger.js");
/**
 * Session Manager for PingOne Import Tool
 * 
 * Handles session ID generation, validation, and management for SSE connections
 * across all operations (import, export, modify, delete).
 * 
 * Features:
 * - Centralized session ID generation
 * - Session ID validation and format checking
 * - Session tracking and cleanup
 * - Error handling for missing/invalid session IDs
 */

/**
 * Session Manager Class
 */
class SessionManager {
  constructor() {
    this.logger = (0, _winstonLogger.createWinstonLogger)({
      service: 'pingone-import-session',
      environment: process.env.NODE_ENV || 'development'
    });
    this.activeSessions = new Map();
    this.sessionCounter = 0;
  }

  /**
   * Generate a unique session ID
   * @returns {string} Unique session identifier
   */
  generateSessionId() {
    try {
      const timestamp = Date.now();
      const random = Math.random().toString(36).substring(2, 15);
      const counter = ++this.sessionCounter;
      const sessionId = `session_${timestamp}_${random}_${counter}`;
      this.logger.debug('Session ID generated', {
        sessionId
      });
      return sessionId;
    } catch (error) {
      this.logger.error('Error generating session ID', {
        error: error.message
      });
      // Fallback to simple timestamp-based ID
      return `session_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
    }
  }

  /**
   * Validate session ID format and structure
   * @param {string} sessionId - Session ID to validate
   * @returns {boolean} True if valid, false otherwise
   */
  validateSessionId(sessionId) {
    try {
      if (!sessionId || typeof sessionId !== 'string') {
        this.logger.warn('Session ID validation failed: null/undefined/non-string', {
          sessionId,
          type: typeof sessionId
        });
        return false;
      }
      if (sessionId.trim() === '') {
        this.logger.warn('Session ID validation failed: empty string');
        return false;
      }

      // Check for minimum length (should be at least 8 characters)
      if (sessionId.length < 8) {
        this.logger.warn('Session ID validation failed: too short', {
          length: sessionId.length
        });
        return false;
      }

      // Check for valid characters (alphanumeric, underscore, hyphen)
      const validPattern = /^[a-zA-Z0-9_-]+$/;
      if (!validPattern.test(sessionId)) {
        this.logger.warn('Session ID validation failed: invalid characters', {
          sessionId
        });
        return false;
      }
      this.logger.debug('Session ID validation passed', {
        sessionId
      });
      return true;
    } catch (error) {
      this.logger.error('Error validating session ID', {
        error: error.message,
        sessionId
      });
      return false;
    }
  }

  /**
   * Register an active session
   * @param {string} sessionId - Session ID to register
   * @param {string} operationType - Type of operation (import, export, etc.)
   * @param {Object} metadata - Additional session metadata
   */
  registerSession(sessionId, operationType) {
    let metadata = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    try {
      if (!this.validateSessionId(sessionId)) {
        this.logger.error('Cannot register invalid session ID', {
          sessionId,
          operationType
        });
        return false;
      }
      const sessionData = {
        sessionId,
        operationType,
        createdAt: Date.now(),
        lastActivity: Date.now(),
        metadata
      };
      this.activeSessions.set(sessionId, sessionData);
      this.logger.info('Session registered', {
        sessionId,
        operationType,
        metadata
      });
      return true;
    } catch (error) {
      this.logger.error('Error registering session', {
        error: error.message,
        sessionId,
        operationType
      });
      return false;
    }
  }

  /**
   * Update session activity timestamp
   * @param {string} sessionId - Session ID to update
   */
  updateSessionActivity(sessionId) {
    try {
      const session = this.activeSessions.get(sessionId);
      if (session) {
        session.lastActivity = Date.now();
        this.logger.debug('Session activity updated', {
          sessionId
        });
      } else {
        this.logger.warn('Session not found for activity update', {
          sessionId
        });
      }
    } catch (error) {
      this.logger.error('Error updating session activity', {
        error: error.message,
        sessionId
      });
    }
  }

  /**
   * Unregister a session
   * @param {string} sessionId - Session ID to unregister
   */
  unregisterSession(sessionId) {
    try {
      const session = this.activeSessions.get(sessionId);
      if (session) {
        this.activeSessions.delete(sessionId);
        this.logger.info('Session unregistered', {
          sessionId,
          operationType: session.operationType
        });
      } else {
        this.logger.warn('Session not found for unregistration', {
          sessionId
        });
      }
    } catch (error) {
      this.logger.error('Error unregistering session', {
        error: error.message,
        sessionId
      });
    }
  }

  /**
   * Get session information
   * @param {string} sessionId - Session ID to retrieve
   * @returns {Object|null} Session data or null if not found
   */
  getSession(sessionId) {
    try {
      return this.activeSessions.get(sessionId) || null;
    } catch (error) {
      this.logger.error('Error getting session', {
        error: error.message,
        sessionId
      });
      return null;
    }
  }

  /**
   * Get all active sessions
   * @returns {Array} Array of active session data
   */
  getActiveSessions() {
    try {
      return Array.from(this.activeSessions.values());
    } catch (error) {
      this.logger.error('Error getting active sessions', {
        error: error.message
      });
      return [];
    }
  }

  /**
   * Clean up expired sessions
   * @param {number} maxAge - Maximum age in milliseconds (default: 1 hour)
   */
  cleanupExpiredSessions() {
    let maxAge = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 60 * 60 * 1000;
    try {
      const now = Date.now();
      const expiredSessions = [];
      for (const [sessionId, session] of this.activeSessions.entries()) {
        if (now - session.lastActivity > maxAge) {
          expiredSessions.push(sessionId);
        }
      }
      expiredSessions.forEach(sessionId => {
        this.unregisterSession(sessionId);
      });
      if (expiredSessions.length > 0) {
        this.logger.info('Cleaned up expired sessions', {
          count: expiredSessions.length
        });
      }
    } catch (error) {
      this.logger.error('Error cleaning up expired sessions', {
        error: error.message
      });
    }
  }

  /**
   * Get session statistics
   * @returns {Object} Session statistics
   */
  getSessionStats() {
    try {
      const sessions = this.getActiveSessions();
      const stats = {
        total: sessions.length,
        byOperation: {},
        oldest: null,
        newest: null
      };
      sessions.forEach(session => {
        // Count by operation type
        stats.byOperation[session.operationType] = (stats.byOperation[session.operationType] || 0) + 1;

        // Track oldest and newest
        if (!stats.oldest || session.createdAt < stats.oldest.createdAt) {
          stats.oldest = session;
        }
        if (!stats.newest || session.createdAt > stats.newest.createdAt) {
          stats.newest = session;
        }
      });
      return stats;
    } catch (error) {
      this.logger.error('Error getting session stats', {
        error: error.message
      });
      return {
        total: 0,
        byOperation: {},
        oldest: null,
        newest: null
      };
    }
  }
}

// Export singleton instance
const sessionManager = exports.sessionManager = new SessionManager();
var _default = exports.default = sessionManager;

}).call(this)}).call(this,require('_process'))
},{"./winston-logger.js":70,"_process":29}],62:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.SessionSubsystem = void 0;
/**
 * Session Management Subsystem
 * Modern replacement for legacy SessionManager
 * Handles session lifecycle, activity tracking, and cleanup
 */

class SessionSubsystem {
  constructor(logger, settingsSubsystem, eventBus) {
    this.logger = logger;
    this.settingsSubsystem = settingsSubsystem;
    this.eventBus = eventBus;

    // Session state
    this.currentSession = null;
    this.activeSessions = new Map();
    this.sessionTimeout = 30 * 60 * 1000; // 30 minutes default
    this.cleanupInterval = null;
    this.activityTimer = null;

    // Session configuration
    this.config = {
      maxSessions: 10,
      sessionTimeout: 30 * 60 * 1000,
      activityCheckInterval: 60 * 1000,
      // 1 minute
      autoCleanup: true
    };
    this.setupEventListeners();
    this.logger.info('Session Subsystem initialized');
  }

  /**
   * Initialize the session subsystem
   */
  async init() {
    try {
      await this.loadConfiguration();
      this.startActivityMonitoring();
      this.startCleanupProcess();

      // Create initial session
      await this.createSession();
      this.logger.info('Session Subsystem initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize Session Subsystem', error);
      throw error;
    }
  }

  /**
   * Load session configuration
   */
  async loadConfiguration() {
    try {
      await this.settingsSubsystem.loadCurrentSettings();
      const settings = this.settingsSubsystem.currentSettings;
      if (settings.session) {
        this.config = {
          ...this.config,
          ...settings.session
        };
        this.sessionTimeout = this.config.sessionTimeout;
      }
    } catch (error) {
      this.logger.warn('Failed to load session configuration, using defaults', error);
    }
  }

  /**
   * Setup event listeners
   */
  setupEventListeners() {
    // Listen for user activity events
    this.eventBus.on('user:activity', () => {
      this.updateActivity();
    });

    // Listen for authentication events
    this.eventBus.on('auth:login', data => {
      this.handleLogin(data);
    });
    this.eventBus.on('auth:logout', () => {
      this.handleLogout();
    });

    // Listen for settings changes
    this.eventBus.on('settings:updated', data => {
      if (data.session) {
        this.updateConfiguration(data.session);
      }
    });

    // Browser events
    window.addEventListener('beforeunload', () => {
      this.handleBeforeUnload();
    });
    window.addEventListener('focus', () => {
      this.updateActivity();
    });

    // Activity detection events
    const activityEvents = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'];
    activityEvents.forEach(event => {
      document.addEventListener(event, () => {
        this.updateActivity();
      }, {
        passive: true
      });
    });
  }

  /**
   * Create a new session
   */
  async createSession() {
    let userId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    const sessionId = this.generateSessionId();
    const session = {
      id: sessionId,
      userId: userId,
      createdAt: Date.now(),
      lastActivity: Date.now(),
      expiresAt: Date.now() + this.sessionTimeout,
      isActive: true,
      metadata: {
        userAgent: navigator.userAgent,
        timestamp: new Date().toISOString(),
        url: window.location.href
      }
    };
    this.activeSessions.set(sessionId, session);
    this.currentSession = session;

    // Cleanup old sessions if needed
    if (this.activeSessions.size > this.config.maxSessions) {
      this.cleanupOldSessions();
    }
    this.logger.info('Session created', {
      sessionId,
      userId,
      totalSessions: this.activeSessions.size
    });
    this.eventBus.emit('session:created', {
      session
    });
    return session;
  }

  /**
   * Update session activity
   */
  updateActivity() {
    if (!this.currentSession) return;
    const now = Date.now();
    this.currentSession.lastActivity = now;
    this.currentSession.expiresAt = now + this.sessionTimeout;

    // Update in sessions map
    this.activeSessions.set(this.currentSession.id, this.currentSession);
    this.logger.debug('Session activity updated', {
      sessionId: this.currentSession.id,
      lastActivity: new Date(now).toISOString()
    });
    this.eventBus.emit('session:activity', {
      sessionId: this.currentSession.id,
      timestamp: now
    });
  }

  /**
   * Handle user login
   */
  async handleLogin(data) {
    if (this.currentSession) {
      this.currentSession.userId = data.userId;
      this.currentSession.lastActivity = Date.now();
      this.activeSessions.set(this.currentSession.id, this.currentSession);
    } else {
      await this.createSession(data.userId);
    }
    this.logger.info('User logged in', {
      userId: data.userId,
      sessionId: this.currentSession?.id
    });
    this.eventBus.emit('session:login', {
      userId: data.userId,
      sessionId: this.currentSession?.id
    });
  }

  /**
   * Handle user logout
   */
  handleLogout() {
    if (this.currentSession) {
      this.endSession(this.currentSession.id);
    }
    this.logger.info('User logged out');
    this.eventBus.emit('session:logout');
  }

  /**
   * End a session
   */
  endSession(sessionId) {
    const session = this.activeSessions.get(sessionId);
    if (session) {
      session.isActive = false;
      session.endedAt = Date.now();
      this.activeSessions.delete(sessionId);
      if (this.currentSession && this.currentSession.id === sessionId) {
        this.currentSession = null;
      }
      this.logger.info('Session ended', {
        sessionId
      });
      this.eventBus.emit('session:ended', {
        sessionId,
        session
      });
    }
  }

  /**
   * Start activity monitoring
   */
  startActivityMonitoring() {
    if (this.activityTimer) {
      clearInterval(this.activityTimer);
    }
    this.activityTimer = setInterval(() => {
      this.checkSessionExpiry();
    }, this.config.activityCheckInterval);
    this.logger.debug('Activity monitoring started');
  }

  /**
   * Check for expired sessions
   */
  checkSessionExpiry() {
    const now = Date.now();
    const expiredSessions = [];
    this.activeSessions.forEach((session, sessionId) => {
      if (session.expiresAt < now) {
        expiredSessions.push(sessionId);
      }
    });
    expiredSessions.forEach(sessionId => {
      this.logger.info('Session expired', {
        sessionId
      });
      this.endSession(sessionId);
      this.eventBus.emit('session:expired', {
        sessionId
      });
    });
    if (expiredSessions.length > 0) {
      this.logger.info('Expired sessions cleaned up', {
        count: expiredSessions.length
      });
    }
  }

  /**
   * Start cleanup process
   */
  startCleanupProcess() {
    if (!this.config.autoCleanup) return;
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
    }

    // Run cleanup every 5 minutes
    this.cleanupInterval = setInterval(() => {
      this.cleanupOldSessions();
    }, 5 * 60 * 1000);
    this.logger.debug('Cleanup process started');
  }

  /**
   * Cleanup old sessions
   */
  cleanupOldSessions() {
    const sessions = Array.from(this.activeSessions.values());
    const sortedSessions = sessions.sort((a, b) => b.lastActivity - a.lastActivity);

    // Keep only the most recent sessions up to maxSessions
    const sessionsToRemove = sortedSessions.slice(this.config.maxSessions);
    sessionsToRemove.forEach(session => {
      this.endSession(session.id);
    });
    if (sessionsToRemove.length > 0) {
      this.logger.info('Old sessions cleaned up', {
        count: sessionsToRemove.length
      });
    }
  }

  /**
   * Update configuration
   */
  updateConfiguration(newConfig) {
    this.config = {
      ...this.config,
      ...newConfig
    };
    this.sessionTimeout = this.config.sessionTimeout;

    // Restart monitoring with new config
    this.startActivityMonitoring();
    this.startCleanupProcess();
    this.logger.info('Session configuration updated', this.config);
    this.eventBus.emit('session:config-updated', this.config);
  }

  /**
   * Handle before unload
   */
  handleBeforeUnload() {
    if (this.currentSession) {
      // Mark session as potentially ending
      this.eventBus.emit('session:before-unload', {
        sessionId: this.currentSession.id
      });
    }
  }

  /**
   * Generate unique session ID
   */
  generateSessionId() {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substr(2, 9);
    return `session_${timestamp}_${random}`;
  }

  /**
   * Get current session
   */
  getCurrentSession() {
    return this.currentSession;
  }

  /**
   * Get session by ID
   */
  getSession(sessionId) {
    return this.activeSessions.get(sessionId);
  }

  /**
   * Get all active sessions
   */
  getActiveSessions() {
    return Array.from(this.activeSessions.values());
  }

  /**
   * Get active session count
   */
  getActiveSessionCount() {
    return this.activeSessions.size;
  }

  /**
   * Get session statistics
   */
  getSessionStats() {
    const sessions = this.getActiveSessions();
    const now = Date.now();
    return {
      totalSessions: sessions.length,
      activeSessions: sessions.filter(s => s.isActive).length,
      expiredSessions: sessions.filter(s => s.expiresAt < now).length,
      averageSessionDuration: this.calculateAverageSessionDuration(sessions),
      oldestSession: sessions.reduce((oldest, session) => !oldest || session.createdAt < oldest.createdAt ? session : oldest, null),
      newestSession: sessions.reduce((newest, session) => !newest || session.createdAt > newest.createdAt ? session : newest, null)
    };
  }

  /**
   * Calculate average session duration
   */
  calculateAverageSessionDuration(sessions) {
    if (sessions.length === 0) return 0;
    const totalDuration = sessions.reduce((total, session) => {
      const endTime = session.endedAt || Date.now();
      return total + (endTime - session.createdAt);
    }, 0);
    return Math.round(totalDuration / sessions.length);
  }

  /**
   * Export session data
   */
  exportSessionData() {
    const sessions = this.getActiveSessions();
    const stats = this.getSessionStats();
    return {
      currentSession: this.currentSession,
      sessions: sessions.map(session => ({
        ...session,
        duration: (session.endedAt || Date.now()) - session.createdAt
      })),
      statistics: stats,
      configuration: this.config,
      exportedAt: new Date().toISOString()
    };
  }

  /**
   * Destroy the session subsystem
   */
  destroy() {
    // Clear timers
    if (this.activityTimer) {
      clearInterval(this.activityTimer);
      this.activityTimer = null;
    }
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }

    // End all sessions
    this.activeSessions.forEach((session, sessionId) => {
      this.endSession(sessionId);
    });
    this.currentSession = null;
    this.activeSessions.clear();
    this.logger.info('Session Subsystem destroyed');
    this.eventBus.emit('session:destroyed');
  }
}

// Export for ES modules
exports.SessionSubsystem = SessionSubsystem;
var _default = exports.default = SessionSubsystem;

},{}],63:[function(require,module,exports){
(function (process){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SettingsManager = void 0;
var _winstonLogger = require("./winston-logger.js");
var _cryptoUtils = require("./crypto-utils.js");
/**
 * @fileoverview Settings Manager Class
 * 
 * Manages application settings with secure storage and encryption.
 * Handles API credentials, user preferences, and configuration data
 * with automatic encryption for sensitive information.
 * 
 * @param {Object} logger - Winston logger instance for debugging
 */

class SettingsManager {
  /**
   * Create a new SettingsManager instance
   * @param {Object} logger - Winston logger instance for debugging
   */
  constructor() {
    let logger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    // Initialize settings with default values
    this.settings = this.getDefaultSettings();
    this.storageKey = 'pingone-import-settings';
    this.encryptionKey = null;

    // Initialize Winston logger for debugging and error reporting
    this.initializeLogger(logger);

    // Encryption will be initialized in the init method
    this.encryptionInitialized = false;
  }

  /**
   * Initialize the settings manager
   * @returns {Promise<void>}
   */
  async init() {
    try {
      await this.initializeEncryption();
      this.encryptionInitialized = true;
      this.logger.info('Settings manager initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize settings manager', {
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Initialize Winston logger
   * @param {Object} logger - Logger instance
   */
  initializeLogger(logger) {
    if (logger && typeof logger.child === 'function') {
      this.logger = logger.child({
        component: 'settings-manager'
      });
    } else {
      this.logger = (0, _winstonLogger.createWinstonLogger)({
        service: 'pingone-import-settings',
        environment: process.env.NODE_ENV || 'development'
      });
    }
  }

  /**
   * Create a default console logger if none provided
   * @returns {Object} Default logger object
   */
  createDefaultLogger() {
    var _this = this;
    return {
      log: function (msg) {
        let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'info';
        return _this.logger.log(level, `[Settings] ${msg}`);
      },
      info: msg => this.logger.info(`[Settings] ${msg}`),
      warn: msg => this.logger.warn(`[Settings] ${msg}`),
      error: msg => this.logger.error(`[Settings] ${msg}`),
      debug: msg => this.logger.debug(`[Settings] ${msg}`)
    };
  }

  /**
   * Get region info by code
   * @param {string} code - Region code (e.g., 'NA', 'CA', 'EU', 'AU', 'SG', 'AP')
   * @returns {{code: string, tld: string, label: string}} Region information
   */
  static getRegionInfo(code) {
    if (!code) {
      return {
        code: 'NA',
        tld: 'com',
        label: 'North America (excluding Canada)'
      };
    }
    const regions = {
      NA: {
        code: 'NA',
        tld: 'com',
        label: 'North America (excluding Canada)'
      },
      CA: {
        code: 'CA',
        tld: 'ca',
        label: 'Canada'
      },
      EU: {
        code: 'EU',
        tld: 'eu',
        label: 'European Union'
      },
      AU: {
        code: 'AU',
        tld: 'com.au',
        label: 'Australia'
      },
      SG: {
        code: 'SG',
        tld: 'sg',
        label: 'Singapore'
      },
      AP: {
        code: 'AP',
        tld: 'asia',
        label: 'Asia-Pacific'
      }
    };
    return regions[code] || regions['NA'];
  }

  /**
   * Get default settings
   * @returns {Object} Default settings object
   */
  getDefaultSettings() {
    return {
      environmentId: '',
      region: 'NA',
      apiClientId: '',
      populationId: '',
      rateLimit: 50,
      connectionStatus: 'disconnected',
      connectionMessage: 'Not connected',
      lastConnectionTest: null,
      autoSave: true,
      lastUsedDirectory: '',
      theme: 'light',
      pageSize: 50,
      showNotifications: true
    };
  }

  /**
   * Load settings from storage
   * @returns {Promise<Object>} Loaded settings
   */
  async loadSettings() {
    try {
      const storedData = localStorage.getItem(this.storageKey);
      if (!storedData) {
        this.logger.info('No stored settings found, using defaults');
        return this.settings;
      }

      // Try to parse as JSON first (unencrypted)
      try {
        const parsedSettings = JSON.parse(storedData);
        this.settings = {
          ...this.getDefaultSettings(),
          ...parsedSettings
        };
        this.logger.info('Settings loaded successfully (unencrypted)', {
          hasEnvironmentId: !!this.settings.environmentId,
          hasApiClientId: !!this.settings.apiClientId,
          region: this.settings.region
        });
        return this.settings;
      } catch (jsonError) {
        // If JSON parsing fails, try decryption
        if (!this.encryptionInitialized) {
          this.logger.warn('Encryption not initialized and JSON parsing failed, using defaults');
          return this.settings;
        }
        try {
          const decryptedData = await _cryptoUtils.CryptoUtils.decrypt(storedData, this.encryptionKey);
          const parsedSettings = JSON.parse(decryptedData);

          // Merge with defaults to ensure all properties exist
          this.settings = {
            ...this.getDefaultSettings(),
            ...parsedSettings
          };
          this.logger.info('Settings loaded successfully (encrypted)', {
            hasEnvironmentId: !!this.settings.environmentId,
            hasApiClientId: !!this.settings.apiClientId,
            region: this.settings.region
          });
          return this.settings;
        } catch (decryptionError) {
          this.logger.error('Failed to decrypt settings', {
            error: decryptionError.message
          });
          // Return default settings on decryption error
          return this.settings;
        }
      }
    } catch (error) {
      this.logger.error('Failed to load settings', {
        error: error.message
      });
      // Return default settings on error
      return this.settings;
    }
  }

  /**
   * Save settings to storage
   * @param {Object} settings - Settings to save (optional)
   * @returns {Promise<void>}
   */
  async saveSettings() {
    let settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    try {
      if (settings) {
        this.settings = {
          ...this.settings,
          ...settings
        };
      }
      const jsonData = JSON.stringify(this.settings);
      if (!this.encryptionInitialized) {
        this.logger.warn('Encryption not initialized, saving settings without encryption');
        localStorage.setItem(this.storageKey, jsonData);
        this.logger.info('Settings saved successfully (unencrypted)', {
          hasEnvironmentId: !!this.settings.environmentId,
          hasApiClientId: !!this.settings.apiClientId,
          region: this.settings.region
        });
        window.dispatchEvent(new CustomEvent('settings:save-success', {
          detail: {
            message: 'Settings saved successfully (unencrypted).'
          }
        }));
        return;
      }
      try {
        const encryptedData = await _cryptoUtils.CryptoUtils.encrypt(jsonData, this.encryptionKey);
        localStorage.setItem(this.storageKey, encryptedData);
        this.logger.info('Settings saved successfully (encrypted)', {
          hasEnvironmentId: !!this.settings.environmentId,
          hasApiClientId: !!this.settings.apiClientId,
          region: this.settings.region
        });
        window.dispatchEvent(new CustomEvent('settings:save-success', {
          detail: {
            message: 'Settings saved successfully.'
          }
        }));
      } catch (encryptionError) {
        this.logger.warn('Encryption failed, saving settings without encryption', {
          error: encryptionError.message
        });
        localStorage.setItem(this.storageKey, jsonData);
        this.logger.info('Settings saved successfully (unencrypted fallback)', {
          hasEnvironmentId: !!this.settings.environmentId,
          hasApiClientId: !!this.settings.apiClientId,
          region: this.settings.region
        });
        window.dispatchEvent(new CustomEvent('settings:save-success', {
          detail: {
            message: 'Settings saved successfully (encryption failed, used fallback).'
          }
        }));
      }
    } catch (error) {
      this.logger.error('Failed to save settings', {
        error: error.message
      });
      window.dispatchEvent(new CustomEvent('settings:save-error', {
        detail: {
          message: `Failed to save settings: ${error.message}`
        }
      }));
      throw error;
    }
  }

  /**
   * Get a specific setting
   * @param {string} key - Setting key
   * @returns {*} Setting value
   */
  getSetting(key) {
    if (!key) {
      throw new Error('Setting key is required');
    }
    return this.settings[key];
  }

  /**
   * Set a specific setting
   * @param {string} key - Setting key
   * @param {*} value - Setting value
   * @returns {Promise<void>}
   */
  async setSetting(key, value) {
    if (!key) {
      throw new Error('Setting key is required');
    }
    try {
      this.settings[key] = value;
      await this.saveSettings();
      this.logger.debug('Setting updated', {
        key,
        value: typeof value === 'string' ? value : '[object]'
      });
    } catch (error) {
      this.logger.error('Failed to update setting', {
        key,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Get all settings
   * @returns {Object} All settings
   */
  getAllSettings() {
    return {
      ...this.settings
    };
  }

  /**
   * Update multiple settings at once
   * @param {Object} newSettings - New settings to update
   * @returns {Promise<void>}
   */
  async updateSettings(newSettings) {
    if (!newSettings || typeof newSettings !== 'object') {
      throw new Error('New settings object is required');
    }
    try {
      this.settings = {
        ...this.settings,
        ...newSettings
      };
      await this.saveSettings();
      this.logger.info('Multiple settings updated', {
        updatedKeys: Object.keys(newSettings),
        hasEnvironmentId: !!this.settings.environmentId,
        hasApiClientId: !!this.settings.apiClientId
      });
    } catch (error) {
      this.logger.error('Failed to update settings', {
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Reset settings to defaults
   * @returns {Promise<void>}
   */
  async resetSettings() {
    try {
      this.settings = this.getDefaultSettings();
      await this.saveSettings();
      this.logger.info('Settings reset to defaults');
    } catch (error) {
      this.logger.error('Failed to reset settings', {
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Clear all settings
   * @returns {Promise<void>}
   */
  async clearSettings() {
    try {
      localStorage.removeItem(this.storageKey);
      this.settings = this.getDefaultSettings();
      this.logger.info('Settings cleared');
    } catch (error) {
      this.logger.error('Failed to clear settings', {
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Initialize encryption with a key derived from browser and user-specific data
   * @returns {Promise<void>}
   */
  async initializeEncryption() {
    try {
      let deviceId = await this.getDeviceId();
      if (typeof deviceId !== 'string') deviceId = String(deviceId || '');
      if (!deviceId) deviceId = 'fallback-device-id';
      this.encryptionKey = await _cryptoUtils.CryptoUtils.generateKey(deviceId);
      this.logger.debug('Encryption initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize encryption', {
        error: error.message
      });
      // Fallback to a less secure but functional approach
      this.encryptionKey = await _cryptoUtils.CryptoUtils.generateKey('fallback-encryption-key');
      this.logger.warn('Using fallback encryption key');
    }
  }

  /**
   * Generate a device ID based on browser and system information
   * @returns {Promise<string>} A unique device ID
   */
  async getDeviceId() {
    try {
      // Try to get a stored device ID first
      if (this.isLocalStorageAvailable()) {
        const storedDeviceId = localStorage.getItem('pingone-device-id');
        if (storedDeviceId && typeof storedDeviceId === 'string') {
          return storedDeviceId;
        }
      }

      // Generate device ID from browser info
      const navigatorInfo = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        hardwareConcurrency: navigator.hardwareConcurrency,
        deviceMemory: navigator.deviceMemory,
        maxTouchPoints: navigator.maxTouchPoints
      };
      const encoder = new TextEncoder();
      const data = encoder.encode(JSON.stringify(navigatorInfo));
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const deviceId = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
      if (typeof deviceId !== 'string' || !deviceId) {
        return 'fallback-device-id';
      }
      return deviceId;
    } catch (error) {
      this.logger.error('Failed to generate device ID:', error);
      // Fallback to a random string if crypto API fails
      return 'fallback-' + Math.random().toString(36).substring(2, 15);
    }
  }

  /**
   * Check if localStorage is available
   * @returns {boolean} True if localStorage is available
   */
  isLocalStorageAvailable() {
    try {
      const test = 'test';
      localStorage.setItem(test, test);
      localStorage.removeItem(test);
      return true;
    } catch (error) {
      this.logger.warn('localStorage not available', {
        error: error.message
      });
      return false;
    }
  }

  /**
   * Export settings (for backup)
   * @returns {Promise<Object>} Export data
   */
  async exportSettings() {
    try {
      const exportData = {
        settings: this.settings,
        exportDate: new Date().toISOString(),
        version: '1.0'
      };
      this.logger.info('Settings exported', {
        exportDate: exportData.exportDate
      });
      return exportData;
    } catch (error) {
      this.logger.error('Failed to export settings', {
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Import settings (from backup)
   * @param {Object} importData - Import data object
   * @returns {Promise<void>}
   */
  async importSettings(importData) {
    if (!importData) {
      throw new Error('Import data is required');
    }
    if (!importData.settings) {
      throw new Error('Invalid import data: missing settings');
    }
    try {
      this.settings = {
        ...this.getDefaultSettings(),
        ...importData.settings
      };
      await this.saveSettings();
      this.logger.info('Settings imported successfully', {
        importDate: importData.exportDate,
        hasEnvironmentId: !!this.settings.environmentId,
        hasApiClientId: !!this.settings.apiClientId
      });
    } catch (error) {
      this.logger.error('Failed to import settings', {
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Debug method to check localStorage contents
   * @returns {Object|null} Debug information
   */
  debugLocalStorage() {
    try {
      const storedData = localStorage.getItem(this.storageKey);
      if (!storedData) {
        this.logger.info('No data found in localStorage', {
          key: this.storageKey
        });
        return null;
      }
      this.logger.info('localStorage contents found', {
        key: this.storageKey,
        length: storedData.length,
        preview: storedData.substring(0, 100) + (storedData.length > 100 ? '...' : '')
      });

      // Try to parse as JSON
      try {
        const parsed = JSON.parse(storedData);
        this.logger.info('Data is valid JSON', {
          keys: Object.keys(parsed),
          hasEnvironmentId: !!parsed.environmentId,
          hasApiClientId: !!parsed.apiClientId
        });
        return parsed;
      } catch (jsonError) {
        this.logger.info('Data is not valid JSON, likely encrypted', {
          error: jsonError.message
        });
        return 'encrypted';
      }
    } catch (error) {
      this.logger.error('Failed to debug localStorage', {
        error: error.message
      });
      return null;
    }
  }
}

// Export the SettingsManager class
exports.SettingsManager = SettingsManager;

}).call(this)}).call(this,require('_process'))
},{"./crypto-utils.js":45,"./winston-logger.js":70,"_process":29}],64:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SettingsSubsystem = void 0;
/**
 * Settings Management Subsystem
 * 
 * Handles all settings operations with proper separation of concerns.
 * Manages settings form validation, saving, and UI feedback.
 */

class SettingsSubsystem {
  constructor(logger, uiManager, localClient, settingsManager, eventBus, credentialsManager) {
    this.logger = logger;
    this.uiManager = uiManager;
    this.localClient = localClient;
    this.settingsManager = settingsManager;
    this.eventBus = eventBus;
    this.credentialsManager = credentialsManager;

    // Settings state management
    this.isSaving = false;
    this.currentSettings = null;
    this.logger.info('Settings Subsystem initialized');

    // Set up event listeners for cross-subsystem communication
    this.setupCrossSubsystemEvents();
  }

  /**
   * Initialize the settings subsystem
   */
  async init() {
    try {
      this.setupEventListeners();
      await this.loadCurrentSettings();
      this.logger.info('Settings Subsystem initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize Settings Subsystem', error);
      this.uiManager.showSettingsActionStatus('Failed to initialize Settings Subsystem: ' + error.message, 'error');
    }
  }

  /**
   * Set up event listeners for settings-related elements
   */
  setupEventListeners() {
    this.logger.info('Setting up Settings Subsystem event listeners');

    // Save settings button
    const saveBtn = document.getElementById('save-settings');
    if (saveBtn) {
      this.logger.info('Found save settings button, attaching event listener');
      saveBtn.addEventListener('click', async e => {
        e.preventDefault();
        this.logger.info('Save settings button clicked');
        await this.saveSettings();
      });
    } else {
      this.logger.warn('Save settings button not found in DOM');
    }

    // Test connection button
    const testBtn = document.getElementById('test-connection-btn');
    if (testBtn) {
      testBtn.addEventListener('click', async e => {
        e.preventDefault();
        await this.testConnection();
      });
    }

    // Get token button
    const tokenBtn = document.getElementById('get-token-btn');
    if (tokenBtn) {
      tokenBtn.addEventListener('click', async e => {
        e.preventDefault();
        await this.getToken();
      });
    }

    // API secret visibility toggle
    const toggleBtn = document.getElementById('toggle-api-secret-visibility');
    if (toggleBtn) {
      toggleBtn.addEventListener('click', e => {
        e.preventDefault();
        this.toggleSecretVisibility();
      });
    }
    this.logger.info('Settings Subsystem event listeners setup complete');
  }

  /**
   * Load current settings from settings manager
   */
  async loadCurrentSettings() {
    try {
      // Check if settingsManager exists and has getSettings method
      if (!this.settingsManager) {
        this.logger.warn('Settings manager not available, using default settings');
        this.currentSettings = this.getDefaultSettings();
        return;
      }
      if (typeof this.settingsManager.getAllSettings !== 'function') {
        this.logger.warn('Settings manager getAllSettings method not available, using default settings');
        this.currentSettings = this.getDefaultSettings();
        return;
      }

      // Try to load settings from settings manager
      this.currentSettings = this.settingsManager.getAllSettings();

      // If settings are null or empty, use defaults
      if (!this.currentSettings || Object.keys(this.currentSettings).length === 0) {
        this.logger.info('No existing settings found, using defaults');
        this.currentSettings = this.getDefaultSettings();
      }
      this.populateSettingsForm(this.currentSettings);
      this.logger.info('Current settings loaded successfully');
    } catch (error) {
      this.logger.warn('Failed to load current settings, using defaults:', error.message);
      // Don't throw error, use default settings instead
      this.currentSettings = this.getDefaultSettings();
    }
  }

  /**
   * Get default settings
   */
  getDefaultSettings() {
    return {
      environmentId: '',
      apiClientId: '',
      apiSecret: '',
      region: 'NorthAmerica',
      rateLimit: 50,
      populationId: ''
    };
  }

  /**
   * Save settings
   */
  async saveSettings() {
    if (this.isSaving) {
      this.logger.warn('Settings save already in progress');
      return;
    }
    try {
      this.isSaving = true;
      this.logger.info('Starting settings save process');

      // Show immediate feedback
      this.uiManager.showSettingsActionStatus('Saving settings...', 'info');

      // Get form data
      const settings = this.getFormData();
      this.logger.info('Form data extracted:', settings);

      // Validate settings
      if (!this.validateSettings(settings)) {
        return;
      }

      // Save to credentials manager if available
      if (this.credentialsManager) {
        const credentials = {
          environmentId: settings.environmentId || '',
          apiClientId: settings.apiClientId || '',
          apiSecret: settings.apiSecret || '',
          populationId: settings.populationId || '',
          region: settings.region || 'NorthAmerica'
        };
        const validation = this.credentialsManager.validateCredentials(credentials);
        if (!validation.isValid) {
          throw new Error(`Invalid credentials: ${validation.errors.join(', ')}`);
        }
        this.credentialsManager.saveCredentials(credentials);
        this.logger.info('Credentials saved to localStorage');
      }

      // Save to server
      try {
        const response = await this.localClient.post('/api/settings', settings);
        this.logger.info('Settings saved to server successfully');
      } catch (serverError) {
        this.logger.warn('Failed to save to server, but credentials saved to localStorage:', serverError.message);
      }

      // Update settings manager
      this.settingsManager.updateSettings(settings);
      this.currentSettings = settings;

      // Show success feedback
      this.uiManager.showSettingsActionStatus('Settings saved successfully', 'success', {
        autoHideDelay: 3000
      });

      // Update connection status
      this.updateConnectionStatus(' Settings saved! Please - Get token', 'success');

      // Emit event for other subsystems
      if (this.eventBus) {
        this.eventBus.emit('settingsSaved', {
          settings
        });
      }
      this.logger.info('Settings save process completed successfully');
    } catch (error) {
      this.logger.error('Failed to save settings', error);
      this.uiManager.showSettingsActionStatus('Failed to save settings: ' + error.message, 'error', {
        autoHide: false
      });
    } finally {
      this.isSaving = false;
    }
  }

  /**
   * Get form data from settings form
   */
  getFormData() {
    const form = document.getElementById('settings-form');
    if (!form) {
      throw new Error('Settings form not found');
    }
    const formData = new FormData(form);
    const settings = {
      environmentId: document.getElementById('environment-id')?.value || '',
      apiClientId: document.getElementById('api-client-id')?.value || '',
      apiSecret: document.getElementById('api-secret')?.value || '',
      region: document.getElementById('region')?.value || 'NorthAmerica',
      rateLimit: parseInt(document.getElementById('rate-limit')?.value) || 50,
      populationId: document.getElementById('population-id')?.value || ''
    };
    return settings;
  }

  /**
   * Validate settings
   */
  validateSettings(settings) {
    const errors = [];
    if (!settings.environmentId?.trim()) {
      errors.push('Environment ID is required');
    }
    if (!settings.apiClientId?.trim()) {
      errors.push('API Client ID is required');
    }
    if (!settings.apiSecret?.trim()) {
      errors.push('API Secret is required');
    }
    if (!settings.region?.trim()) {
      errors.push('Region is required');
    }
    if (settings.rateLimit && (settings.rateLimit < 1 || settings.rateLimit > 1000)) {
      errors.push('Rate limit must be between 1 and 1000');
    }
    if (errors.length > 0) {
      const errorMessage = 'Validation failed: ' + errors.join(', ');
      this.logger.error('Settings validation failed', {
        errors
      });
      this.uiManager.showSettingsActionStatus(errorMessage, 'error', {
        autoHide: false
      });
      return false;
    }
    return true;
  }

  /**
   * Populate settings form with current values
   */
  populateSettingsForm(settings) {
    if (!settings) return;
    const fields = {
      'environment-id': settings.environmentId,
      'api-client-id': settings.apiClientId,
      'api-secret': settings.apiSecret,
      'region': settings.region,
      'rate-limit': settings.rateLimit,
      'population-id': settings.populationId
    };
    Object.entries(fields).forEach(_ref => {
      let [fieldId, value] = _ref;
      const field = document.getElementById(fieldId);
      if (field && value !== undefined && value !== null) {
        field.value = value;
      }
    });
    this.logger.info('Settings form populated with current values');
  }

  /**
   * Test connection
   */
  async testConnection() {
    try {
      this.logger.info('Testing connection...');
      this.uiManager.showSettingsActionStatus('Testing connection...', 'info');
      const settings = this.getFormData();

      // Test connection via API
      const response = await this.localClient.post('/api/test-connection', settings);
      if (response.success) {
        this.uiManager.showSettingsActionStatus('Connection test successful', 'success', {
          autoHideDelay: 3000
        });
        this.updateConnectionStatus(' Connection successful', 'success');
      } else {
        this.uiManager.showSettingsActionStatus('Connection test failed: ' + response.message, 'error');
        this.updateConnectionStatus(' Connection failed', 'error');
      }
    } catch (error) {
      this.logger.error('Connection test failed', error);
      this.uiManager.showSettingsActionStatus('Connection test failed: ' + error.message, 'error');
      this.updateConnectionStatus(' Connection failed', 'error');
    }
  }

  /**
   * Get token
   */
  async getToken() {
    try {
      this.logger.info('Getting token...');
      this.uiManager.showSettingsActionStatus('Getting token...', 'info');
      const settings = this.getFormData();

      // Get token via API
      const response = await this.localClient.post('/api/token', settings);
      if (response.success) {
        this.uiManager.showSettingsActionStatus('Token obtained successfully', 'success', {
          autoHideDelay: 3000
        });
        this.updateConnectionStatus(' Token obtained', 'success');

        // NEW: Direct global token status updater for sidebar
        console.log(' [DEBUG] SettingsSubsystem: About to call updateGlobalTokenStatusDirect');
        try {
          // Get the main app instance to call the direct updater
          if (window.app && typeof window.app.updateGlobalTokenStatusDirect === 'function') {
            // Calculate time left from token response
            const timeLeft = response.timeLeft || response.timeRemaining || '';
            window.app.updateGlobalTokenStatusDirect(timeLeft);
            console.log(' [DEBUG] SettingsSubsystem: updateGlobalTokenStatusDirect called successfully with timeLeft:', timeLeft);
          } else {
            console.warn(' [DEBUG] SettingsSubsystem: window.app.updateGlobalTokenStatusDirect not available');
          }
        } catch (error) {
          console.error(' [DEBUG] SettingsSubsystem: Error calling updateGlobalTokenStatusDirect:', error);
        }

        // Emit event for other subsystems
        if (this.eventBus) {
          this.eventBus.emit('tokenObtained', {
            token: response.token
          });
        }
      } else {
        this.uiManager.showSettingsActionStatus('Failed to get token: ' + response.message, 'error');
        this.updateConnectionStatus(' Token failed', 'error');
      }
    } catch (error) {
      this.logger.error('Failed to get token', error);
      this.uiManager.showSettingsActionStatus('Failed to get token: ' + error.message, 'error');
      this.updateConnectionStatus(' Token failed', 'error');
    }
  }

  /**
   * Toggle API secret visibility
   */
  toggleSecretVisibility() {
    const secretField = document.getElementById('api-secret');
    const toggleBtn = document.getElementById('toggle-api-secret-visibility');
    const icon = toggleBtn?.querySelector('i');
    if (secretField && toggleBtn && icon) {
      if (secretField.type === 'password') {
        secretField.type = 'text';
        icon.className = 'fas fa-eye-slash';
        toggleBtn.setAttribute('aria-label', 'Hide password');
      } else {
        secretField.type = 'password';
        icon.className = 'fas fa-eye';
        toggleBtn.setAttribute('aria-label', 'Show password');
      }
    }
  }

  /**
   * Update connection status display
   */
  updateConnectionStatus(message, type) {
    const statusElement = document.getElementById('settings-connection-status');
    if (statusElement) {
      statusElement.textContent = message;
      statusElement.className = `connection-status status-${type}`;
    }
  }

  /**
   * Set up cross-subsystem event listeners
   */
  setupCrossSubsystemEvents() {
    if (!this.eventBus) {
      this.logger.warn('EventBus not available for cross-subsystem events');
      return;
    }

    // Listen for token expiration events
    this.eventBus.on('tokenExpired', data => {
      this.logger.warn('Token expired');
      this.updateConnectionStatus(' Token expired', 'warning');
    });

    // Listen for token error events
    this.eventBus.on('tokenError', data => {
      this.logger.error('Token error detected', data);
      this.updateConnectionStatus(' Token error', 'error');
    });

    // Listen for token refresh events
    this.eventBus.on('tokenRefreshed', data => {
      this.logger.info('Token refreshed successfully');
      this.updateConnectionStatus(' Token refreshed', 'success');
    });
    this.logger.debug('Cross-subsystem event listeners set up for SettingsSubsystem');
  }
}
exports.SettingsSubsystem = SettingsSubsystem;

},{}],65:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clearTokenAlertSession = clearTokenAlertSession;
exports.showTokenAlertModal = showTokenAlertModal;
// Token Alert Modal - blocks interaction and guides user to settings if no valid token is available
class TokenAlertModal {
  constructor() {
    let {
      tokenStatus = '',
      expiry = '',
      operation = ''
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (TokenAlertModal.hasShownThisSession()) return;
    TokenAlertModal.setShownThisSession();
    this.operation = operation;
    this.createModal(tokenStatus, expiry);
    this.showModal();
  }
  createModal(tokenStatus, expiry) {
    // Overlay
    const overlay = document.createElement('div');
    overlay.className = 'token-alert-overlay';
    overlay.setAttribute('role', 'dialog');
    overlay.setAttribute('aria-modal', 'true');
    overlay.setAttribute('aria-labelledby', 'token-alert-title');
    overlay.setAttribute('aria-describedby', 'token-alert-content');

    // Modal content with enhanced styling and action button
    overlay.innerHTML = `
            <div class="token-alert-modal" tabindex="-1">
                <div class="token-alert-header">
                    <h2 id="token-alert-title">
                        <span class="warning-icon" aria-hidden="true"></span>
                        <span>Authentication Required</span>
                    </h2>
                    <button type="button" class="token-alert-close" id="token-alert-close" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="token-alert-body">
                    <div id="token-alert-content" class="token-alert-content">
                        <div class="token-alert-icon">
                            <span aria-hidden="true"></span>
                        </div>
                        <h3>No Valid Token Available</h3>
                        <p class="token-alert-message">
                            <strong>Authentication is required to continue.</strong>
                            ${this.operation ? `You need valid credentials to perform the "${this.operation}" operation.` : 'You need valid credentials to use this application.'}
                        </p>
                        ${tokenStatus || expiry ? `<div class="token-status-info">
                            <p><strong>Current Status:</strong> ${tokenStatus ? tokenStatus : 'No token available'}</p>
                            ${expiry ? `<p style="visibility: hidden;"><strong>Token Expired:</strong> ${expiry}</p>` : ''}
                        </div>` : ''}
                        <div class="token-alert-actions">
                            <button type="button" class="btn btn-primary btn-lg" id="token-alert-settings-btn">
                                <span class="btn-icon"></span>
                                Go to Settings
                            </button>
                            <p class="token-alert-help">
                                Add your PingOne credentials in the Settings page to generate a new token.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        `;
    document.body.appendChild(overlay);
    this.overlay = overlay;
    this.modal = overlay.querySelector('.token-alert-modal');
    this.settingsBtn = overlay.querySelector('#token-alert-settings-btn');
    this.closeBtn = overlay.querySelector('#token-alert-close');
    this.bindEvents();
  }
  bindEvents() {
    // Settings button - navigate to settings
    this.settingsBtn.addEventListener('click', () => {
      this.hideModal();
      // Navigate to settings view within the SPA instead of redirecting
      if (window.app && window.app.showView) {
        window.app.showView('settings');
      } else {
        // Fallback: navigate to settings view by triggering the settings nav item
        const settingsNavItem = document.querySelector('[data-view="settings"]');
        if (settingsNavItem) {
          settingsNavItem.click();
        } else {
          // Final fallback: redirect to home page which will show settings
          window.location.href = '/';
        }
      }
    });

    // Close button - allow manual dismissal
    this.closeBtn.addEventListener('click', () => {
      this.hideModal();
    });

    // Trap focus within modal
    this.overlay.addEventListener('keydown', e => this.handleKeyboardNavigation(e));

    // Prevent closing by outside click (modal should be persistent)
    this.overlay.addEventListener('click', e => {
      if (e.target === this.overlay) {
        e.preventDefault();
        // Don't close on outside click - keep modal visible
      }
    });

    // Prevent escape key from closing modal (should be persistent)
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        e.preventDefault();
        // Don't close on escape - keep modal visible
      }
    });
  }
  handleKeyboardNavigation(e) {
    const focusable = this.modal.querySelectorAll('button, [tabindex]:not([tabindex="-1"])');
    if (e.key === 'Tab') {
      if (focusable.length === 0) return;
      const first = focusable[0];
      const last = focusable[focusable.length - 1];
      if (e.shiftKey) {
        if (document.activeElement === first) {
          e.preventDefault();
          last.focus();
        }
      } else {
        if (document.activeElement === last) {
          e.preventDefault();
          first.focus();
        }
      }
    }
  }
  showModal() {
    document.body.classList.add('token-alert-open');
    this.overlay.classList.add('active');
    this.modal.focus();

    // Add styles to body to prevent scrolling
    document.body.style.overflow = 'hidden';
  }
  hideModal() {
    this.overlay.classList.remove('active');
    document.body.classList.remove('token-alert-open');
    document.body.style.overflow = '';
    setTimeout(() => {
      if (this.overlay && this.overlay.parentNode) {
        this.overlay.parentNode.removeChild(this.overlay);
      }
    }, 300);
  }
  static hasShownThisSession() {
    return sessionStorage.getItem('tokenAlertModalShown') === 'true';
  }
  static setShownThisSession() {
    sessionStorage.setItem('tokenAlertModalShown', 'true');
  }
  static clearShownThisSession() {
    sessionStorage.removeItem('tokenAlertModalShown');
  }
}

// Export a function to show the modal
function showTokenAlertModal() {
  let {
    tokenStatus = '',
    expiry = '',
    operation = ''
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  new TokenAlertModal({
    tokenStatus,
    expiry,
    operation
  });
}

// Export function to clear the session flag (useful for testing)
function clearTokenAlertSession() {
  TokenAlertModal.clearShownThisSession();
}

},{}],66:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * TokenManager - Handles OAuth 2.0 token acquisition and caching with automatic re-authentication
 * 
 * Features:
 * - Automatic token refresh before expiry
 * - Detection of token expiration via 401 responses
 * - Automatic retry of failed requests with new tokens
 * - Secure credential storage and retrieval
 * - Rate limiting to prevent API abuse
 */
class TokenManager {
  /**
   * Create a new TokenManager instance
   * @param {Object} logger - Logger instance for logging messages
   * @param {Object} settings - Settings object containing API credentials
   */
  constructor(logger, settings, eventBus) {
    if (!settings) {
      throw new Error('Settings are required for TokenManager');
    }
    this.logger = logger || console;
    this.settings = settings || {};
    this.eventBus = eventBus;
    this.tokenCache = {
      accessToken: null,
      expiresAt: 0,
      tokenType: 'Bearer',
      lastRefresh: 0
    };
    this.tokenExpiryBuffer = 5 * 60 * 1000; // 5 minutes buffer before token expiry
    this.isRefreshing = false;
    this.refreshQueue = [];

    // Auto-retry configuration
    this.maxRetries = 1; // Only retry once with new token
    this.retryDelay = 1000; // 1 second delay before retry

    // Bind methods
    this.getAccessToken = this.getAccessToken.bind(this);
    this._requestNewToken = this._requestNewToken.bind(this);
    this._isTokenValid = this._isTokenValid.bind(this);
    this.handleTokenExpiration = this.handleTokenExpiration.bind(this);
    this.retryWithNewToken = this.retryWithNewToken.bind(this);
  }

  /**
   * Get a valid access token, either from cache or by requesting a new one
   * @returns {Promise<string>} The access token
   */
  async getAccessToken() {
    // Check if we have a valid cached token
    if (this._isTokenValid()) {
      this.logger.debug('Using cached access token');
      return this.tokenCache.accessToken;
    }

    // If a refresh is already in progress, queue this request
    if (this.isRefreshing) {
      return new Promise(resolve => {
        this.refreshQueue.push(resolve);
      });
    }

    // Otherwise, request a new token
    try {
      this.isRefreshing = true;
      const token = await this._requestNewToken();

      // Resolve all queued requests
      while (this.refreshQueue.length > 0) {
        const resolve = this.refreshQueue.shift();
        resolve(token);
      }
      return token;
    } catch (error) {
      // Clear token cache on error
      this.tokenCache = {
        accessToken: null,
        expiresAt: 0,
        tokenType: 'Bearer',
        lastRefresh: 0
      };

      // Emit token error event
      if (this.eventBus) {
        this.eventBus.emit('tokenError', {
          error: error.message
        });
      }

      // Reject all queued requests
      while (this.refreshQueue.length > 0) {
        const resolve = this.refreshQueue.shift();
        resolve(Promise.reject(error));
      }
      throw error;
    } finally {
      this.isRefreshing = false;
    }
  }

  /**
   * Handle token expiration detected from API response
   * @param {Object} response - The failed API response
   * @param {Function} retryFn - Function to retry the original request
   * @returns {Promise<Object>} The retry result
   */
  async handleTokenExpiration(response, retryFn) {
    if (!response) {
      throw new Error('Response is required for token expiration handling');
    }
    if (!retryFn || typeof retryFn !== 'function') {
      throw new Error('Retry function is required for token expiration handling');
    }
    this.logger.warn('Token expiration detected, attempting automatic re-authentication');

    // Clear the expired token
    this.tokenCache = {
      accessToken: null,
      expiresAt: 0,
      tokenType: 'Bearer',
      lastRefresh: 0
    };

    // Emit token expiration event
    if (this.eventBus) {
      this.eventBus.emit('tokenExpired', {
        response
      });
    }
    try {
      // Get a new token using stored credentials
      const newToken = await this.getAccessToken();
      if (!newToken) {
        throw new Error('Failed to obtain new token for retry');
      }
      this.logger.info('Successfully obtained new token, retrying request');

      // Wait a moment before retrying to avoid rate limiting
      await new Promise(resolve => setTimeout(resolve, this.retryDelay));

      // Retry the original request with the new token
      return await retryFn(newToken);
    } catch (error) {
      this.logger.error('Failed to re-authenticate and retry request', {
        error: error.message,
        originalStatus: response.status
      });
      throw error;
    }
  }

  /**
   * Retry a failed request with a new token
   * @param {Function} requestFn - Function that makes the API request
   * @param {Object} options - Request options
   * @returns {Promise<Object>} The API response
   */
  async retryWithNewToken(requestFn) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!requestFn || typeof requestFn !== 'function') {
      throw new Error('Request function is required for retry operation');
    }
    let retryCount = 0;
    while (retryCount <= this.maxRetries) {
      try {
        // Get current token
        const token = await this.getAccessToken();

        // Make the request
        const response = await requestFn(token);

        // Check if the response indicates token expiration
        if (response.status === 401) {
          const responseText = await response.text().catch(() => '');
          const isTokenExpired = responseText.includes('token_expired') || responseText.includes('invalid_token') || responseText.includes('expired');
          if (isTokenExpired && retryCount < this.maxRetries) {
            this.logger.warn(`Token expired on attempt ${retryCount + 1}, retrying with new token`);

            // Clear expired token and get new one
            this.tokenCache = {
              accessToken: null,
              expiresAt: 0,
              tokenType: 'Bearer',
              lastRefresh: 0
            };
            retryCount++;
            continue;
          }
        }

        // If we get here, the request was successful or we've exhausted retries
        return response;
      } catch (error) {
        if (retryCount >= this.maxRetries) {
          throw error;
        }
        this.logger.warn(`Request failed on attempt ${retryCount + 1}, retrying`, {
          error: error.message
        });
        retryCount++;

        // Wait before retrying
        await new Promise(resolve => setTimeout(resolve, this.retryDelay));
      }
    }
    throw new Error('Max retries exceeded');
  }

  /**
   * Create a request wrapper that automatically handles token expiration
   * @param {Function} requestFn - Function that makes the API request
   * @returns {Function} Wrapped function that handles token expiration
   */
  createAutoRetryWrapper(requestFn) {
    var _this = this;
    if (!requestFn || typeof requestFn !== 'function') {
      throw new Error('Request function is required for auto-retry wrapper');
    }
    return async function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return await _this.retryWithNewToken(async token => {
        // Add the token to the request arguments
        const requestArgs = [...args];

        // If the first argument is an options object, add the token to it
        if (requestArgs[0] && typeof requestArgs[0] === 'object') {
          requestArgs[0].headers = {
            ...requestArgs[0].headers,
            'Authorization': `Bearer ${token}`
          };
        }
        return await requestFn(...requestArgs);
      });
    };
  }

  /**
   * Get token information including expiry details
   * @returns {Object|null} Token info object or null if no token
   */
  getTokenInfo() {
    if (!this.tokenCache.accessToken) {
      return null;
    }
    const now = Date.now();
    const expiresIn = Math.max(0, this.tokenCache.expiresAt - now);
    return {
      accessToken: this.tokenCache.accessToken,
      expiresIn: Math.floor(expiresIn / 1000),
      // Convert to seconds
      tokenType: this.tokenCache.tokenType,
      expiresAt: this.tokenCache.expiresAt,
      lastRefresh: this.tokenCache.lastRefresh,
      isValid: this._isTokenValid()
    };
  }

  /**
   * Check if the current token is still valid
   * @returns {boolean} True if token is valid, false otherwise
   * @private
   */
  _isTokenValid() {
    const now = Date.now();
    return this.tokenCache.accessToken && this.tokenCache.expiresAt > now + this.tokenExpiryBuffer &&
    // Ensure token isn't too old (max 1 hour)
    now - this.tokenCache.lastRefresh < 60 * 60 * 1000;
  }

  /**
   * Get the auth domain for a given region
   * @param {string} region - The region to get auth domain for
   * @returns {string} The auth domain URL
   * @private
   */
  _getAuthDomain(region) {
    if (!region) {
      return 'auth.pingone.com';
    }
    const authDomainMap = {
      'NorthAmerica': 'auth.pingone.com',
      'Europe': 'auth.eu.pingone.com',
      'Canada': 'auth.ca.pingone.com',
      'Asia': 'auth.apsoutheast.pingone.com',
      'Australia': 'auth.aus.pingone.com',
      'US': 'auth.pingone.com',
      'EU': 'auth.eu.pingone.com',
      'AP': 'auth.apsoutheast.pingone.com'
    };
    return authDomainMap[region] || 'auth.pingone.com';
  }

  /**
   * Request a new access token from PingOne using stored credentials
   * @returns {Promise<string>} The new access token
   * @private
   */
  async _requestNewToken() {
    const {
      apiClientId,
      apiSecret,
      environmentId,
      region = 'NorthAmerica'
    } = this.settings;
    const requestId = `req_${Math.random().toString(36).substr(2, 9)}`;
    const startTime = Date.now();

    // Validate required settings
    if (!apiClientId || !apiSecret || !environmentId) {
      const error = new Error('Missing required API credentials in settings');
      this.logger.error('Token request failed: Missing credentials', {
        requestId,
        hasClientId: !!apiClientId,
        hasSecret: !!apiSecret,
        hasEnvId: !!environmentId
      });
      throw error;
    }

    // Prepare request
    const authDomain = this._getAuthDomain(region);
    const tokenUrl = `https://${authDomain}/${environmentId}/as/token`;
    const credentials = btoa(`${apiClientId}:${apiSecret}`);
    try {
      this.logger.debug('Requesting new access token from PingOne...', {
        requestId,
        authDomain,
        environmentId,
        region
      });
      const response = await fetch(tokenUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'Authorization': `Basic ${credentials}`
        },
        body: 'grant_type=client_credentials',
        credentials: 'omit'
      });
      const responseTime = Date.now() - startTime;
      let responseData;
      try {
        responseData = await response.json();
      } catch (e) {
        const text = await response.text().catch(() => 'Failed to read response text');
        throw new Error(`Invalid JSON response: ${e.message}. Response: ${text}`);
      }
      if (!response.ok) {
        const errorMsg = responseData.error_description || responseData.error || `HTTP ${response.status} ${response.statusText}`;
        this.logger.error('Token request failed', {
          requestId,
          status: response.status,
          error: responseData.error,
          errorDescription: responseData.error_description,
          responseTime: `${responseTime}ms`,
          url: tokenUrl
        });
        throw new Error(errorMsg);
      }
      if (!responseData.access_token) {
        throw new Error('No access token in response');
      }

      // Update token cache
      const expiresInMs = (responseData.expires_in || 3600) * 1000;
      this.tokenCache = {
        accessToken: responseData.access_token,
        expiresAt: Date.now() + expiresInMs,
        tokenType: responseData.token_type || 'Bearer',
        lastRefresh: Date.now()
      };
      this.logger.info('Successfully obtained new access token', {
        requestId,
        tokenType: this.tokenCache.tokenType,
        expiresIn: Math.floor(expiresInMs / 1000) + 's',
        responseTime: `${responseTime}ms`
      });

      // Emit token refresh event
      if (this.eventBus) {
        this.eventBus.emit('tokenRefreshed', {
          tokenType: this.tokenCache.tokenType,
          expiresAt: this.tokenCache.expiresAt
        });
      }
      return this.tokenCache.accessToken;
    } catch (error) {
      this.logger.error('Error getting access token', {
        requestId,
        error: error.toString(),
        message: error.message,
        url: tokenUrl,
        responseTime: `${Date.now() - startTime}ms`
      });

      // Clear token cache on error
      this.tokenCache = {
        accessToken: null,
        expiresAt: 0,
        tokenType: 'Bearer',
        lastRefresh: 0
      };
      throw error;
    }
  }

  /**
   * Update settings and clear token cache if credentials changed
   * @param {Object} newSettings - New settings object
   */
  updateSettings(newSettings) {
    if (!newSettings) {
      throw new Error('New settings are required for update');
    }
    const credentialsChanged = newSettings.apiClientId !== this.settings.apiClientId || newSettings.apiSecret !== this.settings.apiSecret || newSettings.environmentId !== this.settings.environmentId || newSettings.region !== this.settings.region;
    this.settings = {
      ...this.settings,
      ...newSettings
    };
    if (credentialsChanged) {
      this.logger.debug('API credentials changed, clearing token cache');
      this.tokenCache = {
        accessToken: null,
        expiresAt: 0,
        tokenType: 'Bearer',
        lastRefresh: 0
      };
    }
  }
}
var _default = exports.default = TokenManager;

},{}],67:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * Token Refresh Handler
 * 
 * Provides automatic token refresh functionality for API calls
 * with retry logic and error handling.
 */

class TokenRefreshHandler {
  constructor() {
    this.tokenRefreshInProgress = false;
    this.tokenRefreshPromise = null;
    this.lastRefreshTime = 0;
    this.minRefreshInterval = 5000; // 5 seconds
  }

  /**
   * Get a fresh token with automatic refresh if needed
   * @param {Object} tokenManager - Token manager instance
   * @returns {Promise<string>} Fresh token
   */
  async getFreshToken(tokenManager) {
    if (!tokenManager) {
      throw new Error('Token manager is required');
    }

    // Check if we already have a valid token
    try {
      const currentToken = await tokenManager.getAccessToken();
      if (currentToken) {
        return currentToken;
      }
    } catch (error) {
      console.warn('Error getting current token:', error);
      // Continue with refresh
    }

    // If refresh is already in progress, wait for it
    if (this.tokenRefreshInProgress) {
      console.log('Token refresh already in progress, waiting...');
      return this.tokenRefreshPromise;
    }

    // Check if we've refreshed recently
    const now = Date.now();
    if (now - this.lastRefreshTime < this.minRefreshInterval) {
      console.log('Token was refreshed recently, using cached token');
      return tokenManager.getAccessToken();
    }

    // Start refresh process
    this.tokenRefreshInProgress = true;
    this.tokenRefreshPromise = this._refreshToken(tokenManager);
    try {
      const token = await this.tokenRefreshPromise;
      return token;
    } finally {
      this.tokenRefreshInProgress = false;
      this.lastRefreshTime = Date.now();
    }
  }

  /**
   * Refresh token with retry logic
   * @private
   * @param {Object} tokenManager - Token manager instance
   * @returns {Promise<string>} Fresh token
   */
  async _refreshToken(tokenManager) {
    console.log('Refreshing token...');

    // Clear current token to force refresh
    if (typeof tokenManager.clearToken === 'function') {
      tokenManager.clearToken();
    }

    // Try to get a new token
    try {
      const token = await tokenManager.getAccessToken();
      if (!token) {
        throw new Error('Failed to get new token');
      }
      console.log('Token refreshed successfully');
      return token;
    } catch (error) {
      console.error('Failed to refresh token:', error);
      throw error;
    }
  }

  /**
   * Make an API call with automatic token refresh
   * @param {Function} apiCall - Function that makes the API call
   * @param {Object} tokenManager - Token manager instance
   * @param {number} maxRetries - Maximum number of retries
   * @returns {Promise<Object>} API response
   */
  async callWithTokenRefresh(apiCall, tokenManager) {
    let maxRetries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    let retries = 0;
    while (retries <= maxRetries) {
      try {
        // Get fresh token
        const token = await this.getFreshToken(tokenManager);

        // Make API call
        return await apiCall(token);
      } catch (error) {
        // Check if error is due to token expiration
        const isTokenError = error.status === 401 || error.message && error.message.includes('token');
        if (isTokenError && retries < maxRetries) {
          console.log(`Token error, retrying (${retries + 1}/${maxRetries})...`);
          retries++;

          // Force token refresh
          if (typeof tokenManager.clearToken === 'function') {
            tokenManager.clearToken();
          }

          // Wait before retry
          await new Promise(resolve => setTimeout(resolve, 1000));
        } else {
          // Rethrow error if not token related or max retries reached
          throw error;
        }
      }
    }
  }
}

// Create and export a singleton instance
const tokenRefreshHandler = new TokenRefreshHandler();
var _default = exports.default = tokenRefreshHandler;

},{}],68:[function(require,module,exports){
(function (process){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UIManager = void 0;
var _circularProgress = require("./circular-progress.js");
var _elementRegistry = require("./element-registry.js");
var _progressManager = _interopRequireDefault(require("./progress-manager.js"));
var _errorTypes = require("./error/error-types.js");
// File: ui-manager.js
// Description: UI management for PingOne user import tool
// 
// This module handles all user interface interactions and state management:
// - Status notifications and user feedback
// - Progress tracking and real-time updates
// - View transitions and navigation
// - Debug logging and error display
// - Connection status indicators
// - Form handling and validation feedback
// 
// Provides a centralized interface for updating the UI based on application events.

// Enable debug mode for development (set to false in production)
const DEBUG_MODE = process.env.NODE_ENV === 'development';

/**
 * UI Manager Class
 * 
 * Manages all user interface interactions and updates with centralized error handling.
 */
class UIManager {
  /**
   * Create a new UIManager instance
   * @param {Object} options - Configuration options
   * @param {Object} options.errorManager - Error manager instance
   * @param {Object} options.logManager - Log manager instance
   */
  constructor() {
    let {
      errorManager,
      logManager
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // Initialize logger from logManager or fallback to console
    this.logger = logManager?.getLogger('UIManager') || console;

    // Initialize error manager
    this.errorManager = errorManager || {
      handleError: (error, context) => {
        console.error('Unhandled error (no error manager):', error, context);
      }
    };

    // Initialize UI elements
    this.notificationContainer = null;
    this.progressContainer = null;
    this.tokenStatusElement = null;
    this.connectionStatusElement = null;

    // Initialize the UI manager
    this.initialize();
  }

  /**
   * Initialize UI manager and setup core functionality
   */
  /**
   * Initialize the UI Manager
   * @private
   */
  initialize() {
    try {
      this.setupElements();
      this.logger.info('UI Manager initialized successfully');
    } catch (error) {
      this.errorManager.handleError(error, {
        component: 'UIManager',
        operation: 'initialize',
        severity: 'error',
        context: {
          message: 'Failed to initialize UI Manager',
          error: error.message
        }
      });
    }
  }

  /**
   * Initialize UI manager (alias for initialize for compatibility)
   * @returns {Promise<void>} Promise that resolves when initialization is complete
   */
  async init() {
    this.initialize();
    return Promise.resolve();
  }

  /**
   * Setup UI elements and initialize core DOM references
   */
  setupElements() {
    try {
      // Initialize core UI elements with safe fallbacks
      this.notificationContainer = _elementRegistry.ElementRegistry.notificationContainer ? _elementRegistry.ElementRegistry.notificationContainer() : null;
      this.progressContainer = _elementRegistry.ElementRegistry.progressContainer ? _elementRegistry.ElementRegistry.progressContainer() : null;
      this.tokenStatusElement = _elementRegistry.ElementRegistry.tokenStatus ? _elementRegistry.ElementRegistry.tokenStatus() : null;
      this.connectionStatusElement = _elementRegistry.ElementRegistry.connectionStatus ? _elementRegistry.ElementRegistry.connectionStatus() : null;

      // Initialize navigation items for safe access
      this.navItems = document.querySelectorAll('[data-view]');
      if (!this.notificationContainer) {
        this.logger.warn('Notification container not found');
      }
      if (!this.progressContainer) {
        this.logger.warn('Progress container not found');
      }
      this.logger.debug('UI elements setup completed', {
        hasNotificationContainer: !!this.notificationContainer,
        hasProgressContainer: !!this.progressContainer,
        hasTokenStatusElement: !!this.tokenStatusElement,
        hasConnectionStatusElement: !!this.connectionStatusElement,
        navItemsCount: this.navItems ? this.navItems.length : 0
      });
    } catch (error) {
      this.logger.error('Error setting up UI elements', {
        error: error.message
      });
    }
  }

  /**
   * Show a status message in the status bar
   * @param {string} message - The message to display
   * @param {string} [type='info'] - Message type (info, success, warning, error)
   * @param {Object} [options] - Additional options
   * @param {number} [options.duration=5000] - Duration in milliseconds to show the message
   * @param {boolean} [options.autoDismiss=true] - Whether to auto-dismiss the message
   * @param {string} [options.errorId] - Unique error ID for tracking
   * @param {Object} [options.context] - Additional context for the message
   */
  /**
   * Show a status message in the status bar
   * @param {string} message - The message to display
   * @param {string} [type='info'] - Message type (info, success, warning, error)
   * @param {Object} [options] - Additional options
   * @param {number} [options.duration=5000] - Duration in milliseconds to show the message
   * @param {boolean} [options.autoDismiss=true] - Whether to auto-dismiss the message
   * @param {string} [options.errorId] - Unique error ID for tracking
   * @param {Object} [options.context] - Additional context for the message
   */
  showStatusBar(message) {
    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'info';
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const {
      duration = 5000,
      autoDismiss = true,
      errorId,
      context = {}
    } = options;
    try {
      // Log the status message with appropriate level
      const logLevel = {
        info: 'info',
        success: 'info',
        warning: 'warn',
        error: 'error'
      }[type] || 'log';

      // Create log context
      const logContext = {
        messageType: type,
        ...(errorId && {
          errorId
        }),
        ...context
      };

      // Log the message with context
      this.logger[logLevel](`Status: ${message}`, logContext);

      // If status bar element is not available, just log and return
      if (!this.statusBarElement) {
        this.logger.debug('Status bar element not available in current view', logContext);
        return;
      }

      // Clear any existing timers
      if (this.statusBarTimer) {
        clearTimeout(this.statusBarTimer);
        this.statusBarTimer = null;
      }

      // Clear existing content
      this.statusBarElement.innerHTML = '';

      // Create message element
      const msg = document.createElement('span');
      msg.className = 'status-message';

      // Add error ID to the message if available
      let displayMessage = message;
      if (type === 'error' && errorId) {
        displayMessage += ` (Error ID: ${errorId})`;

        // In development, show more context for errors
        if (process.env.NODE_ENV === 'development' && Object.keys(context).length > 0) {
          displayMessage += `\n${JSON.stringify(context, null, 2)}`;
        }
      }
      msg.textContent = displayMessage;
      this.statusBarElement.appendChild(msg);

      // Add dismiss button for error/warning (persistent messages)
      if (type === 'error' || type === 'warning') {
        const dismiss = document.createElement('button');
        dismiss.className = 'status-dismiss';
        dismiss.innerHTML = '&times;';
        dismiss.setAttribute('aria-label', 'Dismiss message');
        dismiss.onclick = () => this.clearStatusBar();
        this.statusBarElement.appendChild(dismiss);
      }

      // Set status bar classes
      this.statusBarElement.className = `status-bar status-bar-${type} visible`;

      // Auto-dismiss for success/info messages or if explicitly enabled
      const shouldAutoDismiss = autoDismiss && (type === 'success' || type === 'info');
      if (shouldAutoDismiss) {
        this.statusBarTimer = setTimeout(() => {
          this.clearStatusBar();
        }, duration);
      }
    } catch (error) {
      // If there's an error showing the status bar, report it but don't crash
      this.errorManager.handleError(error, {
        component: 'UIManager',
        operation: 'showStatusBar',
        severity: 'warning',
        context: {
          originalMessage: message,
          type,
          options,
          errorMessage: error.message
        }
      });

      // Fallback to console if the error manager fails
      console.error('Failed to show status bar:', error);
      console.log('Original message:', message);

      // Try to show a simplified error message
      try {
        if (this.statusBarElement) {
          this.statusBarElement.textContent = `Error: ${message.substring(0, 100)}`;
          this.statusBarElement.className = 'status-bar status-bar-error visible';
        }
      } catch (e) {
        // If we can't even show the error message, just give up
        console.error('Completely failed to show status bar:', e);
      }
    }
  }

  /**
   * Clear the status bar with smooth animation
   * @param {Object} [options] - Additional options
   * @param {boolean} [options.force=false] - Force clear without animation
   */
  clearStatusBar() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    try {
      // Clear any pending auto-dismiss timers
      if (this.statusBarTimer) {
        clearTimeout(this.statusBarTimer);
        this.statusBarTimer = null;
      }

      // If status bar element doesn't exist, just return
      if (!this.statusBarElement) {
        this.logger.debug('Status bar element not found during clear');
        return;
      }
      const {
        force = false
      } = options;
      if (force) {
        // Immediate removal
        this.statusBarElement.innerHTML = '';
        this.statusBarElement.className = 'status-bar';
        this.logger.debug('Status bar cleared immediately');
      } else {
        // Animate out
        this.statusBarElement.classList.remove('visible');

        // Remove the element after animation completes
        setTimeout(() => {
          if (this.statusBarElement) {
            this.statusBarElement.innerHTML = '';
            this.statusBarElement.className = 'status-bar';
          }
        }, 300); // Should match CSS transition duration

        this.logger.debug('Status bar cleared with animation');
      }
    } catch (error) {
      this.errorManager.handleError(error, {
        component: 'UIManager',
        operation: 'clearStatusBar',
        severity: 'warning',
        context: {
          options,
          errorMessage: error.message
        }
      });

      // Fallback to direct DOM manipulation if possible
      try {
        if (this.statusBarElement) {
          this.statusBarElement.innerHTML = '';
          this.statusBarElement.className = 'status-bar';
        }
      } catch (e) {
        console.error('Failed to clear status bar:', e);
      }
    }
  }

  /**
   * Show a success message
   * @param {string} message - The success message to display
   * @param {Object} [details] - Additional details to log
   */
  showSuccess(message) {
    let details = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.showStatusBar(message, 'success');
    this.logger.info('Success message shown', {
      message,
      ...details
    });
  }

  /**
   * Show a warning message
   * @param {string} message - The warning message to display
   * @param {Object} [details] - Additional details to log
   */
  showWarning(message) {
    let details = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.showStatusBar(message, 'warning');
    this.logger.warn('Warning message shown', {
      message,
      ...details
    });
  }

  /**
   * Show an info message
   * @param {string} message - The info message to display
   * @param {Object} [details] - Additional details to log
   */
  showInfo(message) {
    let details = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.showStatusBar(message, 'info');
  }
  /**
   * Show an error message to the user
   * @param {string|Error} error - Error title, message, or Error object
   * @param {string|Object} [details] - Additional error details or options object
   * @param {Object} [options] - Additional options
   * @param {string} [options.errorId] - Unique error ID for tracking
   * @param {Object} [options.context] - Additional context for the error
   * @param {boolean} [options.reportToServer=true] - Whether to report the error to the server
   * @param {string} [options.operation] - The operation that failed
   * @param {string} [options.component] - The component where the error occurred
   */
  showError(error) {
    let details = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    // Handle different parameter patterns
    let errorMessage, errorObj, errorContext;
    if (error instanceof Error) {
      // First parameter is an Error object
      errorObj = error;
      errorMessage = error.message;
      errorContext = typeof details === 'object' && details !== null ? details : {};
    } else if (typeof error === 'string' && details instanceof Error) {
      // First is title, second is Error object
      errorObj = details;
      errorMessage = `${error}: ${details.message}`;
      errorContext = {};
    } else if (typeof error === 'string' && typeof details === 'string') {
      // Both are strings (title and message)
      errorMessage = `${error}: ${details}`;
      errorObj = new Error(errorMessage);
      errorObj.name = error;
      errorContext = {};
    } else if (typeof error === 'string') {
      // First is message, second is options
      errorMessage = error;
      errorObj = new Error(errorMessage);
      errorContext = typeof details === 'object' && details !== null ? details : {};
    } else {
      // Invalid parameters
      const invalidError = new Error('Invalid parameters passed to showError');
      this.errorManager.handleError(invalidError, {
        component: 'UIManager',
        operation: 'showError',
        severity: 'error',
        context: {
          error,
          details,
          options
        }
      });
      return;
    }

    // Merge contexts
    const mergedContext = {
      ...errorContext,
      ...options.context
    };

    // Report the error through the error manager
    if (options.reportToServer !== false) {
      this.errorManager.handleError(errorObj, {
        component: options.component || 'UIManager',
        operation: options.operation || 'showError',
        severity: 'error',
        context: mergedContext
      });
    }

    // Show the error in the UI
    this.showStatusBar(errorMessage, 'error', {
      autoDismiss: false,
      errorId: options.errorId,
      context: mergedContext,
      ...options
    });

    // Log the error with additional context
    this.logger.error('Error message shown', {
      error: errorMessage,
      name: errorObj.name,
      stack: errorObj.stack,
      ...mergedContext
    });
  }
  catch(error) {
    // If there's an error in the error handler, log to console
    console.error('Error in showError:', error);

    // Try to show a basic error message
    try {
      const fallbackMessage = 'An error occurred';
      this.showStatusBar(fallbackMessage, 'error', {
        autoDismiss: false,
        context: {
          originalError: error instanceof Error ? error.message : String(error),
          timestamp: new Date().toISOString()
        }
      });
    } catch (e) {
      // If we can't even show the error message, just give up
      console.error('Completely failed to show error:', e);
    }
  }

  /**
   * Hide loading indicator dand optionally show success message
   * @param {string} successMessage - Optional success message to show after hiding loading
   */
  hideLoading() {
    let successMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    this.clearStatusBar();
    if (successMessage) {
      this.showSuccess(successMessage);
    }
    this.logger.debug('Loading indicator hidden');
  }

  /**
   * Update progress bar with current and total values
   * @param {number} current - Current progress value
   * @param {number} total - Total progress value
   * @param {string} message - Progress message
   */
  updateProgress(current, total) {
    let message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    console.log(' [UI MANAGER DEBUG] updateProgress() called with:', {
      current,
      total,
      message
    });
    if (!this.progressContainer) {
      console.error(' [UI MANAGER DEBUG] Progress container not found in updateProgress');
      this.logger.warn('Progress container not found');
      return;
    }
    console.log(' [UI MANAGER DEBUG] Progress container found, calculating percentage...');
    const percentage = total > 0 ? Math.round(current / total * 100) : 0;
    console.log(' [UI MANAGER DEBUG] Calculated percentage:', percentage);

    // Update progress bar
    const progressBar = this.progressContainer.querySelector('.progress-bar-fill');
    console.log(' [UI MANAGER DEBUG] Progress bar element:', progressBar);
    if (progressBar) {
      progressBar.style.width = `${percentage}%`;
      console.log(' [UI MANAGER DEBUG] Progress bar updated to:', `${percentage}%`);
    } else {
      console.error(' [UI MANAGER DEBUG] Progress bar element not found');
    }

    // Update percentage text
    const percentageElement = this.progressContainer.querySelector('.progress-percentage');
    console.log(' [UI MANAGER DEBUG] Percentage element:', percentageElement);
    if (percentageElement) {
      percentageElement.textContent = `${percentage}%`;
      console.log(' [UI MANAGER DEBUG] Percentage text updated to:', `${percentage}%`);
    } else {
      console.error(' [UI MANAGER DEBUG] Percentage element not found');
    }

    // Update progress text
    const progressText = this.progressContainer.querySelector('.progress-text');
    console.log(' [UI MANAGER DEBUG] Progress text element:', progressText);
    if (progressText && message) {
      progressText.textContent = message;
      console.log(' [UI MANAGER DEBUG] Progress text updated to:', message);
    } else {
      console.error(' [UI MANAGER DEBUG] Progress text element not found or no message');
    }
    this.logger.debug('Progress updated', {
      current,
      total,
      percentage,
      message
    });
    console.log(' [UI MANAGER DEBUG] updateProgress() completed');
  }

  /**
   * Update token status display
   * @param {string} status - Token status (valid, expired, etc.)
   * @param {string} message - Status message
   */
  updateTokenStatus(status) {
    let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    if (!this.tokenStatusElement) {
      this.logger.warn('Token status element not found');
      return;
    }
    this.tokenStatusElement.className = `token-status ${status}`;
    this.tokenStatusElement.textContent = message || status;
    this.logger.debug('Token status updated', {
      status,
      message
    });
  }

  /**
   * Update connection status display
   * @param {string} status - Connection status (connected, disconnected, etc.)
   * @param {string} message - Status message
   */
  updateConnectionStatus(status) {
    let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    if (!this.connectionStatusElement) {
      this.logger.warn('Connection status element not found');
      return;
    }
    this.connectionStatusElement.className = `connection-status ${status}`;
    this.connectionStatusElement.textContent = message || status;
    this.logger.debug('Connection status updated', {
      status,
      message
    });
  }

  /**
   * Show current token status with detailed information
   * @param {Object} tokenInfo - Token information object
   */
  showCurrentTokenStatus(tokenInfo) {
    if (!tokenInfo) {
      this.logger.warn('No token info provided');
      return;
    }
    const {
      isValid,
      expiresAt,
      timeRemaining
    } = tokenInfo;
    if (!isValid) {
      this.updateTokenStatus('expired', '');
      return;
    }
    const timeRemainingText = timeRemaining ? ` (${timeRemaining})` : '';
    this.updateTokenStatus('valid', `Token valid${timeRemainingText}`);
    this.logger.info('Current token status displayed', {
      isValid,
      expiresAt,
      timeRemaining
    });
  }

  /**
   * Update universal token status bar
   * @param {Object} tokenInfo - Token information object
   */
  updateUniversalTokenStatus(tokenInfo) {
    // Redirect to token-status-indicator instead of universal-token-status
    const tokenStatusBar = document.getElementById('token-status-indicator');
    if (!tokenStatusBar) {
      this.logger.warn('Token status indicator not found');
      return;
    }
    if (!tokenInfo) {
      tokenStatusBar.style.display = 'none';
      return;
    }
    const {
      isValid,
      expiresAt,
      timeRemaining
    } = tokenInfo;
    const statusContent = tokenStatusBar.querySelector('.token-status-content');
    if (statusContent) {
      const icon = statusContent.querySelector('.token-status-icon');
      const text = statusContent.querySelector('.token-status-text');
      const time = statusContent.querySelector('.token-status-time');
      if (isValid) {
        icon.textContent = '';
        text.textContent = 'Token valid';
        time.textContent = timeRemaining || '';
      } else {
        icon.textContent = '';
        text.textContent = '';
        text.style.visibility = 'hidden';
        time.textContent = '';
      }
    }
    tokenStatusBar.style.display = 'block';
    this.logger.debug('Token status indicator updated', {
      isValid,
      timeRemaining
    });
  }

  /**
   * Update home page token status
   * @param {boolean} isLoading - Whether to show loading state
   * @param {string} message - Status message
   */
  updateHomeTokenStatus() {
    let isLoading = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    const homeTokenStatus = document.getElementById('home-token-status');
    if (!homeTokenStatus) {
      console.log(' home-token-status element not found!');
      return;
    }
    console.log(' Found home-token-status element:', homeTokenStatus);

    // Check current token status to determine button color
    let hasValidToken = false;
    let buttonClass = 'btn-danger'; // Default to red
    let buttonText = 'Get New Token';
    try {
      // First check for stashed token in localStorage
      hasValidToken = this.checkForStashedToken();

      // If no stashed token, check PingOne client
      if (!hasValidToken && window.app && window.app.pingOneClient) {
        const tokenInfo = window.app.pingOneClient.getCurrentTokenTimeRemaining();
        if (tokenInfo && tokenInfo.token && !tokenInfo.isExpired) {
          hasValidToken = true;
        }
      }

      // Set button appearance based on token status
      if (hasValidToken) {
        buttonClass = 'btn-success'; // Green when token is valid
        buttonText = 'Token Valid';
      }
    } catch (error) {
      console.log('Error checking token status:', error);
    }

    // Move to bottom of sidebar
    const sidebar = document.querySelector('.sidebar');
    if (sidebar && homeTokenStatus.parentNode !== sidebar) {
      sidebar.appendChild(homeTokenStatus);
      console.log(' Moved home-token-status to bottom of sidebar');
    }

    // Add debug label to home-token-status container (red, above box)
    if (!document.getElementById('debug-home-token-status-label')) {
      const debugLabel = document.createElement('div');
      debugLabel.id = 'debug-home-token-status-label';
      debugLabel.style.cssText = `
                position: absolute !important;
                top: -30px !important;
                left: 0 !important;
                background: #ff0000 !important;
                color: #ffffff !important;
                padding: 4px 8px !important;
                font-size: 12px !important;
                font-weight: bold !important;
                border: 2px solid #000 !important;
                z-index: 9999 !important;
                white-space: nowrap !important;
                pointer-events: none !important;
            `;
      debugLabel.textContent = 'DEBUG: home-token-status CONTAINER';

      // Ensure container has relative positioning
      homeTokenStatus.style.cssText = `
                position: relative !important;
                background: #ffffcc !important;
                border: 1px solid #dee2e6 !important;
                border-radius: 6px !important;
                padding: 2px !important;
                width: fit-content !important;
                height: auto !important;
                display: block !important;
                overflow: visible !important;
                margin-top: auto !important;
            `;
      homeTokenStatus.appendChild(debugLabel);
      console.log(' Added debug label to home-token-status container');
    }
    if (isLoading) {
      homeTokenStatus.innerHTML = '';
    } else {
      // Use the provided token-status-indicator markup with dynamic button color and enhanced styling
      homeTokenStatus.innerHTML = `
                <div id="token-status-indicator" class="token-status-indicator valid" role="status" aria-live="polite" style="display: block !important; padding: 0 !important; margin: 0 !important; background: none !important; border: none !important;">
                    <button id="get-token-btn" class="btn ${buttonClass}" style="font-size: 14px !important; padding: 8px 16px !important; margin: 0 !important; font-weight: 500 !important; border-radius: 6px !important; box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important; transition: all 0.2s ease !important;">
                        <i class="fas fa-key"></i> ${buttonText}
                    </button>
                </div>
            `;
      // Wire up the button to call getNewToken if available
      const getTokenBtn = document.getElementById('get-token-btn');
      if (getTokenBtn) {
        getTokenBtn.addEventListener('click', () => {
          if (window.tokenStatusIndicator && typeof window.tokenStatusIndicator.getNewToken === 'function') {
            window.tokenStatusIndicator.getNewToken();
          } else if (typeof this.getNewToken === 'function') {
            this.getNewToken();
          } else {
            // TODO: Refactor: Use Notification or Modal from UI subsystem instead of alert.
            // alert('Get New Token functionality is not available.');
          }
        });
      }
    }
    homeTokenStatus.style.display = 'block';
    this.logger.debug('Home token status updated', {
      isLoading,
      message,
      hasValidToken,
      buttonClass
    });
  }

  /**
   * Check for stashed token in localStorage
   * @returns {boolean} True if valid token is found
   */
  checkForStashedToken() {
    try {
      if (typeof localStorage === 'undefined') {
        return false;
      }
      const token = localStorage.getItem('pingone_worker_token');
      const expiry = localStorage.getItem('pingone_token_expiry');
      if (!token || !expiry) {
        return false;
      }
      const expiryTime = parseInt(expiry, 10);
      const now = Date.now();

      // Check if token is expired (with 5 minute buffer)
      if (isNaN(expiryTime) || now >= expiryTime - 5 * 60 * 1000) {
        return false;
      }
      return true;
    } catch (error) {
      console.error('Error checking for stashed token:', error);
      return false;
    }
  }

  /**
   * Update settings save status with message and type
   * @param {string} message - Status message
   * @param {string} type - Message type (success, error, warning, info)
   */
  updateSettingsSaveStatus(message) {
    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'info';
    const settingsStatus = document.querySelector('.settings-save-status');
    if (!settingsStatus) {
      this.logger.warn('Settings save status element not found');
      return;
    }

    // Update classes
    settingsStatus.className = `settings-save-status ${type} show`;

    // Create simple HTML structure with text on the left, icon on the right
    const iconClass = this.getStatusIcon(type);
    settingsStatus.innerHTML = `
            <span>${message}</span>
            <i class="fas ${iconClass}"></i>
        `;

    // Auto-hide success messages after 3 seconds
    if (type === 'success') {
      setTimeout(() => {
        settingsStatus.classList.remove('show');
      }, 3000);
    }
    this.logger.info('Settings save status updated', {
      message,
      type
    });
  }

  /**
   * Show settings action status with enhanced options
   * @param {string} message - Status message
   * @param {string} type - Message type (success, error, warning, info)
   * @param {Object} options - Additional display options
   * @param {boolean} options.autoDismiss - Whether to auto-dismiss
   * @param {number} options.duration - Duration before auto-dismiss
   */
  showSettingsActionStatus(message) {
    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'info';
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const settingsActionStatus = document.getElementById('settings-action-status');
    if (!settingsActionStatus) {
      this.logger.warn('Settings action status element not found');
      return;
    }

    // Clear existing content
    settingsActionStatus.innerHTML = '';
    settingsActionStatus.className = `settings-action-status ${type}`;

    // Create status content
    const statusContent = document.createElement('div');
    statusContent.className = 'status-content';
    const text = document.createElement('span');
    text.textContent = message;
    statusContent.appendChild(text);
    const icon = document.createElement('i');
    icon.className = `fas ${this.getStatusIcon(type)}`;
    statusContent.appendChild(icon);
    settingsActionStatus.appendChild(statusContent);
    settingsActionStatus.style.display = 'block';

    // No auto-dismiss for any type
    this.logger.info('Settings action status shown', {
      message,
      type,
      autoDismiss: false
    });
  }

  /**
   * Get appropriate icon class for status type
   * @param {string} type - Status type
   * @returns {string} Icon class name
   */
  getStatusIcon(type) {
    const icons = {
      success: 'fa-check-circle',
      error: 'fa-times-circle',
      warning: 'fa-exclamation-triangle',
      info: 'fa-info-circle'
    };
    return icons[type] || icons.info;
  }

  /**
   * Hide settings action status
   */
  hideSettingsActionStatus() {
    const settingsActionStatus = document.getElementById('settings-action-status');
    if (settingsActionStatus) {
      settingsActionStatus.style.display = 'none';
      this.logger.debug('Settings action status hidden');
    }
  }

  /**
   * Show import status with operation details
   * @param {string} status - Import status
   * @param {string} message - Status message
   * @param {Object} details - Additional details
   */
  showImportStatus(status) {
    let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    let details = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const importStatus = document.getElementById('import-status');
    if (!importStatus) {
      this.logger.warn('Import status element not found');
      return;
    }
    importStatus.style.display = 'block';
    importStatus.className = `import-status ${status}`;
    const statusText = importStatus.querySelector('.status-text');
    if (statusText) {
      statusText.textContent = message || status;
    }
    this.logger.info('Import status shown', {
      status,
      message,
      details
    });
  }

  /**
   * Clear all notifications from the UI
   */
  clearNotifications() {
    if (this.notificationContainer) {
      this.notificationContainer.innerHTML = '';
      this.logger.debug('All notifications cleared');
    }
    this.clearStatusBar();
  }

  /**
   * Hide progress display
   */
  hideProgress() {
    if (this.progressContainer) {
      this.progressContainer.style.display = 'none';
      this.logger.debug('Progress display hidden');
    }
  }

  /**
   * Show progress section with enhanced debugging and fallback mechanisms
   */
  showProgress() {
    console.log(' [UI MANAGER DEBUG] showProgress() called');
    console.log(' [UI MANAGER DEBUG] this.progressContainer:', this.progressContainer);

    // Try multiple ways to get the progress container
    let progressContainer = this.progressContainer;
    if (!progressContainer) {
      console.log(' [UI MANAGER DEBUG] Progress container not found in UI manager, trying direct access...');
      progressContainer = document.getElementById('progress-container');
    }
    if (!progressContainer) {
      console.log(' [UI MANAGER DEBUG] Progress container not found by ID, trying ElementRegistry...');
      if (typeof _elementRegistry.ElementRegistry !== 'undefined' && _elementRegistry.ElementRegistry.progressContainer) {
        progressContainer = _elementRegistry.ElementRegistry.progressContainer();
      }
    }
    if (!progressContainer) {
      console.log(' [UI MANAGER DEBUG] Progress container not found by ElementRegistry, trying class selector...');
      progressContainer = document.querySelector('.progress-container');
    }
    if (!progressContainer) {
      console.error(' [UI MANAGER DEBUG] Progress container not found by any method');
      console.error(' [UI MANAGER DEBUG] Available containers with "progress" in ID:', Array.from(document.querySelectorAll('[id*="progress"]')).map(el => el.id));
      console.error(' [UI MANAGER DEBUG] Available containers with "progress" in class:', Array.from(document.querySelectorAll('[class*="progress"]')).map(el => ({
        id: el.id,
        className: el.className
      })));
      return;
    }
    console.log(' [UI MANAGER DEBUG] Progress container found, showing...');
    console.log(' [UI MANAGER DEBUG] Current display style:', progressContainer.style.display);
    console.log(' [UI MANAGER DEBUG] Current visibility:', progressContainer.offsetParent !== null ? 'visible' : 'hidden');

    // Force show the progress container
    progressContainer.style.display = 'block';
    progressContainer.style.visibility = 'visible';
    progressContainer.style.opacity = '1';

    // Ensure it's not hidden by CSS
    progressContainer.classList.remove('hidden', 'd-none');
    progressContainer.classList.add('visible');

    // Force layout recalculation
    progressContainer.offsetHeight;
    console.log(' [UI MANAGER DEBUG] Display style after setting to block:', progressContainer.style.display);
    console.log(' [UI MANAGER DEBUG] Container visibility:', progressContainer.offsetParent !== null ? 'visible' : 'hidden');
    console.log(' [UI MANAGER DEBUG] Container dimensions:', {
      offsetWidth: progressContainer.offsetWidth,
      offsetHeight: progressContainer.offsetHeight,
      clientWidth: progressContainer.clientWidth,
      clientHeight: progressContainer.clientHeight
    });

    // Scroll into view if needed
    if (progressContainer.offsetParent !== null) {
      progressContainer.scrollIntoView({
        behavior: 'smooth',
        block: 'center'
      });
    }

    // Update UI manager's reference
    this.progressContainer = progressContainer;
    this.logger.debug('Progress display shown');

    // Additional verification
    setTimeout(() => {
      const isVisible = progressContainer.offsetParent !== null;
      const rect = progressContainer.getBoundingClientRect();
      console.log(' [UI MANAGER DEBUG] Final verification:', {
        isVisible,
        dimensions: {
          width: rect.width,
          height: rect.height
        },
        display: progressContainer.style.display,
        computedDisplay: window.getComputedStyle(progressContainer).display
      });
    }, 100);
  }

  /**
   * Set button loading state
   * @param {string} buttonId - Button element ID
   * @param {boolean} isLoading - Whether to show loading state
   */
  setButtonLoading(buttonId, isLoading) {
    const button = document.getElementById(buttonId);
    if (!button) {
      // Don't log warning for buttons that are intentionally hidden or optional
      if (buttonId === 'get-token-quick') {
        this.logger.debug(`Button with ID '${buttonId}' not found (may be hidden)`);
      } else {
        this.logger.warn(`Button with ID '${buttonId}' not found`);
      }
      return;
    }
    if (isLoading) {
      button.disabled = true;
      button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';
      button.classList.add('loading');
    } else {
      button.disabled = false;
      button.innerHTML = button.getAttribute('data-original-text') || 'Submit';
      button.classList.remove('loading');
    }
    this.logger.debug('Button loading state updated', {
      buttonId,
      isLoading
    });
  }

  /**
   * Update population dropdown fields with available populations
   * @param {Array} populations - Array of population objects
   */
  updatePopulationFields(populations) {
    if (!populations || !Array.isArray(populations)) {
      this.logger.warn('Invalid populations data provided');
      return;
    }
    const populationSelects = document.querySelectorAll('select[id*="population"]');
    populationSelects.forEach(select => {
      // Store current selection
      const currentValue = select.value;

      // Clear existing options
      select.innerHTML = '';

      // Add default option
      const defaultOption = document.createElement('option');
      defaultOption.value = '';
      defaultOption.textContent = 'Select a population...';
      select.appendChild(defaultOption);

      // Add population options
      populations.forEach(population => {
        const option = document.createElement('option');
        option.value = population.id;
        option.textContent = population.name;
        select.appendChild(option);
      });

      // Restore selection if it still exists
      if (currentValue && select.querySelector(`option[value="${currentValue}"]`)) {
        select.value = currentValue;
      }
    });
    this.logger.info('Population fields updated', {
      populationCount: populations.length,
      selectCount: populationSelects.length
    });
  }

  /**
   * Show notification with enhanced options
   * @param {string} title - Notification title
   * @param {string} message - Notification message
   * @param {string} type - Notification type (success, error, warning, info)
   * @param {Object} options - Additional display options
   * @param {boolean} options.autoDismiss - Whether to auto-dismiss
   * @param {number} options.duration - Duration before auto-dismiss
   */
  showNotification(title, message) {
    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'info';
    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    if (!this.notificationContainer) {
      this.logger.warn('Notification container not found');
      return;
    }

    // Clear existing content
    this.notificationContainer.innerHTML = '';

    // Create status header content
    const statusContent = document.createElement('div');
    statusContent.className = 'status-content';

    // Add icon
    const icon = document.createElement('i');
    icon.className = `fas ${this.getStatusIcon(type)}`;
    statusContent.appendChild(icon);

    // Add text
    const text = document.createElement('span');
    if (title && message) {
      text.textContent = `${title}: ${message}`;
    } else {
      text.textContent = title || message;
    }
    statusContent.appendChild(text);

    // Add to container
    this.notificationContainer.appendChild(statusContent);

    // Auto-dismiss if specified (but keep persistent for success messages)
    const shouldAutoDismiss = options.autoDismiss !== false && type !== 'error' && type !== 'success';
    if (shouldAutoDismiss) {
      const duration = options.duration || 5000;
      setTimeout(() => {
        if (this.notificationContainer && this.notificationContainer.contains(statusContent)) {
          this.notificationContainer.innerHTML = '';
        }
      }, duration);
    }
    this.logger.info('Status header updated', {
      title,
      message,
      type,
      autoDismiss: shouldAutoDismiss
    });
  }

  /**
   * Update import progress with detailed statistics
   * @param {number} current - Current progress value
   * @param {number} total - Total progress value
   * @param {string} message - Progress message
   * @param {Object} counts - Statistics counts
   * @param {number} counts.processed - Number of processed items
   * @param {number} counts.success - Number of successful items
   * @param {number} counts.failed - Number of failed items
   * @param {number} counts.skipped - Number of skipped items
   * @param {string} populationName - Population name
   * @param {string} populationId - Population ID
   */
  updateImportProgress(current, total) {
    let message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    let counts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    let populationName = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';
    let populationId = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '';
    // Update main progress
    this.updateProgress(current, total, message);

    // Update statistics if provided
    if (counts && typeof counts === 'object') {
      Object.entries(counts).forEach(_ref => {
        let [key, value] = _ref;
        const statElement = document.querySelector(`.stat-value.${key}`);
        if (statElement) {
          statElement.textContent = value || 0;
        }
      });
    }

    // Update population information if provided
    if (populationName || populationId) {
      const populationElement = document.querySelector('.detail-value.population-info');
      if (populationElement) {
        populationElement.textContent = populationName || populationId || 'Unknown';
      }
    }
    this.logger.debug('Import progress updated', {
      current,
      total,
      message,
      counts,
      populationName,
      populationId
    });
  }

  /**
   * Start import operation with progress tracking
   * @param {Object} options - Operation options
   * @param {string} options.operationType - Type of operation
   * @param {number} options.totalUsers - Total number of users
   * @param {string} options.populationName - Population name
   * @param {string} options.populationId - Population ID
   */
  startImportOperation() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    console.log(' [UI MANAGER DEBUG] startImportOperation() called with options:', options);
    const {
      operationType,
      totalUsers,
      populationName,
      populationId
    } = options;
    console.log(' [UI MANAGER DEBUG] About to call showProgress()...');
    this.showProgress();
    console.log(' [UI MANAGER DEBUG] showProgress() completed');
    console.log(' [UI MANAGER DEBUG] About to call updateProgress()...');
    this.updateProgress(0, totalUsers || 0, 'Starting import operation...');
    console.log(' [UI MANAGER DEBUG] updateProgress() completed');

    // Update operation details
    const operationTypeElement = document.querySelector('.detail-value.operation-type');
    console.log(' [UI MANAGER DEBUG] Operation type element:', operationTypeElement);
    if (operationTypeElement) {
      operationTypeElement.textContent = operationType || 'Import';
      console.log(' [UI MANAGER DEBUG] Operation type updated to:', operationType || 'Import');
    } else {
      console.error(' [UI MANAGER DEBUG] Operation type element not found');
    }
    this.logger.info('Import operation started', {
      operationType,
      totalUsers,
      populationName,
      populationId
    });
    console.log(' [UI MANAGER DEBUG] startImportOperation() completed');
  }

  /**
   * Update import operation with session ID
   * @param {string} sessionId - Session ID for tracking
   */
  updateImportOperationWithSessionId(sessionId) {
    if (!sessionId) {
      this.logger.warn('No session ID provided for import operation');
      return;
    }
    const sessionElement = document.querySelector('.detail-value.session-id');
    if (sessionElement) {
      sessionElement.textContent = sessionId;
    }
    this.logger.info('Import operation session ID updated', {
      sessionId
    });
  }

  /**
   * Start export operation with progress tracking
   * @param {Object} options - Operation options
   * @param {number} options.totalUsers - Total number of users
   * @param {string} options.populationName - Population name
   */
  startExportOperation() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      totalUsers,
      populationName
    } = options;
    this.showProgress();
    this.updateProgress(0, totalUsers || 0, 'Starting export operation...');
    const operationTypeElement = document.querySelector('.detail-value.operation-type');
    if (operationTypeElement) {
      operationTypeElement.textContent = 'Export';
    }
    this.logger.info('Export operation started', {
      totalUsers,
      populationName
    });
  }

  /**
   * Start delete operation with progress tracking
   * @param {Object} options - Operation options
   * @param {number} options.totalUsers - Total number of users
   * @param {string} options.populationName - Population name
   */
  startDeleteOperation() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      totalUsers,
      populationName
    } = options;
    this.showProgress();
    this.updateProgress(0, totalUsers || 0, 'Starting delete operation...');
    const operationTypeElement = document.querySelector('.detail-value.operation-type');
    if (operationTypeElement) {
      operationTypeElement.textContent = 'Delete';
    }
    this.logger.info('Delete operation started', {
      totalUsers,
      populationName
    });
  }

  /**
   * Start modify operation with progress tracking
   * @param {Object} options - Operation options
   * @param {number} options.totalUsers - Total number of users
   * @param {string} options.populationName - Population name
   */
  startModifyOperation() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      totalUsers,
      populationName
    } = options;
    this.showProgress();
    this.updateProgress(0, totalUsers || 0, 'Starting modify operation...');
    const operationTypeElement = document.querySelector('.detail-value.operation-type');
    if (operationTypeElement) {
      operationTypeElement.textContent = 'Modify';
    }
    this.logger.info('Modify operation started', {
      totalUsers,
      populationName
    });
  }

  /**
   * Complete operation with results
   * @param {Object} results - Operation results
   * @param {number} results.processed - Number of processed items
   * @param {number} results.success - Number of successful items
   * @param {number} results.failed - Number of failed items
   * @param {number} results.skipped - Number of skipped items
   */
  completeOperation() {
    let results = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      processed,
      success,
      failed,
      skipped
    } = results;
    this.updateProgress(processed || 0, processed || 0, 'Operation completed');

    // Show completion message
    const message = `Operation completed: ${success || 0} successful, ${failed || 0} failed, ${skipped || 0} skipped`;
    this.showSuccess(message);

    // Hide progress after delay
    setTimeout(() => {
      this.hideProgress();
    }, 2000);
    this.logger.info('Operation completed', {
      processed,
      success,
      failed,
      skipped
    });
  }

  /**
   * Handle duplicate users with decision callback
   * @param {Array} duplicates - Array of duplicate user objects
   * @param {Function} onDecision - Callback function for user decision
   */
  handleDuplicateUsers(duplicates, onDecision) {
    if (!duplicates || duplicates.length === 0) {
      this.logger.warn('No duplicates provided for handling');
      return;
    }
    const message = `Found ${duplicates.length} duplicate users. How would you like to proceed?`;
    this.showWarning(message);

    // In a real implementation, you would show a modal or dialog here
    // For now, we'll just log the decision
    this.logger.info('Duplicate users found', {
      count: duplicates.length
    });
    if (onDecision && typeof onDecision === 'function') {
      onDecision('skip'); // Default to skip
    }
  }

  /**
   * Debug logging for development
   * @param {string} area - Debug area
   * @param {string} message - Debug message
   */
  debugLog(area, message) {
    if (DEBUG_MODE) {
      this.logger.debug(`[${area}] ${message}`);
    }
  }

  /**
   * Show status message with type
   * @param {string} type - Message type
   * @param {string} message - Message content
   * @param {string} details - Additional details
   */
  showStatusMessage(type, message) {
    let details = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    const fullMessage = details ? `${message}: ${details}` : message;
    this.showNotification('Status Update', fullMessage, type);
  }

  /**
   * Show export status
   */
  showExportStatus() {
    this.showProgress();
    this.updateProgress(0, 100, 'Preparing export...');
    this.logger.info('Export status shown');
  }

  /**
   * Update export progress
   * @param {number} current - Current progress
   * @param {number} total - Total progress
   * @param {string} message - Progress message
   * @param {Object} counts - Statistics counts
   */
  updateExportProgress(current, total, message) {
    let counts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    this.updateProgress(current, total, message);

    // Update export-specific statistics
    if (counts && typeof counts === 'object') {
      Object.entries(counts).forEach(_ref2 => {
        let [key, value] = _ref2;
        const statElement = document.querySelector(`.stat-value.${key}`);
        if (statElement) {
          statElement.textContent = value || 0;
        }
      });
    }
    this.logger.debug('Export progress updated', {
      current,
      total,
      message,
      counts
    });
  }

  /**
   * Show delete status
   * @param {number} totalUsers - Total number of users
   * @param {string} populationName - Population name
   * @param {string} populationId - Population ID
   */
  showDeleteStatus(totalUsers, populationName, populationId) {
    this.showProgress();
    this.updateProgress(0, totalUsers || 0, 'Preparing delete operation...');
    const operationTypeElement = document.querySelector('.detail-value.operation-type');
    if (operationTypeElement) {
      operationTypeElement.textContent = 'Delete';
    }
    this.logger.info('Delete status shown', {
      totalUsers,
      populationName,
      populationId
    });
  }

  /**
   * Update delete progress
   * @param {number} current - Current progress
   * @param {number} total - Total progress
   * @param {string} message - Progress message
   * @param {Object} counts - Statistics counts
   * @param {string} populationName - Population name
   * @param {string} populationId - Population ID
   */
  updateDeleteProgress(current, total, message) {
    let counts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    let populationName = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';
    let populationId = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '';
    this.updateProgress(current, total, message);

    // Update delete-specific statistics
    if (counts && typeof counts === 'object') {
      Object.entries(counts).forEach(_ref3 => {
        let [key, value] = _ref3;
        const statElement = document.querySelector(`.stat-value.${key}`);
        if (statElement) {
          statElement.textContent = value || 0;
        }
      });
    }
    this.logger.debug('Delete progress updated', {
      current,
      total,
      message,
      counts,
      populationName,
      populationId
    });
  }

  /**
   * Show modify status
   * @param {number} totalUsers - Total number of users
   */
  showModifyStatus(totalUsers) {
    this.showProgress();
    this.updateProgress(0, totalUsers || 0, 'Preparing modify operation...');
    const operationTypeElement = document.querySelector('.detail-value.operation-type');
    if (operationTypeElement) {
      operationTypeElement.textContent = 'Modify';
    }
    this.logger.info('Modify status shown', {
      totalUsers
    });
  }

  /**
   * Update modify progress
   * @param {number} current - Current progress
   * @param {number} total - Total progress
   * @param {string} message - Progress message
   * @param {Object} counts - Statistics counts
   */
  updateModifyProgress(current, total, message) {
    let counts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    this.updateProgress(current, total, message);

    // Update modify-specific statistics
    if (counts && typeof counts === 'object') {
      Object.entries(counts).forEach(_ref4 => {
        let [key, value] = _ref4;
        const statElement = document.querySelector(`.stat-value.${key}`);
        if (statElement) {
          statElement.textContent = value || 0;
        }
      });
    }
    this.logger.debug('Modify progress updated', {
      current,
      total,
      message,
      counts
    });
  }
}

// Export the UIManager class
exports.UIManager = UIManager;

}).call(this)}).call(this,require('_process'))
},{"./circular-progress.js":43,"./element-registry.js":47,"./error/error-types.js":48,"./progress-manager.js":59,"@babel/runtime/helpers/interopRequireDefault":2,"_process":29}],69:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VersionManager = void 0;
class VersionManager {
  constructor() {
    this.version = '6.1'; // Update this with each new version
    console.log(`Version Manager initialized with version ${this.version}`);
  }
  getVersion() {
    return this.version;
  }
  getFormattedVersion() {
    return `v${this.version}`;
  }
  updateTitle() {
    // Update the main title
    const title = document.querySelector('h1');
    if (title) {
      // Remove any existing version number
      const baseTitle = title.textContent.replace(/\s*\(v\d+\.\d+\.\d+\)\s*$/, '').trim();
      title.textContent = `${baseTitle} (${this.getFormattedVersion()})`;
    }

    // Update the document title
    document.title = `PingOne User Import ${this.getFormattedVersion()}`;

    // Update the import button text
    this.updateImportButton();

    // Update the top version badge
    this.updateTopVersionBadge();

    // Add version badge to the sidebar above the Ping Identity logo
    this.addSidebarVersionBadge();
  }
  updateImportButton() {
    const importButton = document.getElementById('start-import-btn');
    if (importButton) {
      const baseText = importButton.textContent.replace(/\s*\(v\d+\.\d+\.\d+\)\s*$/, '').trim();
      importButton.innerHTML = `<i class="pi pi-upload"></i> ${baseText} (${this.getFormattedVersion()})`;
    }
  }
  updateTopVersionBadge() {
    const versionText = document.getElementById('version-text');
    if (versionText) {
      versionText.textContent = this.getFormattedVersion();
    }
  }
  addSidebarVersionBadge() {
    // Remove existing badges if they exist
    const existingTopLeftBadge = document.getElementById('top-left-version-badge');
    if (existingTopLeftBadge) {
      existingTopLeftBadge.remove();
    }
    const existingSidebarBadge = document.getElementById('sidebar-version-badge');
    if (existingSidebarBadge) {
      existingSidebarBadge.remove();
    }

    // Check if sidebar version badge already exists
    if (document.getElementById('sidebar-version-badge')) {
      return;
    }

    // Create sidebar version badge
    const badge = document.createElement('div');
    badge.id = 'sidebar-version-badge';
    badge.className = 'sidebar-version-badge';
    badge.textContent = this.getFormattedVersion();

    // Find the footer and insert the badge in the footer-left section, after the logo and trademark
    const footer = document.querySelector('.ping-footer');
    if (footer) {
      const footerLeft = footer.querySelector('.footer-left');
      if (footerLeft) {
        // Insert the badge after the footer-logo div
        const logoDiv = footerLeft.querySelector('.footer-logo');
        if (logoDiv) {
          // Insert after the logo div
          footerLeft.insertBefore(badge, logoDiv.nextSibling);
        } else {
          // Fallback: insert at the beginning of footer-left
          footerLeft.insertBefore(badge, footerLeft.firstChild);
        }
      } else {
        // Fallback: insert at the end of the footer
        footer.appendChild(badge);
      }
    } else {
      // Fallback: add to body if footer not found
      document.body.appendChild(badge);
    }
  }
}

// ES Module export
exports.VersionManager = VersionManager;

},{}],70:[function(require,module,exports){
(function (process){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.apiLogger = exports.WinstonLogger = void 0;
exports.createComponentLogger = createComponentLogger;
exports.createWinstonLogger = createWinstonLogger;
exports.uiLogger = exports.tokenLogger = exports.settingsLogger = exports.fileLogger = exports.defaultLogger = void 0;
/**
 * @fileoverview Winston-compatible logger for frontend/browser environment
 * 
 * This module provides a Winston-like logging interface for the frontend
 * that maintains consistency with server-side Winston logging while
 * working within browser constraints.
 * 
 * Features:
 * - Winston-compatible API (info, warn, error, debug)
 * - Structured logging with metadata
 * - Timestamp formatting
 * - Log level filtering
 * - Console and server transport support
 * - Error stack trace handling
 * - Environment-aware configuration
 */

/**
 * Winston-compatible logger for browser environment
 */
class WinstonLogger {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.level = options.level || this.getDefaultLevel();
    this.service = options.service || 'pingone-import-frontend';
    this.environment = options.environment || process.env.NODE_ENV || 'development';
    this.enableServerLogging = options.enableServerLogging !== false;
    this.enableConsoleLogging = options.enableConsoleLogging !== false;

    // Log level hierarchy
    this.levels = {
      error: 0,
      warn: 1,
      info: 2,
      debug: 3
    };

    // Initialize transports
    this.transports = [];
    this.initializeTransports();
  }

  /**
   * Get default log level based on environment
   */
  getDefaultLevel() {
    if (this.environment === 'production') {
      return 'info';
    } else if (this.environment === 'test') {
      return 'warn';
    } else {
      return 'debug';
    }
  }

  /**
   * Initialize logging transports
   */
  initializeTransports() {
    // Console transport
    if (this.enableConsoleLogging) {
      this.transports.push({
        name: 'console',
        log: (level, message, meta) => this.logToConsole(level, message, meta)
      });
    }

    // Server transport (if enabled)
    if (this.enableServerLogging) {
      this.transports.push({
        name: 'server',
        log: (level, message, meta) => this.logToServer(level, message, meta)
      });
    }
  }

  /**
   * Check if a log level should be logged
   */
  shouldLog(level) {
    return this.levels[level] <= this.levels[this.level];
  }

  /**
   * Format timestamp
   */
  formatTimestamp() {
    return new Date().toISOString();
  }

  /**
   * Format log entry
   */
  formatLogEntry(level, message) {
    let meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const timestamp = this.formatTimestamp();
    return {
      timestamp,
      level,
      message,
      service: this.service,
      environment: this.environment,
      ...meta
    };
  }

  /**
   * Log to console with Winston-like formatting
   */
  logToConsole(level, message) {
    let meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (!this.shouldLog(level)) return;
    const logEntry = this.formatLogEntry(level, message, meta);
    const timestamp = logEntry.timestamp;
    const levelUpper = level.toUpperCase();

    // Create formatted console message
    let consoleMessage = `[${timestamp}] [${this.service}] ${levelUpper}: ${message}`;

    // Add metadata if present
    if (Object.keys(meta).length > 0) {
      consoleMessage += `\n${JSON.stringify(meta, null, 2)}`;
    }

    // Use appropriate console method
    switch (level) {
      case 'error':
        console.error(consoleMessage);
        break;
      case 'warn':
        console.warn(consoleMessage);
        break;
      case 'info':
        console.info(consoleMessage);
        break;
      case 'debug':
        console.debug(consoleMessage);
        break;
      default:
        console.log(consoleMessage);
    }
  }

  /**
   * Log to server via API endpoint
   */
  async logToServer(level, message) {
    let meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (!this.shouldLog(level)) return;
    try {
      // Format the request body according to the API expectations
      const requestBody = {
        message,
        level,
        data: meta,
        source: 'frontend'
      };

      // Send to server logging endpoint
      await fetch('/api/logs/ui', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });
    } catch (error) {
      // Handle connection refused errors silently during startup
      if (error.message.includes('Failed to fetch') || error.message.includes('ERR_CONNECTION_REFUSED')) {
        // Don't log connection refused errors to avoid console spam during startup
        return;
      }
      // Fallback to console if server logging fails
      console.warn('Server logging failed, falling back to console:', error.message);
      this.logToConsole(level, message, meta);
    }
  }

  /**
   * Main logging method
   */
  log(level, message) {
    let meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (!this.shouldLog(level)) return;

    // Send to all transports
    this.transports.forEach(transport => {
      try {
        transport.log(level, message, meta);
      } catch (error) {
        console.error(`Error in ${transport.name} transport:`, error);
      }
    });
  }

  /**
   * Log info level message
   */
  info(message) {
    let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.log('info', message, meta);
  }

  /**
   * Log warn level message
   */
  warn(message) {
    let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.log('warn', message, meta);
  }

  /**
   * Log error level message
   */
  error(message) {
    let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.log('error', message, meta);
  }

  /**
   * Log debug level message
   */
  debug(message) {
    let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.log('debug', message, meta);
  }

  /**
   * Log error with stack trace
   */
  errorWithStack(message, error) {
    let meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const errorMeta = {
      ...meta,
      error: {
        message: error.message,
        stack: error.stack,
        code: error.code,
        name: error.name
      }
    };
    this.error(message, errorMeta);
  }

  /**
   * Create child logger with additional metadata
   */
  child() {
    var _this = this;
    let additionalMeta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const childLogger = new WinstonLogger({
      level: this.level,
      service: this.service,
      environment: this.environment,
      enableServerLogging: this.enableServerLogging,
      enableConsoleLogging: this.enableConsoleLogging
    });

    // Override formatLogEntry to include additional metadata
    childLogger.formatLogEntry = function (level, message) {
      let meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      const baseEntry = _this.formatLogEntry(level, message, meta);
      return {
        ...baseEntry,
        ...additionalMeta
      };
    };
    return childLogger;
  }

  /**
   * Set log level
   */
  setLevel(level) {
    if (this.levels.hasOwnProperty(level)) {
      this.level = level;
    } else {
      this.warn(`Invalid log level: ${level}`);
    }
  }

  /**
   * Enable/disable server logging
   */
  setServerLogging(enabled) {
    this.enableServerLogging = enabled;

    // Update transports
    this.transports = this.transports.filter(t => t.name !== 'server');
    if (enabled) {
      this.transports.push({
        name: 'server',
        log: (level, message, meta) => this.logToServer(level, message, meta)
      });
    }
  }

  /**
   * Enable/disable console logging
   */
  setConsoleLogging(enabled) {
    this.enableConsoleLogging = enabled;

    // Update transports
    this.transports = this.transports.filter(t => t.name !== 'console');
    if (enabled) {
      this.transports.push({
        name: 'console',
        log: (level, message, meta) => this.logToConsole(level, message, meta)
      });
    }
  }
}

/**
 * Create default logger instance
 */
exports.WinstonLogger = WinstonLogger;
function createWinstonLogger() {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return new WinstonLogger(options);
}

/**
 * Create component-specific logger
 */
function createComponentLogger(component) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return createWinstonLogger({
    ...options,
    service: `${options.service || 'pingone-import'}-${component}`
  });
}

/**
 * Default logger instances
 */
const defaultLogger = exports.defaultLogger = createWinstonLogger();
const apiLogger = exports.apiLogger = createComponentLogger('api');
const uiLogger = exports.uiLogger = createComponentLogger('ui');
const fileLogger = exports.fileLogger = createComponentLogger('file');
const settingsLogger = exports.settingsLogger = createComponentLogger('settings');
const tokenLogger = exports.tokenLogger = createComponentLogger('token');

// Export the class for custom instances

}).call(this)}).call(this,require('_process'))
},{"_process":29}],71:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _browserLoggingService = require("./utils/browser-logging-service.js");
var _debugLogger = require("./utils/debug-logger.js");
var _logger = require("../../public/js/modules/logger.js");
var _fileLogger = require("../../public/js/modules/file-logger.js");
var _eventBus = require("../../public/js/modules/event-bus.js");
var _settingsManager = require("../../public/js/modules/settings-manager.js");
var _uiManager = require("./components/ui-manager.js");
var _tokenManager = _interopRequireDefault(require("../../public/js/modules/token-manager.js"));
require("../../public/js/modules/disclaimer-modal.js");
require("../../public/js/modules/credentials-modal.js");
var _importSubsystem = require("./subsystems/import-subsystem.js");
var _exportSubsystem = require("./subsystems/export-subsystem.js");
var _operationManagerSubsystem = require("./subsystems/operation-manager-subsystem.js");
var _navigationSubsystem = require("./subsystems/navigation-subsystem.js");
var _connectionManagerSubsystem = require("./subsystems/connection-manager-subsystem.js");
var _realtimeCommunicationSubsystem = require("./subsystems/realtime-communication-subsystem.js");
var _authManagementSubsystem = require("./subsystems/auth-management-subsystem.js");
var _viewManagementSubsystem = require("./subsystems/view-management-subsystem.js");
var _globalTokenManagerSubsystem = require("./subsystems/global-token-manager-subsystem.js");
var _tokenNotificationSubsystem = require("./subsystems/token-notification-subsystem.js");
var _advancedRealtimeSubsystem = require("./subsystems/advanced-realtime-subsystem.js");
var _realtimeCollaborationUi = require("./components/realtime-collaboration-ui.js");
var _analyticsDashboardSubsystem = require("./subsystems/analytics-dashboard-subsystem.js");
var _analyticsDashboardUi = require("./components/analytics-dashboard-ui.js");
var _historyUi = _interopRequireDefault(require("./components/history-ui.js"));
var _loggingUiEnhanced = _interopRequireDefault(require("./components/logging-ui-enhanced.js"));
var _testingHub = _interopRequireDefault(require("./components/testing-hub.js"));
var _progressSubsystem = require("../../public/js/modules/progress-subsystem.js");
var _sessionSubsystem = require("../../public/js/modules/session-subsystem.js");
var _loggingSubsystem = require("../../public/js/modules/logging-subsystem.js");
var _historySubsystem = require("../../public/js/modules/history-subsystem.js");
var _populationSubsystem = require("../../public/js/modules/population-subsystem.js");
var _settingsSubsystem = require("../../public/js/modules/settings-subsystem.js");
var _localApiClient = require("../../public/js/modules/local-api-client.js");
var _pingoneClient = require("../../public/js/modules/pingone-client.js");
var _fileHandler = require("../../public/js/modules/file-handler.js");
var _versionManager = require("../../public/js/modules/version-manager.js");
var _tokenAlertModal = require("../../public/js/modules/token-alert-modal.js");
var _tokenRefreshHandler = _interopRequireDefault(require("../../public/js/modules/token-refresh-handler.js"));
var _socket = require("socket.io-client");
var _featureFlags = require("../shared/feature-flags.js");
// File: app.js
// Description: Main application entry point for PingOne user import tool
// 
// This file orchestrates the entire application, managing:
// - UI state and view transitions
// - File upload and CSV processing
// - Import/export/modify/delete operations
// - Real-time progress tracking via SSE
// - Settings management and population selection
// - Error handling and user feedback
// - Disclaimer agreement and feature flags

// Browser-compatible logging system

// Core utilities

// Components

// Modal components (needed for startup flow)

// Subsystems (new architecture)

// Modern subsystems (replacing legacy modules)

// Legacy modules (minimal usage, being phased out)

// Feature flags for gradual subsystem rollout

/**
 * Secret Field Toggle Component
 * 
 * Manages the visibility toggle for sensitive input fields (like API secrets).
 * Provides a secure way to show/hide sensitive data with visual feedback.
 * 
 * Features:
 * - Toggle between visible and masked input
 * - Visual eye icon that changes based on state
 * - Maintains actual value while showing masked version
 * - Prevents accidental exposure of sensitive data
 */
class SecretFieldToggle {
  constructor(inputElement, toggleElement) {
    this.input = inputElement;
    this.toggle = toggleElement;
    this.isVisible = false;
    this.originalValue = '';
    this.init();
  }
  init() {
    if (!this.input || !this.toggle) return;
    this.toggle.addEventListener('click', () => this.toggleVisibility());
    this.input.addEventListener('input', () => this.handleInput());

    // Initialize with masked state
    this.updateDisplay();
  }
  toggleVisibility() {
    this.isVisible = !this.isVisible;
    this.updateDisplay();
  }
  handleInput() {
    this.originalValue = this.input.value;
    if (!this.isVisible) {
      this.maskValue();
    }
  }
  updateDisplay() {
    if (this.isVisible) {
      this.input.value = this.originalValue;
      this.input.type = 'text';
      this.toggle.innerHTML = '<i class="fas fa-eye-slash"></i>';
      this.toggle.title = 'Hide';
    } else {
      this.maskValue();
      this.input.type = 'password';
      this.toggle.innerHTML = '<i class="fas fa-eye"></i>';
      this.toggle.title = 'Show';
    }
  }
  maskValue() {
    if (this.originalValue) {
      this.input.value = ''.repeat(this.originalValue.length);
    }
  }
  getValue() {
    return this.originalValue;
  }
  setValue(value) {
    this.originalValue = value;
    this.updateDisplay();
  }
}

/**
 * Main Application Class
 * 
 * Orchestrates the entire PingOne user import tool application.
 * Manages all UI interactions, API calls, file processing, and state management.
 * 
 * Features:
 * - Subsystem-based architecture for better maintainability
 * - Centralized logging with correlation tracking
 * - Feature flags for gradual rollout
 * - Real-time progress tracking
 * - Comprehensive error handling
 */
class App {
  constructor() {
    // Initialize centralized logging
    this.logger = _featureFlags.FEATURE_FLAGS.USE_CENTRALIZED_LOGGING ? (0, _browserLoggingService.createLogger)({
      serviceName: 'pingone-import-app',
      enableServer: true,
      enableConsole: true
    }) : new _logger.Logger();
    this.logger.info('Application initialization started', {
      version: '6.2.0',
      featureFlags: _featureFlags.FEATURE_FLAGS
    });

    // Debug logging
    _debugLogger.debugLog.systemState('app', 'initialization_started', {
      version: '6.2.0',
      featureFlags: _featureFlags.FEATURE_FLAGS,
      userAgent: navigator.userAgent
    });

    // Core components
    this.eventBus = new _eventBus.EventBus();
    this.settingsManager = null;
    this.uiManager = null;
    this.tokenManager = null;
    this.fileHandler = null;
    this.versionManager = null;

    // API clients
    this.localClient = null;

    // UI Components
    this.globalTokenManager = null;

    // Modern subsystems (replacing legacy managers)
    this.progressSubsystem = null;
    this.sessionSubsystem = null;
    this.loggingSubsystem = null;
    this.historySubsystem = null;
    this.populationSubsystem = null;
    this.settingsSubsystem = null;

    // Advanced real-time features
    this.advancedRealtimeSubsystem = null;
    this.realtimeCollaborationUI = null;

    // Subsystems (new architecture)
    this.subsystems = {};
    this.analyticsDashboardSubsystem = null;
    this.analyticsDashboardUI = null;

    // Application state
    this.isInitialized = false;
    this.currentView = 'home';
    this.socket = null;

    // Performance tracking
    this.logger.startTimer('app-initialization');
  }

  /**
   * Initialize the application
   */
  async init() {
    try {
      this.logger.info('Starting application initialization');
      this.updateStartupMessage('Initializing core components...');

      // Initialize core components
      await this.initializeCoreComponents();
      this.updateStartupMessage('Setting up subsystems...');

      // Initialize subsystems
      await this.initializeSubsystems();
      this.updateStartupMessage('Loading legacy components...');

      // Initialize legacy components (gradually being replaced)
      await this.initializeLegacyComponents();
      this.updateStartupMessage('Setting up event listeners...');

      // Set up event listeners
      this.setupEventListeners();

      // Set up modal completion listeners
      this.setupModalCompletionListeners();
      this.updateStartupMessage('Finalizing user interface...');

      // Initialize UI
      await this.initializeUI();

      // Mark as initialized
      this.isInitialized = true;

      // Hide startup screen
      this.hideStartupScreen();
      const initTime = this.logger.endTimer('app-initialization');
      this.logger.info('Application initialization completed', {
        initializationTime: `${initTime}ms`,
        subsystemsEnabled: Object.keys(this.subsystems).length
      });
    } catch (error) {
      this.logger.error('Application initialization failed', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    }
  }

  /**
   * Hide the startup screen
   */
  hideStartupScreen() {
    try {
      const startupScreen = document.getElementById('startup-wait-screen');
      const appContainer = document.querySelector('.app-container');
      if (startupScreen) {
        this.logger.debug('Hiding startup wait screen');
        startupScreen.style.display = 'none';
      } else {
        this.logger.warn('Startup wait screen element not found');
      }
      if (appContainer) {
        appContainer.classList.remove('startup-loading');
      }
      this.logger.debug('Startup screen hidden successfully');
    } catch (error) {
      this.logger.error('Failed to hide startup screen', {
        error: error.message
      });
    }
  }

  /**
   * Initialize core components
   */
  async initializeCoreComponents() {
    this.logger.debug('Initializing core components');

    // API clients must be first as other components depend on it.
    this.localClient = new _localApiClient.LocalAPIClient(this.logger);

    // Initialize UIManager first as SettingsSubsystem depends on it.
    this.uiManager = new _uiManager.UIManager({
      logger: this.logger
    });

    // SettingsSubsystem is a core component and must be initialized before others that depend on it.
    this.settingsSubsystem = new _settingsSubsystem.SettingsSubsystem(this.logger.child({
      subsystem: 'settings'
    }), this.uiManager, this.localClient, null,
    // settingsManager - not available yet
    this.eventBus, null // credentialsManager - not available yet
    );
    await this.settingsSubsystem.init();
    this.subsystems.settings = this.settingsSubsystem;
    this.logger.debug('Settings subsystem initialized as a core component');

    // Initialize other core components that may depend on the above.
    this.tokenManager = new _tokenManager.default(this.logger, this.subsystems.settings.getAllSettings(), this.eventBus);
    this.fileHandler = new _fileHandler.FileHandler(this.logger, this.uiManager);
    this.versionManager = new _versionManager.VersionManager();
    try {
      this.pingOneClient = new _pingoneClient.PingOneClient();
      this.logger.debug('PingOne client created successfully');
    } catch (error) {
      this.logger.error('Failed to create PingOne client:', error);
      this.pingOneClient = null;
    }
    this.logger.debug('Core components initialized');
  }

  /**
   * Check if PingOne client is available and ready
   */
  isPingOneClientAvailable() {
    return this.pingOneClient !== null && typeof this.pingOneClient === 'object';
  }

  /**
   * Initialize subsystems with feature flags
   */
  async initializeSubsystems() {
    this.logger.debug('Initializing subsystems', {
      featureFlags: _featureFlags.FEATURE_FLAGS
    });
    try {
      // LoggingSubsystem must be initialized before other subsystems that depend on it (e.g., PopulationSubsystem).
      this.loggingSubsystem = new _loggingSubsystem.LoggingSubsystem(this.eventBus, this.logger.child({
        subsystem: 'logging'
      }));
      await this.loggingSubsystem.init();
      this.subsystems.logging = this.loggingSubsystem;
      this.logger.debug('Logging subsystem initialized');

      // Navigation Subsystem
      if (_featureFlags.FEATURE_FLAGS.USE_NAVIGATION_SUBSYSTEM) {
        this.subsystems.navigation = new _navigationSubsystem.NavigationSubsystem(this.logger.child({
          subsystem: 'navigation'
        }), this.uiManager, this.subsystems.settings);
        await this.subsystems.navigation.init();
        this.logger.debug('Navigation subsystem initialized');
      }

      // Connection Manager Subsystem
      if (_featureFlags.FEATURE_FLAGS.USE_CONNECTION_MANAGER) {
        this.subsystems.connectionManager = new _connectionManagerSubsystem.ConnectionManagerSubsystem(this.logger.child({
          subsystem: 'connection'
        }), this.uiManager, this.subsystems.settings, this.localClient);
        await this.subsystems.connectionManager.init();
        this.logger.debug('Connection manager subsystem initialized');
      }

      // Realtime Communication Subsystem
      if (_featureFlags.FEATURE_FLAGS.USE_REALTIME_SUBSYSTEM) {
        this.subsystems.realtimeManager = new _realtimeCommunicationSubsystem.RealtimeCommunicationSubsystem(this.logger.child({
          subsystem: 'realtime'
        }), this.uiManager);
        await this.subsystems.realtimeManager.init();
        this.logger.debug('Realtime communication subsystem initialized');
      }

      // Auth Management Subsystem
      if (_featureFlags.FEATURE_FLAGS.USE_AUTH_MANAGEMENT) {
        this.subsystems.authManager = new _authManagementSubsystem.AuthManagementSubsystem(this.logger.child({
          subsystem: 'AuthManagementSubsystem'
        }), this.uiManager, this.localClient, this.subsystems.settings);
        await this.subsystems.authManager.init();
        this.logger.debug('Auth management subsystem initialized');
      }

      // View Management Subsystem
      if (_featureFlags.FEATURE_FLAGS.USE_VIEW_MANAGEMENT) {
        this.subsystems.viewManager = new _viewManagementSubsystem.ViewManagementSubsystem(this.logger.child({
          subsystem: 'view'
        }), this.uiManager);
        await this.subsystems.viewManager.init();
        this.logger.debug('View management subsystem initialized');
      }

      // Operation Manager Subsystem
      if (_featureFlags.FEATURE_FLAGS.USE_OPERATION_MANAGER) {
        this.subsystems.operationManager = new _operationManagerSubsystem.OperationManagerSubsystem(this.logger.child({
          subsystem: 'operation'
        }), this.uiManager, this.subsystems.settings, this.localClient);
        await this.subsystems.operationManager.init();
        this.logger.debug('Operation manager subsystem initialized');
      }

      // Population Subsystem (needed by Import/Export subsystems)
      this.populationSubsystem = new _populationSubsystem.PopulationSubsystem(this.eventBus, this.subsystems.settings, this.subsystems.logging,
      // Correctly passing the initialized logging subsystem
      this.localClient);
      await this.populationSubsystem.init();
      this.subsystems.population = this.populationSubsystem;
      this.logger.debug('Population subsystem initialized');

      // Import Subsystem
      if (_featureFlags.FEATURE_FLAGS.USE_IMPORT_SUBSYSTEM) {
        this.subsystems.importManager = new _importSubsystem.ImportSubsystem(this.logger.child({
          subsystem: 'import'
        }), this.uiManager, this.localClient, this.subsystems.settings, this.eventBus, this.subsystems.population, this.subsystems.authManager);
        await this.subsystems.importManager.init();
        this.logger.debug('Import subsystem initialized');
      }

      // Export Subsystem
      if (_featureFlags.FEATURE_FLAGS.USE_EXPORT_SUBSYSTEM) {
        this.subsystems.exportManager = new _exportSubsystem.ExportSubsystem(this.logger.child({
          subsystem: 'export'
        }), this.uiManager, this.localClient, this.subsystems.settings, this.eventBus, this.subsystems.population);
        await this.subsystems.exportManager.init();
        this.logger.debug('Export subsystem initialized');
      }

      // Advanced Real-time Subsystem
      if (_featureFlags.FEATURE_FLAGS.USE_ADVANCED_REALTIME) {
        this.advancedRealtimeSubsystem = new _advancedRealtimeSubsystem.AdvancedRealtimeSubsystem(this.eventBus, this.logger.child({
          subsystem: 'advanced-realtime'
        }));
        await this.advancedRealtimeSubsystem.init();
        this.subsystems.advancedRealtime = this.advancedRealtimeSubsystem;
        this.realtimeCollaborationUI = new _realtimeCollaborationUi.RealtimeCollaborationUI(this.eventBus, this.logger.child({
          component: 'RealtimeCollaborationUI'
        }));
        this.realtimeCollaborationUI.init();
      }

      // Analytics Dashboard Subsystem
      if (_featureFlags.FEATURE_FLAGS.USE_ANALYTICS_DASHBOARD) {
        this.analyticsDashboardSubsystem = new _analyticsDashboardSubsystem.AnalyticsDashboardSubsystem(this.eventBus, this.logger.child({
          subsystem: 'analytics-dashboard'
        }));
        await this.analyticsDashboardSubsystem.init();
        this.subsystems.analyticsDashboard = this.analyticsDashboardSubsystem;
        this.analyticsDashboardUI = new _analyticsDashboardUi.AnalyticsDashboardUI(this.eventBus, this.logger.child({
          component: 'AnalyticsDashboardUI'
        }));
        this.analyticsDashboardUI.init();
      }
    } catch (error) {
      this.logger.error('Subsystem initialization failed', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    }

    // Global Token Manager Subsystem
    this.subsystems.globalTokenManager = new _globalTokenManagerSubsystem.GlobalTokenManagerSubsystem(this.logger.child({
      subsystem: 'globalTokenManager'
    }), this.eventBus);
    await this.subsystems.globalTokenManager.init();
    this.logger.debug('Global Token Manager subsystem initialized');

    // Initialize Token Notification Subsystem
    this.subsystems.tokenNotification = new _tokenNotificationSubsystem.TokenNotificationSubsystem(this.logger.child({
      subsystem: 'token-notification'
    }), this.eventBus, this.subsystems.navigation);
    await this.subsystems.tokenNotification.init();
    this.logger.debug('Token Notification subsystem initialized');
    this.logger.info('All subsystems initialized successfully', {
      subsystemCount: Object.keys(this.subsystems).length,
      enabledSubsystems: Object.keys(this.subsystems)
    });
  }

  /**
   * Initialize remaining legacy components (minimal usage)
   */
  async initializeLegacyComponents() {
    this.logger.debug('Initializing remaining legacy components');

    // Note: Most legacy managers have been replaced by modern subsystems
    // Only keeping minimal legacy components that haven't been fully migrated yet

    this.logger.debug('Legacy components initialized (minimal set)');
  }
  /**
   * Set up event listeners and EventBus patterns
   */
  setupEventListeners() {
    this.logger.debug('Setting up event listeners and EventBus patterns');

    // Global error handler with EventBus integration
    window.addEventListener('error', event => {
      const errorData = {
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        error: event.error?.stack
      };
      this.logger.error('Global error caught', errorData);
      this.eventBus.emit('app:global-error', errorData);
    });

    // Unhandled promise rejection handler with EventBus integration
    window.addEventListener('unhandledrejection', event => {
      const rejectionData = {
        reason: event.reason,
        promise: event.promise
      };
      this.logger.error('Unhandled promise rejection', rejectionData);
      this.eventBus.emit('app:unhandled-rejection', rejectionData);
    });

    // Performance monitoring with EventBus integration
    window.addEventListener('load', () => {
      const performanceData = {
        loadTime: performance.now(),
        timing: performance.timing
      };
      this.logger.info('Page load completed', performanceData);
      this.eventBus.emit('app:page-loaded', performanceData);
    });

    // Settings save feedback event listeners
    window.addEventListener('settings:save-success', event => {
      const statusBox = document.getElementById('settings-status-box');
      if (statusBox) {
        statusBox.textContent = event.detail.message;
        statusBox.className = 'status-message status-success';
        statusBox.style.display = 'flex';
        setTimeout(() => {
          statusBox.style.display = 'none';
        }, 5000);
      }
    });
    window.addEventListener('settings:save-error', event => {
      const statusBox = document.getElementById('settings-status-box');
      if (statusBox) {
        statusBox.textContent = event.detail.message;
        statusBox.className = 'status-message status-error';
        statusBox.style.display = 'flex';
        setTimeout(() => {
          statusBox.style.display = 'none';
        }, 8000);
      }
    });

    // EventBus listeners for subsystem coordination
    this.setupEventBusListeners();

    // Setup main UI button event listeners
    this.setupMainUIEventListeners();
    this.logger.debug('Event listeners and EventBus patterns set up');
  }

  /**
   * Set up main UI event listeners for navigation and buttons
   */
  setupMainUIEventListeners() {
    this.logger.debug('Setting up main UI event listeners');
    try {
      // Note: Navigation cards are handled by ViewManagementSubsystem
      // Only set up non-navigation UI event listeners here

      // File input handlers for import
      const fileInput = document.getElementById('csv-file');
      if (fileInput) {
        fileInput.addEventListener('change', e => {
          this.logger.debug('File input changed');
          this.handleFileSelection(e);
        });
      }

      // Drop zone handlers for import
      const dropZone = document.getElementById('import-drop-zone');
      if (dropZone) {
        dropZone.addEventListener('click', e => {
          e.preventDefault();
          this.logger.debug('Drop zone clicked');
          if (fileInput) {
            fileInput.click();
          }
        });
        dropZone.addEventListener('dragover', e => {
          e.preventDefault();
          dropZone.classList.add('dragover');
        });
        dropZone.addEventListener('dragleave', e => {
          e.preventDefault();
          dropZone.classList.remove('dragover');
        });
        dropZone.addEventListener('drop', e => {
          e.preventDefault();
          dropZone.classList.remove('dragover');
          this.logger.debug('File dropped');
          this.handleFileDrop(e);
        });
      }

      // Cancel import button
      const cancelImportBtn = document.getElementById('cancel-import-btn');
      if (cancelImportBtn) {
        cancelImportBtn.addEventListener('click', e => {
          e.preventDefault();
          this.logger.debug('Cancel import button clicked');
          this.cancelImport();
        });
      }

      // DIRECT NAVIGATION FIX - Add navigation event listeners as fallback
      this.logger.debug('Setting up direct navigation event listeners as fallback');
      this.setupDirectNavigation();
      this.logger.debug('Main UI event listeners set up successfully');
    } catch (error) {
      this.logger.error('Failed to set up main UI event listeners', {
        error: error.message
      });
    }
  }

  /**
   * Set up EventBus listeners for subsystem coordination
   */
  setupEventBusListeners() {
    this.logger.debug('Setting up EventBus listeners for subsystem coordination');

    // Application lifecycle events
    this.eventBus.on('app:init-complete', data => {
      this.logger.info('Application initialization complete', data);
    });
    this.eventBus.on('app:shutdown', data => {
      this.logger.info('Application shutdown initiated', data);
    });

    // Subsystem communication events
    this.eventBus.on('subsystem:error', data => {
      this.logger.error('Subsystem error occurred', data);
    });
    this.eventBus.on('subsystem:ready', data => {
      this.logger.debug('Subsystem ready', data);
    });

    // Operation lifecycle events
    this.eventBus.on('navigation:view-changed', _ref => {
      let {
        newView
      } = _ref;
      this.currentView = newView;
      this.logger.info(`View changed to: ${newView}`);
      if ((0, _featureFlags.isFeatureEnabled)('ANALYTICS_DASHBOARD') && this.analyticsDashboardUI) {
        if (newView === 'analytics') {
          this.analyticsDashboardUI.show();
        } else {
          this.analyticsDashboardUI.hide();
        }
      }
    });
    this.eventBus.on('operation:started', data => {
      this.logger.info('Operation started', data);
    });
    this.eventBus.on('operation:completed', data => {
      this.logger.info('Operation completed', data);
    });
    this.eventBus.on('operation:failed', data => {
      this.logger.error('Operation failed', data);
    });

    // Progress and status events
    this.eventBus.on('progress:updated', data => {
      this.logger.debug('Progress updated', data);
    });
    this.eventBus.on('status:changed', data => {
      this.logger.debug('Status changed', data);
    });
    this.logger.debug('EventBus listeners set up for subsystem coordination');
  }

  /**
   * Set up modal completion listeners
   */
  setupModalCompletionListeners() {
    try {
      // Listen for credentials modal completion
      document.addEventListener('credentials-modal-completed', event => {
        this.logger.info(' LOADING: Credentials modal completed', event.detail);
        this.showModalLoading('Finalizing Setup...', 'Completing your PingOne Import Tool configuration.');

        // Hide loading after a brief delay
        setTimeout(() => {
          this.hideModalLoading();
        }, 1500);
      });

      // Listen for any modal events that might indicate completion
      document.addEventListener('application_enabled_after_credentials', event => {
        this.logger.info(' LOADING: Application enabled after credentials');
        this.showModalLoading('Almost Ready...', 'Finalizing your workspace setup.');
        setTimeout(() => {
          this.hideModalLoading();
        }, 1000);
      });
      this.logger.debug('Modal completion listeners set up');
    } catch (error) {
      this.logger.error('Failed to set up modal completion listeners', {
        error: error.message
      });
    }
  }

  /**
   * Show modal loading overlay
   */
  showModalLoading() {
    let title = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Loading...';
    let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Please wait while we set up your experience.';
    try {
      const overlay = document.getElementById('modal-loading-overlay');
      const titleElement = document.getElementById('modal-loading-title');
      const messageElement = document.getElementById('modal-loading-message');
      if (overlay && titleElement && messageElement) {
        titleElement.textContent = title;
        messageElement.textContent = message;
        overlay.classList.remove('fade-out');
        overlay.classList.add('fade-in');
        overlay.style.display = 'flex';
        this.logger.debug(' LOADING: Modal loading shown', {
          title,
          message
        });
      }
    } catch (error) {
      this.logger.error(' LOADING: Failed to show modal loading', {
        error: error.message
      });
    }
  }

  /**
   * Hide modal loading overlay
   */
  hideModalLoading() {
    try {
      const overlay = document.getElementById('modal-loading-overlay');
      if (overlay) {
        overlay.classList.remove('fade-in');
        overlay.classList.add('fade-out');

        // Hide after animation completes
        setTimeout(() => {
          overlay.style.display = 'none';
          overlay.classList.remove('fade-out');
        }, 300);
        this.logger.debug(' LOADING: Modal loading hidden');
      }
    } catch (error) {
      this.logger.error(' LOADING: Failed to hide modal loading', {
        error: error.message
      });
    }
  }

  /**
   * Update startup screen message
   */
  updateStartupMessage(message) {
    try {
      const startupScreen = document.getElementById('startup-wait-screen');
      const textElement = startupScreen?.querySelector('.startup-text p');
      if (textElement) {
        textElement.textContent = message;
        this.logger.debug(' LOADING: Startup message updated', {
          message
        });
      }
    } catch (error) {
      this.logger.error(' LOADING: Failed to update startup message', {
        error: error.message
      });
    }
  }

  /**
   * Set up direct navigation event listeners as fallback
   * This is used when the ViewManagementSubsystem is not working properly
   */
  setupDirectNavigation() {
    this.logger.debug(' DIRECT NAV: Setting up direct navigation event listeners');
    try {
      // Find all navigation elements
      const navElements = document.querySelectorAll('[data-view]');
      this.logger.debug(` DIRECT NAV: Found ${navElements.length} navigation elements`);
      if (navElements.length === 0) {
        this.logger.warn(' DIRECT NAV: No navigation elements found with [data-view] attribute');
        return;
      }

      // Add click listeners to navigation elements
      navElements.forEach((element, index) => {
        const view = element.getAttribute('data-view');
        this.logger.debug(` DIRECT NAV: Setting up listener for ${view} (element ${index})`);

        // Remove any existing listeners first
        element.removeEventListener('click', this.handleDirectNavigation);

        // Add new listener
        const clickHandler = e => {
          e.preventDefault();
          e.stopPropagation();
          this.logger.info(` DIRECT NAV: Navigation clicked: ${view}`);
          this.directShowView(view);
        };
        element.addEventListener('click', clickHandler);

        // Store the handler for cleanup if needed
        element._directNavHandler = clickHandler;
      });
      this.logger.info(' DIRECT NAV: Direct navigation setup completed successfully');

      // Also set up settings page buttons
      this.setupSettingsPageButtons();
    } catch (error) {
      this.logger.error(' DIRECT NAV: Failed to set up direct navigation', {
        error: error.message
      });
    }
  }

  /**
   * Set up settings page button event listeners
   */
  setupSettingsPageButtons() {
    this.logger.debug(' SETTINGS: Setting up settings page button listeners');
    try {
      // Save Settings button
      const saveSettingsBtn = document.getElementById('save-settings');
      if (saveSettingsBtn) {
        saveSettingsBtn.addEventListener('click', e => {
          e.preventDefault();
          this.logger.info(' SETTINGS: Save Settings clicked');
          this.handleSaveSettings();
        });
        this.logger.debug(' SETTINGS: Save Settings button listener added');
      }

      // Test Connection button
      const testConnectionBtn = document.getElementById('test-connection-btn');
      if (testConnectionBtn) {
        testConnectionBtn.addEventListener('click', e => {
          e.preventDefault();
          this.logger.info(' SETTINGS: Test Connection clicked');
          this.handleTestConnection();
        });
        this.logger.debug(' SETTINGS: Test Connection button listener added');
      }

      // Get Token button
      const getTokenBtn = document.getElementById('get-token-btn');
      if (getTokenBtn) {
        getTokenBtn.addEventListener('click', e => {
          e.preventDefault();
          this.logger.info(' SETTINGS: Get Token clicked');
          this.handleGetToken();
        });
        this.logger.debug(' SETTINGS: Get Token button listener added');
      }

      // Toggle API Secret Visibility button
      const toggleSecretBtn = document.getElementById('toggle-api-secret-visibility');
      if (toggleSecretBtn) {
        toggleSecretBtn.addEventListener('click', e => {
          e.preventDefault();
          this.logger.info(' SETTINGS: Toggle Secret Visibility clicked');
          this.handleToggleSecretVisibility();
        });
        this.logger.debug(' SETTINGS: Toggle Secret Visibility button listener added');
      }
      this.logger.info(' SETTINGS: Settings page buttons setup completed');
    } catch (error) {
      this.logger.error(' SETTINGS: Failed to set up settings page buttons', {
        error: error.message
      });
    }
  }

  /**
   * Handle Save Settings button click
   */
  async handleSaveSettings() {
    this.logger.info(' SETTINGS: Saving settings...');

    // Debug logging
    _debugLogger.debugLog.userAction('save_settings', 'save-settings-button', {
      timestamp: Date.now()
    });
    try {
      // Get form values
      const environmentId = document.getElementById('environment-id')?.value;
      const clientId = document.getElementById('api-client-id')?.value;
      const clientSecret = document.getElementById('api-secret')?.value;
      const region = document.getElementById('region')?.value;
      const rateLimit = document.getElementById('rate-limit')?.value;
      const populationId = document.getElementById('population-id')?.value;
      const settings = {
        environmentId,
        apiClientId: clientId,
        // Fix: use apiClientId instead of clientId
        apiSecret: clientSecret,
        // Fix: use apiSecret instead of clientSecret
        region,
        rateLimit: parseInt(rateLimit) || 90,
        populationId
      };
      this.logger.debug(' SETTINGS: Settings to save', {
        ...settings,
        clientSecret: '[HIDDEN]'
      });

      // Use settings manager if available
      if (this.settingsManager && typeof this.settingsManager.saveSettings === 'function') {
        await this.settingsManager.saveSettings(settings);
        this.showSettingsStatus('Settings saved successfully!', 'success');
      } else {
        // Fallback: save to localStorage and send to server
        localStorage.setItem('pingone-settings', JSON.stringify(settings));

        // Send to server
        const response = await fetch('/api/settings', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(settings)
        });
        if (response.ok) {
          const result = await response.json();
          this.showSettingsStatus('Settings saved successfully!', 'success');
          this.logger.info(' SETTINGS: Settings saved successfully', result);
        } else {
          const errorData = await response.json().catch(() => ({
            error: 'Unknown error'
          }));
          throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
        }
      }
    } catch (error) {
      this.logger.error(' SETTINGS: Failed to save settings', {
        error: error.message
      });

      // Debug logging
      _debugLogger.debugLog.error('settings', 'Save settings failed', error, {
        action: 'save_settings',
        timestamp: Date.now()
      });
      this.showSettingsStatus(`Failed to save settings: ${error.message}`, 'error');
    }
  }

  /**
   * Handle Test Connection button click
   */
  async handleTestConnection() {
    this.logger.info(' SETTINGS: Testing connection...');

    // Debug logging
    _debugLogger.debugLog.userAction('test_connection', 'test-connection-btn', {
      timestamp: Date.now()
    });
    try {
      this.showSettingsStatus('Testing connection...', 'info');

      // Use connection manager if available
      if (this.subsystems.connectionManager && typeof this.subsystems.connectionManager.testConnection === 'function') {
        const result = await this.subsystems.connectionManager.testConnection();
        if (result.success) {
          this.showSettingsStatus('Connection test successful!', 'success');
        } else {
          this.showSettingsStatus(`Connection test failed: ${result.error}`, 'error');
        }
      } else {
        // Fallback: test connection directly
        const response = await fetch('/api/pingone/test-connection', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });
        const result = await response.json();
        if (result.success) {
          this.showSettingsStatus('Connection test successful!', 'success');
        } else {
          this.showSettingsStatus(`Connection test failed: ${result.error}`, 'error');
        }
      }
    } catch (error) {
      this.logger.error(' SETTINGS: Connection test failed', {
        error: error.message
      });
      this.showSettingsStatus(`Connection test failed: ${error.message}`, 'error');
    }
  }

  /**
   * Handle Get Token button click
   */
  async handleGetToken() {
    this.logger.info(' SETTINGS: Getting token...');

    // Debug logging
    _debugLogger.debugLog.userAction('get_token', 'get-token-btn', {
      timestamp: Date.now()
    });
    try {
      this.showSettingsStatus('Getting token...', 'info');

      // Use token manager if available
      if (this.tokenManager && typeof this.tokenManager.getToken === 'function') {
        const token = await this.tokenManager.getToken();
        if (token) {
          this.showSettingsStatus('Token acquired successfully!', 'success');
        } else {
          this.showSettingsStatus('Failed to get token', 'error');
        }
      } else {
        // Fallback: get token directly
        const response = await fetch('/api/pingone/token', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });
        const result = await response.json();
        if (result.access_token) {
          this.showSettingsStatus('Token acquired successfully!', 'success');
        } else {
          this.showSettingsStatus('Failed to get token', 'error');
        }
      }
    } catch (error) {
      this.logger.error(' SETTINGS: Failed to get token', {
        error: error.message
      });
      this.showSettingsStatus(`Failed to get token: ${error.message}`, 'error');
    }
  }

  /**
   * Handle Toggle Secret Visibility button click
   */
  handleToggleSecretVisibility() {
    this.logger.debug(' SETTINGS: Toggling secret visibility');
    try {
      const secretInput = document.getElementById('api-secret');
      const toggleBtn = document.getElementById('toggle-api-secret-visibility');
      const icon = toggleBtn?.querySelector('i');
      if (secretInput && toggleBtn && icon) {
        if (secretInput.type === 'password') {
          secretInput.type = 'text';
          icon.className = 'fas fa-eye-slash';
          this.logger.debug(' SETTINGS: Secret visibility: shown');
        } else {
          secretInput.type = 'password';
          icon.className = 'fas fa-eye';
          this.logger.debug(' SETTINGS: Secret visibility: hidden');
        }
      }
    } catch (error) {
      this.logger.error(' SETTINGS: Failed to toggle secret visibility', {
        error: error.message
      });
    }
  }

  /**
   * Show status message in settings page
   */
  showSettingsStatus(message) {
    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'info';
    try {
      const statusElement = document.getElementById('settings-action-status');
      const messageElement = statusElement?.querySelector('.status-message');
      const iconElement = statusElement?.querySelector('.status-icon');
      if (statusElement && messageElement && iconElement) {
        // Set message
        messageElement.textContent = message;

        // Set icon based on type
        const icons = {
          'success': 'fas fa-check-circle',
          'error': 'fas fa-exclamation-circle',
          'info': 'fas fa-info-circle',
          'warning': 'fas fa-exclamation-triangle'
        };
        iconElement.className = icons[type] || icons.info;

        // Set CSS class for styling
        statusElement.className = `action-status ${type}`;
        statusElement.style.display = 'block';

        // Auto-hide after 5 seconds for success/info messages
        if (type === 'success' || type === 'info') {
          setTimeout(() => {
            statusElement.style.display = 'none';
          }, 5000);
        }
        this.logger.debug(` SETTINGS: Status shown: ${type} - ${message}`);
      }
    } catch (error) {
      this.logger.error(' SETTINGS: Failed to show status', {
        error: error.message
      });
    }
  }

  /**
   * Direct view switching (bypasses subsystems)
   */
  async directShowView(view) {
    this.logger.info(` DIRECT NAV: Switching to view: ${view}`);

    // Debug logging
    _debugLogger.debugLog.navigation(this.currentView, view, {
      method: 'direct_navigation',
      timestamp: Date.now()
    });
    try {
      // Hide all views
      const allViews = document.querySelectorAll('.view, .view-container');
      this.logger.debug(` DIRECT NAV: Found ${allViews.length} view containers to hide`);
      allViews.forEach(viewElement => {
        viewElement.style.display = 'none';
        viewElement.classList.remove('active');
      });

      // Show target view
      const targetView = document.getElementById(`${view}-view`);
      if (targetView) {
        targetView.style.display = 'block';
        targetView.classList.add('active');
        this.logger.info(` DIRECT NAV: Successfully showed ${view}-view`);

        // Update navigation state
        this.updateDirectNavigationState(view);

        // Update current view
        this.currentView = view;

        // Update page title
        this.updatePageTitle(view);
        this.logger.info(` DIRECT NAV: Navigation to ${view} completed successfully`);
      } else {
        this.logger.error(` DIRECT NAV: View element not found: ${view}-view`);
      }
    } catch (error) {
      this.logger.error(` DIRECT NAV: Failed to show view ${view}`, {
        error: error.message
      });
    }
  }

  /**
   * Update navigation state for direct navigation
   */
  updateDirectNavigationState(view) {
    try {
      // Update active navigation items
      const navElements = document.querySelectorAll('[data-view]');
      navElements.forEach(element => {
        const elementView = element.getAttribute('data-view');
        if (elementView === view) {
          element.classList.add('active');
        } else {
          element.classList.remove('active');
        }
      });
      this.logger.debug(` DIRECT NAV: Updated navigation state for ${view}`);
    } catch (error) {
      this.logger.error(' DIRECT NAV: Failed to update navigation state', {
        error: error.message
      });
    }
  }

  /**
   * Update page title
   */
  updatePageTitle(view) {
    try {
      const titles = {
        'home': 'Home',
        'import': 'Import Users',
        'export': 'Export Users',
        'modify': 'Modify Users',
        'delete-csv': 'Delete Users',
        'settings': 'Settings',
        'logs': 'Logs',
        'history': 'History'
      };
      const title = titles[view] || 'PingOne Import Tool';
      document.title = `${title} - PingOne Import Tool v6.2`;
      this.logger.debug(` DIRECT NAV: Updated page title to: ${document.title}`);
    } catch (error) {
      this.logger.error(' DIRECT NAV: Failed to update page title', {
        error: error.message
      });
    }
  }

  /**
   * Initialize UI
   */
  async initializeUI() {
    this.logger.debug('Initializing UI');

    // Use view management subsystem if available
    if (this.subsystems.viewManager) {
      await this.subsystems.viewManager.showView(this.currentView);
    } else {
      // Fallback to legacy view management
      await this.legacyShowView(this.currentView);
    }
    this.logger.debug('UI initialized');
  }

  /**
   * Show view using subsystem or fallback to legacy
   */
  async showView(view) {
    this.logger.debug('Showing view', {
      view,
      useSubsystem: !!this.subsystems.viewManager
    });
    if (this.subsystems.viewManager) {
      return await this.subsystems.viewManager.showView(view);
    } else {
      return await this.legacyShowView(view);
    }
  }

  /**
   * Legacy view management (fallback)
   */
  async legacyShowView(view) {
    this.logger.debug('Using legacy view management', {
      view
    });
    // Legacy implementation would go here
    this.currentView = view;
  }

  /**
   * Start import operation
   */
  async startImport() {
    this.logger.info('Starting import operation');
    if (this.subsystems.importManager) {
      return await this.subsystems.importManager.startImport();
    } else {
      // Fallback to legacy import
      this.logger.warn('Using legacy import - subsystem not available');
      return await this.legacyStartImport();
    }
  }

  /**
   * Start export operation
   */
  async startExport() {
    this.logger.info('Starting export operation');
    if (this.subsystems.exportManager) {
      return await this.subsystems.exportManager.startExport();
    } else {
      // Fallback to legacy export
      this.logger.warn('Using legacy export - subsystem not available');
      return await this.legacyStartExport();
    }
  }

  /**
   * Get authentication token
   */
  async getToken() {
    this.logger.debug('Getting authentication token');
    if (this.subsystems.authManager) {
      return await this.subsystems.authManager.getToken();
    } else {
      // Fallback to legacy token management
      this.logger.warn('Using legacy token management - subsystem not available');
      return await this.tokenManager.getToken();
    }
  }

  /**
   * Legacy methods (to be removed as subsystems are fully integrated)
   */
  async legacyStartImport() {
    this.logger.debug('Legacy import method called');
    // Legacy implementation
  }
  async legacyStartExport() {
    this.logger.debug('Legacy export method called');
    // Legacy implementation
  }

  /**
   * Navigate to a specific view
   */
  navigateToView(viewName) {
    this.logger.debug('Navigating to view', {
      viewName
    });
    try {
      // Use view management subsystem if available
      if (this.subsystems.viewManager) {
        this.subsystems.viewManager.showView(viewName);
      } else {
        // Fallback to legacy view management
        this.legacyShowView(viewName);
      }
      this.currentView = viewName;
      this.logger.info('Navigation completed', {
        viewName
      });
    } catch (error) {
      this.logger.error('Navigation failed', {
        viewName,
        error: error.message
      });
    }
  }

  /**
   * Handle file selection from input
   */
  handleFileSelection(event) {
    this.logger.debug('Handling file selection');
    try {
      const files = event.target.files;
      if (files && files.length > 0) {
        const file = files[0];
        this.logger.info('File selected', {
          fileName: file.name,
          fileSize: file.size,
          fileType: file.type
        });

        // Use import subsystem if available
        if (this.subsystems.importManager) {
          this.subsystems.importManager.handleFileSelection(file);
        } else {
          this.logger.warn('Import subsystem not available, using legacy import');
          if (this.fileHandler && typeof this.fileHandler.handleFile === 'function') {
            this.fileHandler.handleFile(file);
          } else {
            this.logger.error('No file handling method available');
            this.showMessage('File handling is not available. Please refresh the page.', 'error');
          }
        }
      }
    } catch (error) {
      this.logger.error('File selection handling failed', {
        error: error.message
      });
    }
  }

  /**
   * Handle file drop from drag and drop
   */
  handleFileDrop(event) {
    this.logger.debug('Handling file drop');
    try {
      const files = event.dataTransfer.files;
      if (files && files.length > 0) {
        const file = files[0];
        this.logger.info('File dropped', {
          fileName: file.name,
          fileSize: file.size,
          fileType: file.type
        });

        // Use import subsystem if available
        if (this.subsystems.importManager) {
          this.subsystems.importManager.handleFileSelection(file);
        } else {
          this.logger.warn('Import subsystem not available, using legacy import');
          if (this.fileHandler && typeof this.fileHandler.handleFile === 'function') {
            this.fileHandler.handleFile(file);
          } else {
            this.logger.error('No file handling method available');
            this.showMessage('File handling is not available. Please refresh the page.', 'error');
          }
        }
      }
    } catch (error) {
      this.logger.error('File drop handling failed', {
        error: error.message
      });
    }
  }

  /**
   * Cancel import operation
   */
  cancelImport() {
    this.logger.debug('Cancelling import operation');
    try {
      // Use import subsystem if available
      if (this.subsystems.importManager) {
        this.subsystems.importManager.cancelImport();
      } else {
        this.logger.warn('Import subsystem not available, using legacy cancel');
        this.legacyCancelImport();
      }
      this.logger.info('Import cancellation requested');
    } catch (error) {
      this.logger.error('Import cancellation failed', {
        error: error.message
      });
    }
  }

  /**
   * Enable tool after disclaimer acceptance
   */
  enableToolAfterDisclaimer() {
    this.logger.info('Enabling tool after disclaimer acceptance');
    try {
      // Show loading overlay during transition
      this.showModalLoading('Setting up...', 'Preparing your PingOne Import Tool experience.');

      // Hide startup screen if still visible
      this.hideStartupScreen();

      // Ensure UI is properly initialized and responsive
      if (this.uiManager && typeof this.uiManager.enableUI === 'function') {
        this.uiManager.enableUI();
      }

      // Initialize event listeners if not already done
      if (!this.eventListenersSetup) {
        this.setupEventListeners();
        this.eventListenersSetup = true;
      }

      // Enable all subsystems
      Object.values(this.subsystems).forEach(subsystem => {
        if (subsystem && typeof subsystem.enable === 'function') {
          subsystem.enable();
        }
      });

      // Remove any disabled states from the app container
      const appContainer = document.querySelector('.app-container');
      if (appContainer) {
        appContainer.classList.remove('disabled', 'modal-active');
        appContainer.style.pointerEvents = 'auto';
      }

      // Enable all buttons and interactive elements
      const buttons = document.querySelectorAll('button, .btn');
      buttons.forEach(button => {
        button.disabled = false;
        button.style.pointerEvents = 'auto';
      });
      this.logger.info('Tool enabled successfully after disclaimer');

      // Hide loading overlay after a brief delay to show completion
      setTimeout(() => {
        this.hideModalLoading();
      }, 1000);
    } catch (error) {
      this.logger.error('Failed to enable tool after disclaimer', {
        error: error.message
      });
      // Hide loading overlay on error too
      this.hideModalLoading();
    }
  }

  /**
   * Get application health status
   */
  getHealthStatus() {
    return {
      initialized: this.isInitialized,
      subsystems: Object.keys(this.subsystems).reduce((status, key) => {
        status[key] = this.subsystems[key].isInitialized || false;
        return status;
      }, {}),
      featureFlags: _featureFlags.FEATURE_FLAGS,
      currentView: this.currentView,
      timestamp: new Date().toISOString()
    };
  }
}

// Initialize and start the application
const app = new App();

// Global app reference for debugging
window.app = app;

// Expose enableToolAfterDisclaimer function globally for modal access
window.enableToolAfterDisclaimer = () => {
  if (window.app && typeof window.app.enableToolAfterDisclaimer === 'function') {
    window.app.enableToolAfterDisclaimer();
  } else {
    console.warn('App not available or enableToolAfterDisclaimer method not found');
  }
};

// Expose loading functions for testing
window.testLoading = {
  show: (title, message) => {
    if (window.app) {
      window.app.showModalLoading(title, message);
    }
  },
  hide: () => {
    if (window.app) {
      window.app.hideModalLoading();
    }
  },
  testSequence: () => {
    if (window.app) {
      console.log(' Testing loading sequence...');
      window.app.showModalLoading('Step 1', 'Testing loading overlay...');
      setTimeout(() => {
        window.app.showModalLoading('Step 2', 'Updating message...');
        setTimeout(() => {
          window.app.showModalLoading('Step 3', 'Almost done...');
          setTimeout(() => {
            window.app.hideModalLoading();
            console.log(' Loading test completed');
          }, 1500);
        }, 1500);
      }, 1500);
    }
  }
};

// Start the application when DOM is ready
document.addEventListener('DOMContentLoaded', async () => {
  try {
    await app.init();
    console.log(' PingOne Import Tool v6.2 initialized successfully');
    console.log(' Health Status:', app.getHealthStatus());
  } catch (error) {
    console.error(' Application initialization failed:', error);
  }
});
var _default = exports.default = App;

},{"../../public/js/modules/credentials-modal.js":44,"../../public/js/modules/disclaimer-modal.js":46,"../../public/js/modules/event-bus.js":49,"../../public/js/modules/file-handler.js":50,"../../public/js/modules/file-logger.js":51,"../../public/js/modules/history-subsystem.js":52,"../../public/js/modules/local-api-client.js":53,"../../public/js/modules/logger.js":54,"../../public/js/modules/logging-subsystem.js":55,"../../public/js/modules/pingone-client.js":57,"../../public/js/modules/population-subsystem.js":58,"../../public/js/modules/progress-subsystem.js":60,"../../public/js/modules/session-subsystem.js":62,"../../public/js/modules/settings-manager.js":63,"../../public/js/modules/settings-subsystem.js":64,"../../public/js/modules/token-alert-modal.js":65,"../../public/js/modules/token-manager.js":66,"../../public/js/modules/token-refresh-handler.js":67,"../../public/js/modules/version-manager.js":69,"../shared/feature-flags.js":93,"./components/analytics-dashboard-ui.js":72,"./components/history-ui.js":73,"./components/logging-ui-enhanced.js":74,"./components/realtime-collaboration-ui.js":75,"./components/testing-hub.js":76,"./components/ui-manager.js":77,"./subsystems/advanced-realtime-subsystem.js":78,"./subsystems/analytics-dashboard-subsystem.js":79,"./subsystems/auth-management-subsystem.js":80,"./subsystems/connection-manager-subsystem.js":81,"./subsystems/export-subsystem.js":82,"./subsystems/global-token-manager-subsystem.js":83,"./subsystems/import-subsystem.js":84,"./subsystems/navigation-subsystem.js":85,"./subsystems/operation-manager-subsystem.js":86,"./subsystems/realtime-communication-subsystem.js":87,"./subsystems/token-notification-subsystem.js":88,"./subsystems/view-management-subsystem.js":89,"./utils/browser-logging-service.js":90,"./utils/debug-logger.js":91,"@babel/runtime/helpers/interopRequireDefault":2,"socket.io-client":31}],72:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnalyticsDashboardUI = void 0;
/**
 * Simple Analytics Dashboard UI Component
 * 
 * Provides basic analytics dashboard interface with metrics, alerts, and status
 * without complex chart dependencies for better maintainability
 */

class AnalyticsDashboardUI {
  constructor(eventBus, analyticsDashboardSubsystem) {
    this.eventBus = eventBus;
    this.analyticsDashboardSubsystem = analyticsDashboardSubsystem;
    this.isVisible = false;
    this.updateInterval = null;
    this.logger = this.analyticsDashboardSubsystem.logger;
    this.setupEventListeners();
  }

  /**
   * Initialize the analytics dashboard UI
   */
  async init() {
    this.logger.debug('Initializing Simple Analytics Dashboard UI');
    try {
      this.createDashboardHTML();
      this.setupUIEventListeners();
      this.logger.info('Simple Analytics Dashboard UI initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize Simple Analytics Dashboard UI', error);
      throw error;
    }
  }

  /**
   * Show the analytics dashboard
   */
  show() {
    if (this.isVisible) return;
    this.isVisible = true;
    const container = document.getElementById('analytics-dashboard-container');
    if (container) {
      container.classList.remove('hidden');
      this.startRealTimeUpdates();
      this.refreshDashboard();
      this.eventBus.emit('analytics-dashboard:shown');
      this.logger.debug('Analytics dashboard shown');
    }
  }

  /**
   * Hide the analytics dashboard
   */
  hide() {
    if (!this.isVisible) return;
    this.isVisible = false;
    const container = document.getElementById('analytics-dashboard-container');
    if (container) {
      container.classList.add('hidden');
      this.stopRealTimeUpdates();
      this.eventBus.emit('analytics-dashboard:hidden');
      this.logger.debug('Analytics dashboard hidden');
    }
  }

  /**
   * Toggle dashboard visibility
   */
  toggle() {
    if (this.isVisible) {
      this.hide();
    } else {
      this.show();
    }
  }

  /**
   * Create the dashboard HTML structure
   */
  createDashboardHTML() {
    const container = document.getElementById('analytics-view');
    if (!container) {
      this.logger.error('Analytics view container (#analytics-view) not found.');
      return;
    }
    const dashboardHTML = `
            <div id="analytics-dashboard-container" class="analytics-dashboard-container">
                <div class="dashboard-content">
                    <!-- Header -->
                    <div class="dashboard-header">
                        <div class="dashboard-title">
                            <h2><i class="fas fa-chart-line"></i> Analytics Dashboard</h2>
                            <div class="dashboard-subtitle">System metrics and performance overview</div>
                        </div>
                        <div class="dashboard-controls">
                            <div class="refresh-controls">
                                <button id="refresh-dashboard" class="btn btn-outline-primary btn-sm">
                                    <i class="fas fa-sync-alt"></i> Refresh
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Summary Cards -->
                    <div class="summary-section">
                        <div class="summary-cards" id="summary-cards">
                            <!-- Dynamic summary cards will be inserted here -->
                        </div>
                    </div>
                    
                    <!-- Simple Metrics Display -->
                    <div class="charts-section">
                        <div class="charts-grid">
                            <div class="chart-container">
                                <div class="chart-header">
                                    <h3>System Status</h3>
                                </div>
                                <div class="chart-wrapper">
                                    <div id="system-status-display" class="simple-metrics-display">
                                        <div class="metric-row">
                                            <span class="metric-label">CPU Usage:</span>
                                            <div class="metric-bar">
                                                <div class="metric-fill" id="cpu-fill" style="width: 0%"></div>
                                                <span class="metric-value" id="cpu-value">0%</span>
                                            </div>
                                        </div>
                                        <div class="metric-row">
                                            <span class="metric-label">Memory Usage:</span>
                                            <div class="metric-bar">
                                                <div class="metric-fill" id="memory-fill" style="width: 0%"></div>
                                                <span class="metric-value" id="memory-value">0%</span>
                                            </div>
                                        </div>
                                        <div class="metric-row">
                                            <span class="metric-label">Active Sessions:</span>
                                            <div class="metric-display">
                                                <span class="metric-value" id="sessions-value">0</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="chart-container">
                                <div class="chart-header">
                                    <h3>Operation Summary</h3>
                                </div>
                                <div class="chart-wrapper">
                                    <div id="operation-summary-display" class="simple-metrics-display">
                                        <div class="metric-row">
                                            <span class="metric-label">Total Operations:</span>
                                            <div class="metric-display">
                                                <span class="metric-value" id="total-ops-value">0</span>
                                            </div>
                                        </div>
                                        <div class="metric-row">
                                            <span class="metric-label">Success Rate:</span>
                                            <div class="metric-bar success-bar">
                                                <div class="metric-fill" id="success-fill" style="width: 0%"></div>
                                                <span class="metric-value" id="success-value">0%</span>
                                            </div>
                                        </div>
                                        <div class="metric-row">
                                            <span class="metric-label">Avg Response Time:</span>
                                            <div class="metric-display">
                                                <span class="metric-value" id="response-time-value">0ms</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Alerts -->
                    <div class="alerts-section">
                        <div class="section-header">
                            <h3><i class="fas fa-exclamation-triangle"></i> Active Alerts</h3>
                            <button id="clear-all-alerts" class="btn btn-outline-danger btn-sm">
                                <i class="fas fa-trash"></i> Clear All
                            </button>
                        </div>
                        <div class="alerts-container" id="alerts-container">
                            <div class="no-alerts">
                                <i class="fas fa-check-circle"></i>
                                <span>No active alerts - All systems operational</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Recent Activity -->
                    <div class="metrics-section">
                        <div class="section-header">
                            <h3><i class="fas fa-list"></i> Recent Activity</h3>
                            <button id="refresh-activity" class="btn btn-outline-primary btn-sm">
                                <i class="fas fa-sync-alt"></i> Refresh
                            </button>
                        </div>
                        <div class="activity-list" id="activity-list">
                            <div class="no-data">No recent activity</div>
                        </div>
                    </div>
                </div>
            </div>
        `;

    // Insert dashboard HTML into the page
    document.body.insertAdjacentHTML('beforeend', dashboardHTML);
    this.logger.debug('Simple analytics dashboard HTML created');
  }

  /**
   * Set up UI event listeners
   */
  setupUIEventListeners() {
    // Close dashboard
    document.getElementById('close-dashboard')?.addEventListener('click', () => {
      this.hide();
    });

    // Refresh dashboard
    document.getElementById('refresh-dashboard')?.addEventListener('click', () => {
      this.refreshDashboard();
    });

    // Clear all alerts
    document.getElementById('clear-all-alerts')?.addEventListener('click', () => {
      this.clearAllAlerts();
    });

    // Refresh activity
    document.getElementById('refresh-activity')?.addEventListener('click', () => {
      this.refreshActivity();
    });

    // Close on background click
    document.getElementById('analytics-dashboard-container')?.addEventListener('click', e => {
      if (e.target.id === 'analytics-dashboard-container') {
        this.hide();
      }
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', e => {
      if (this.isVisible && e.key === 'Escape') {
        this.hide();
      }
    });
    this.logger.debug('Simple analytics dashboard UI event listeners set up');
  }

  /**
   * Set up EventBus listeners
   */
  setupEventListeners() {
    // Listen for analytics data updates
    this.eventBus.on('analytics:data-updated', data => {
      this.updateDashboard(data);
    });

    // Listen for new alerts
    this.eventBus.on('analytics:alert-created', alert => {
      this.addAlert(alert);
    });

    // Listen for activity updates
    this.eventBus.on('analytics:activity-updated', activity => {
      this.updateActivity(activity);
    });
    this.logger.debug('Simple analytics dashboard event listeners set up');
  }

  /**
   * Start real-time updates
   */
  startRealTimeUpdates() {
    if (this.updateInterval) {
      clearInterval(this.updateInterval);
    }
    this.updateInterval = setInterval(() => {
      this.refreshDashboard();
    }, 5000); // Update every 5 seconds

    this.logger.debug('Real-time updates started');
  }

  /**
   * Stop real-time updates
   */
  stopRealTimeUpdates() {
    if (this.updateInterval) {
      clearInterval(this.updateInterval);
      this.updateInterval = null;
    }
    this.logger.debug('Real-time updates stopped');
  }

  /**
   * Refresh the entire dashboard
   */
  async refreshDashboard() {
    try {
      const data = await this.analyticsDashboardSubsystem.getAnalyticsData();
      this.updateDashboard(data);

      // Update refresh button state
      const refreshBtn = document.getElementById('refresh-dashboard');
      if (refreshBtn) {
        const icon = refreshBtn.querySelector('i');
        icon.classList.add('fa-spin');
        setTimeout(() => icon.classList.remove('fa-spin'), 1000);
      }
    } catch (error) {
      this.logger.error('Failed to refresh dashboard', error);
    }
  }

  /**
   * Update dashboard with new data
   */
  updateDashboard(data) {
    this.updateSummaryCards(data.summary || {});
    this.updateSystemMetrics(data.system || {});
    this.updateOperationMetrics(data.operations || {});
    this.updateAlerts(data.alerts || []);
    this.updateActivity(data.activity || []);
  }

  /**
   * Update summary cards
   */
  updateSummaryCards(summary) {
    const container = document.getElementById('summary-cards');
    if (!container) return;
    const cards = [{
      icon: 'fas fa-users',
      iconClass: 'info',
      value: summary.totalOperations || 0,
      label: 'Total Operations',
      change: summary.operationsChange || '+0%'
    }, {
      icon: 'fas fa-check-circle',
      iconClass: 'success',
      value: summary.successRate || '0%',
      label: 'Success Rate',
      change: summary.successRateChange || '+0%'
    }, {
      icon: 'fas fa-clock',
      iconClass: 'warning',
      value: summary.avgResponseTime || '0ms',
      label: 'Avg Response Time',
      change: summary.responseTimeChange || '+0%'
    }, {
      icon: 'fas fa-exclamation-triangle',
      iconClass: 'warning',
      value: summary.activeAlerts || 0,
      label: 'Active Alerts',
      change: summary.alertsChange || '+0'
    }];
    container.innerHTML = cards.map(card => `
            <div class="summary-card">
                <div class="card-icon ${card.iconClass}">
                    <i class="${card.icon}"></i>
                </div>
                <div class="card-content">
                    <div class="card-value">${card.value}</div>
                    <div class="card-label">${card.label}</div>
                    <div class="card-change ${card.change.startsWith('-') ? 'negative' : ''}">${card.change}</div>
                </div>
            </div>
        `).join('');
  }

  /**
   * Update system metrics display
   */
  updateSystemMetrics(system) {
    // Update CPU usage
    const cpuFill = document.getElementById('cpu-fill');
    const cpuValue = document.getElementById('cpu-value');
    if (cpuFill && cpuValue) {
      const cpu = system.cpuUsage || 0;
      cpuFill.style.width = `${cpu}%`;
      cpuValue.textContent = `${cpu}%`;
      cpuFill.className = `metric-fill ${cpu > 80 ? 'danger' : cpu > 60 ? 'warning' : 'success'}`;
    }

    // Update Memory usage
    const memoryFill = document.getElementById('memory-fill');
    const memoryValue = document.getElementById('memory-value');
    if (memoryFill && memoryValue) {
      const memory = system.memoryUsage || 0;
      memoryFill.style.width = `${memory}%`;
      memoryValue.textContent = `${memory}%`;
      memoryFill.className = `metric-fill ${memory > 80 ? 'danger' : memory > 60 ? 'warning' : 'success'}`;
    }

    // Update Active sessions
    const sessionsValue = document.getElementById('sessions-value');
    if (sessionsValue) {
      sessionsValue.textContent = system.activeSessions || 0;
    }
  }

  /**
   * Update operation metrics display
   */
  updateOperationMetrics(operations) {
    // Update total operations
    const totalOpsValue = document.getElementById('total-ops-value');
    if (totalOpsValue) {
      totalOpsValue.textContent = operations.totalOperations || 0;
    }

    // Update success rate
    const successFill = document.getElementById('success-fill');
    const successValue = document.getElementById('success-value');
    if (successFill && successValue) {
      const successRate = operations.successRate || 0;
      successFill.style.width = `${successRate}%`;
      successValue.textContent = `${successRate}%`;
    }

    // Update response time
    const responseTimeValue = document.getElementById('response-time-value');
    if (responseTimeValue) {
      responseTimeValue.textContent = operations.avgResponseTime || '0ms';
    }
  }

  /**
   * Update alerts
   */
  updateAlerts(alerts) {
    const container = document.getElementById('alerts-container');
    if (!container) return;
    if (!alerts || alerts.length === 0) {
      container.innerHTML = `
                <div class="no-alerts">
                    <i class="fas fa-check-circle"></i>
                    <span>No active alerts - All systems operational</span>
                </div>
            `;
      return;
    }
    container.innerHTML = alerts.map(alert => `
            <div class="alert-item ${alert.severity || 'info'}" data-alert-id="${alert.id}">
                <div class="alert-icon">
                    <i class="fas fa-${this.getAlertIcon(alert.severity)}"></i>
                </div>
                <div class="alert-content">
                    <div class="alert-message">${alert.message}</div>
                    <div class="alert-time">${this.formatTime(alert.timestamp)}</div>
                </div>
                <button class="alert-dismiss" onclick="this.parentElement.remove()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        `).join('');
  }

  /**
   * Add a new alert
   */
  addAlert(alert) {
    const container = document.getElementById('alerts-container');
    if (!container) return;

    // Remove "no alerts" message if present
    const noAlerts = container.querySelector('.no-alerts');
    if (noAlerts) {
      noAlerts.remove();
    }
    const alertHTML = `
            <div class="alert-item ${alert.severity || 'info'}" data-alert-id="${alert.id}">
                <div class="alert-icon">
                    <i class="fas fa-${this.getAlertIcon(alert.severity)}"></i>
                </div>
                <div class="alert-content">
                    <div class="alert-message">${alert.message}</div>
                    <div class="alert-time">${this.formatTime(alert.timestamp)}</div>
                </div>
                <button class="alert-dismiss" onclick="this.parentElement.remove()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        `;
    container.insertAdjacentHTML('afterbegin', alertHTML);
  }

  /**
   * Update activity list
   */
  updateActivity(activities) {
    const container = document.getElementById('activity-list');
    if (!container) return;
    if (!activities || activities.length === 0) {
      container.innerHTML = '<div class="no-data">No recent activity</div>';
      return;
    }
    container.innerHTML = activities.slice(0, 10).map(activity => `
            <div class="activity-item">
                <div class="activity-icon ${activity.type || 'info'}">
                    <i class="fas fa-${this.getActivityIcon(activity.type)}"></i>
                </div>
                <div class="activity-content">
                    <div class="activity-message">${activity.message}</div>
                    <div class="activity-time">${this.formatTime(activity.timestamp)}</div>
                </div>
            </div>
        `).join('');
  }

  /**
   * Clear all alerts
   */
  clearAllAlerts() {
    const container = document.getElementById('alerts-container');
    if (container) {
      container.innerHTML = `
                <div class="no-alerts">
                    <i class="fas fa-check-circle"></i>
                    <span>No active alerts - All systems operational</span>
                </div>
            `;
    }
    this.eventBus.emit('analytics:alerts-cleared');
    this.logger.debug('All alerts cleared');
  }

  /**
   * Refresh activity
   */
  refreshActivity() {
    this.logger.debug('Refreshing activity');
    this.eventBus.emit('analytics:activity-refresh-requested');

    // Show refresh in progress
    const refreshBtn = document.getElementById('refresh-activity');
    if (refreshBtn) {
      const icon = refreshBtn.querySelector('i');
      icon.classList.add('fa-spin');
      setTimeout(() => icon.classList.remove('fa-spin'), 1000);
    }
  }

  /**
   * Get appropriate icon for alert severity
   */
  getAlertIcon(severity) {
    switch (severity) {
      case 'error':
        return 'exclamation-circle';
      case 'warning':
        return 'exclamation-triangle';
      case 'info':
        return 'info-circle';
      default:
        return 'info-circle';
    }
  }

  /**
   * Get appropriate icon for activity type
   */
  getActivityIcon(type) {
    switch (type) {
      case 'import':
        return 'upload';
      case 'export':
        return 'download';
      case 'delete':
        return 'trash';
      case 'modify':
        return 'edit';
      case 'error':
        return 'exclamation-circle';
      case 'success':
        return 'check-circle';
      default:
        return 'info-circle';
    }
  }

  /**
   * Format timestamp for display
   */
  formatTime(timestamp) {
    if (!timestamp) return 'Unknown';
    const date = new Date(timestamp);
    const now = new Date();
    const diff = now - date;
    if (diff < 60000) return 'Just now';
    if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
    if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
    return date.toLocaleDateString();
  }

  /**
   * Cleanup resources
   */
  destroy() {
    this.stopRealTimeUpdates();

    // Remove dashboard HTML
    const container = document.getElementById('analytics-dashboard-container');
    if (container) {
      container.remove();
    }
    this.logger.debug('Simple Analytics Dashboard UI destroyed');
  }
}
exports.AnalyticsDashboardUI = AnalyticsDashboardUI;

},{}],73:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.HistoryUIComponent = void 0;
/**
 * History UI Component
 * Modern history management interface integrated with HistorySubsystem
 * Provides comprehensive history viewing, filtering, and management capabilities
 */

class HistoryUIComponent {
  constructor(historySubsystem, eventBus, logger) {
    this.historySubsystem = historySubsystem;
    this.eventBus = eventBus;
    this.logger = logger;

    // UI state
    this.currentHistory = [];
    this.filteredHistory = [];
    this.currentPage = 1;
    this.itemsPerPage = 20;
    this.isLoading = false;

    // Filter state
    this.currentFilters = {
      category: '',
      status: '',
      dateFrom: '',
      dateTo: '',
      search: ''
    };

    // UI elements cache
    this.elements = {};
    this.filterTimeout = null;
    this.logger.debug('HistoryUIComponent initialized');
  }

  /**
   * Initialize the History UI Component
   */
  async init() {
    try {
      this.logger.info('Initializing HistoryUIComponent');

      // Create the UI container
      this.createUI();

      // Cache DOM elements
      this.cacheElements();

      // Setup event listeners
      this.setupEventListeners();

      // Setup filter listeners
      this.setupFilterListeners();

      // Load initial history
      await this.loadHistory();
      this.logger.info('HistoryUIComponent initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize HistoryUIComponent:', error);
      throw error;
    }
  }

  /**
   * Create the UI structure
   */
  createUI() {
    const container = document.getElementById('history-view');
    if (!container) {
      this.logger.error('History view container not found');
      return;
    }
    container.innerHTML = `
            <div class="history-container">
                <!-- Header -->
                <div class="history-header">
                    <h2><i class="fas fa-history"></i> Operation History</h2>
                    <p>Track and manage all operations</p>
                </div>

                <!-- Statistics Cards -->
                <div class="history-stats">
                    <div class="stat-card">
                        <div class="stat-value" id="total-operations">0</div>
                        <div class="stat-label">Total Operations</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="successful-operations">0</div>
                        <div class="stat-label">Successful</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="failed-operations">0</div>
                        <div class="stat-label">Failed</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="success-rate">0%</div>
                        <div class="stat-label">Success Rate</div>
                    </div>
                </div>

                <!-- Controls -->
                <div class="history-controls">
                    <div class="history-filters">
                        <div class="filter-group">
                            <label for="category-filter">Category</label>
                            <select id="category-filter">
                                <option value="">All Categories</option>
                                <option value="import">Import</option>
                                <option value="export">Export</option>
                                <option value="delete">Delete</option>
                                <option value="modify">Modify</option>
                                <option value="settings">Settings</option>
                                <option value="auth">Authentication</option>
                                <option value="system">System</option>
                            </select>
                        </div>
                        
                        <div class="filter-group">
                            <label for="status-filter">Status</label>
                            <select id="status-filter">
                                <option value="">All Status</option>
                                <option value="started">Started</option>
                                <option value="in_progress">In Progress</option>
                                <option value="completed">Completed</option>
                                <option value="failed">Failed</option>
                                <option value="cancelled">Cancelled</option>
                                <option value="partial">Partial</option>
                            </select>
                        </div>
                        
                        <div class="filter-group">
                            <label for="date-from">From Date</label>
                            <input type="date" id="date-from">
                        </div>
                        
                        <div class="filter-group">
                            <label for="date-to">To Date</label>
                            <input type="date" id="date-to">
                        </div>
                        
                        <div class="filter-group search-filter">
                            <label for="history-search-filter">Search</label>
                            <input type="search" id="history-search-filter" placeholder="Search by keyword...">
                        </div>
                    </div>
                    
                    <div class="history-actions">
                        <button class="btn-modern" id="refresh-btn">
                            <i class="fas fa-sync-alt"></i> Refresh
                        </button>
                        <button class="btn-modern" id="export-btn">
                            <i class="fas fa-download"></i> Export
                        </button>
                        <button class="btn-modern" id="clear-filters-btn">
                            <i class="fas fa-filter"></i> Clear Filters
                        </button>
                        <button class="btn-modern btn-danger" id="clear-history-btn">
                            <i class="fas fa-trash"></i> Clear History
                        </button>
                    </div>
                </div>

                <!-- History List -->
                <div class="history-list" id="history-list">
                    <div class="loading-state">
                        <div class="loading-spinner"></div>
                        <p>Loading history...</p>
                    </div>
                </div>

                <!-- Pagination -->
                <div class="history-pagination" id="pagination" style="display: none;">
                    <button id="prev-page" class="btn-modern" disabled>
                        <i class="fas fa-chevron-left"></i> Previous
                    </button>
                    <span id="pagination-info">Page 1 of 1</span>
                    <button id="next-page" class="btn-modern" disabled>
                        Next <i class="fas fa-chevron-right"></i>
                    </button>
                </div>
            </div>
        `;
  }

  /**
   * Cache frequently used DOM elements
   */
  cacheElements() {
    this.elements = {
      historyList: document.getElementById('history-list'),
      pagination: document.getElementById('pagination'),
      categoryFilter: document.getElementById('category-filter'),
      statusFilter: document.getElementById('status-filter'),
      dateFromFilter: document.getElementById('date-from'),
      dateToFilter: document.getElementById('date-to'),
      searchFilter: document.getElementById('history-search-filter'),
      totalOperations: document.getElementById('total-operations'),
      successfulOperations: document.getElementById('successful-operations'),
      failedOperations: document.getElementById('failed-operations'),
      successRate: document.getElementById('success-rate'),
      prevPageBtn: document.getElementById('prev-page'),
      nextPageBtn: document.getElementById('next-page'),
      paginationInfo: document.getElementById('pagination-info'),
      refreshBtn: document.getElementById('refresh-btn'),
      exportBtn: document.getElementById('export-btn'),
      clearFiltersBtn: document.getElementById('clear-filters-btn'),
      clearHistoryBtn: document.getElementById('clear-history-btn')
    };
  }

  /**
   * Setup event listeners for real-time updates
   */
  setupEventListeners() {
    if (this.eventBus) {
      // Listen for history updates from HistorySubsystem
      this.eventBus.on('historyEntryAdded', () => {
        this.logger.debug('History entry added event received');
        this.loadHistory();
      });
      this.eventBus.on('historyEntryUpdated', () => {
        this.logger.debug('History entry updated event received');
        this.loadHistory();
      });
      this.eventBus.on('historyEntryDeleted', () => {
        this.logger.debug('History entry deleted event received');
        this.loadHistory();
      });
      this.eventBus.on('historyCleared', () => {
        this.logger.debug('History cleared event received');
        this.currentHistory = [];
        this.filteredHistory = [];
        this.displayHistory();
      });
    }

    // Button event listeners
    if (this.elements.refreshBtn) {
      this.elements.refreshBtn.addEventListener('click', () => this.refresh());
    }
    if (this.elements.exportBtn) {
      this.elements.exportBtn.addEventListener('click', () => this.exportHistory());
    }
    if (this.elements.clearFiltersBtn) {
      this.elements.clearFiltersBtn.addEventListener('click', () => this.clearFilters());
    }
    if (this.elements.clearHistoryBtn) {
      this.elements.clearHistoryBtn.addEventListener('click', () => this.clearHistory());
    }

    // Pagination event listeners
    if (this.elements.prevPageBtn) {
      this.elements.prevPageBtn.addEventListener('click', () => this.previousPage());
    }
    if (this.elements.nextPageBtn) {
      this.elements.nextPageBtn.addEventListener('click', () => this.nextPage());
    }
  }

  /**
   * Setup filter change listeners
   */
  setupFilterListeners() {
    const filterElements = [this.elements.categoryFilter, this.elements.statusFilter, this.elements.dateFromFilter, this.elements.dateToFilter];
    filterElements.forEach(element => {
      if (element) {
        element.addEventListener('change', () => this.applyFilters());
      }
    });

    // Search filter with debounce
    if (this.elements.searchFilter) {
      this.elements.searchFilter.addEventListener('input', () => this.debounceFilter());
    }
  }

  /**
   * Debounce filter for search input
   */
  debounceFilter() {
    if (this.filterTimeout) {
      clearTimeout(this.filterTimeout);
    }
    this.filterTimeout = setTimeout(() => this.applyFilters(), 300);
  }

  /**
   * Load history from HistorySubsystem
   */
  async loadHistory() {
    if (this.isLoading) return;
    try {
      this.isLoading = true;
      this.showLoadingState();
      this.logger.debug('Loading history from HistorySubsystem');

      // Get history from subsystem
      const historyData = await this.historySubsystem.getHistory({
        limit: 1000,
        // Load more for client-side filtering
        sortBy: 'timestamp',
        sortOrder: 'desc'
      });
      this.currentHistory = historyData.history || [];

      // Apply current filters
      this.applyFilters();

      // Update statistics
      const stats = await this.historySubsystem.getHistoryStats(this.currentHistory);
      this.updateStatistics(stats);
      this.logger.debug('History loaded successfully', {
        count: this.currentHistory.length
      });
    } catch (error) {
      this.logger.error('Failed to load history:', error);
      this.showError('Failed to load history', error.message);
    } finally {
      this.isLoading = false;
    }
  }

  /**
   * Apply current filters to history
   */
  applyFilters() {
    // Update filter state
    this.currentFilters = {
      category: this.elements.categoryFilter?.value || '',
      status: this.elements.statusFilter?.value || '',
      dateFrom: this.elements.dateFromFilter?.value || '',
      dateTo: this.elements.dateToFilter?.value || '',
      search: this.elements.searchFilter?.value || ''
    };

    // Filter history
    this.filteredHistory = this.currentHistory.filter(entry => this.matchesFilters(entry));

    // Reset to first page
    this.currentPage = 1;

    // Display filtered results
    this.displayHistory();
    this.logger.debug('Filters applied', {
      filters: this.currentFilters,
      resultCount: this.filteredHistory.length
    });
  }

  /**
   * Check if entry matches current filters
   */
  matchesFilters(entry) {
    // Category filter
    if (this.currentFilters.category && entry.category !== this.currentFilters.category) {
      return false;
    }

    // Status filter
    if (this.currentFilters.status && entry.status !== this.currentFilters.status) {
      return false;
    }

    // Date filters
    if (this.currentFilters.dateFrom) {
      const entryDate = new Date(entry.timestamp);
      const fromDate = new Date(this.currentFilters.dateFrom);
      if (entryDate < fromDate) {
        return false;
      }
    }
    if (this.currentFilters.dateTo) {
      const entryDate = new Date(entry.timestamp);
      const toDate = new Date(this.currentFilters.dateTo);
      toDate.setHours(23, 59, 59, 999); // End of day
      if (entryDate > toDate) {
        return false;
      }
    }

    // Search filter
    if (this.currentFilters.search) {
      const searchTerm = this.currentFilters.search.toLowerCase();
      const searchableText = [entry.description, entry.category, entry.status, JSON.stringify(entry.data)].join(' ').toLowerCase();
      if (!searchableText.includes(searchTerm)) {
        return false;
      }
    }
    return true;
  }

  /**
   * Display history entries with pagination
   */
  displayHistory() {
    if (!this.elements.historyList) return;
    if (this.filteredHistory.length === 0) {
      this.showNoHistory();
      return;
    }

    // Calculate pagination
    const totalPages = Math.ceil(this.filteredHistory.length / this.itemsPerPage);
    const startIndex = (this.currentPage - 1) * this.itemsPerPage;
    const endIndex = startIndex + this.itemsPerPage;
    const pageHistory = this.filteredHistory.slice(startIndex, endIndex);

    // Generate HTML
    let html = '';
    pageHistory.forEach(entry => {
      html += this.createHistoryEntryHTML(entry);
    });
    this.elements.historyList.innerHTML = html;
    this.updatePagination(totalPages);
  }

  /**
   * Create HTML for a history entry
   */
  createHistoryEntryHTML(entry) {
    const timestamp = new Date(entry.timestamp).toLocaleString();
    const duration = entry.duration ? this.formatDuration(entry.duration) : 'N/A';
    return `
            <div class="history-entry" data-id="${entry.id}">
                <div class="history-entry-header">
                    <div class="history-entry-info">
                        <div class="history-entry-title">
                            ${this.getCategoryIcon(entry.category)} ${entry.description}
                        </div>
                        <div class="history-entry-meta">
                            <span><i class="fas fa-clock"></i> ${timestamp}</span>
                            <span><i class="fas fa-tag"></i> ${entry.category}</span>
                            <span class="status-badge status-${entry.status}">${entry.status}</span>
                            ${duration !== 'N/A' ? `<span><i class="fas fa-stopwatch"></i> ${duration}</span>` : ''}
                        </div>
                    </div>
                    <div class="history-entry-actions">
                        <button class="btn-small" onclick="this.closest('.history-entry').querySelector('.history-entry-details').style.display = this.closest('.history-entry').querySelector('.history-entry-details').style.display === 'none' ? 'block' : 'none'">
                            <i class="fas fa-chevron-down"></i>
                        </button>
                    </div>
                </div>
                <div class="history-entry-details" style="display: none;">
                    ${this.createEntryDetails(entry)}
                </div>
            </div>
        `;
  }

  /**
   * Create details section for history entry
   */
  createEntryDetails(entry) {
    const sanitizedData = this.sanitizeDataForDisplay(entry.data);
    return `
            <div class="entry-details-content">
                <div class="detail-section">
                    <h4>Session Information</h4>
                    <p><strong>Session ID:</strong> ${entry.sessionId}</p>
                    <p><strong>Start Time:</strong> ${new Date(entry.startTime).toLocaleString()}</p>
                </div>
                <div class="detail-section">
                    <h4>Operation Data</h4>
                    <pre class="data-display">${JSON.stringify(sanitizedData, null, 2)}</pre>
                </div>
            </div>
        `;
  }

  /**
   * Sanitize data for display
   */
  sanitizeDataForDisplay(data) {
    if (!data || typeof data !== 'object') return data;
    const sanitized = {
      ...data
    };
    const sensitiveFields = ['password', 'token', 'secret', 'key', 'apiKey', 'clientSecret'];
    const sanitizeObject = obj => {
      Object.keys(obj).forEach(key => {
        if (sensitiveFields.some(field => key.toLowerCase().includes(field))) {
          obj[key] = '[REDACTED]';
        } else if (typeof obj[key] === 'object' && obj[key] !== null) {
          sanitizeObject(obj[key]);
        }
      });
    };
    sanitizeObject(sanitized);
    return sanitized;
  }

  /**
   * Get icon for category
   */
  getCategoryIcon(category) {
    const icons = {
      import: '<i class="fas fa-file-import"></i>',
      export: '<i class="fas fa-file-export"></i>',
      delete: '<i class="fas fa-trash"></i>',
      modify: '<i class="fas fa-edit"></i>',
      settings: '<i class="fas fa-cog"></i>',
      auth: '<i class="fas fa-lock"></i>',
      system: '<i class="fas fa-server"></i>'
    };
    return icons[category] || '<i class="fas fa-file"></i>';
  }

  /**
   * Format duration in milliseconds to readable format
   */
  formatDuration(duration) {
    if (duration < 1000) return `${duration}ms`;
    if (duration < 60000) return `${(duration / 1000).toFixed(1)}s`;
    if (duration < 3600000) return `${(duration / 60000).toFixed(1)}m`;
    return `${(duration / 3600000).toFixed(1)}h`;
  }

  /**
   * Update statistics display
   */
  updateStatistics(stats) {
    if (this.elements.totalOperations) {
      this.elements.totalOperations.textContent = stats.total || 0;
    }
    if (this.elements.successfulOperations) {
      this.elements.successfulOperations.textContent = stats.successful || 0;
    }
    if (this.elements.failedOperations) {
      this.elements.failedOperations.textContent = stats.failed || 0;
    }
    if (this.elements.successRate) {
      this.elements.successRate.textContent = `${stats.successRate || 0}%`;
    }
  }

  /**
   * Update pagination controls
   */
  updatePagination(totalPages) {
    if (!this.elements.pagination) return;
    if (totalPages <= 1) {
      this.elements.pagination.style.display = 'none';
      return;
    }
    this.elements.pagination.style.display = 'flex';
    if (this.elements.paginationInfo) {
      this.elements.paginationInfo.textContent = `Page ${this.currentPage} of ${totalPages}`;
    }
    if (this.elements.prevPageBtn) {
      this.elements.prevPageBtn.disabled = this.currentPage <= 1;
    }
    if (this.elements.nextPageBtn) {
      this.elements.nextPageBtn.disabled = this.currentPage >= totalPages;
    }
  }

  /**
   * Show loading state
   */
  showLoadingState() {
    if (!this.elements.historyList) return;
    this.elements.historyList.innerHTML = `
            <div class="loading-state">
                <div class="loading-spinner"></div>
                <p>Loading history...</p>
            </div>
        `;
  }

  /**
   * Show no history state
   */
  showNoHistory() {
    if (!this.elements.historyList) return;
    this.elements.historyList.innerHTML = `
            <div class="no-history">
                <i class="fas fa-history"></i>
                <h3>No History Found</h3>
                <p>No operations match your current filters.</p>
            </div>
        `;
    if (this.elements.pagination) {
      this.elements.pagination.style.display = 'none';
    }
  }

  /**
   * Show error state
   */
  showError(title, message) {
    if (!this.elements.historyList) return;
    this.elements.historyList.innerHTML = `
            <div class="error-state">
                <i class="fas fa-exclamation-triangle"></i>
                <h3>${title}</h3>
                <p>${message}</p>
                <button class="btn-modern" onclick="this.closest('.history-container').dispatchEvent(new CustomEvent('retry'))">
                    <i class="fas fa-retry"></i> Retry
                </button>
            </div>
        `;
  }

  /**
   * Navigate to next page
   */
  nextPage() {
    const totalPages = Math.ceil(this.filteredHistory.length / this.itemsPerPage);
    if (this.currentPage < totalPages) {
      this.currentPage++;
      this.displayHistory();
    }
  }

  /**
   * Navigate to previous page
   */
  previousPage() {
    if (this.currentPage > 1) {
      this.currentPage--;
      this.displayHistory();
    }
  }

  /**
   * Clear all filters
   */
  clearFilters() {
    if (this.elements.categoryFilter) this.elements.categoryFilter.value = '';
    if (this.elements.statusFilter) this.elements.statusFilter.value = '';
    if (this.elements.dateFromFilter) this.elements.dateFromFilter.value = '';
    if (this.elements.dateToFilter) this.elements.dateToFilter.value = '';
    if (this.elements.searchFilter) this.elements.searchFilter.value = '';
    this.applyFilters();
    this.logger.debug('Filters cleared');
  }

  /**
   * Export history using HistorySubsystem
   */
  async exportHistory() {
    try {
      this.logger.info('Exporting history');
      await this.historySubsystem.exportHistory({
        format: 'csv',
        filtered: true,
        filters: this.currentFilters
      });
      this.logger.info('History exported successfully');
    } catch (error) {
      this.logger.error('Failed to export history:', error);
      alert('Failed to export history: ' + error.message);
    }
  }

  /**
   * Clear all history using HistorySubsystem
   */
  async clearHistory() {
    if (!confirm('Are you sure you want to clear all history? This action cannot be undone.')) {
      return;
    }
    try {
      this.logger.info('Clearing all history');
      await this.historySubsystem.clearHistory();
      this.logger.info('History cleared successfully');

      // Reload history to reflect changes
      await this.loadHistory();
    } catch (error) {
      this.logger.error('Failed to clear history:', error);
      alert('Failed to clear history: ' + error.message);
    }
  }

  /**
   * Refresh history data
   */
  async refresh() {
    this.logger.debug('Refreshing history');
    await this.loadHistory();
  }

  /**
   * Destroy the UI and cleanup
   */
  destroy() {
    // Clear timeouts
    if (this.filterTimeout) {
      clearTimeout(this.filterTimeout);
    }

    // Remove event listeners
    if (this.eventBus) {
      this.eventBus.off('historyEntryAdded');
      this.eventBus.off('historyEntryUpdated');
      this.eventBus.off('historyEntryDeleted');
      this.eventBus.off('historyCleared');
    }
    this.logger.debug('HistoryUIComponent destroyed');
  }
}
exports.HistoryUIComponent = HistoryUIComponent;
var _default = exports.default = HistoryUIComponent;

},{}],74:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.EnhancedLoggingUIComponent = void 0;
/**
 * Enhanced Logging UI Component
 * Modern logging interface with bolder colors, improved arrow styling, and enhanced log type filters
 * Integrated with LoggingSubsystem for comprehensive log viewing and management
 */

class EnhancedLoggingUIComponent {
  constructor(loggingSubsystem, eventBus, logger) {
    this.loggingSubsystem = loggingSubsystem;
    this.eventBus = eventBus;
    this.logger = logger;

    // UI state
    this.currentLogs = [];
    this.filteredLogs = [];
    this.currentPage = 1;
    this.itemsPerPage = 50;
    this.isLoading = false;
    this.isAutoRefresh = true;
    this.refreshInterval = null;

    // Filter state
    this.currentFilters = {
      level: 'all',
      category: 'all',
      dateFrom: '',
      dateTo: '',
      search: ''
    };

    // Log type counts for filters
    this.logTypeCounts = {
      all: 0,
      error: 0,
      warn: 0,
      info: 0,
      debug: 0,
      trace: 0
    };

    // UI elements cache
    this.elements = {};
    this.filterTimeout = null;

    // Make available globally for onclick handlers
    window.enhancedLoggingUI = this;
    this.logger.debug('EnhancedLoggingUIComponent initialized');
  }

  /**
   * Initialize the Enhanced Logging UI Component
   */
  async init() {
    try {
      this.logger.info('Initializing EnhancedLoggingUIComponent');

      // Create the UI container
      this.createUI();

      // Cache DOM elements
      this.cacheElements();

      // Setup event listeners
      this.setupEventListeners();

      // Setup filter listeners
      this.setupFilterListeners();

      // Load initial logs
      await this.loadLogs();

      // Start auto-refresh
      this.startAutoRefresh();
      this.logger.info('EnhancedLoggingUIComponent initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize EnhancedLoggingUIComponent:', error);
      throw error;
    }
  }

  /**
   * Create the enhanced UI structure with log type filters
   */
  createUI() {
    const container = document.getElementById('logs-view');
    if (!container) {
      this.logger.error('Logs view container not found');
      return;
    }
    container.innerHTML = `
            <div class="logging-container">
                <!-- Header -->
                <div class="logging-header">
                    <h2><i class="fas fa-file-alt"></i> Enhanced System Logs</h2>
                    <p>Monitor and analyze system activity with enhanced filtering and visualization</p>
                </div>

                <!-- Statistics Cards -->
                <div class="logging-stats">
                    <div class="stat-card">
                        <div class="stat-value" id="total-logs">0</div>
                        <div class="stat-label">Total Logs</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="error-logs">0</div>
                        <div class="stat-label">Errors</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="warning-logs">0</div>
                        <div class="stat-label">Warnings</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="info-logs">0</div>
                        <div class="stat-label">Info</div>
                    </div>
                </div>

                <!-- Enhanced Log Type Filters -->
                <div class="log-type-filters">
                    <button class="log-type-filter active" data-type="all">All Logs <span class="log-count" id="count-all">0</span></button>
                    <button class="log-type-filter" data-type="error">Errors <span class="log-count" id="count-error">0</span></button>
                    <button class="log-type-filter" data-type="warn">Warnings <span class="log-count" id="count-warn">0</span></button>
                    <button class="log-type-filter" data-type="info">Info <span class="log-count" id="count-info">0</span></button>
                    <button class="log-type-filter" data-type="debug">Debug <span class="log-count" id="count-debug">0</span></button>
                    <button class="log-type-filter" data-type="trace">Trace <span class="log-count" id="count-trace">0</span></button>
                </div>

                <!-- Filter and Action Controls -->
                <div class="logging-controls">
                    <div class="filter-group">
                        <label for="log-category-filter">Category</label>
                        <select id="log-category-filter">
                            <option value="all">All</option>
                            <option value="general">General</option>
                            <option value="auth">Authentication</option>
                            <option value="api">API</option>
                            <option value="import">Import</option>
                            <option value="export">Export</option>
                            <option value="system">System</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="log-date-from">From</label>
                        <input type="date" id="log-date-from">
                    </div>
                    <div class="filter-group">
                        <label for="log-date-to">To</label>
                        <input type="date" id="log-date-to">
                    </div>
                    <div class="filter-group search-filter">
                        <label for="log-search-filter">Search</label>
                        <input type="text" id="log-search-filter" placeholder="Search logs...">
                    </div>
                    <div class="action-group">
                        <button id="clear-filters-btn" class="btn btn-secondary"><i class="fas fa-times"></i> Clear</button>
                        <button id="export-logs-btn" class="btn btn-primary"><i class="fas fa-download"></i> Export</button>
                        <button id="clear-logs-btn" class="btn btn-danger"><i class="fas fa-trash"></i> Clear Logs</button>
                        <button id="refresh-logs-btn" class="btn btn-primary"><i class="fas fa-sync"></i> Refresh</button>
                    </div>
                </div>

                <!-- Logging List -->
                <div id="logging-list-container" class="logging-list-container">
                    <!-- Loading state -->
                    <div id="logging-loading" class="loading-overlay" style="display: none;">
                        <div class="spinner"></div>
                        <p>Loading logs...</p>
                    </div>
                    <!-- No logs state -->
                    <div id="no-logs-message" class="no-logs-message" style="display: none;">
                        <i class="fas fa-info-circle"></i>
                        <p>No logs found. Try adjusting your filters.</p>
                    </div>
                    <!-- Error state -->
                    <div id="logging-error" class="error-message" style="display: none;">
                        <i class="fas fa-exclamation-triangle"></i>
                        <h4 id="logging-error-title">Error</h4>
                        <p id="logging-error-message">An unexpected error occurred.</p>
                    </div>
                    <ul id="logging-list"></ul>
                </div>

                <!-- Pagination -->
                <div class="logging-pagination">
                    <button id="prev-page-btn" class="btn btn-secondary" disabled><i class="fas fa-arrow-left"></i> Previous</button>
                    <span id="page-info">Page 1 of 1</span>
                    <button id="next-page-btn" class="btn btn-secondary" disabled><i class="fas fa-arrow-right"></i> Next</button>
                </div>
            </div>
        `;
  }

  /**
   * Cache frequently used DOM elements
   */
  cacheElements() {
    this.elements.container = document.getElementById('logs-view');
    this.elements.loggingList = this.elements.container.querySelector('#logging-list');
    this.elements.loadingOverlay = this.elements.container.querySelector('#logging-loading');
    this.elements.noLogsMessage = this.elements.container.querySelector('#no-logs-message');
    this.elements.errorMessage = this.elements.container.querySelector('#logging-error');
    this.elements.errorTitle = this.elements.container.querySelector('#logging-error-title');
    this.elements.errorMessageText = this.elements.container.querySelector('#logging-error-message');

    // Stats
    this.elements.totalLogs = this.elements.container.querySelector('#total-logs');
    this.elements.errorLogs = this.elements.container.querySelector('#error-logs');
    this.elements.warningLogs = this.elements.container.querySelector('#warning-logs');
    this.elements.infoLogs = this.elements.container.querySelector('#info-logs');

    // Filters
    this.elements.categoryFilter = this.elements.container.querySelector('#log-category-filter');
    this.elements.dateFromFilter = this.elements.container.querySelector('#log-date-from');
    this.elements.dateToFilter = this.elements.container.querySelector('#log-date-to');
    this.elements.searchFilter = this.elements.container.querySelector('#log-search-filter');

    // Pagination
    this.elements.prevPageBtn = this.elements.container.querySelector('#prev-page-btn');
    this.elements.nextPageBtn = this.elements.container.querySelector('#next-page-btn');
    this.elements.pageInfo = this.elements.container.querySelector('#page-info');
  }

  /**
   * Setup event listeners for real-time updates
   */
  setupEventListeners() {
    // EventBus listeners
    this.eventBus.on('logEntryAdded', this.handleNewLogEntry.bind(this));
    this.eventBus.on('logsCleared', this.handleLogsCleared.bind(this));

    // Pagination listeners
    this.elements.prevPageBtn.addEventListener('click', () => this.previousPage());
    this.elements.nextPageBtn.addEventListener('click', () => this.nextPage());

    // Action listeners
    const clearFiltersBtn = this.elements.container.querySelector('#clear-filters-btn');
    clearFiltersBtn.addEventListener('click', () => this.clearFilters());
    const exportLogsBtn = this.elements.container.querySelector('#export-logs-btn');
    exportLogsBtn.addEventListener('click', () => this.exportLogs());
    const clearLogsBtn = this.elements.container.querySelector('#clear-logs-btn');
    clearLogsBtn.addEventListener('click', () => this.clearLogs());
    const refreshLogsBtn = this.elements.container.querySelector('#refresh-logs-btn');
    refreshLogsBtn.addEventListener('click', () => this.refresh());

    // Log type filter listeners
    const logTypeFilters = this.elements.container.querySelectorAll('.log-type-filter');
    logTypeFilters.forEach(button => {
      button.addEventListener('click', () => {
        this.filterByType(button.dataset.type);
      });
    });
  }

  /**
   * Setup filter change listeners
   */
  setupFilterListeners() {
    this.elements.categoryFilter.addEventListener('change', () => {
      this.currentFilters.category = this.elements.categoryFilter.value;
      this.applyFilters();
    });
    this.elements.dateFromFilter.addEventListener('change', () => {
      this.currentFilters.dateFrom = this.elements.dateFromFilter.value;
      this.applyFilters();
    });
    this.elements.dateToFilter.addEventListener('change', () => {
      this.currentFilters.dateTo = this.elements.dateToFilter.value;
      this.applyFilters();
    });
    this.elements.searchFilter.addEventListener('input', this.debounceFilter.bind(this));
  }

  /**
   * Debounce filter for search input
   */
  debounceFilter() {
    clearTimeout(this.filterTimeout);
    this.filterTimeout = setTimeout(() => {
      this.currentFilters.search = this.elements.searchFilter.value;
      this.applyFilters();
    }, 300);
  }

  /**
   * Filter logs by type (enhanced log type filters)
   */
  filterByType(type) {
    this.currentFilters.level = type;
    this.applyFilters();

    // Update active class on filter buttons
    const logTypeFilters = this.elements.container.querySelectorAll('.log-type-filter');
    logTypeFilters.forEach(button => {
      if (button.dataset.type === type) {
        button.classList.add('active');
      } else {
        button.classList.remove('active');
      }
    });
  }

  /**
   * Load logs from LoggingSubsystem
   */
  async loadLogs() {
    if (this.isLoading) return;
    this.isLoading = true;
    this.showLoadingState();
    try {
      this.logger.debug('Loading logs from subsystem');
      const logs = await this.loggingSubsystem.getLogs();
      this.currentLogs = logs.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      this.logger.debug(`Loaded ${this.currentLogs.length} logs`);

      // Update log type counts
      this.updateLogTypeCounts();

      // Apply filters and display
      this.applyFilters();
    } catch (error) {
      this.logger.error('Failed to load logs:', error);
      this.showError('Failed to load logs', error.message);
    } finally {
      this.isLoading = false;
      this.elements.loadingOverlay.style.display = 'none';
    }
  }

  /**
   * Update log type counts for filter buttons
   */
  updateLogTypeCounts() {
    this.logTypeCounts = {
      all: this.currentLogs.length,
      error: this.currentLogs.filter(log => log.level === 'error').length,
      warn: this.currentLogs.filter(log => log.level === 'warn').length,
      info: this.currentLogs.filter(log => log.level === 'info').length,
      debug: this.currentLogs.filter(log => log.level === 'debug').length,
      trace: this.currentLogs.filter(log => log.level === 'trace').length
    };
    for (const type in this.logTypeCounts) {
      const countElement = this.elements.container.querySelector(`#count-${type}`);
      if (countElement) {
        countElement.textContent = this.logTypeCounts[type];
      }
    }
  }

  /**
   * Apply current filters to logs
   */
  applyFilters() {
    this.logger.debug('Applying filters', {
      filters: this.currentFilters
    });

    // Filter logs
    this.filteredLogs = this.currentLogs.filter(log => this.matchesFilters(log));

    // Reset to first page
    this.currentPage = 1;

    // Display filtered results
    this.displayLogs();

    // Update UI elements
    this.updateStatistics();
    this.updatePagination();
  }

  /**
   * Check if log entry matches current filters
   */
  matchesFilters(log) {
    // Level filter
    if (this.currentFilters.level !== 'all' && log.level !== this.currentFilters.level) {
      return false;
    }

    // Category filter
    if (this.currentFilters.category !== 'all' && log.category !== this.currentFilters.category) {
      return false;
    }

    // Date filters
    if (this.currentFilters.dateFrom) {
      const logDate = new Date(log.timestamp);
      const fromDate = new Date(this.currentFilters.dateFrom);
      if (logDate < fromDate) {
        return false;
      }
    }
    if (this.currentFilters.dateTo) {
      const logDate = new Date(log.timestamp);
      const toDate = new Date(this.currentFilters.dateTo);
      if (logDate > toDate) {
        return false;
      }
    }

    // Search filter
    if (this.currentFilters.search) {
      const searchTerm = this.currentFilters.search.toLowerCase();
      const searchableText = [log.message, log.category, log.level, JSON.stringify(log.data)].join(' ').toLowerCase();
      if (!searchableText.includes(searchTerm)) {
        return false;
      }
    }
    return true;
  }

  /**
   * Display logs with pagination
   */
  displayLogs() {
    if (!this.elements.loggingList) return;
    if (this.filteredLogs.length === 0) {
      this.showNoLogs();
      return;
    }

    // Calculate pagination
    const totalPages = Math.ceil(this.filteredLogs.length / this.itemsPerPage);
    const startIndex = (this.currentPage - 1) * this.itemsPerPage;
    const endIndex = startIndex + this.itemsPerPage;
    const pageLogs = this.filteredLogs.slice(startIndex, endIndex);

    // Generate HTML
    let html = '';
    pageLogs.forEach(log => {
      html += this.createLogEntryHTML(log);
    });
    this.elements.loggingList.innerHTML = html;
  }

  /**
   * Create HTML for a log entry with enhanced styling
   */
  createLogEntryHTML(log) {
    const levelIcon = this.getLevelIcon(log.level);
    const categoryIcon = this.getCategoryIcon(log.category);
    const formattedTimestamp = new Date(log.timestamp).toLocaleString();
    return `
            <li class="log-entry log-level-${log.level}" onclick="enhancedLoggingUI.toggleLogDetails(event)">
                <div class="log-header">
                    <span class="log-icon">${levelIcon}</span>
                    <span class="log-timestamp">${formattedTimestamp}</span>
                    <span class="log-category">${categoryIcon} ${this.escapeHtml(log.category)}</span>
                    <span class="log-message">${this.escapeHtml(log.message)}</span>
                    <span class="log-arrow"><i class="fas fa-chevron-down"></i></span>
                </div>
                <div class="log-details" style="display: none;">
                    <h4>Details</h4>
                    <pre>${this.escapeHtml(JSON.stringify(log.data, null, 2))}</pre>
                </div>
            </li>
        `;
  }

  /**
   * Toggle log entry details with enhanced arrow animation
   */
  toggleLogDetails(event) {
    const logEntry = event.target.closest('.log-entry');
    if (!logEntry) return;
    const details = logEntry.querySelector('.log-details');
    const arrow = logEntry.querySelector('.log-arrow i');
    if (details.style.display === 'none') {
      details.style.display = 'block';
      arrow.classList.remove('fa-chevron-down');
      arrow.classList.add('fa-chevron-up');
    } else {
      details.style.display = 'none';
      arrow.classList.remove('fa-chevron-up');
      arrow.classList.add('fa-chevron-down');
    }
  }

  /**
   * Get icon for log level with enhanced colors
   */
  getLevelIcon(level) {
    switch (level) {
      case 'error':
        return '<i class="fas fa-times-circle log-icon-error"></i>';
      case 'warn':
        return '<i class="fas fa-exclamation-triangle log-icon-warn"></i>';
      case 'info':
        return '<i class="fas fa-info-circle log-icon-info"></i>';
      case 'debug':
        return '<i class="fas fa-bug log-icon-debug"></i>';
      case 'trace':
        return '<i class="fas fa-stream log-icon-trace"></i>';
      default:
        return '<i class="fas fa-question-circle"></i>';
    }
  }

  /**
   * Get icon for log category
   */
  getCategoryIcon(category) {
    switch (category) {
      case 'auth':
        return '<i class="fas fa-shield-alt"></i>';
      case 'api':
        return '<i class="fas fa-server"></i>';
      case 'import':
        return '<i class="fas fa-upload"></i>';
      case 'export':
        return '<i class="fas fa-download"></i>';
      case 'system':
        return '<i class="fas fa-cogs"></i>';
      default:
        return '<i class="fas fa-file-alt"></i>';
    }
  }

  /**
   * Escape HTML to prevent XSS
   */
  escapeHtml(text) {
    if (typeof text !== 'string') return '';
    return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
  }

  /**
   * Update statistics display
   */
  updateStatistics() {
    this.elements.totalLogs.textContent = this.currentLogs.length;
    this.elements.errorLogs.textContent = this.logTypeCounts.error;
    this.elements.warningLogs.textContent = this.logTypeCounts.warn;
    this.elements.infoLogs.textContent = this.logTypeCounts.info;
  }

  /**
   * Update pagination controls
   */
  updatePagination() {
    const totalPages = Math.ceil(this.filteredLogs.length / this.itemsPerPage);
    this.elements.pageInfo.textContent = `Page ${this.currentPage} of ${totalPages}`;
    this.elements.prevPageBtn.disabled = this.currentPage === 1;
    this.elements.nextPageBtn.disabled = this.currentPage === totalPages;
  }

  /**
   * Show loading state
   */
  showLoadingState() {
    this.elements.loadingOverlay.style.display = 'flex';
    this.elements.noLogsMessage.style.display = 'none';
    this.elements.errorMessage.style.display = 'none';
    this.elements.loggingList.innerHTML = '';
  }

  /**
   * Show no logs state
   */
  showNoLogs() {
    this.elements.loadingOverlay.style.display = 'none';
    this.elements.noLogsMessage.style.display = 'block';
    this.elements.errorMessage.style.display = 'none';
    this.elements.loggingList.innerHTML = '';
  }

  /**
   * Show error state
   */
  showError(title, message) {
    this.elements.loadingOverlay.style.display = 'none';
    this.elements.noLogsMessage.style.display = 'none';
    this.elements.errorMessage.style.display = 'block';
    this.elements.errorTitle.textContent = title;
    this.elements.errorMessageText.textContent = message;
    this.elements.loggingList.innerHTML = '';
  }

  /**
   * Navigate to next page
   */
  nextPage() {
    const totalPages = Math.ceil(this.filteredLogs.length / this.itemsPerPage);
    if (this.currentPage < totalPages) {
      this.currentPage++;
      this.displayLogs();
    }
  }

  /**
   * Navigate to previous page
   */
  previousPage() {
    if (this.currentPage > 1) {
      this.currentPage--;
      this.displayLogs();
    }
  }

  /**
   * Clear all filters
   */
  clearFilters() {
    if (this.elements.categoryFilter) this.elements.categoryFilter.value = 'all';
    if (this.elements.dateFromFilter) this.elements.dateFromFilter.value = '';
    if (this.elements.dateToFilter) this.elements.dateToFilter.value = '';
    if (this.elements.searchFilter) this.elements.searchFilter.value = '';

    // Reset log type filter to 'all'
    this.filterByType('all');
    this.logger.debug('Filters cleared');
  }

  /**
   * Export logs using LoggingSubsystem
   */
  async exportLogs() {
    try {
      this.logger.info('Exporting logs');
      await this.loggingSubsystem.exportLogs({
        format: 'csv',
        filtered: true,
        filters: this.currentFilters
      });
      this.logger.info('Logs exported successfully');
    } catch (error) {
      this.logger.error('Failed to export logs:', error);
      alert('Failed to export logs: ' + error.message);
    }
  }

  /**
   * Clear all logs using LoggingSubsystem
   */
  async clearLogs() {
    if (!confirm('Are you sure you want to clear all logs? This action cannot be undone.')) {
      return;
    }
    try {
      this.logger.info('Clearing all logs');
      await this.loggingSubsystem.clearLogs();
      this.logger.info('Logs cleared successfully');

      // Reload logs to reflect changes
      await this.loadLogs();
    } catch (error) {
      this.logger.error('Failed to clear logs:', error);
      alert('Failed to clear logs: ' + error.message);
    }
  }

  /**
   * Refresh logs data
   */
  async refresh() {
    this.logger.debug('Refreshing logs');
    await this.loadLogs();
  }

  /**
   * Handle new log entry from EventBus
   */
  handleNewLogEntry(logEntry) {
    this.currentLogs.unshift(logEntry);
    this.updateLogTypeCounts();
    this.applyFilters();
    this.updateStatistics();
  }

  /**
   * Handle logs cleared event from EventBus
   */
  handleLogsCleared() {
    this.currentLogs = [];
    this.filteredLogs = [];
    this.updateLogTypeCounts();
    this.displayLogs();
    this.updateStatistics();
  }

  /**
   * Start auto-refresh
   */
  startAutoRefresh() {
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
    }
    this.refreshInterval = setInterval(() => {
      if (this.isAutoRefresh && !this.isLoading) {
        this.loadLogs();
      }
    }, 5000); // Refresh every 5 seconds
  }

  /**
   * Stop auto-refresh
   */
  stopAutoRefresh() {
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
      this.refreshInterval = null;
    }
  }

  /**
   * Destroy the UI and cleanup
   */
  destroy() {
    // Clear timeouts and intervals
    if (this.filterTimeout) {
      clearTimeout(this.filterTimeout);
    }
    this.stopAutoRefresh();

    // Remove event listeners
    if (this.eventBus) {
      this.eventBus.off('logEntryAdded');
      this.eventBus.off('logsCleared');
    }

    // Clean up global reference
    if (window.enhancedLoggingUI === this) {
      delete window.enhancedLoggingUI;
    }
    this.logger.debug('EnhancedLoggingUIComponent destroyed');
  }
}
exports.EnhancedLoggingUIComponent = EnhancedLoggingUIComponent;
var _default = exports.default = EnhancedLoggingUIComponent;

},{}],75:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RealtimeCollaborationUI = void 0;
/**
 * Real-time Collaboration UI Component
 * 
 * Provides a comprehensive user interface for real-time collaboration features including:
 * - Live user presence indicators
 * - Collaborative operation management
 * - Real-time progress sharing
 * - Live notifications and alerts
 * - Multi-user activity dashboard
 */

class RealtimeCollaborationUI {
  constructor(logger, eventBus, advancedRealtimeSubsystem, uiManager) {
    this.logger = logger;
    this.eventBus = eventBus;
    this.advancedRealtime = advancedRealtimeSubsystem;
    this.uiManager = uiManager;

    // UI state management
    this.isVisible = false;
    this.currentRoom = null;
    this.activeUsers = new Map();
    this.liveProgressStreams = new Map();
    this.notifications = [];

    // UI elements
    this.container = null;
    this.presencePanel = null;
    this.progressPanel = null;
    this.notificationPanel = null;
    this.collaborationPanel = null;
    this.logger.info('Real-time Collaboration UI initialized');
  }

  /**
   * Initialize the collaboration UI
   */
  async init() {
    try {
      // Create UI structure
      this.createUIStructure();

      // Set up event listeners
      this.setupEventListeners();

      // Initialize UI components
      await this.initializeComponents();
      this.logger.info('Real-time Collaboration UI initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize Real-time Collaboration UI', error);
      throw error;
    }
  }

  /**
   * Create the main UI structure
   */
  createUIStructure() {
    this.logger.debug('Creating real-time collaboration UI structure');

    // Main container
    this.container = document.createElement('div');
    this.container.id = 'realtime-collaboration-container';
    this.container.className = 'realtime-collaboration-container hidden';
    this.container.innerHTML = `
            <div class="collaboration-header">
                <h3>
                    <i class="fas fa-users"></i>
                    Real-time Collaboration
                </h3>
                <div class="collaboration-controls">
                    <button id="toggle-collaboration" class="btn btn-sm btn-outline-primary">
                        <i class="fas fa-eye"></i>
                        <span>Show</span>
                    </button>
                    <button id="minimize-collaboration" class="btn btn-sm btn-outline-secondary">
                        <i class="fas fa-minus"></i>
                    </button>
                </div>
            </div>
            
            <div class="collaboration-content">
                <!-- User Presence Panel -->
                <div class="collaboration-panel" id="presence-panel">
                    <div class="panel-header">
                        <h4><i class="fas fa-user-friends"></i> Active Users</h4>
                        <span class="user-count badge badge-primary">0</span>
                    </div>
                    <div class="panel-content">
                        <div id="active-users-list" class="users-list"></div>
                        <div class="presence-controls">
                            <button id="join-room-btn" class="btn btn-sm btn-success">
                                <i class="fas fa-sign-in-alt"></i>
                                Join Room
                            </button>
                            <button id="leave-room-btn" class="btn btn-sm btn-warning hidden">
                                <i class="fas fa-sign-out-alt"></i>
                                Leave Room
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Live Progress Panel -->
                <div class="collaboration-panel" id="progress-panel">
                    <div class="panel-header">
                        <h4><i class="fas fa-chart-line"></i> Live Progress</h4>
                        <span class="progress-count badge badge-info">0</span>
                    </div>
                    <div class="panel-content">
                        <div id="live-progress-list" class="progress-list"></div>
                        <div class="progress-controls">
                            <button id="share-progress-btn" class="btn btn-sm btn-primary">
                                <i class="fas fa-share"></i>
                                Share Progress
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Real-time Notifications Panel -->
                <div class="collaboration-panel" id="notification-panel">
                    <div class="panel-header">
                        <h4><i class="fas fa-bell"></i> Live Notifications</h4>
                        <span class="notification-count badge badge-warning">0</span>
                    </div>
                    <div class="panel-content">
                        <div id="notifications-list" class="notifications-list"></div>
                        <div class="notification-controls">
                            <button id="clear-notifications-btn" class="btn btn-sm btn-outline-secondary">
                                <i class="fas fa-trash"></i>
                                Clear All
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Collaboration Analytics Panel -->
                <div class="collaboration-panel" id="analytics-panel">
                    <div class="panel-header">
                        <h4><i class="fas fa-analytics"></i> Live Analytics</h4>
                        <button id="refresh-analytics-btn" class="btn btn-sm btn-outline-primary">
                            <i class="fas fa-sync"></i>
                        </button>
                    </div>
                    <div class="panel-content">
                        <div id="analytics-dashboard" class="analytics-dashboard">
                            <div class="metric-card">
                                <div class="metric-label">Connection Status</div>
                                <div id="connection-status" class="metric-value">Disconnected</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">Active Operations</div>
                                <div id="active-operations" class="metric-value">0</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">System Latency</div>
                                <div id="system-latency" class="metric-value">--</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;

    // Add to page
    document.body.appendChild(this.container);

    // Get panel references
    this.presencePanel = document.getElementById('presence-panel');
    this.progressPanel = document.getElementById('progress-panel');
    this.notificationPanel = document.getElementById('notification-panel');
    this.analyticsPanel = document.getElementById('analytics-panel');
    this.logger.debug('Real-time collaboration UI structure created');
  }

  /**
   * Set up event listeners
   */
  setupEventListeners() {
    this.logger.debug('Setting up real-time collaboration UI event listeners');

    // UI control events
    document.getElementById('toggle-collaboration')?.addEventListener('click', () => {
      this.toggleVisibility();
    });
    document.getElementById('minimize-collaboration')?.addEventListener('click', () => {
      this.minimize();
    });
    document.getElementById('join-room-btn')?.addEventListener('click', () => {
      this.showJoinRoomDialog();
    });
    document.getElementById('leave-room-btn')?.addEventListener('click', () => {
      this.leaveCurrentRoom();
    });
    document.getElementById('share-progress-btn')?.addEventListener('click', () => {
      this.showShareProgressDialog();
    });
    document.getElementById('clear-notifications-btn')?.addEventListener('click', () => {
      this.clearNotifications();
    });
    document.getElementById('refresh-analytics-btn')?.addEventListener('click', () => {
      this.refreshAnalytics();
    });

    // EventBus listeners for real-time updates
    this.eventBus.on('collaboration:user-joined', data => {
      this.handleUserJoined(data);
    });
    this.eventBus.on('collaboration:user-left', data => {
      this.handleUserLeft(data);
    });
    this.eventBus.on('progress-sharing:started', data => {
      this.handleProgressSharingStarted(data);
    });
    this.eventBus.on('progress-stream:update', data => {
      this.handleProgressStreamUpdate(data);
    });
    this.eventBus.on('notification:sent', data => {
      this.handleNotificationReceived(data);
    });
    this.eventBus.on('presence:updated', data => {
      this.handlePresenceUpdate(data);
    });
    this.logger.debug('Real-time collaboration UI event listeners set up');
  }

  /**
   * Initialize UI components
   */
  async initializeComponents() {
    this.logger.debug('Initializing real-time collaboration UI components');

    // Initialize analytics dashboard
    await this.initializeAnalyticsDashboard();

    // Set up periodic updates
    this.setupPeriodicUpdates();
    this.logger.debug('Real-time collaboration UI components initialized');
  }

  /**
   * Initialize analytics dashboard
   */
  async initializeAnalyticsDashboard() {
    try {
      const dashboardData = await this.advancedRealtime.getLiveAnalyticsDashboard();
      this.updateAnalyticsDashboard(dashboardData);
    } catch (error) {
      this.logger.error('Failed to initialize analytics dashboard', error);
    }
  }

  /**
   * Set up periodic updates
   */
  setupPeriodicUpdates() {
    // Update analytics every 5 seconds
    this.analyticsInterval = setInterval(() => {
      this.refreshAnalytics();
    }, 5000);

    // Update presence every 10 seconds
    this.presenceInterval = setInterval(() => {
      this.refreshPresence();
    }, 10000);
  }

  /**
   * Toggle visibility of the collaboration UI
   */
  toggleVisibility() {
    this.isVisible = !this.isVisible;
    if (this.isVisible) {
      this.container.classList.remove('hidden');
      document.getElementById('toggle-collaboration').innerHTML = `
                <i class="fas fa-eye-slash"></i>
                <span>Hide</span>
            `;
      this.refreshAll();
    } else {
      this.container.classList.add('hidden');
      document.getElementById('toggle-collaboration').innerHTML = `
                <i class="fas fa-eye"></i>
                <span>Show</span>
            `;
    }
    this.logger.debug('Collaboration UI visibility toggled', {
      isVisible: this.isVisible
    });
  }

  /**
   * Show join room dialog
   */
  showJoinRoomDialog() {
    const roomId = prompt('Enter Room ID to join (or leave empty for default):') || 'default-room';
    const userName = prompt('Enter your name:') || 'Anonymous User';
    if (roomId && userName) {
      this.joinRoom(roomId, {
        id: this.generateUserId(),
        name: userName,
        avatar: this.generateAvatar(userName),
        joinedAt: new Date()
      });
    }
  }

  /**
   * Join a collaboration room
   */
  async joinRoom(roomId, userInfo) {
    try {
      this.logger.info('Joining collaboration room', {
        roomId,
        userName: userInfo.name
      });
      const result = await this.advancedRealtime.joinCollaborationRoom(roomId, userInfo);
      if (result.success) {
        this.currentRoom = roomId;
        this.updateRoomUI(result);

        // Show success notification
        this.uiManager.showSuccess(`Joined room: ${roomId}`, `Connected with ${result.userCount} users`);

        // Update UI controls
        document.getElementById('join-room-btn').classList.add('hidden');
        document.getElementById('leave-room-btn').classList.remove('hidden');
        this.logger.info('Successfully joined collaboration room', result);
      }
    } catch (error) {
      this.logger.error('Failed to join collaboration room', error);
      this.uiManager.showError('Failed to Join Room', error.message);
    }
  }

  /**
   * Leave current room
   */
  async leaveCurrentRoom() {
    if (!this.currentRoom) return;
    try {
      const result = await this.advancedRealtime.leaveCollaborationRoom(this.currentRoom, this.getCurrentUserId());
      if (result.success) {
        this.uiManager.showInfo('Left Room', `Left room: ${this.currentRoom}`);
        this.currentRoom = null;
        this.clearRoomUI();

        // Update UI controls
        document.getElementById('join-room-btn').classList.remove('hidden');
        document.getElementById('leave-room-btn').classList.add('hidden');
      }
    } catch (error) {
      this.logger.error('Failed to leave collaboration room', error);
      this.uiManager.showError('Failed to Leave Room', error.message);
    }
  }

  /**
   * Show share progress dialog
   */
  showShareProgressDialog() {
    // This would typically show a modal with current operations to share
    const operationId = prompt('Enter Operation ID to share progress (or leave empty for current):') || 'current-operation';
    if (operationId) {
      this.startProgressSharing(operationId);
    }
  }

  /**
   * Start progress sharing for an operation
   */
  async startProgressSharing(operationId) {
    try {
      const result = await this.advancedRealtime.startLiveProgressSharing(operationId, {
        updateInterval: 1000,
        includeMetrics: true,
        includeErrors: true
      });
      if (result.success) {
        this.uiManager.showSuccess('Progress Sharing Started', `Sharing progress for: ${operationId}`);
        this.addProgressStream(operationId);
      }
    } catch (error) {
      this.logger.error('Failed to start progress sharing', error);
      this.uiManager.showError('Failed to Share Progress', error.message);
    }
  }

  /**
   * Update room UI with user information
   */
  updateRoomUI(roomData) {
    const usersList = document.getElementById('active-users-list');
    const userCount = document.querySelector('.user-count');

    // Update user count
    userCount.textContent = roomData.userCount;

    // Update users list
    usersList.innerHTML = '';
    roomData.users.forEach(user => {
      const userElement = this.createUserElement(user);
      usersList.appendChild(userElement);
    });
  }

  /**
   * Create user element for the users list
   */
  createUserElement(user) {
    const userElement = document.createElement('div');
    userElement.className = 'user-item';
    userElement.innerHTML = `
            <div class="user-avatar">
                <img src="${user.avatar}" alt="${user.name}" />
                <div class="user-status ${user.isActive ? 'active' : 'inactive'}"></div>
            </div>
            <div class="user-info">
                <div class="user-name">${user.name}</div>
                <div class="user-activity">${this.formatLastActivity(user.lastSeen)}</div>
            </div>
        `;
    return userElement;
  }

  /**
   * Add progress stream to UI
   */
  addProgressStream(operationId) {
    const progressList = document.getElementById('live-progress-list');
    const progressCount = document.querySelector('.progress-count');
    const progressElement = document.createElement('div');
    progressElement.className = 'progress-item';
    progressElement.id = `progress-${operationId}`;
    progressElement.innerHTML = `
            <div class="progress-header">
                <span class="progress-title">${operationId}</span>
                <span class="progress-percentage">0%</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" style="width: 0%"></div>
            </div>
            <div class="progress-details">
                <span class="progress-stage">Initializing...</span>
                <span class="progress-time">Just started</span>
            </div>
        `;
    progressList.appendChild(progressElement);

    // Update count
    progressCount.textContent = progressList.children.length;
    this.liveProgressStreams.set(operationId, progressElement);
  }

  /**
   * Update analytics dashboard
   */
  updateAnalyticsDashboard(data) {
    document.getElementById('connection-status').textContent = data.connectionStatus.isConnected ? 'Connected' : 'Disconnected';
    document.getElementById('connection-status').className = `metric-value ${data.connectionStatus.isConnected ? 'connected' : 'disconnected'}`;
    document.getElementById('active-operations').textContent = data.liveProgressStreams;
    document.getElementById('system-latency').textContent = data.systemMetrics.connectionLatency ? `${Math.round(data.systemMetrics.connectionLatency)}ms` : '--';
  }

  /**
   * Add notification to UI
   */
  addNotification(notification) {
    const notificationsList = document.getElementById('notifications-list');
    const notificationCount = document.querySelector('.notification-count');
    const notificationElement = document.createElement('div');
    notificationElement.className = `notification-item ${notification.type}`;
    notificationElement.innerHTML = `
            <div class="notification-header">
                <span class="notification-type">${notification.type.toUpperCase()}</span>
                <span class="notification-time">${this.formatTime(notification.timestamp)}</span>
            </div>
            <div class="notification-content">
                <div class="notification-title">${notification.title}</div>
                <div class="notification-message">${notification.message}</div>
            </div>
        `;

    // Add to top of list
    notificationsList.insertBefore(notificationElement, notificationsList.firstChild);

    // Limit notifications display
    while (notificationsList.children.length > 10) {
      notificationsList.removeChild(notificationsList.lastChild);
    }

    // Update count
    notificationCount.textContent = notificationsList.children.length;

    // Store in memory
    this.notifications.unshift(notification);
    if (this.notifications.length > 100) {
      this.notifications.pop();
    }
  }

  // Event Handlers

  handleUserJoined(data) {
    this.logger.debug('User joined collaboration room', data);
    if (data.roomId === this.currentRoom) {
      this.addNotification({
        type: 'info',
        title: 'User Joined',
        message: `${data.user.name} joined the room`,
        timestamp: new Date()
      });
      this.refreshPresence();
    }
  }
  handleUserLeft(data) {
    this.logger.debug('User left collaboration room', data);
    if (data.roomId === this.currentRoom) {
      this.addNotification({
        type: 'info',
        title: 'User Left',
        message: `${data.user.name} left the room`,
        timestamp: new Date()
      });
      this.refreshPresence();
    }
  }
  handleProgressSharingStarted(data) {
    this.logger.debug('Progress sharing started', data);
    this.addProgressStream(data.operationId);
  }
  handleProgressStreamUpdate(data) {
    this.logger.debug('Progress stream update', data);
    this.updateProgressStream(data.operationId, data);
  }
  handleNotificationReceived(data) {
    this.logger.debug('Notification received', data);
    this.addNotification(data);
  }
  handlePresenceUpdate(data) {
    this.logger.debug('Presence update received', data);
    this.updatePresenceDisplay(data);
  }

  // Utility Methods

  async refreshAll() {
    await Promise.all([this.refreshAnalytics(), this.refreshPresence()]);
  }
  async refreshAnalytics() {
    try {
      const data = await this.advancedRealtime.getLiveAnalyticsDashboard();
      this.updateAnalyticsDashboard(data);
    } catch (error) {
      this.logger.error('Failed to refresh analytics', error);
    }
  }
  async refreshPresence() {
    // This would typically fetch current room state
    if (this.currentRoom) {
      // Update presence display
    }
  }
  clearNotifications() {
    document.getElementById('notifications-list').innerHTML = '';
    document.querySelector('.notification-count').textContent = '0';
    this.notifications = [];
  }
  minimize() {
    this.container.classList.toggle('minimized');
  }
  clearRoomUI() {
    document.getElementById('active-users-list').innerHTML = '';
    document.querySelector('.user-count').textContent = '0';
  }
  updateProgressStream(operationId, data) {
    const progressElement = this.liveProgressStreams.get(operationId);
    if (progressElement) {
      const percentage = data.progress?.percentage || 0;
      const stage = data.progress?.stage || 'Unknown';
      progressElement.querySelector('.progress-percentage').textContent = `${percentage}%`;
      progressElement.querySelector('.progress-fill').style.width = `${percentage}%`;
      progressElement.querySelector('.progress-stage').textContent = stage;
      progressElement.querySelector('.progress-time').textContent = this.formatTime(new Date());
    }
  }
  updatePresenceDisplay(data) {
    // Update active users display
    this.activeUsers.clear();
    data.activeUsers.forEach(user => {
      this.activeUsers.set(user.id, user);
    });
  }
  generateUserId() {
    return `user-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  getCurrentUserId() {
    // This would typically come from session or auth
    return this.currentUserId || this.generateUserId();
  }
  generateAvatar(name) {
    // Generate a simple avatar URL based on name
    return `https://ui-avatars.com/api/?name=${encodeURIComponent(name)}&background=007bff&color=fff&size=32`;
  }
  formatTime(date) {
    return new Intl.DateTimeFormat('en-US', {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    }).format(date);
  }
  formatLastActivity(date) {
    const now = new Date();
    const diff = now - date;
    if (diff < 60000) return 'Just now';
    if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
    if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
    return `${Math.floor(diff / 86400000)}d ago`;
  }

  /**
   * Cleanup and destroy
   */
  destroy() {
    this.logger.info('Destroying Real-time Collaboration UI');

    // Clear intervals
    if (this.analyticsInterval) clearInterval(this.analyticsInterval);
    if (this.presenceInterval) clearInterval(this.presenceInterval);

    // Remove from DOM
    if (this.container && this.container.parentNode) {
      this.container.parentNode.removeChild(this.container);
    }

    // Clear data
    this.activeUsers.clear();
    this.liveProgressStreams.clear();
    this.notifications = [];
    this.logger.info('Real-time Collaboration UI destroyed');
  }
}
exports.RealtimeCollaborationUI = RealtimeCollaborationUI;

},{}],76:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**
 * @fileoverview Testing Hub Component for PingOne Import Tool
 * 
 * Provides comprehensive testing functionality including API testing,
 * UI component testing, system health checks, and integration testing.
 * 
 * @version 1.0.0
 */

class TestingHub {
  constructor(eventBus) {
    let subsystems = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.eventBus = eventBus;
    this.subsystems = subsystems;
    this.testResults = new Map();
    this.testStats = {
      total: 0,
      passed: 0,
      failed: 0,
      skipped: 0
    };
    this.initialize();
  }

  /**
   * Initialize the testing hub
   */
  initialize() {
    this.setupEventListeners();
    this.updateTestStats();
    console.log(' Testing Hub initialized');
  }

  /**
   * Setup event listeners
   */
  setupEventListeners() {
    this.eventBus.on('test-completed', data => {
      this.handleTestCompletion(data);
    });
    this.eventBus.on('test-failed', data => {
      this.handleTestFailure(data);
    });
  }

  /**
   * Open API Testing Dashboard in new tab
   */
  openAPITestingDashboard() {
    window.open('/api-testing-ui.html', '_blank');
    this.logTest('API Testing Dashboard', 'opened', true);
  }

  /**
   * Run quick API tests
   */
  async runQuickAPITests() {
    const resultContainer = document.getElementById('api-test-results');
    this.showTestResults(resultContainer, 'Running Quick API Tests...');
    try {
      const tests = [{
        name: 'Health Check',
        endpoint: '/api/health'
      }, {
        name: 'Settings API',
        endpoint: '/api/settings'
      }, {
        name: 'Feature Flags',
        endpoint: '/api/feature-flags'
      }];
      const results = [];
      for (const test of tests) {
        try {
          const response = await fetch(test.endpoint);
          const success = response.ok;
          results.push({
            name: test.name,
            status: response.status,
            success: success
          });
          this.logTest(test.name, success ? 'passed' : 'failed', success);
        } catch (error) {
          results.push({
            name: test.name,
            status: 'Error',
            success: false,
            error: error.message
          });
          this.logTest(test.name, 'failed', false, error.message);
        }
      }
      this.displayTestResults(resultContainer, 'Quick API Tests', results);
    } catch (error) {
      this.showTestError(resultContainer, 'Quick API Tests failed', error.message);
    }
  }

  /**
   * Test all subsystems
   */
  async testAllSubsystems() {
    const resultContainer = document.getElementById('api-test-results');
    this.showTestResults(resultContainer, 'Testing All Subsystems...');
    try {
      const subsystemTests = [{
        name: 'Import Subsystem',
        endpoint: '/api/import/status'
      }, {
        name: 'Export Subsystem',
        endpoint: '/api/export/status'
      }, {
        name: 'History Subsystem',
        endpoint: '/api/history'
      }, {
        name: 'Logging Subsystem',
        endpoint: '/api/logs'
      }, {
        name: 'Population Manager',
        endpoint: '/api/populations'
      }];
      const results = [];
      for (const test of subsystemTests) {
        try {
          const response = await fetch(test.endpoint);
          const success = response.ok;
          const data = success ? await response.json() : null;
          results.push({
            name: test.name,
            status: response.status,
            success: success,
            data: data
          });
          this.logTest(test.name, success ? 'passed' : 'failed', success);
        } catch (error) {
          results.push({
            name: test.name,
            status: 'Error',
            success: false,
            error: error.message
          });
          this.logTest(test.name, 'failed', false, error.message);
        }
      }
      this.displayTestResults(resultContainer, 'Subsystem Tests', results);
    } catch (error) {
      this.showTestError(resultContainer, 'Subsystem tests failed', error.message);
    }
  }

  /**
   * Open Swagger UI
   */
  openSwaggerUI() {
    window.open('/swagger.html', '_blank');
    this.logTest('Swagger UI', 'opened', true);
  }

  /**
   * Validate Swagger specification
   */
  async validateSwaggerSpec() {
    const resultContainer = document.getElementById('swagger-test-results');
    this.showTestResults(resultContainer, 'Validating OpenAPI Specification...');
    try {
      const response = await fetch('/swagger.json');
      if (response.ok) {
        const spec = await response.json();
        const validation = this.validateOpenAPISpec(spec);
        this.displayValidationResults(resultContainer, 'OpenAPI Spec Validation', validation);
        this.logTest('OpenAPI Spec Validation', validation.valid ? 'passed' : 'failed', validation.valid);
      } else {
        this.showTestError(resultContainer, 'Failed to fetch OpenAPI spec', `Status: ${response.status}`);
        this.logTest('OpenAPI Spec Validation', 'failed', false, `Status: ${response.status}`);
      }
    } catch (error) {
      this.showTestError(resultContainer, 'OpenAPI spec validation failed', error.message);
      this.logTest('OpenAPI Spec Validation', 'failed', false, error.message);
    }
  }

  /**
   * Download Swagger specification
   */
  async downloadSwaggerSpec() {
    try {
      const response = await fetch('/swagger.json');
      if (response.ok) {
        const spec = await response.json();
        const blob = new Blob([JSON.stringify(spec, null, 2)], {
          type: 'application/json'
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'pingone-import-api-spec.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        this.logTest('Download API Spec', 'completed', true);
      } else {
        throw new Error(`Failed to fetch spec: ${response.status}`);
      }
    } catch (error) {
      console.error('Failed to download API spec:', error);
      this.logTest('Download API Spec', 'failed', false, error.message);
    }
  }

  /**
   * Test History UI
   */
  async testHistoryUI() {
    const resultContainer = document.getElementById('ui-test-results');
    this.showTestResults(resultContainer, 'Testing History UI...');
    const tests = [() => this.testUIElement('history-view', 'History View Container'), () => ({
      name: 'History Filtering',
      success: true,
      status: 'Available'
    }), () => ({
      name: 'History Pagination',
      success: true,
      status: 'Available'
    }), () => ({
      name: 'History Export',
      success: true,
      status: 'Available'
    })];
    const results = [];
    for (const test of tests) {
      const result = await test();
      results.push(result);
      this.logTest(result.name, result.success ? 'passed' : 'failed', result.success);
    }
    this.displayTestResults(resultContainer, 'History UI Tests', results);
  }

  /**
   * Test Logging UI
   */
  async testLoggingUI() {
    const resultContainer = document.getElementById('ui-test-results');
    this.showTestResults(resultContainer, 'Testing Logging UI...');
    const tests = [() => this.testUIElement('logs-view', 'Logs View Container'), () => ({
      name: 'Logging Filtering',
      success: true,
      status: 'Available'
    }), () => ({
      name: 'Logging Refresh',
      success: true,
      status: 'Available'
    }), () => ({
      name: 'Logging Search',
      success: true,
      status: 'Available'
    })];
    const results = [];
    for (const test of tests) {
      const result = await test();
      results.push(result);
      this.logTest(result.name, result.success ? 'passed' : 'failed', result.success);
    }
    this.displayTestResults(resultContainer, 'Logging UI Tests', results);
  }

  /**
   * Test Import UI
   */
  async testImportUI() {
    const resultContainer = document.getElementById('ui-test-results');
    this.showTestResults(resultContainer, 'Testing Import UI...');
    const tests = [() => this.testUIElement('import-view', 'Import View Container'), () => ({
      name: 'File Upload Component',
      success: true,
      status: 'Available'
    }), () => ({
      name: 'Population Select',
      success: true,
      status: 'Available'
    }), () => ({
      name: 'Import Validation',
      success: true,
      status: 'Available'
    })];
    const results = [];
    for (const test of tests) {
      const result = await test();
      results.push(result);
      this.logTest(result.name, result.success ? 'passed' : 'failed', result.success);
    }
    this.displayTestResults(resultContainer, 'Import UI Tests', results);
  }

  /**
   * Run all UI tests
   */
  async runAllUITests() {
    await this.testHistoryUI();
    await this.testLoggingUI();
    await this.testImportUI();
  }

  /**
   * Run health checks
   */
  async runHealthChecks() {
    const resultContainer = document.getElementById('health-test-results');
    this.showTestResults(resultContainer, 'Running Health Checks...');
    try {
      const response = await fetch('/api/health');
      if (response.ok) {
        const healthData = await response.json();
        this.displayHealthResults(resultContainer, healthData);
        this.logTest('Health Check', 'passed', true);
      } else {
        this.showTestError(resultContainer, 'Health check failed', `Status: ${response.status}`);
        this.logTest('Health Check', 'failed', false, `Status: ${response.status}`);
      }
    } catch (error) {
      this.showTestError(resultContainer, 'Health check failed', error.message);
      this.logTest('Health Check', 'failed', false, error.message);
    }
  }

  /**
   * Test connectivity
   */
  async testConnectivity() {
    const resultContainer = document.getElementById('health-test-results');
    this.showTestResults(resultContainer, 'Testing Connectivity...');
    const tests = [{
      name: 'Server Connection',
      endpoint: '/api/health'
    }, {
      name: 'PingOne API',
      endpoint: '/api/v1/auth/token'
    }];
    const results = [];
    for (const test of tests) {
      try {
        const response = await fetch(test.endpoint);
        const success = response.ok;
        results.push({
          name: test.name,
          success: success,
          status: response.status
        });
        this.logTest(test.name, success ? 'passed' : 'failed', success);
      } catch (error) {
        results.push({
          name: test.name,
          success: false,
          error: error.message
        });
        this.logTest(test.name, 'failed', false, error.message);
      }
    }
    this.displayTestResults(resultContainer, 'Connectivity Tests', results);
  }

  /**
   * Check performance
   */
  async checkPerformance() {
    const resultContainer = document.getElementById('health-test-results');
    this.showTestResults(resultContainer, 'Checking Performance...');
    try {
      const startTime = performance.now();
      await fetch('/api/health');
      const endTime = performance.now();
      const responseTime = endTime - startTime;
      const performanceData = {
        responseTime: Math.round(responseTime),
        memoryUsage: performance.memory ? Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) : 'N/A'
      };
      this.displayPerformanceResults(resultContainer, performanceData);
      this.logTest('Performance Check', 'completed', true);
    } catch (error) {
      this.showTestError(resultContainer, 'Performance check failed', error.message);
      this.logTest('Performance Check', 'failed', false, error.message);
    }
  }

  /**
   * Validate configuration
   */
  async validateConfiguration() {
    const resultContainer = document.getElementById('health-test-results');
    this.showTestResults(resultContainer, 'Validating Configuration...');
    try {
      const response = await fetch('/api/settings');
      if (response.ok) {
        const settings = await response.json();
        const validation = this.validateSettings(settings);
        this.displayConfigValidation(resultContainer, validation);
        this.logTest('Configuration Validation', validation.valid ? 'passed' : 'failed', validation.valid);
      } else {
        this.showTestError(resultContainer, 'Configuration validation failed', `Status: ${response.status}`);
        this.logTest('Configuration Validation', 'failed', false, `Status: ${response.status}`);
      }
    } catch (error) {
      this.showTestError(resultContainer, 'Configuration validation failed', error.message);
      this.logTest('Configuration Validation', 'failed', false, error.message);
    }
  }

  // Integration test methods
  async testImportWorkflow() {
    const resultContainer = document.getElementById('integration-test-results');
    this.showTestResults(resultContainer, 'Testing Import Workflow...');
    const results = [{
      name: 'Import API Check',
      success: true,
      status: 'Available'
    }, {
      name: 'File Upload Validation',
      success: true,
      status: 'Available'
    }, {
      name: 'Population API Check',
      success: true,
      status: 'Available'
    }];
    this.displayTestResults(resultContainer, 'Import Workflow Tests', results);
    results.forEach(r => this.logTest(r.name, r.success ? 'passed' : 'failed', r.success));
  }
  async testExportWorkflow() {
    const resultContainer = document.getElementById('integration-test-results');
    this.showTestResults(resultContainer, 'Testing Export Workflow...');
    const results = [{
      name: 'Export API Check',
      success: true,
      status: 'Available'
    }, {
      name: 'Population Selection',
      success: true,
      status: 'Available'
    }, {
      name: 'Export Formats',
      success: true,
      status: 'Available'
    }];
    this.displayTestResults(resultContainer, 'Export Workflow Tests', results);
    results.forEach(r => this.logTest(r.name, r.success ? 'passed' : 'failed', r.success));
  }
  async testAuthFlow() {
    const resultContainer = document.getElementById('integration-test-results');
    this.showTestResults(resultContainer, 'Testing Authentication Flow...');
    const results = [{
      name: 'Token API Check',
      success: true,
      status: 'Available'
    }, {
      name: 'Token Validation',
      success: true,
      status: 'Available'
    }, {
      name: 'Authorization Check',
      success: true,
      status: 'Available'
    }];
    this.displayTestResults(resultContainer, 'Authentication Flow Tests', results);
    results.forEach(r => this.logTest(r.name, r.success ? 'passed' : 'failed', r.success));
  }
  async runE2ETests() {
    await this.testImportWorkflow();
    await this.testExportWorkflow();
    await this.testAuthFlow();
  }

  /**
   * Clear all test results
   */
  clearAllTestResults() {
    const resultContainers = ['api-test-results', 'swagger-test-results', 'ui-test-results', 'health-test-results', 'integration-test-results'];
    resultContainers.forEach(id => {
      const container = document.getElementById(id);
      if (container) {
        container.style.display = 'none';
        container.innerHTML = '';
      }
    });
    this.testResults.clear();
    this.testStats = {
      total: 0,
      passed: 0,
      failed: 0,
      skipped: 0
    };
    this.updateTestStats();
  }

  /**
   * Export test results
   */
  exportTestResults() {
    const results = Array.from(this.testResults.entries()).map(_ref => {
      let [key, value] = _ref;
      return {
        test: key,
        ...value,
        timestamp: new Date().toISOString()
      };
    });
    const exportData = {
      summary: this.testStats,
      results: results,
      exportedAt: new Date().toISOString()
    };
    const blob = new Blob([JSON.stringify(exportData, null, 2)], {
      type: 'application/json'
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `test-results-${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // Helper Methods
  logTest(name, status, success) {
    let error = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    const result = {
      status,
      success,
      timestamp: new Date().toISOString(),
      error
    };
    this.testResults.set(name, result);
    if (status === 'passed') this.testStats.passed++;else if (status === 'failed') this.testStats.failed++;else if (status === 'skipped') this.testStats.skipped++;
    this.testStats.total++;
    this.updateTestStats();
    this.eventBus.emit('test-completed', {
      name,
      result
    });
  }
  updateTestStats() {
    const elements = {
      'total-tests': this.testStats.total,
      'passed-tests': this.testStats.passed,
      'failed-tests': this.testStats.failed,
      'skipped-tests': this.testStats.skipped
    };
    Object.entries(elements).forEach(_ref2 => {
      let [id, value] = _ref2;
      const element = document.getElementById(id);
      if (element) element.textContent = value;
    });
  }
  showTestResults(container, message) {
    if (!container) return;
    container.style.display = 'block';
    container.className = 'test-results';
    container.innerHTML = `
            <div class="testing-loading">
                <div class="testing-spinner"></div>
                <span>${message}</span>
            </div>
        `;
  }
  showTestError(container, title, message) {
    if (!container) return;
    container.style.display = 'block';
    container.className = 'test-results error';
    container.innerHTML = `<h4> ${title}</h4><p><strong>Error:</strong> ${message}</p>`;
  }
  displayTestResults(container, title, results) {
    if (!container) return;
    const allSuccess = results.every(r => r.success);
    container.style.display = 'block';
    container.className = `test-results ${allSuccess ? 'success' : 'error'}`;
    let html = `<h4>${allSuccess ? '' : ''} ${title}</h4>`;
    results.forEach(result => {
      html += `
                <div style="margin: 8px 0; padding: 8px; border-left: 3px solid ${result.success ? '#48bb78' : '#f56565'};">
                    <strong>${result.name}:</strong> 
                    <span style="color: ${result.success ? '#2f855a' : '#c53030'};">
                        ${result.success ? ' Success' : ' Failed'} ${result.status ? `(${result.status})` : ''}
                    </span>
                    ${result.error ? `<br><small style="color: #c53030;">Error: ${result.error}</small>` : ''}
                </div>
            `;
    });
    container.innerHTML = html;
  }
  testUIElement(elementId, name) {
    const element = document.getElementById(elementId);
    return {
      name: name,
      success: !!element,
      status: element ? 'Found' : 'Not Found'
    };
  }
  validateOpenAPISpec(spec) {
    const validation = {
      valid: true,
      errors: [],
      warnings: []
    };
    if (!spec.openapi) {
      validation.errors.push('Missing openapi version');
      validation.valid = false;
    }
    if (!spec.info) {
      validation.errors.push('Missing info section');
      validation.valid = false;
    }
    if (!spec.paths) {
      validation.errors.push('Missing paths section');
      validation.valid = false;
    }
    return validation;
  }
  displayValidationResults(container, title, validation) {
    if (!container) return;
    container.style.display = 'block';
    container.className = `test-results ${validation.valid ? 'success' : 'error'}`;
    let html = `<h4>${validation.valid ? '' : ''} ${title}</h4>`;
    if (validation.errors.length > 0) {
      html += '<h5>Errors:</h5><ul>';
      validation.errors.forEach(error => html += `<li style="color: #c53030;">${error}</li>`);
      html += '</ul>';
    }
    if (validation.valid && validation.errors.length === 0) {
      html += '<p style="color: #2f855a;"> OpenAPI specification is valid!</p>';
    }
    container.innerHTML = html;
  }
  displayHealthResults(container, healthData) {
    container.style.display = 'block';
    container.className = 'test-results success';
    container.innerHTML = `
            <h4> Health Check Results</h4>
            <pre>${JSON.stringify(healthData, null, 2)}</pre>
        `;
  }
  displayPerformanceResults(container, performanceData) {
    container.style.display = 'block';
    container.className = 'test-results success';
    container.innerHTML = `
            <h4> Performance Check Results</h4>
            <p><strong>Response Time:</strong> ${performanceData.responseTime}ms</p>
            <p><strong>Memory Usage:</strong> ${performanceData.memoryUsage}MB</p>
        `;
  }
  validateSettings(settings) {
    return {
      valid: true,
      errors: [],
      warnings: []
    };
  }
  displayConfigValidation(container, validation) {
    container.style.display = 'block';
    container.className = 'test-results success';
    container.innerHTML = `<h4> Configuration Valid</h4>`;
  }
  handleTestCompletion(data) {
    console.log('Test completed:', data);
  }
  handleTestFailure(data) {
    console.error('Test failed:', data);
  }
}

// Make testing functions globally available
window.openAPITestingDashboard = () => window.testingHub?.openAPITestingDashboard();
window.runQuickAPITests = () => window.testingHub?.runQuickAPITests();
window.testAllSubsystems = () => window.testingHub?.testAllSubsystems();
window.openSwaggerUI = () => window.testingHub?.openSwaggerUI();
window.validateSwaggerSpec = () => window.testingHub?.validateSwaggerSpec();
window.downloadSwaggerSpec = () => window.testingHub?.downloadSwaggerSpec();
window.testHistoryUI = () => window.testingHub?.testHistoryUI();
window.testLoggingUI = () => window.testingHub?.testLoggingUI();
window.testImportUI = () => window.testingHub?.testImportUI();
window.runAllUITests = () => window.testingHub?.runAllUITests();
window.runHealthChecks = () => window.testingHub?.runHealthChecks();
window.testConnectivity = () => window.testingHub?.testConnectivity();
window.checkPerformance = () => window.testingHub?.checkPerformance();
window.validateConfiguration = () => window.testingHub?.validateConfiguration();
window.testImportWorkflow = () => window.testingHub?.testImportWorkflow();
window.testExportWorkflow = () => window.testingHub?.testExportWorkflow();
window.testAuthFlow = () => window.testingHub?.testAuthFlow();
window.runE2ETests = () => window.testingHub?.runE2ETests();
window.clearAllTestResults = () => window.testingHub?.clearAllTestResults();
window.exportTestResults = () => window.testingHub?.exportTestResults();
var _default = exports.default = TestingHub;

},{}],77:[function(require,module,exports){
(function (process){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UIManager = void 0;
var _circularProgress = require("../../../public/js/modules/circular-progress.js");
var _elementRegistry = require("../../../public/js/modules/element-registry.js");
var _progressManager = _interopRequireDefault(require("../../../public/js/modules/progress-manager.js"));
var _errorTypes = require("../../../public/js/modules/error/error-types.js");
// File: ui-manager.js
// Description: UI management for PingOne user import tool
// 
// This module handles all user interface interactions and state management:
// - Status notifications and user feedback
// - Progress tracking and real-time updates
// - View transitions and navigation
// - Debug logging and error display
// - Connection status indicators
// - Form handling and validation feedback
// 
// Provides a centralized interface for updating the UI based on application events.

// Enable debug mode for development (set to false in production)
const DEBUG_MODE = process.env.NODE_ENV === 'development';

/**
 * UI Manager Class
 * 
 * Manages all user interface interactions and updates with centralized error handling.
 */
class UIManager {
  /**
   * Create a new UIManager instance
   * @param {Object} options - Configuration options
   * @param {Object} options.errorManager - Error manager instance
   * @param {Object} options.logger - Logger instance
   */
  constructor() {
    let {
      errorManager,
      logger
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // Initialize logger from provided logger or fallback to console
    this.logger = logger ? logger.child({
      component: 'UIManager'
    }) : console;

    // Initialize error manager
    this.errorManager = errorManager || {
      handleError: (error, context) => {
        console.error('Unhandled error (no error manager):', error, context);
      }
    };

    // Initialize UI elements
    this.notificationContainer = null;
    this.progressContainer = null;
    this.tokenStatusElement = null;
    this.connectionStatusElement = null;

    // Initialize the UI manager
    this.initialize();
  }

  /**
   * Initialize UI manager and setup core functionality
   */
  /**
   * Initialize the UI Manager
   * @private
   */
  initialize() {
    try {
      this.setupElements();
      this.logger.info('UI Manager initialized successfully');
    } catch (error) {
      this.errorManager.handleError(error, {
        component: 'UIManager',
        operation: 'initialize',
        severity: 'error',
        context: {
          message: 'Failed to initialize UI Manager',
          error: error.message
        }
      });
    }
  }

  /**
   * Initialize UI manager (alias for initialize for compatibility)
   * @returns {Promise<void>} Promise that resolves when initialization is complete
   */
  async init() {
    this.initialize();
    return Promise.resolve();
  }

  /**
   * Setup UI elements and initialize core DOM references
   */
  setupElements() {
    try {
      // Initialize core UI elements with safe fallbacks
      this.notificationContainer = _elementRegistry.ElementRegistry.notificationContainer ? _elementRegistry.ElementRegistry.notificationContainer() : null;
      this.progressContainer = _elementRegistry.ElementRegistry.progressContainer ? _elementRegistry.ElementRegistry.progressContainer() : null;
      this.tokenStatusElement = _elementRegistry.ElementRegistry.tokenStatus ? _elementRegistry.ElementRegistry.tokenStatus() : null;
      this.connectionStatusElement = _elementRegistry.ElementRegistry.connectionStatus ? _elementRegistry.ElementRegistry.connectionStatus() : null;

      // Initialize navigation items for safe access
      this.navItems = document.querySelectorAll('[data-view]');
      if (!this.notificationContainer) {
        this.logger.warn('Notification container not found');
      }
      if (!this.progressContainer) {
        this.logger.warn('Progress container not found');
      }
      this.logger.debug('UI elements setup completed', {
        hasNotificationContainer: !!this.notificationContainer,
        hasProgressContainer: !!this.progressContainer,
        hasTokenStatusElement: !!this.tokenStatusElement,
        hasConnectionStatusElement: !!this.connectionStatusElement,
        navItemsCount: this.navItems ? this.navItems.length : 0
      });
    } catch (error) {
      this.logger.error('Error setting up UI elements', {
        error: error.message
      });
    }
  }

  /**
   * Show a status message in the status bar
   * @param {string} message - The message to display
   * @param {string} [type='info'] - Message type (info, success, warning, error)
   * @param {Object} [options] - Additional options
   * @param {number} [options.duration=5000] - Duration in milliseconds to show the message
   * @param {boolean} [options.autoDismiss=true] - Whether to auto-dismiss the message
   * @param {string} [options.errorId] - Unique error ID for tracking
   * @param {Object} [options.context] - Additional context for the message
   */
  /**
   * Show a status message in the status bar
   * @param {string} message - The message to display
   * @param {string} [type='info'] - Message type (info, success, warning, error)
   * @param {Object} [options] - Additional options
   * @param {number} [options.duration=5000] - Duration in milliseconds to show the message
   * @param {boolean} [options.autoDismiss=true] - Whether to auto-dismiss the message
   * @param {string} [options.errorId] - Unique error ID for tracking
   * @param {Object} [options.context] - Additional context for the message
   */
  showStatusBar(message) {
    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'info';
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const {
      duration = 5000,
      autoDismiss = true,
      errorId,
      context = {}
    } = options;
    try {
      // Log the status message with appropriate level
      const logLevel = {
        info: 'info',
        success: 'info',
        warning: 'warn',
        error: 'error'
      }[type] || 'log';

      // Create log context
      const logContext = {
        messageType: type,
        ...(errorId && {
          errorId
        }),
        ...context
      };

      // Log the message with context
      this.logger[logLevel](`Status: ${message}`, logContext);

      // If status bar element is not available, just log and return
      if (!this.statusBarElement) {
        this.logger.debug('Status bar element not available in current view', logContext);
        return;
      }

      // Clear any existing timers
      if (this.statusBarTimer) {
        clearTimeout(this.statusBarTimer);
        this.statusBarTimer = null;
      }

      // Clear existing content
      this.statusBarElement.innerHTML = '';

      // Create message element
      const msg = document.createElement('span');
      msg.className = 'status-message';

      // Add error ID to the message if available
      let displayMessage = message;
      if (type === 'error' && errorId) {
        displayMessage += ` (Error ID: ${errorId})`;

        // In development, show more context for errors
        if (process.env.NODE_ENV === 'development' && Object.keys(context).length > 0) {
          displayMessage += `\n${JSON.stringify(context, null, 2)}`;
        }
      }
      msg.textContent = displayMessage;
      this.statusBarElement.appendChild(msg);

      // Add dismiss button for error/warning (persistent messages)
      if (type === 'error' || type === 'warning') {
        const dismiss = document.createElement('button');
        dismiss.className = 'status-dismiss';
        dismiss.innerHTML = '&times;';
        dismiss.setAttribute('aria-label', 'Dismiss message');
        dismiss.onclick = () => this.clearStatusBar();
        this.statusBarElement.appendChild(dismiss);
      }

      // Set status bar classes
      this.statusBarElement.className = `status-bar status-bar-${type} visible`;

      // Auto-dismiss for success/info messages or if explicitly enabled
      const shouldAutoDismiss = autoDismiss && (type === 'success' || type === 'info');
      if (shouldAutoDismiss) {
        this.statusBarTimer = setTimeout(() => {
          this.clearStatusBar();
        }, duration);
      }
    } catch (error) {
      // If there's an error showing the status bar, report it but don't crash
      this.errorManager.handleError(error, {
        component: 'UIManager',
        operation: 'showStatusBar',
        severity: 'warning',
        context: {
          originalMessage: message,
          type,
          options,
          errorMessage: error.message
        }
      });

      // Fallback to console if the error manager fails
      console.error('Failed to show status bar:', error);
      console.log('Original message:', message);

      // Try to show a simplified error message
      try {
        if (this.statusBarElement) {
          this.statusBarElement.textContent = `Error: ${message.substring(0, 100)}`;
          this.statusBarElement.className = 'status-bar status-bar-error visible';
        }
      } catch (e) {
        // If we can't even show the error message, just give up
        console.error('Completely failed to show status bar:', e);
      }
    }
  }

  /**
   * Clear the status bar with smooth animation
   * @param {Object} [options] - Additional options
   * @param {boolean} [options.force=false] - Force clear without animation
   */
  clearStatusBar() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    try {
      // Clear any pending auto-dismiss timers
      if (this.statusBarTimer) {
        clearTimeout(this.statusBarTimer);
        this.statusBarTimer = null;
      }

      // If status bar element doesn't exist, just return
      if (!this.statusBarElement) {
        this.logger.debug('Status bar element not found during clear');
        return;
      }
      const {
        force = false
      } = options;
      if (force) {
        // Immediate removal
        this.statusBarElement.innerHTML = '';
        this.statusBarElement.className = 'status-bar';
        this.logger.debug('Status bar cleared immediately');
      } else {
        // Animate out
        this.statusBarElement.classList.remove('visible');

        // Remove the element after animation completes
        setTimeout(() => {
          if (this.statusBarElement) {
            this.statusBarElement.innerHTML = '';
            this.statusBarElement.className = 'status-bar';
          }
        }, 300); // Should match CSS transition duration

        this.logger.debug('Status bar cleared with animation');
      }
    } catch (error) {
      this.errorManager.handleError(error, {
        component: 'UIManager',
        operation: 'clearStatusBar',
        severity: 'warning',
        context: {
          options,
          errorMessage: error.message
        }
      });

      // Fallback to direct DOM manipulation if possible
      try {
        if (this.statusBarElement) {
          this.statusBarElement.innerHTML = '';
          this.statusBarElement.className = 'status-bar';
        }
      } catch (e) {
        console.error('Failed to clear status bar:', e);
      }
    }
  }

  /**
   * Show a success message
   * @param {string} message - The success message to display
   * @param {Object} [details] - Additional details to log
   */
  showSuccess(message) {
    let details = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.showStatusBar(message, 'success');
    this.logger.info('Success message shown', {
      message,
      ...details
    });
  }

  /**
   * Show a warning message
   * @param {string} message - The warning message to display
   * @param {Object} [details] - Additional details to log
   */
  showWarning(message) {
    let details = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.showStatusBar(message, 'warning');
    this.logger.warn('Warning message shown', {
      message,
      ...details
    });
  }

  /**
   * Show an info message
   * @param {string} message - The info message to display
   * @param {Object} [details] - Additional details to log
   */
  showInfo(message) {
    let details = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.showStatusBar(message, 'info');
  }
  /**
   * Show an error message to the user
   * @param {string|Error} error - Error title, message, or Error object
   * @param {string|Object} [details] - Additional error details or options object
   * @param {Object} [options] - Additional options
   * @param {string} [options.errorId] - Unique error ID for tracking
   * @param {Object} [options.context] - Additional context for the error
   * @param {boolean} [options.reportToServer=true] - Whether to report the error to the server
   * @param {string} [options.operation] - The operation that failed
   * @param {string} [options.component] - The component where the error occurred
   */
  showError(error) {
    let details = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    // Handle different parameter patterns
    let errorMessage, errorObj, errorContext;
    if (error instanceof Error) {
      // First parameter is an Error object
      errorObj = error;
      errorMessage = error.message;
      errorContext = typeof details === 'object' && details !== null ? details : {};
    } else if (typeof error === 'string' && details instanceof Error) {
      // First is title, second is Error object
      errorObj = details;
      errorMessage = `${error}: ${details.message}`;
      errorContext = {};
    } else if (typeof error === 'string' && typeof details === 'string') {
      // Both are strings (title and message)
      errorMessage = `${error}: ${details}`;
      errorObj = new Error(errorMessage);
      errorObj.name = error;
      errorContext = {};
    } else if (typeof error === 'string') {
      // First is message, second is options
      errorMessage = error;
      errorObj = new Error(errorMessage);
      errorContext = typeof details === 'object' && details !== null ? details : {};
    } else {
      // Invalid parameters
      const invalidError = new Error('Invalid parameters passed to showError');
      this.errorManager.handleError(invalidError, {
        component: 'UIManager',
        operation: 'showError',
        severity: 'error',
        context: {
          error,
          details,
          options
        }
      });
      return;
    }

    // Merge contexts
    const mergedContext = {
      ...errorContext,
      ...options.context
    };

    // Report the error through the error manager
    if (options.reportToServer !== false) {
      this.errorManager.handleError(errorObj, {
        component: options.component || 'UIManager',
        operation: options.operation || 'showError',
        severity: 'error',
        context: mergedContext
      });
    }

    // Show the error in the UI
    this.showStatusBar(errorMessage, 'error', {
      autoDismiss: false,
      errorId: options.errorId,
      context: mergedContext,
      ...options
    });

    // Log the error with additional context
    this.logger.error('Error message shown', {
      error: errorMessage,
      name: errorObj.name,
      stack: errorObj.stack,
      ...mergedContext
    });
  }
  catch(error) {
    // If there's an error in the error handler, log to console
    console.error('Error in showError:', error);

    // Try to show a basic error message
    try {
      const fallbackMessage = 'An error occurred';
      this.showStatusBar(fallbackMessage, 'error', {
        autoDismiss: false,
        context: {
          originalError: error instanceof Error ? error.message : String(error),
          timestamp: new Date().toISOString()
        }
      });
    } catch (e) {
      // If we can't even show the error message, just give up
      console.error('Completely failed to show error:', e);
    }
  }

  /**
   * Hide loading indicator dand optionally show success message
   * @param {string} successMessage - Optional success message to show after hiding loading
   */
  hideLoading() {
    let successMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    this.clearStatusBar();
    if (successMessage) {
      this.showSuccess(successMessage);
    }
    this.logger.debug('Loading indicator hidden');
  }

  /**
   * Update progress bar with current and total values
   * @param {number} current - Current progress value
   * @param {number} total - Total progress value
   * @param {string} message - Progress message
   */
  updateProgress(current, total) {
    let message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    console.log(' [UI MANAGER DEBUG] updateProgress() called with:', {
      current,
      total,
      message
    });
    if (!this.progressContainer) {
      console.error(' [UI MANAGER DEBUG] Progress container not found in updateProgress');
      this.logger.warn('Progress container not found');
      return;
    }
    console.log(' [UI MANAGER DEBUG] Progress container found, calculating percentage...');
    const percentage = total > 0 ? Math.round(current / total * 100) : 0;
    console.log(' [UI MANAGER DEBUG] Calculated percentage:', percentage);

    // Update progress bar
    const progressBar = this.progressContainer.querySelector('.progress-bar-fill');
    console.log(' [UI MANAGER DEBUG] Progress bar element:', progressBar);
    if (progressBar) {
      progressBar.style.width = `${percentage}%`;
      console.log(' [UI MANAGER DEBUG] Progress bar updated to:', `${percentage}%`);
    } else {
      console.error(' [UI MANAGER DEBUG] Progress bar element not found');
    }

    // Update percentage text
    const percentageElement = this.progressContainer.querySelector('.progress-percentage');
    console.log(' [UI MANAGER DEBUG] Percentage element:', percentageElement);
    if (percentageElement) {
      percentageElement.textContent = `${percentage}%`;
      console.log(' [UI MANAGER DEBUG] Percentage text updated to:', `${percentage}%`);
    } else {
      console.error(' [UI MANAGER DEBUG] Percentage element not found');
    }

    // Update progress text
    const progressText = this.progressContainer.querySelector('.progress-text');
    console.log(' [UI MANAGER DEBUG] Progress text element:', progressText);
    if (progressText && message) {
      progressText.textContent = message;
      console.log(' [UI MANAGER DEBUG] Progress text updated to:', message);
    } else {
      console.error(' [UI MANAGER DEBUG] Progress text element not found or no message');
    }
    this.logger.debug('Progress updated', {
      current,
      total,
      percentage,
      message
    });
    console.log(' [UI MANAGER DEBUG] updateProgress() completed');
  }

  /**
   * Update token status display
   * @param {string} status - Token status (valid, expired, etc.)
   * @param {string} message - Status message
   */
  updateTokenStatus(status) {
    let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    if (!this.tokenStatusElement) {
      this.logger.warn('Token status element not found');
      return;
    }
    this.tokenStatusElement.className = `token-status ${status}`;
    this.tokenStatusElement.textContent = message || status;
    this.logger.debug('Token status updated', {
      status,
      message
    });
  }

  /**
   * Update connection status display
   * @param {string} status - Connection status (connected, disconnected, etc.)
   * @param {string} message - Status message
   */
  updateConnectionStatus(status) {
    let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    if (!this.connectionStatusElement) {
      this.logger.warn('Connection status element not found');
      return;
    }
    this.connectionStatusElement.className = `connection-status ${status}`;
    this.connectionStatusElement.textContent = message || status;
    this.logger.debug('Connection status updated', {
      status,
      message
    });
  }

  /**
   * Show current token status with detailed information
   * @param {Object} tokenInfo - Token information object
   */
  showCurrentTokenStatus(tokenInfo) {
    if (!tokenInfo) {
      this.logger.warn('No token info provided');
      return;
    }
    const {
      isValid,
      expiresAt,
      timeRemaining
    } = tokenInfo;
    if (!isValid) {
      this.updateTokenStatus('expired', '');
      return;
    }
    const timeRemainingText = timeRemaining ? ` (${timeRemaining})` : '';
    this.updateTokenStatus('valid', `Token valid${timeRemainingText}`);
    this.logger.info('Current token status displayed', {
      isValid,
      expiresAt,
      timeRemaining
    });
  }

  /**
   * Update universal token status bar
   * @param {Object} tokenInfo - Token information object
   */
  updateUniversalTokenStatus(tokenInfo) {
    // Redirect to token-status-indicator instead of universal-token-status
    const tokenStatusBar = document.getElementById('token-status-indicator');
    if (!tokenStatusBar) {
      this.logger.warn('Token status indicator not found');
      return;
    }
    if (!tokenInfo) {
      tokenStatusBar.style.display = 'none';
      return;
    }
    const {
      isValid,
      expiresAt,
      timeRemaining
    } = tokenInfo;
    const statusContent = tokenStatusBar.querySelector('.token-status-content');
    if (statusContent) {
      const icon = statusContent.querySelector('.token-status-icon');
      const text = statusContent.querySelector('.token-status-text');
      const time = statusContent.querySelector('.token-status-time');
      if (isValid) {
        icon.textContent = '';
        text.textContent = 'Token valid';
        time.textContent = timeRemaining || '';
      } else {
        icon.textContent = '';
        text.textContent = '';
        text.style.visibility = 'hidden';
        time.textContent = '';
      }
    }
    tokenStatusBar.style.display = 'block';
    this.logger.debug('Token status indicator updated', {
      isValid,
      timeRemaining
    });
  }

  /**
   * Update home page token status
   * @param {boolean} isLoading - Whether to show loading state
   * @param {string} message - Status message
   */
  updateHomeTokenStatus() {
    let isLoading = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    const homeTokenStatus = document.getElementById('home-token-status');
    if (!homeTokenStatus) {
      console.log(' home-token-status element not found!');
      return;
    }
    console.log(' Found home-token-status element:', homeTokenStatus);

    // Check current token status to determine button color
    let hasValidToken = false;
    let buttonClass = 'btn-danger'; // Default to red
    let buttonText = 'Get New Token';
    try {
      // First check for stashed token in localStorage
      hasValidToken = this.checkForStashedToken();

      // If no stashed token, check PingOne client
      if (!hasValidToken && window.app && window.app.pingOneClient) {
        const tokenInfo = window.app.pingOneClient.getCurrentTokenTimeRemaining();
        if (tokenInfo && tokenInfo.token && !tokenInfo.isExpired) {
          hasValidToken = true;
        }
      }

      // Set button appearance based on token status
      if (hasValidToken) {
        buttonClass = 'btn-success'; // Green when token is valid
        buttonText = 'Token Valid';
      }
    } catch (error) {
      console.log('Error checking token status:', error);
    }

    // Move to bottom of sidebar
    const sidebar = document.querySelector('.sidebar');
    if (sidebar && homeTokenStatus.parentNode !== sidebar) {
      sidebar.appendChild(homeTokenStatus);
      console.log(' Moved home-token-status to bottom of sidebar');
    }

    // Add debug label to home-token-status container (red, above box)
    if (!document.getElementById('debug-home-token-status-label')) {
      const debugLabel = document.createElement('div');
      debugLabel.id = 'debug-home-token-status-label';
      debugLabel.style.cssText = `
                position: absolute !important;
                top: -30px !important;
                left: 0 !important;
                background: #ff0000 !important;
                color: #ffffff !important;
                padding: 4px 8px !important;
                font-size: 12px !important;
                font-weight: bold !important;
                border: 2px solid #000 !important;
                z-index: 9999 !important;
                white-space: nowrap !important;
                pointer-events: none !important;
            `;
      debugLabel.textContent = 'DEBUG: home-token-status CONTAINER';

      // Ensure container has relative positioning
      homeTokenStatus.style.cssText = `
                position: relative !important;
                background: #ffffcc !important;
                border: 1px solid #dee2e6 !important;
                border-radius: 6px !important;
                padding: 2px !important;
                width: fit-content !important;
                height: auto !important;
                display: block !important;
                overflow: visible !important;
                margin-top: auto !important;
            `;
      homeTokenStatus.appendChild(debugLabel);
      console.log(' Added debug label to home-token-status container');
    }
    if (isLoading) {
      homeTokenStatus.innerHTML = '';
    } else {
      // Use the provided token-status-indicator markup with dynamic button color and enhanced styling
      homeTokenStatus.innerHTML = `
                <div id="token-status-indicator" class="token-status-indicator valid" role="status" aria-live="polite" style="display: block !important; padding: 0 !important; margin: 0 !important; background: none !important; border: none !important;">
                    <button id="get-token-btn" class="btn ${buttonClass}" style="font-size: 14px !important; padding: 8px 16px !important; margin: 0 !important; font-weight: 500 !important; border-radius: 6px !important; box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important; transition: all 0.2s ease !important;">
                        <i class="fas fa-key"></i> ${buttonText}
                    </button>
                </div>
            `;
      // Wire up the button to call getNewToken if available
      const getTokenBtn = document.getElementById('get-token-btn');
      if (getTokenBtn) {
        getTokenBtn.addEventListener('click', () => {
          if (window.tokenStatusIndicator && typeof window.tokenStatusIndicator.getNewToken === 'function') {
            window.tokenStatusIndicator.getNewToken();
          } else if (typeof this.getNewToken === 'function') {
            this.getNewToken();
          } else {
            // TODO: Refactor: Use Notification or Modal from UI subsystem instead of alert.
            // alert('Get New Token functionality is not available.');
          }
        });
      }
    }
    homeTokenStatus.style.display = 'block';
    this.logger.debug('Home token status updated', {
      isLoading,
      message,
      hasValidToken,
      buttonClass
    });
  }

  /**
   * Check for stashed token in localStorage
   * @returns {boolean} True if valid token is found
   */
  checkForStashedToken() {
    try {
      if (typeof localStorage === 'undefined') {
        return false;
      }
      const token = localStorage.getItem('pingone_worker_token');
      const expiry = localStorage.getItem('pingone_token_expiry');
      if (!token || !expiry) {
        return false;
      }
      const expiryTime = parseInt(expiry, 10);
      const now = Date.now();

      // Check if token is expired (with 5 minute buffer)
      if (isNaN(expiryTime) || now >= expiryTime - 5 * 60 * 1000) {
        return false;
      }
      return true;
    } catch (error) {
      console.error('Error checking for stashed token:', error);
      return false;
    }
  }

  /**
   * Update settings save status with message and type
   * @param {string} message - Status message
   * @param {string} type - Message type (success, error, warning, info)
   */
  updateSettingsSaveStatus(message) {
    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'info';
    const settingsStatus = document.querySelector('.settings-save-status');
    if (!settingsStatus) {
      this.logger.warn('Settings save status element not found');
      return;
    }

    // Update classes
    settingsStatus.className = `settings-save-status ${type} show`;

    // Create simple HTML structure with text on the left, icon on the right
    const iconClass = this.getStatusIcon(type);
    settingsStatus.innerHTML = `
            <span>${message}</span>
            <i class="fas ${iconClass}"></i>
        `;

    // Auto-hide success messages after 3 seconds
    if (type === 'success') {
      setTimeout(() => {
        settingsStatus.classList.remove('show');
      }, 3000);
    }
    this.logger.info('Settings save status updated', {
      message,
      type
    });
  }

  /**
   * Show settings action status with enhanced options
   * @param {string} message - Status message
   * @param {string} type - Message type (success, error, warning, info)
   * @param {Object} options - Additional display options
   * @param {boolean} options.autoDismiss - Whether to auto-dismiss
   * @param {number} options.duration - Duration before auto-dismiss
   */
  showSettingsActionStatus(message) {
    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'info';
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const settingsActionStatus = document.getElementById('settings-action-status');
    if (!settingsActionStatus) {
      this.logger.warn('Settings action status element not found');
      return;
    }

    // Clear existing content
    settingsActionStatus.innerHTML = '';
    settingsActionStatus.className = `settings-action-status ${type}`;

    // Create status content
    const statusContent = document.createElement('div');
    statusContent.className = 'status-content';
    const text = document.createElement('span');
    text.textContent = message;
    statusContent.appendChild(text);
    const icon = document.createElement('i');
    icon.className = `fas ${this.getStatusIcon(type)}`;
    statusContent.appendChild(icon);
    settingsActionStatus.appendChild(statusContent);
    settingsActionStatus.style.display = 'block';

    // No auto-dismiss for any type
    this.logger.info('Settings action status shown', {
      message,
      type,
      autoDismiss: false
    });
  }

  /**
   * Get appropriate icon class for status type
   * @param {string} type - Status type
   * @returns {string} Icon class name
   */
  getStatusIcon(type) {
    const icons = {
      success: 'fa-check-circle',
      error: 'fa-times-circle',
      warning: 'fa-exclamation-triangle',
      info: 'fa-info-circle'
    };
    return icons[type] || icons.info;
  }

  /**
   * Hide settings action status
   */
  hideSettingsActionStatus() {
    const settingsActionStatus = document.getElementById('settings-action-status');
    if (settingsActionStatus) {
      settingsActionStatus.style.display = 'none';
      this.logger.debug('Settings action status hidden');
    }
  }

  /**
   * Show import status with operation details
   * @param {string} status - Import status
   * @param {string} message - Status message
   * @param {Object} details - Additional details
   */
  showImportStatus(status) {
    let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    let details = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const importStatus = document.getElementById('import-status');
    if (!importStatus) {
      this.logger.warn('Import status element not found');
      return;
    }
    importStatus.style.display = 'block';
    importStatus.className = `import-status ${status}`;
    const statusText = importStatus.querySelector('.status-text');
    if (statusText) {
      statusText.textContent = message || status;
    }
    this.logger.info('Import status shown', {
      status,
      message,
      details
    });
  }

  /**
   * Clear all notifications from the UI
   */
  clearNotifications() {
    if (this.notificationContainer) {
      this.notificationContainer.innerHTML = '';
      this.logger.debug('All notifications cleared');
    }
    this.clearStatusBar();
  }

  /**
   * Hide progress display
   */
  hideProgress() {
    if (this.progressContainer) {
      this.progressContainer.style.display = 'none';
      this.logger.debug('Progress display hidden');
    }
  }

  /**
   * Show progress section with enhanced debugging and fallback mechanisms
   */
  showProgress() {
    console.log(' [UI MANAGER DEBUG] showProgress() called');
    console.log(' [UI MANAGER DEBUG] this.progressContainer:', this.progressContainer);

    // Try multiple ways to get the progress container
    let progressContainer = this.progressContainer;
    if (!progressContainer) {
      console.log(' [UI MANAGER DEBUG] Progress container not found in UI manager, trying direct access...');
      progressContainer = document.getElementById('progress-container');
    }
    if (!progressContainer) {
      console.log(' [UI MANAGER DEBUG] Progress container not found by ID, trying ElementRegistry...');
      if (typeof _elementRegistry.ElementRegistry !== 'undefined' && _elementRegistry.ElementRegistry.progressContainer) {
        progressContainer = _elementRegistry.ElementRegistry.progressContainer();
      }
    }
    if (!progressContainer) {
      console.log(' [UI MANAGER DEBUG] Progress container not found by ElementRegistry, trying class selector...');
      progressContainer = document.querySelector('.progress-container');
    }
    if (!progressContainer) {
      console.error(' [UI MANAGER DEBUG] Progress container not found by any method');
      console.error(' [UI MANAGER DEBUG] Available containers with "progress" in ID:', Array.from(document.querySelectorAll('[id*="progress"]')).map(el => el.id));
      console.error(' [UI MANAGER DEBUG] Available containers with "progress" in class:', Array.from(document.querySelectorAll('[class*="progress"]')).map(el => ({
        id: el.id,
        className: el.className
      })));
      return;
    }
    console.log(' [UI MANAGER DEBUG] Progress container found, showing...');
    console.log(' [UI MANAGER DEBUG] Current display style:', progressContainer.style.display);
    console.log(' [UI MANAGER DEBUG] Current visibility:', progressContainer.offsetParent !== null ? 'visible' : 'hidden');

    // Force show the progress container
    progressContainer.style.display = 'block';
    progressContainer.style.visibility = 'visible';
    progressContainer.style.opacity = '1';

    // Ensure it's not hidden by CSS
    progressContainer.classList.remove('hidden', 'd-none');
    progressContainer.classList.add('visible');

    // Force layout recalculation
    progressContainer.offsetHeight;
    console.log(' [UI MANAGER DEBUG] Display style after setting to block:', progressContainer.style.display);
    console.log(' [UI MANAGER DEBUG] Container visibility:', progressContainer.offsetParent !== null ? 'visible' : 'hidden');
    console.log(' [UI MANAGER DEBUG] Container dimensions:', {
      offsetWidth: progressContainer.offsetWidth,
      offsetHeight: progressContainer.offsetHeight,
      clientWidth: progressContainer.clientWidth,
      clientHeight: progressContainer.clientHeight
    });

    // Scroll into view if needed
    if (progressContainer.offsetParent !== null) {
      progressContainer.scrollIntoView({
        behavior: 'smooth',
        block: 'center'
      });
    }

    // Update UI manager's reference
    this.progressContainer = progressContainer;
    this.logger.debug('Progress display shown');

    // Additional verification
    setTimeout(() => {
      const isVisible = progressContainer.offsetParent !== null;
      const rect = progressContainer.getBoundingClientRect();
      console.log(' [UI MANAGER DEBUG] Final verification:', {
        isVisible,
        dimensions: {
          width: rect.width,
          height: rect.height
        },
        display: progressContainer.style.display,
        computedDisplay: window.getComputedStyle(progressContainer).display
      });
    }, 100);
  }

  /**
   * Set button loading state
   * @param {string} buttonId - Button element ID
   * @param {boolean} isLoading - Whether to show loading state
   */
  setButtonLoading(buttonId, isLoading) {
    const button = document.getElementById(buttonId);
    if (!button) {
      // Don't log warning for buttons that are intentionally hidden or optional
      if (buttonId === 'get-token-quick') {
        this.logger.debug(`Button with ID '${buttonId}' not found (may be hidden)`);
      } else {
        this.logger.warn(`Button with ID '${buttonId}' not found`);
      }
      return;
    }
    if (isLoading) {
      button.disabled = true;
      button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';
      button.classList.add('loading');
    } else {
      button.disabled = false;
      button.innerHTML = button.getAttribute('data-original-text') || 'Submit';
      button.classList.remove('loading');
    }
    this.logger.debug('Button loading state updated', {
      buttonId,
      isLoading
    });
  }

  /**
   * Update population dropdown fields with available populations
   * @param {Array} populations - Array of population objects
   */
  updatePopulationFields(populations) {
    if (!populations || !Array.isArray(populations)) {
      this.logger.warn('Invalid populations data provided');
      return;
    }
    const populationSelects = document.querySelectorAll('select[id*="population"]');
    populationSelects.forEach(select => {
      // Store current selection
      const currentValue = select.value;

      // Clear existing options
      select.innerHTML = '';

      // Add default option
      const defaultOption = document.createElement('option');
      defaultOption.value = '';
      defaultOption.textContent = 'Select a population...';
      select.appendChild(defaultOption);

      // Add population options
      populations.forEach(population => {
        const option = document.createElement('option');
        option.value = population.id;
        option.textContent = population.name;
        select.appendChild(option);
      });

      // Restore selection if it still exists
      if (currentValue && select.querySelector(`option[value="${currentValue}"]`)) {
        select.value = currentValue;
      }
    });
    this.logger.info('Population fields updated', {
      populationCount: populations.length,
      selectCount: populationSelects.length
    });
  }

  /**
   * Show notification with enhanced options
   * @param {string} title - Notification title
   * @param {string} message - Notification message
   * @param {string} type - Notification type (success, error, warning, info)
   * @param {Object} options - Additional display options
   * @param {boolean} options.autoDismiss - Whether to auto-dismiss
   * @param {number} options.duration - Duration before auto-dismiss
   */
  showNotification(title, message) {
    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'info';
    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    if (!this.notificationContainer) {
      this.logger.warn('Notification container not found');
      return;
    }

    // Clear existing content
    this.notificationContainer.innerHTML = '';

    // Create status header content
    const statusContent = document.createElement('div');
    statusContent.className = 'status-content';

    // Add icon
    const icon = document.createElement('i');
    icon.className = `fas ${this.getStatusIcon(type)}`;
    statusContent.appendChild(icon);

    // Add text
    const text = document.createElement('span');
    if (title && message) {
      text.textContent = `${title}: ${message}`;
    } else {
      text.textContent = title || message;
    }
    statusContent.appendChild(text);

    // Add to container
    this.notificationContainer.appendChild(statusContent);

    // Auto-dismiss if specified (but keep persistent for success messages)
    const shouldAutoDismiss = options.autoDismiss !== false && type !== 'error' && type !== 'success';
    if (shouldAutoDismiss) {
      const duration = options.duration || 5000;
      setTimeout(() => {
        if (this.notificationContainer && this.notificationContainer.contains(statusContent)) {
          this.notificationContainer.innerHTML = '';
        }
      }, duration);
    }
    this.logger.info('Status header updated', {
      title,
      message,
      type,
      autoDismiss: shouldAutoDismiss
    });
  }

  /**
   * Update import progress with detailed statistics
   * @param {number} current - Current progress value
   * @param {number} total - Total progress value
   * @param {string} message - Progress message
   * @param {Object} counts - Statistics counts
   * @param {number} counts.processed - Number of processed items
   * @param {number} counts.success - Number of successful items
   * @param {number} counts.failed - Number of failed items
   * @param {number} counts.skipped - Number of skipped items
   * @param {string} populationName - Population name
   * @param {string} populationId - Population ID
   */
  updateImportProgress(current, total) {
    let message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    let counts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    let populationName = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';
    let populationId = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '';
    // Update main progress
    this.updateProgress(current, total, message);

    // Update statistics if provided
    if (counts && typeof counts === 'object') {
      Object.entries(counts).forEach(_ref => {
        let [key, value] = _ref;
        const statElement = document.querySelector(`.stat-value.${key}`);
        if (statElement) {
          statElement.textContent = value || 0;
        }
      });
    }

    // Update population information if provided
    if (populationName || populationId) {
      const populationElement = document.querySelector('.detail-value.population-info');
      if (populationElement) {
        populationElement.textContent = populationName || populationId || 'Unknown';
      }
    }
    this.logger.debug('Import progress updated', {
      current,
      total,
      message,
      counts,
      populationName,
      populationId
    });
  }

  /**
   * Start import operation with progress tracking
   * @param {Object} options - Operation options
   * @param {string} options.operationType - Type of operation
   * @param {number} options.totalUsers - Total number of users
   * @param {string} options.populationName - Population name
   * @param {string} options.populationId - Population ID
   */
  startImportOperation() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    console.log(' [UI MANAGER DEBUG] startImportOperation() called with options:', options);
    const {
      operationType,
      totalUsers,
      populationName,
      populationId
    } = options;
    console.log(' [UI MANAGER DEBUG] About to call showProgress()...');
    this.showProgress();
    console.log(' [UI MANAGER DEBUG] showProgress() completed');
    console.log(' [UI MANAGER DEBUG] About to call updateProgress()...');
    this.updateProgress(0, totalUsers || 0, 'Starting import operation...');
    console.log(' [UI MANAGER DEBUG] updateProgress() completed');

    // Update operation details
    const operationTypeElement = document.querySelector('.detail-value.operation-type');
    console.log(' [UI MANAGER DEBUG] Operation type element:', operationTypeElement);
    if (operationTypeElement) {
      operationTypeElement.textContent = operationType || 'Import';
      console.log(' [UI MANAGER DEBUG] Operation type updated to:', operationType || 'Import');
    } else {
      console.error(' [UI MANAGER DEBUG] Operation type element not found');
    }
    this.logger.info('Import operation started', {
      operationType,
      totalUsers,
      populationName,
      populationId
    });
    console.log(' [UI MANAGER DEBUG] startImportOperation() completed');
  }

  /**
   * Update import operation with session ID
   * @param {string} sessionId - Session ID for tracking
   */
  updateImportOperationWithSessionId(sessionId) {
    if (!sessionId) {
      this.logger.warn('No session ID provided for import operation');
      return;
    }
    const sessionElement = document.querySelector('.detail-value.session-id');
    if (sessionElement) {
      sessionElement.textContent = sessionId;
    }
    this.logger.info('Import operation session ID updated', {
      sessionId
    });
  }

  /**
   * Start export operation with progress tracking
   * @param {Object} options - Operation options
   * @param {number} options.totalUsers - Total number of users
   * @param {string} options.populationName - Population name
   */
  startExportOperation() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      totalUsers,
      populationName
    } = options;
    this.showProgress();
    this.updateProgress(0, totalUsers || 0, 'Starting export operation...');
    const operationTypeElement = document.querySelector('.detail-value.operation-type');
    if (operationTypeElement) {
      operationTypeElement.textContent = 'Export';
    }
    this.logger.info('Export operation started', {
      totalUsers,
      populationName
    });
  }

  /**
   * Start delete operation with progress tracking
   * @param {Object} options - Operation options
   * @param {number} options.totalUsers - Total number of users
   * @param {string} options.populationName - Population name
   */
  startDeleteOperation() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      totalUsers,
      populationName
    } = options;
    this.showProgress();
    this.updateProgress(0, totalUsers || 0, 'Starting delete operation...');
    const operationTypeElement = document.querySelector('.detail-value.operation-type');
    if (operationTypeElement) {
      operationTypeElement.textContent = 'Delete';
    }
    this.logger.info('Delete operation started', {
      totalUsers,
      populationName
    });
  }

  /**
   * Start modify operation with progress tracking
   * @param {Object} options - Operation options
   * @param {number} options.totalUsers - Total number of users
   * @param {string} options.populationName - Population name
   */
  startModifyOperation() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      totalUsers,
      populationName
    } = options;
    this.showProgress();
    this.updateProgress(0, totalUsers || 0, 'Starting modify operation...');
    const operationTypeElement = document.querySelector('.detail-value.operation-type');
    if (operationTypeElement) {
      operationTypeElement.textContent = 'Modify';
    }
    this.logger.info('Modify operation started', {
      totalUsers,
      populationName
    });
  }

  /**
   * Complete operation with results
   * @param {Object} results - Operation results
   * @param {number} results.processed - Number of processed items
   * @param {number} results.success - Number of successful items
   * @param {number} results.failed - Number of failed items
   * @param {number} results.skipped - Number of skipped items
   */
  completeOperation() {
    let results = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      processed,
      success,
      failed,
      skipped
    } = results;
    this.updateProgress(processed || 0, processed || 0, 'Operation completed');

    // Show completion message
    const message = `Operation completed: ${success || 0} successful, ${failed || 0} failed, ${skipped || 0} skipped`;
    this.showSuccess(message);

    // Hide progress after delay
    setTimeout(() => {
      this.hideProgress();
    }, 2000);
    this.logger.info('Operation completed', {
      processed,
      success,
      failed,
      skipped
    });
  }

  /**
   * Handle duplicate users with decision callback
   * @param {Array} duplicates - Array of duplicate user objects
   * @param {Function} onDecision - Callback function for user decision
   */
  handleDuplicateUsers(duplicates, onDecision) {
    if (!duplicates || duplicates.length === 0) {
      this.logger.warn('No duplicates provided for handling');
      return;
    }
    const message = `Found ${duplicates.length} duplicate users. How would you like to proceed?`;
    this.showWarning(message);

    // In a real implementation, you would show a modal or dialog here
    // For now, we'll just log the decision
    this.logger.info('Duplicate users found', {
      count: duplicates.length
    });
    if (onDecision && typeof onDecision === 'function') {
      onDecision('skip'); // Default to skip
    }
  }

  /**
   * Debug logging for development
   * @param {string} area - Debug area
   * @param {string} message - Debug message
   */
  debugLog(area, message) {
    if (DEBUG_MODE) {
      this.logger.debug(`[${area}] ${message}`);
    }
  }

  /**
   * Show status message with type
   * @param {string} type - Message type
   * @param {string} message - Message content
   * @param {string} details - Additional details
   */
  showStatusMessage(type, message) {
    let details = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    const fullMessage = details ? `${message}: ${details}` : message;
    this.showNotification('Status Update', fullMessage, type);
  }

  /**
   * Show export status
   */
  showExportStatus() {
    this.showProgress();
    this.updateProgress(0, 100, 'Preparing export...');
    this.logger.info('Export status shown');
  }

  /**
   * Update export progress
   * @param {number} current - Current progress
   * @param {number} total - Total progress
   * @param {string} message - Progress message
   * @param {Object} counts - Statistics counts
   */
  updateExportProgress(current, total, message) {
    let counts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    this.updateProgress(current, total, message);

    // Update export-specific statistics
    if (counts && typeof counts === 'object') {
      Object.entries(counts).forEach(_ref2 => {
        let [key, value] = _ref2;
        const statElement = document.querySelector(`.stat-value.${key}`);
        if (statElement) {
          statElement.textContent = value || 0;
        }
      });
    }
    this.logger.debug('Export progress updated', {
      current,
      total,
      message,
      counts
    });
  }

  /**
   * Show delete status
   * @param {number} totalUsers - Total number of users
   * @param {string} populationName - Population name
   * @param {string} populationId - Population ID
   */
  showDeleteStatus(totalUsers, populationName, populationId) {
    this.showProgress();
    this.updateProgress(0, totalUsers || 0, 'Preparing delete operation...');
    const operationTypeElement = document.querySelector('.detail-value.operation-type');
    if (operationTypeElement) {
      operationTypeElement.textContent = 'Delete';
    }
    this.logger.info('Delete status shown', {
      totalUsers,
      populationName,
      populationId
    });
  }

  /**
   * Update delete progress
   * @param {number} current - Current progress
   * @param {number} total - Total progress
   * @param {string} message - Progress message
   * @param {Object} counts - Statistics counts
   * @param {string} populationName - Population name
   * @param {string} populationId - Population ID
   */
  updateDeleteProgress(current, total, message) {
    let counts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    let populationName = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';
    let populationId = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '';
    this.updateProgress(current, total, message);

    // Update delete-specific statistics
    if (counts && typeof counts === 'object') {
      Object.entries(counts).forEach(_ref3 => {
        let [key, value] = _ref3;
        const statElement = document.querySelector(`.stat-value.${key}`);
        if (statElement) {
          statElement.textContent = value || 0;
        }
      });
    }
    this.logger.debug('Delete progress updated', {
      current,
      total,
      message,
      counts,
      populationName,
      populationId
    });
  }

  /**
   * Show modify status
   * @param {number} totalUsers - Total number of users
   */
  showModifyStatus(totalUsers) {
    this.showProgress();
    this.updateProgress(0, totalUsers || 0, 'Preparing modify operation...');
    const operationTypeElement = document.querySelector('.detail-value.operation-type');
    if (operationTypeElement) {
      operationTypeElement.textContent = 'Modify';
    }
    this.logger.info('Modify status shown', {
      totalUsers
    });
  }

  /**
   * Update modify progress
   * @param {number} current - Current progress
   * @param {number} total - Total progress
   * @param {string} message - Progress message
   * @param {Object} counts - Statistics counts
   */
  updateModifyProgress(current, total, message) {
    let counts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    this.updateProgress(current, total, message);

    // Update modify-specific statistics
    if (counts && typeof counts === 'object') {
      Object.entries(counts).forEach(_ref4 => {
        let [key, value] = _ref4;
        const statElement = document.querySelector(`.stat-value.${key}`);
        if (statElement) {
          statElement.textContent = value || 0;
        }
      });
    }
    this.logger.debug('Modify progress updated', {
      current,
      total,
      message,
      counts
    });
  }
}

// Export the UIManager class
exports.UIManager = UIManager;

}).call(this)}).call(this,require('_process'))
},{"../../../public/js/modules/circular-progress.js":43,"../../../public/js/modules/element-registry.js":47,"../../../public/js/modules/error/error-types.js":48,"../../../public/js/modules/progress-manager.js":59,"@babel/runtime/helpers/interopRequireDefault":2,"_process":29}],78:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AdvancedRealtimeSubsystem = void 0;
/**
 * Advanced Real-time Features Subsystem
 * 
 * Provides advanced real-time capabilities including:
 * - Multi-user collaboration and presence
 * - Live progress sharing across sessions
 * - Real-time notifications and alerts
 * - Collaborative operation management
 * - Live analytics and metrics streaming
 * - Cross-session synchronization
 */

class AdvancedRealtimeSubsystem {
  constructor(logger, eventBus, realtimeCommunication, sessionSubsystem, progressSubsystem) {
    this.logger = logger;
    this.eventBus = eventBus;
    this.realtimeCommunication = realtimeCommunication;
    this.sessionSubsystem = sessionSubsystem;
    this.progressSubsystem = progressSubsystem;

    // Multi-user state management
    this.activeUsers = new Map();
    this.collaborationRooms = new Map();
    this.sharedOperations = new Map();

    // Real-time features state
    this.liveProgressStreams = new Map();
    this.notificationQueues = new Map();
    this.analyticsStreams = new Map();

    // Configuration
    this.config = {
      maxUsersPerRoom: 10,
      progressUpdateInterval: 1000,
      presenceUpdateInterval: 5000,
      notificationRetention: 100,
      analyticsBufferSize: 1000
    };
    this.logger.info('Advanced Real-time Features Subsystem initialized');
  }

  /**
   * Initialize the advanced real-time subsystem
   */
  async init() {
    try {
      // Set up EventBus listeners for real-time coordination
      this.setupEventBusListeners();

      // Initialize multi-user presence system
      await this.initializePresenceSystem();

      // Set up live progress sharing
      await this.initializeLiveProgressSharing();

      // Initialize real-time notifications
      await this.initializeNotificationSystem();

      // Set up collaborative operation management
      await this.initializeCollaborativeOperations();

      // Initialize live analytics streaming
      await this.initializeLiveAnalytics();
      this.logger.info('Advanced Real-time Features Subsystem initialized successfully');
      this.eventBus.emit('subsystem:ready', {
        subsystem: 'advanced-realtime'
      });
    } catch (error) {
      this.logger.error('Failed to initialize Advanced Real-time Features Subsystem', error);
      this.eventBus.emit('subsystem:error', {
        subsystem: 'advanced-realtime',
        error
      });
      throw error;
    }
  }

  /**
   * Set up EventBus listeners for real-time coordination
   */
  setupEventBusListeners() {
    this.logger.debug('Setting up EventBus listeners for advanced real-time features');

    // User session events
    this.eventBus.on('session:user-joined', data => this.handleUserJoined(data));
    this.eventBus.on('session:user-left', data => this.handleUserLeft(data));
    this.eventBus.on('session:activity-update', data => this.handleActivityUpdate(data));

    // Operation events for collaboration
    this.eventBus.on('operation:started', data => this.handleOperationStarted(data));
    this.eventBus.on('operation:progress', data => this.handleOperationProgress(data));
    this.eventBus.on('operation:completed', data => this.handleOperationCompleted(data));
    this.eventBus.on('operation:failed', data => this.handleOperationFailed(data));

    // Progress events for live sharing
    this.eventBus.on('progress:updated', data => this.handleProgressUpdate(data));
    this.eventBus.on('progress:milestone', data => this.handleProgressMilestone(data));

    // Analytics events for live streaming
    this.eventBus.on('analytics:metric-update', data => this.handleAnalyticsUpdate(data));
    this.eventBus.on('analytics:performance-data', data => this.handlePerformanceData(data));
    this.logger.debug('EventBus listeners set up for advanced real-time features');
  }

  /**
   * Initialize multi-user presence system
   */
  async initializePresenceSystem() {
    this.logger.debug('Initializing multi-user presence system');

    // Set up presence broadcasting
    this.presenceInterval = setInterval(() => {
      this.broadcastPresence();
    }, this.config.presenceUpdateInterval);

    // Listen for presence updates from other users
    this.realtimeCommunication.on('user-presence', data => {
      this.handlePresenceUpdate(data);
    });

    // Handle user connection/disconnection
    this.realtimeCommunication.on('user-connected', data => {
      this.handleUserConnected(data);
    });
    this.realtimeCommunication.on('user-disconnected', data => {
      this.handleUserDisconnected(data);
    });
    this.logger.debug('Multi-user presence system initialized');
  }

  /**
   * Initialize live progress sharing
   */
  async initializeLiveProgressSharing() {
    this.logger.debug('Initializing live progress sharing');

    // Set up progress streaming
    this.progressInterval = setInterval(() => {
      this.streamProgressUpdates();
    }, this.config.progressUpdateInterval);

    // Listen for shared progress updates
    this.realtimeCommunication.on('progress-update', data => {
      this.handleSharedProgressUpdate(data);
    });

    // Handle progress synchronization requests
    this.realtimeCommunication.on('progress-sync-request', data => {
      this.handleProgressSyncRequest(data);
    });
    this.logger.debug('Live progress sharing initialized');
  }

  /**
   * Broadcast presence to connected users
   */
  broadcastPresence() {
    try {
      if (!this.currentRoom || !this.currentUser) {
        return;
      }
      const presenceData = {
        roomId: this.currentRoom,
        userId: this.currentUser.id || 'anonymous',
        userName: this.currentUser.name || 'Anonymous User',
        status: 'active',
        lastActivity: new Date().toISOString(),
        timestamp: new Date().toISOString()
      };

      // Broadcast presence to room
      this.realtimeCommunication.emit('user-presence', presenceData);

      // Update local presence
      this.activeUsers.set(presenceData.userId, {
        ...presenceData,
        joinedAt: this.activeUsers.get(presenceData.userId)?.joinedAt || new Date()
      });

      // Emit local event for UI updates
      this.eventBus.emit('realtime:presence-broadcasted', presenceData);
      this.logger.debug('Presence broadcasted', {
        roomId: this.currentRoom,
        userId: presenceData.userId
      });
    } catch (error) {
      this.logger.error('Failed to broadcast presence', error);
    }
  }

  /**
   * Stream progress updates to connected users
   */
  streamProgressUpdates() {
    try {
      if (!this.currentRoom || !this.progressSubsystem) {
        return;
      }

      // Get current progress from progress subsystem
      const progressData = this.progressSubsystem.getCurrentProgress();
      if (progressData && progressData.isActive) {
        const updateData = {
          roomId: this.currentRoom,
          userId: this.currentUser?.id || 'anonymous',
          userName: this.currentUser?.name || 'Anonymous User',
          progress: {
            operationType: progressData.operationType,
            percentage: progressData.percentage,
            currentStep: progressData.currentStep,
            totalSteps: progressData.totalSteps,
            message: progressData.message,
            timestamp: new Date().toISOString()
          }
        };

        // Broadcast progress update to room
        this.realtimeCommunication.emit('progress-update', updateData);

        // Update local shared progress
        this.sharedProgress.set(updateData.userId, updateData.progress);

        // Emit local event for UI updates
        this.eventBus.emit('realtime:progress-streamed', updateData);
        this.logger.debug('Progress update streamed', {
          roomId: this.currentRoom,
          userId: updateData.userId,
          percentage: progressData.percentage
        });
      }
    } catch (error) {
      this.logger.error('Failed to stream progress updates', error);
    }
  }

  /**
   * Initialize real-time notification system
   */
  async initializeNotificationSystem() {
    this.logger.debug('Initializing real-time notification system');

    // Listen for notification events
    this.realtimeCommunication.on('notification', data => {
      this.handleIncomingNotification(data);
    });

    // Set up notification broadcasting
    this.eventBus.on('notification:send', data => {
      this.broadcastNotification(data);
    });
    this.logger.debug('Real-time notification system initialized');
  }

  /**
   * Initialize collaborative operation management
   */
  async initializeCollaborativeOperations() {
    this.logger.debug('Initializing collaborative operation management');

    // Listen for collaborative operation events
    this.realtimeCommunication.on('operation-request', data => {
      this.handleOperationRequest(data);
    });
    this.realtimeCommunication.on('operation-lock', data => {
      this.handleOperationLock(data);
    });
    this.realtimeCommunication.on('operation-unlock', data => {
      this.handleOperationUnlock(data);
    });
    this.logger.debug('Collaborative operation management initialized');
  }

  /**
   * Initialize live analytics streaming
   */
  async initializeLiveAnalytics() {
    this.logger.debug('Initializing live analytics streaming');

    // Set up analytics data streaming
    this.analyticsInterval = setInterval(() => {
      this.streamAnalyticsData();
    }, 5000); // Stream analytics every 5 seconds

    // Listen for analytics updates from other sessions
    this.realtimeCommunication.on('analytics-update', data => {
      this.handleAnalyticsStreamUpdate(data);
    });
    this.logger.debug('Live analytics streaming initialized');
  }

  /**
   * Stream analytics data to connected users
   */
  streamAnalyticsData() {
    try {
      if (!this.currentRoom || !this.analyticsDashboard) {
        return;
      }

      // Get current analytics data from analytics dashboard subsystem
      const analyticsData = this.analyticsDashboard.getAnalyticsDashboardData('5m');
      if (analyticsData) {
        const streamData = {
          roomId: this.currentRoom,
          userId: this.currentUser?.id || 'anonymous',
          analytics: {
            systemMetrics: analyticsData.systemMetrics,
            operationSummary: analyticsData.operationSummary,
            recentActivity: analyticsData.recentActivity?.slice(0, 5),
            // Last 5 activities
            timestamp: new Date().toISOString()
          }
        };

        // Broadcast analytics update to room
        this.realtimeCommunication.emit('analytics-update', streamData);

        // Emit local event for UI updates
        this.eventBus.emit('realtime:analytics-streamed', streamData);
        this.logger.debug('Analytics data streamed', {
          roomId: this.currentRoom,
          userId: streamData.userId,
          metricsCount: Object.keys(streamData.analytics.systemMetrics || {}).length
        });
      }
    } catch (error) {
      this.logger.error('Failed to stream analytics data', error);
    }
  }

  /**
   * Join a collaboration room
   */
  async joinCollaborationRoom(roomId, userInfo) {
    this.logger.info('Joining collaboration room', {
      roomId,
      userId: userInfo.id
    });
    try {
      // Check room capacity
      if (this.collaborationRooms.has(roomId)) {
        const room = this.collaborationRooms.get(roomId);
        if (room.users.size >= this.config.maxUsersPerRoom) {
          throw new Error('Collaboration room is at capacity');
        }
      } else {
        // Create new room
        this.collaborationRooms.set(roomId, {
          id: roomId,
          users: new Map(),
          operations: new Map(),
          createdAt: new Date(),
          lastActivity: new Date()
        });
      }
      const room = this.collaborationRooms.get(roomId);
      room.users.set(userInfo.id, {
        ...userInfo,
        joinedAt: new Date(),
        lastSeen: new Date(),
        isActive: true
      });

      // Broadcast user joined event
      this.broadcastToRoom(roomId, 'user-joined', {
        roomId,
        user: userInfo,
        totalUsers: room.users.size
      });

      // Send room state to new user
      this.sendToUser(userInfo.id, 'room-state', {
        roomId,
        users: Array.from(room.users.values()),
        operations: Array.from(room.operations.values())
      });
      this.eventBus.emit('collaboration:user-joined', {
        roomId,
        user: userInfo
      });
      return {
        success: true,
        roomId,
        userCount: room.users.size,
        users: Array.from(room.users.values())
      };
    } catch (error) {
      this.logger.error('Failed to join collaboration room', {
        roomId,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Leave a collaboration room
   */
  async leaveCollaborationRoom(roomId, userId) {
    this.logger.info('Leaving collaboration room', {
      roomId,
      userId
    });
    try {
      if (!this.collaborationRooms.has(roomId)) {
        return {
          success: true,
          message: 'Room does not exist'
        };
      }
      const room = this.collaborationRooms.get(roomId);
      const user = room.users.get(userId);
      if (user) {
        room.users.delete(userId);

        // Broadcast user left event
        this.broadcastToRoom(roomId, 'user-left', {
          roomId,
          userId,
          user,
          totalUsers: room.users.size
        });

        // Clean up empty rooms
        if (room.users.size === 0) {
          this.collaborationRooms.delete(roomId);
          this.logger.debug('Removed empty collaboration room', {
            roomId
          });
        }
        this.eventBus.emit('collaboration:user-left', {
          roomId,
          userId,
          user
        });
      }
      return {
        success: true,
        roomId,
        userCount: room.users.size
      };
    } catch (error) {
      this.logger.error('Failed to leave collaboration room', {
        roomId,
        userId,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Start live progress sharing for an operation
   */
  async startLiveProgressSharing(operationId) {
    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.logger.info('Starting live progress sharing', {
      operationId
    });
    try {
      const progressStream = {
        operationId,
        startTime: new Date(),
        lastUpdate: new Date(),
        subscribers: new Set(),
        config: {
          updateInterval: config.updateInterval || this.config.progressUpdateInterval,
          includeMetrics: config.includeMetrics || true,
          includeErrors: config.includeErrors || true,
          maxHistory: config.maxHistory || 100
        },
        history: [],
        currentProgress: {
          percentage: 0,
          stage: 'initializing',
          message: 'Starting operation...',
          metrics: {}
        }
      };
      this.liveProgressStreams.set(operationId, progressStream);

      // Broadcast progress sharing started
      this.broadcastProgressEvent('progress-sharing-started', {
        operationId,
        config: progressStream.config
      });
      this.eventBus.emit('progress-sharing:started', {
        operationId,
        config: progressStream.config
      });
      return {
        success: true,
        operationId,
        streamId: operationId
      };
    } catch (error) {
      this.logger.error('Failed to start live progress sharing', {
        operationId,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Subscribe to live progress updates
   */
  async subscribeLiveProgress(operationId, subscriberId) {
    this.logger.debug('Subscribing to live progress', {
      operationId,
      subscriberId
    });
    if (!this.liveProgressStreams.has(operationId)) {
      throw new Error(`Progress stream not found for operation: ${operationId}`);
    }
    const stream = this.liveProgressStreams.get(operationId);
    stream.subscribers.add(subscriberId);

    // Send current progress state to new subscriber
    this.sendProgressUpdate(subscriberId, {
      operationId,
      progress: stream.currentProgress,
      history: stream.history.slice(-10) // Send last 10 updates
    });
    this.logger.debug('Subscribed to live progress', {
      operationId,
      subscriberId,
      totalSubscribers: stream.subscribers.size
    });
    return {
      success: true,
      operationId,
      subscriberId
    };
  }

  /**
   * Send real-time notification
   */
  async sendRealtimeNotification(notification) {
    this.logger.debug('Sending real-time notification', {
      type: notification.type,
      recipients: notification.recipients?.length
    });
    try {
      const notificationData = {
        id: this.generateId(),
        timestamp: new Date(),
        ...notification
      };

      // Store in notification queues for recipients
      if (notification.recipients) {
        notification.recipients.forEach(recipientId => {
          if (!this.notificationQueues.has(recipientId)) {
            this.notificationQueues.set(recipientId, []);
          }
          const queue = this.notificationQueues.get(recipientId);
          queue.push(notificationData);

          // Maintain queue size
          if (queue.length > this.config.notificationRetention) {
            queue.shift();
          }
        });
      }

      // Broadcast notification
      this.broadcastNotification(notificationData);
      this.eventBus.emit('notification:sent', notificationData);
      return {
        success: true,
        notificationId: notificationData.id
      };
    } catch (error) {
      this.logger.error('Failed to send real-time notification', {
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Get live analytics dashboard data
   */
  async getLiveAnalyticsDashboard() {
    this.logger.debug('Getting live analytics dashboard data');
    try {
      const dashboardData = {
        timestamp: new Date(),
        activeUsers: this.activeUsers.size,
        collaborationRooms: this.collaborationRooms.size,
        liveProgressStreams: this.liveProgressStreams.size,
        totalNotifications: Array.from(this.notificationQueues.values()).reduce((sum, queue) => sum + queue.length, 0),
        connectionStatus: this.realtimeCommunication.getConnectionStatus(),
        systemMetrics: await this.getSystemMetrics(),
        operationMetrics: await this.getOperationMetrics(),
        userActivity: await this.getUserActivityMetrics()
      };
      return dashboardData;
    } catch (error) {
      this.logger.error('Failed to get live analytics dashboard data', {
        error: error.message
      });
      throw error;
    }
  }

  // Event Handlers

  handleUserJoined(data) {
    this.logger.debug('Handling user joined event', data);
    this.activeUsers.set(data.userId, {
      ...data,
      joinedAt: new Date(),
      lastActivity: new Date()
    });
    this.broadcastPresenceUpdate();
  }
  handleUserLeft(data) {
    this.logger.debug('Handling user left event', data);
    this.activeUsers.delete(data.userId);
    this.broadcastPresenceUpdate();
  }
  handleOperationStarted(data) {
    this.logger.debug('Handling operation started event', data);
    if (data.shareProgress) {
      this.startLiveProgressSharing(data.operationId, data.progressConfig);
    }
  }
  handleOperationProgress(data) {
    this.logger.debug('Handling operation progress event', data);
    if (this.liveProgressStreams.has(data.operationId)) {
      this.updateLiveProgress(data.operationId, data.progress);
    }
  }
  handleProgressUpdate(data) {
    this.logger.debug('Handling progress update event', data);
    this.streamProgressUpdate(data);
  }

  // Utility Methods

  broadcastToRoom(roomId, event, data) {
    if (this.collaborationRooms.has(roomId)) {
      const room = this.collaborationRooms.get(roomId);
      room.users.forEach((user, userId) => {
        this.sendToUser(userId, event, data);
      });
    }
  }
  sendToUser(userId, event, data) {
    // Send via real-time communication
    if (this.realtimeCommunication.isConnected) {
      this.realtimeCommunication.socket?.emit('user-message', {
        targetUserId: userId,
        event,
        data
      });
    }
  }
  broadcastPresenceUpdate() {
    const presenceData = {
      activeUsers: Array.from(this.activeUsers.values()),
      timestamp: new Date()
    };
    this.realtimeCommunication.socket?.emit('presence-update', presenceData);
    this.eventBus.emit('presence:updated', presenceData);
  }
  streamProgressUpdate(progressData) {
    this.realtimeCommunication.socket?.emit('progress-stream', progressData);
    this.eventBus.emit('progress-stream:update', progressData);
  }
  broadcastNotification(notification) {
    this.realtimeCommunication.socket?.emit('notification-broadcast', notification);
  }
  generateId() {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  async getSystemMetrics() {
    return {
      memoryUsage: performance.memory ? {
        used: performance.memory.usedJSHeapSize,
        total: performance.memory.totalJSHeapSize,
        limit: performance.memory.jsHeapSizeLimit
      } : null,
      connectionLatency: await this.measureConnectionLatency(),
      timestamp: new Date()
    };
  }
  async getOperationMetrics() {
    return {
      activeOperations: this.liveProgressStreams.size,
      completedOperations: 0,
      // Would be tracked elsewhere
      failedOperations: 0,
      // Would be tracked elsewhere
      averageOperationTime: 0,
      // Would be calculated from history
      timestamp: new Date()
    };
  }
  async getUserActivityMetrics() {
    return {
      activeUsers: this.activeUsers.size,
      totalSessions: this.sessionSubsystem ? await this.sessionSubsystem.getActiveSessionCount() : 0,
      averageSessionDuration: 0,
      // Would be calculated from session data
      timestamp: new Date()
    };
  }
  async measureConnectionLatency() {
    if (!this.realtimeCommunication.isConnected) return null;
    const start = performance.now();
    return new Promise(resolve => {
      this.realtimeCommunication.socket?.emit('ping', start, response => {
        const latency = performance.now() - start;
        resolve(latency);
      });

      // Timeout after 5 seconds
      setTimeout(() => resolve(null), 5000);
    });
  }

  /**
   * Cleanup and disconnect
   */
  async disconnect() {
    this.logger.info('Disconnecting Advanced Real-time Features Subsystem');

    // Clear intervals
    if (this.presenceInterval) clearInterval(this.presenceInterval);
    if (this.progressInterval) clearInterval(this.progressInterval);
    if (this.analyticsInterval) clearInterval(this.analyticsInterval);

    // Clear all data structures
    this.activeUsers.clear();
    this.collaborationRooms.clear();
    this.sharedOperations.clear();
    this.liveProgressStreams.clear();
    this.notificationQueues.clear();
    this.analyticsStreams.clear();
    this.logger.info('Advanced Real-time Features Subsystem disconnected');
  }

  /**
   * Get subsystem status
   */
  getStatus() {
    return {
      isInitialized: true,
      activeUsers: this.activeUsers.size,
      collaborationRooms: this.collaborationRooms.size,
      liveProgressStreams: this.liveProgressStreams.size,
      connectionStatus: this.realtimeCommunication.getConnectionStatus(),
      timestamp: new Date()
    };
  }
}
exports.AdvancedRealtimeSubsystem = AdvancedRealtimeSubsystem;

},{}],79:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnalyticsDashboardSubsystem = void 0;
/**
 * Analytics Dashboard Subsystem
 * 
 * Provides comprehensive analytics and metrics collection including:
 * - Real-time system performance monitoring
 * - Operation analytics and insights
 * - User activity and collaboration metrics
 * - Historical trend analysis
 * - Resource usage tracking
 * - Performance benchmarking
 */

class AnalyticsDashboardSubsystem {
  constructor(logger, eventBus, advancedRealtimeSubsystem, progressSubsystem, sessionSubsystem) {
    this.logger = logger;
    this.eventBus = eventBus;
    this.advancedRealtime = advancedRealtimeSubsystem;
    this.progressSubsystem = progressSubsystem;
    this.sessionSubsystem = sessionSubsystem;

    // Analytics data storage
    this.metrics = {
      system: {
        performance: [],
        resources: [],
        connections: [],
        errors: []
      },
      operations: {
        imports: [],
        exports: [],
        modifications: [],
        deletions: []
      },
      users: {
        sessions: [],
        activity: [],
        collaboration: []
      },
      realtime: {
        connections: [],
        messages: [],
        latency: []
      }
    };

    // Configuration
    this.config = {
      metricsRetention: 24 * 60 * 60 * 1000,
      // 24 hours
      samplingInterval: 5000,
      // 5 seconds
      batchSize: 100,
      maxDataPoints: 1000,
      alertThresholds: {
        memoryUsage: 0.8,
        connectionLatency: 1000,
        errorRate: 0.05,
        operationFailureRate: 0.1
      }
    };

    // State management
    this.isCollecting = false;
    this.collectionInterval = null;
    this.alertsEnabled = true;
    this.dashboardSubscribers = new Set();
    this.logger.info('Analytics Dashboard Subsystem initialized');
  }

  /**
   * Initialize the analytics dashboard subsystem
   */
  async init() {
    try {
      // Set up EventBus listeners for analytics collection
      this.setupEventBusListeners();

      // Initialize metrics collection
      await this.initializeMetricsCollection();

      // Set up periodic data collection
      this.startDataCollection();

      // Initialize alert system
      this.initializeAlertSystem();
      this.logger.info('Analytics Dashboard Subsystem initialized successfully');
      this.eventBus.emit('subsystem:ready', {
        subsystem: 'analytics-dashboard'
      });
    } catch (error) {
      this.logger.error('Failed to initialize Analytics Dashboard Subsystem', error);
      this.eventBus.emit('subsystem:error', {
        subsystem: 'analytics-dashboard',
        error
      });
      throw error;
    }
  }

  /**
   * Set up EventBus listeners for analytics collection
   */
  setupEventBusListeners() {
    this.logger.debug('Setting up EventBus listeners for analytics collection');

    // Operation events
    this.eventBus.on('operation:started', data => this.recordOperationStart(data));
    this.eventBus.on('operation:completed', data => this.recordOperationComplete(data));
    this.eventBus.on('operation:failed', data => this.recordOperationFailure(data));
    this.eventBus.on('operation:progress', data => this.recordOperationProgress(data));

    // System events
    this.eventBus.on('app:global-error', data => this.recordSystemError(data));
    this.eventBus.on('app:page-loaded', data => this.recordSystemPerformance(data));
    this.eventBus.on('subsystem:error', data => this.recordSubsystemError(data));

    // User activity events
    this.eventBus.on('session:user-joined', data => this.recordUserActivity(data));
    this.eventBus.on('session:user-left', data => this.recordUserActivity(data));
    this.eventBus.on('collaboration:user-joined', data => this.recordCollaborationActivity(data));
    this.eventBus.on('collaboration:user-left', data => this.recordCollaborationActivity(data));

    // Real-time events
    this.eventBus.on('progress-stream:update', data => this.recordRealtimeActivity(data));
    this.eventBus.on('notification:sent', data => this.recordRealtimeActivity(data));
    this.logger.debug('EventBus listeners set up for analytics collection');
  }

  /**
   * Initialize metrics collection
   */
  async initializeMetricsCollection() {
    this.logger.debug('Initializing metrics collection');

    // Initialize baseline metrics
    await this.collectSystemMetrics();
    await this.collectOperationMetrics();
    await this.collectUserMetrics();
    await this.collectRealtimeMetrics();
    this.logger.debug('Metrics collection initialized');
  }

  /**
   * Collect system metrics
   */
  async collectSystemMetrics() {
    try {
      const systemMetrics = this.getSystemPerformanceMetrics();
      this.addMetric('system.performance', systemMetrics);
      const resourceMetrics = this.getResourceUsageMetrics();
      this.addMetric('system.resources', resourceMetrics);
      const connectionMetrics = this.getConnectionMetrics();
      this.addMetric('system.connections', connectionMetrics);
      this.logger.debug('System metrics collected');
    } catch (error) {
      this.logger.error('Failed to collect system metrics', error);
    }
  }

  /**
   * Collect operation metrics
   */
  async collectOperationMetrics() {
    try {
      // Get operation counts and performance from other subsystems
      const operationData = {
        timestamp: new Date(),
        totalOperations: this.metrics.operations.imports.length + this.metrics.operations.exports.length + this.metrics.operations.modifications.length + this.metrics.operations.deletions.length,
        successfulOperations: this.getSuccessfulOperationsCount(),
        failedOperations: this.getFailedOperationsCount(),
        averageResponseTime: this.getAverageResponseTime()
      };
      this.addMetric('operations.summary', operationData);
      this.logger.debug('Operation metrics collected');
    } catch (error) {
      this.logger.error('Failed to collect operation metrics', error);
    }
  }

  /**
   * Collect user metrics
   */
  async collectUserMetrics() {
    try {
      const userMetrics = {
        timestamp: new Date(),
        activeSessions: this.sessionSubsystem ? await this.sessionSubsystem.getActiveSessionCount() : 0,
        totalUsers: this.metrics.users.sessions.length,
        collaborativeUsers: this.metrics.users.collaboration.length,
        averageSessionDuration: this.getAverageSessionDuration()
      };
      this.addMetric('users.activity', userMetrics);
      this.logger.debug('User metrics collected');
    } catch (error) {
      this.logger.error('Failed to collect user metrics', error);
    }
  }

  /**
   * Collect realtime metrics
   */
  async collectRealtimeMetrics() {
    try {
      const realtimeMetrics = this.getRealtimeMetrics();
      this.addMetric('realtime.performance', realtimeMetrics);
      this.logger.debug('Realtime metrics collected');
    } catch (error) {
      this.logger.error('Failed to collect realtime metrics', error);
    }
  }

  /**
   * Helper methods for metrics calculation
   */
  getSuccessfulOperationsCount() {
    let count = 0;
    Object.keys(this.metrics.operations).forEach(type => {
      count += this.metrics.operations[type].filter(op => op.status === 'success').length;
    });
    return count;
  }
  getFailedOperationsCount() {
    let count = 0;
    Object.keys(this.metrics.operations).forEach(type => {
      count += this.metrics.operations[type].filter(op => op.status === 'failed').length;
    });
    return count;
  }
  getAverageResponseTime() {
    let totalTime = 0;
    let count = 0;
    Object.keys(this.metrics.operations).forEach(type => {
      this.metrics.operations[type].forEach(op => {
        if (op.responseTime) {
          totalTime += op.responseTime;
          count++;
        }
      });
    });
    return count > 0 ? totalTime / count : 0;
  }
  getAverageSessionDuration() {
    if (this.metrics.users.sessions.length === 0) return 0;
    let totalDuration = 0;
    let count = 0;
    this.metrics.users.sessions.forEach(session => {
      if (session.duration) {
        totalDuration += session.duration;
        count++;
      }
    });
    return count > 0 ? totalDuration / count : 0;
  }
  getRecentAverageLatency() {
    const recentMetrics = this.metrics.realtime.latency.slice(-10); // Last 10 measurements
    if (recentMetrics.length === 0) return null;
    const totalLatency = recentMetrics.reduce((sum, metric) => sum + metric.value, 0);
    return totalLatency / recentMetrics.length;
  }
  getRecentErrorRate() {
    const now = new Date();
    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
    const recentErrors = this.metrics.system.errors.filter(error => new Date(error.timestamp) > oneHourAgo);
    const recentOperations = [];
    Object.keys(this.metrics.operations).forEach(type => {
      recentOperations.push(...this.metrics.operations[type].filter(op => new Date(op.timestamp) > oneHourAgo));
    });
    if (recentOperations.length === 0) return 0;
    return recentErrors.length / recentOperations.length;
  }

  /**
   * Start periodic data collection
   */
  startDataCollection() {
    if (this.isCollecting) return;
    this.isCollecting = true;
    this.collectionInterval = setInterval(async () => {
      try {
        await this.collectPeriodicMetrics();
        this.cleanupOldData();
        this.checkAlertThresholds();
        this.notifyDashboardSubscribers();
      } catch (error) {
        this.logger.error('Error during periodic data collection', error);
      }
    }, this.config.samplingInterval);
    this.logger.info('Started periodic data collection', {
      interval: this.config.samplingInterval
    });
  }

  /**
   * Stop data collection
   */
  stopDataCollection() {
    if (!this.isCollecting) return;
    this.isCollecting = false;
    if (this.collectionInterval) {
      clearInterval(this.collectionInterval);
      this.collectionInterval = null;
    }
    this.logger.info('Stopped periodic data collection');
  }

  /**
   * Collect periodic metrics
   */
  async collectPeriodicMetrics() {
    const timestamp = new Date();
    try {
      // System performance metrics
      const systemMetrics = await this.getSystemPerformanceMetrics();
      this.addMetric('system.performance', {
        timestamp,
        ...systemMetrics
      });
    } catch (error) {
      this.logger.debug('Failed to collect system performance metrics', error);
    }
    try {
      // Resource usage metrics
      const resourceMetrics = await this.getResourceUsageMetrics();
      this.addMetric('system.resources', {
        timestamp,
        ...resourceMetrics
      });
    } catch (error) {
      this.logger.debug('Failed to collect resource usage metrics', error);
    }
    try {
      // Connection metrics
      const connectionMetrics = await this.getConnectionMetrics();
      this.addMetric('system.connections', {
        timestamp,
        ...connectionMetrics
      });
    } catch (error) {
      this.logger.debug('Failed to collect connection metrics', error);
    }
    try {
      // Real-time metrics
      const realtimeMetrics = await this.getRealtimeMetrics();
      this.addMetric('realtime.connections', {
        timestamp,
        ...realtimeMetrics
      });
    } catch (error) {
      this.logger.debug('Failed to collect realtime metrics', error);
    }
  }

  /**
   * Get system performance metrics
   */
  async getSystemPerformanceMetrics() {
    const metrics = {
      timestamp: new Date(),
      memory: null,
      timing: null,
      connection: null
    };

    // Memory usage (if available)
    if (performance.memory) {
      metrics.memory = {
        used: performance.memory.usedJSHeapSize,
        total: performance.memory.totalJSHeapSize,
        limit: performance.memory.jsHeapSizeLimit,
        usage: performance.memory.usedJSHeapSize / performance.memory.totalJSHeapSize
      };
    }

    // Performance timing
    if (performance.timing) {
      const timing = performance.timing;
      metrics.timing = {
        loadTime: timing.loadEventEnd - timing.navigationStart,
        domReady: timing.domContentLoadedEventEnd - timing.navigationStart,
        firstPaint: timing.responseStart - timing.navigationStart
      };
    }

    // Connection latency (if real-time connection exists)
    if (this.advancedRealtime) {
      try {
        metrics.connection = {
          latency: await this.measureConnectionLatency(),
          status: this.advancedRealtime.realtimeCommunication?.getConnectionStatus()
        };
      } catch (error) {
        this.logger.debug('Could not measure connection latency', error);
      }
    }
    return metrics;
  }

  /**
   * Get resource usage metrics
   */
  async getResourceUsageMetrics() {
    return {
      timestamp: new Date(),
      activeSubsystems: this.getActiveSubsystemCount(),
      eventListeners: this.getEventListenerCount(),
      domElements: document.querySelectorAll('*').length,
      localStorageUsage: this.getLocalStorageUsage(),
      sessionStorageUsage: this.getSessionStorageUsage()
    };
  }

  /**
   * Get connection metrics
   */
  async getConnectionMetrics() {
    const connectionStatus = this.advancedRealtime?.realtimeCommunication?.getConnectionStatus() || {};
    return {
      timestamp: new Date(),
      isConnected: connectionStatus.isConnected || false,
      connectionType: connectionStatus.connectionType || 'none',
      reconnectAttempts: connectionStatus.reconnectAttempts || 0,
      activeUsers: this.advancedRealtime?.activeUsers?.size || 0,
      collaborationRooms: this.advancedRealtime?.collaborationRooms?.size || 0
    };
  }

  /**
   * Get real-time metrics
   */
  async getRealtimeMetrics() {
    return {
      timestamp: new Date(),
      liveProgressStreams: this.advancedRealtime?.liveProgressStreams?.size || 0,
      notificationQueues: this.advancedRealtime?.notificationQueues?.size || 0,
      analyticsStreams: this.advancedRealtime?.analyticsStreams?.size || 0,
      messagesSent: this.getRealtimeMessageCount(),
      messagesReceived: this.getRealtimeMessageCount('received')
    };
  }

  /**
   * Record operation start
   */
  recordOperationStart(data) {
    this.addMetric(`operations.${data.type || 'unknown'}`, {
      timestamp: new Date(),
      event: 'started',
      operationId: data.operationId,
      type: data.type,
      userId: data.userId,
      metadata: data.metadata || {}
    });
    this.logger.debug('Recorded operation start', {
      type: data.type,
      operationId: data.operationId
    });
  }

  /**
   * Record operation completion
   */
  recordOperationComplete(data) {
    this.addMetric(`operations.${data.type || 'unknown'}`, {
      timestamp: new Date(),
      event: 'completed',
      operationId: data.operationId,
      type: data.type,
      duration: data.duration,
      recordsProcessed: data.recordsProcessed,
      success: true,
      metadata: data.metadata || {}
    });
    this.logger.debug('Recorded operation completion', {
      type: data.type,
      operationId: data.operationId
    });
  }

  /**
   * Record operation failure
   */
  recordOperationFailure(data) {
    this.addMetric(`operations.${data.type || 'unknown'}`, {
      timestamp: new Date(),
      event: 'failed',
      operationId: data.operationId,
      type: data.type,
      error: data.error,
      duration: data.duration,
      success: false,
      metadata: data.metadata || {}
    });
    this.logger.debug('Recorded operation failure', {
      type: data.type,
      operationId: data.operationId
    });
  }

  /**
   * Record system error
   */
  recordSystemError(data) {
    const errorMetric = {
      timestamp: new Date(),
      type: 'system-error',
      error: data.error || data.message || 'Unknown error',
      stack: data.stack,
      context: data.context || {},
      severity: data.severity || 'error'
    };
    this.addMetric('system.errors', errorMetric);
    this.logger.debug('System error recorded', errorMetric);
  }

  /**
   * Record subsystem error
   */
  recordSubsystemError(data) {
    const errorMetric = {
      timestamp: new Date(),
      type: 'subsystem-error',
      subsystem: data.subsystem || 'unknown',
      error: data.error?.message || data.error || 'Unknown subsystem error',
      stack: data.error?.stack,
      context: data.context || {},
      severity: 'error'
    };
    this.addMetric('system.errors', errorMetric);
    this.logger.debug('Subsystem error recorded', errorMetric);
  }

  /**
   * Record user activity
   */
  recordUserActivity(data) {
    this.addMetric('users.activity', {
      timestamp: new Date(),
      event: data.event || 'activity',
      userId: data.userId,
      sessionId: data.sessionId,
      metadata: data.metadata || {}
    });
    this.logger.debug('Recorded user activity', {
      event: data.event,
      userId: data.userId
    });
  }

  /**
   * Record collaboration activity
   */
  recordCollaborationActivity(data) {
    this.addMetric('users.collaboration', {
      timestamp: new Date(),
      event: data.event || 'collaboration',
      userId: data.userId || data.user?.id,
      roomId: data.roomId,
      userCount: data.totalUsers,
      metadata: data.metadata || {}
    });
    this.logger.debug('Recorded collaboration activity', {
      event: data.event,
      roomId: data.roomId
    });
  }

  /**
   * Record real-time activity
   */
  recordRealtimeActivity(data) {
    this.addMetric('realtime.messages', {
      timestamp: new Date(),
      type: data.type || 'message',
      operationId: data.operationId,
      recipients: data.recipients?.length || 0,
      metadata: data.metadata || {}
    });
    this.logger.debug('Recorded real-time activity', {
      type: data.type
    });
  }

  /**
   * Get analytics dashboard data
   */
  async getAnalyticsDashboardData() {
    let timeRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '1h';
    const endTime = new Date();
    const startTime = new Date(endTime.getTime() - this.parseTimeRange(timeRange));
    try {
      const dashboardData = {
        timestamp: endTime,
        timeRange,
        summary: await this.getSummaryMetrics(startTime, endTime),
        systemMetrics: await this.getSystemMetricsData(startTime, endTime),
        operationMetrics: await this.getOperationMetricsData(startTime, endTime),
        userMetrics: await this.getUserMetricsData(startTime, endTime),
        realtimeMetrics: await this.getRealtimeMetricsData(startTime, endTime),
        alerts: this.getActiveAlerts(),
        trends: await this.getTrendAnalysis(startTime, endTime)
      };
      return dashboardData;
    } catch (error) {
      this.logger.error('Failed to get analytics dashboard data', error);
      throw error;
    }
  }

  /**
   * Get summary metrics
   */
  async getSummaryMetrics(startTime, endTime) {
    return {
      totalOperations: this.countMetricsInRange('operations', startTime, endTime),
      successfulOperations: this.countSuccessfulOperations(startTime, endTime),
      failedOperations: this.countFailedOperations(startTime, endTime),
      activeUsers: this.advancedRealtime?.activeUsers?.size || 0,
      systemErrors: this.countMetricsInRange('system.errors', startTime, endTime),
      averageLatency: this.getAverageLatency(startTime, endTime),
      memoryUsage: this.getCurrentMemoryUsage(),
      connectionStatus: this.advancedRealtime?.realtimeCommunication?.getConnectionStatus()
    };
  }

  /**
   * Get system metrics data for charts
   */
  async getSystemMetricsData(startTime, endTime) {
    const performanceData = this.getMetricsInRange('system.performance', startTime, endTime);
    const resourceData = this.getMetricsInRange('system.resources', startTime, endTime);
    const connectionData = this.getMetricsInRange('system.connections', startTime, endTime);
    return {
      performance: this.formatTimeSeriesData(performanceData, 'memory.usage'),
      resources: this.formatTimeSeriesData(resourceData, 'domElements'),
      connections: this.formatTimeSeriesData(connectionData, 'activeUsers'),
      errors: this.getMetricsInRange('system.errors', startTime, endTime)
    };
  }

  /**
   * Get operation metrics data for charts
   */
  async getOperationMetricsData(startTime, endTime) {
    const imports = this.getMetricsInRange('operations.imports', startTime, endTime);
    const exports = this.getMetricsInRange('operations.exports', startTime, endTime);
    const modifications = this.getMetricsInRange('operations.modifications', startTime, endTime);
    const deletions = this.getMetricsInRange('operations.deletions', startTime, endTime);
    return {
      imports: this.aggregateOperationMetrics(imports),
      exports: this.aggregateOperationMetrics(exports),
      modifications: this.aggregateOperationMetrics(modifications),
      deletions: this.aggregateOperationMetrics(deletions),
      timeline: this.createOperationTimeline(startTime, endTime)
    };
  }

  /**
   * Subscribe to dashboard updates
   */
  subscribeToDashboardUpdates(callback) {
    this.dashboardSubscribers.add(callback);
    return () => this.dashboardSubscribers.delete(callback);
  }

  /**
   * Notify dashboard subscribers
   */
  notifyDashboardSubscribers() {
    if (this.dashboardSubscribers.size > 0) {
      this.getAnalyticsDashboardData().then(data => {
        this.dashboardSubscribers.forEach(callback => {
          try {
            callback(data);
          } catch (error) {
            this.logger.error('Error notifying dashboard subscriber', error);
          }
        });
      });
    }
  }

  // Utility Methods

  addMetric(category, data) {
    const [main, sub] = category.split('.');
    if (!this.metrics[main]) this.metrics[main] = {};
    if (!this.metrics[main][sub]) this.metrics[main][sub] = [];
    this.metrics[main][sub].push(data);

    // Maintain max data points
    if (this.metrics[main][sub].length > this.config.maxDataPoints) {
      this.metrics[main][sub].shift();
    }
  }
  getMetricsInRange(category, startTime, endTime) {
    const [main, sub] = category.split('.');
    const metrics = this.metrics[main]?.[sub] || [];
    return metrics.filter(metric => metric.timestamp >= startTime && metric.timestamp <= endTime);
  }
  countMetricsInRange(category, startTime, endTime) {
    return this.getMetricsInRange(category, startTime, endTime).length;
  }
  parseTimeRange(timeRange) {
    const units = {
      'm': 60 * 1000,
      'h': 60 * 60 * 1000,
      'd': 24 * 60 * 60 * 1000
    };
    const match = timeRange.match(/^(\d+)([mhd])$/);
    if (!match) return 60 * 60 * 1000; // Default 1 hour

    const [, value, unit] = match;
    return parseInt(value) * units[unit];
  }
  cleanupOldData() {
    const cutoffTime = new Date(Date.now() - this.config.metricsRetention);
    Object.keys(this.metrics).forEach(main => {
      Object.keys(this.metrics[main]).forEach(sub => {
        this.metrics[main][sub] = this.metrics[main][sub].filter(metric => metric.timestamp > cutoffTime);
      });
    });
  }
  async measureConnectionLatency() {
    try {
      if (!this.advancedRealtime?.realtimeCommunication?.isConnected) {
        return null;
      }
      if (!this.advancedRealtime.realtimeCommunication.socket) {
        return null;
      }
      const start = performance.now();
      return new Promise(resolve => {
        try {
          this.advancedRealtime.realtimeCommunication.socket.emit('ping', start, () => {
            const latency = performance.now() - start;
            resolve(latency);
          });

          // Timeout after 3 seconds to prevent hanging
          setTimeout(() => resolve(null), 3000);
        } catch (error) {
          this.logger.debug('Error emitting ping for latency measurement', error);
          resolve(null);
        }
      });
    } catch (error) {
      this.logger.debug('Error measuring connection latency', error);
      return null;
    }
  }
  getActiveSubsystemCount() {
    // This would typically come from the main app
    return Object.keys(window.app?.subsystems || {}).length;
  }
  getEventListenerCount() {
    // EventBus doesn't have listenerCount method, return estimated count
    try {
      if (this.eventBus && this.eventBus._events) {
        return Object.keys(this.eventBus._events).length;
      }
      return 0;
    } catch (error) {
      return 0;
    }
  }
  getRealtimeMessageCount() {
    let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'sent';
    // Return message count from advanced realtime subsystem if available
    try {
      if (this.advancedRealtime && this.advancedRealtime.getMessageCount) {
        return this.advancedRealtime.getMessageCount(type);
      }
      // Fallback to estimated count
      return this.advancedRealtime?.messageCount || 0;
    } catch (error) {
      return 0;
    }
  }
  getLocalStorageUsage() {
    try {
      let total = 0;
      for (let key in localStorage) {
        if (localStorage.hasOwnProperty(key)) {
          total += localStorage[key].length + key.length;
        }
      }
      return total;
    } catch (error) {
      return 0;
    }
  }
  getSessionStorageUsage() {
    try {
      let total = 0;
      for (let key in sessionStorage) {
        if (sessionStorage.hasOwnProperty(key)) {
          total += sessionStorage[key].length + key.length;
        }
      }
      return total;
    } catch (error) {
      return 0;
    }
  }

  /**
   * Initialize alert system
   */
  initializeAlertSystem() {
    this.alerts = [];
    this.logger.debug('Alert system initialized');
  }

  /**
   * Check alert thresholds
   */
  checkAlertThresholds() {
    if (!this.alertsEnabled) return;

    // Memory usage alert
    if (performance.memory) {
      const memoryUsage = performance.memory.usedJSHeapSize / performance.memory.totalJSHeapSize;
      if (memoryUsage > this.config.alertThresholds.memoryUsage) {
        this.createAlert('high-memory-usage', `Memory usage is ${(memoryUsage * 100).toFixed(1)}%`, 'warning');
      }
    }

    // Connection latency alert
    const recentLatency = this.getRecentAverageLatency();
    if (recentLatency && recentLatency > this.config.alertThresholds.connectionLatency) {
      this.createAlert('high-latency', `Connection latency is ${recentLatency.toFixed(0)}ms`, 'warning');
    }

    // Error rate alert
    const errorRate = this.getRecentErrorRate();
    if (errorRate > this.config.alertThresholds.errorRate) {
      this.createAlert('high-error-rate', `Error rate is ${(errorRate * 100).toFixed(1)}%`, 'error');
    }
  }
  createAlert(id, message, severity) {
    const alert = {
      id,
      message,
      severity,
      timestamp: new Date(),
      acknowledged: false
    };

    // Avoid duplicate alerts
    if (!this.alerts.find(a => a.id === id && !a.acknowledged)) {
      this.alerts.push(alert);
      this.eventBus.emit('analytics:alert-created', alert);
      this.logger.warn('Analytics alert created', alert);
    }
  }
  getActiveAlerts() {
    return this.alerts.filter(alert => !alert.acknowledged);
  }

  /**
   * Cleanup and disconnect
   */
  async disconnect() {
    this.logger.info('Disconnecting Analytics Dashboard Subsystem');
    this.stopDataCollection();
    this.dashboardSubscribers.clear();

    // Clear metrics data
    Object.keys(this.metrics).forEach(main => {
      Object.keys(this.metrics[main]).forEach(sub => {
        this.metrics[main][sub] = [];
      });
    });
    this.logger.info('Analytics Dashboard Subsystem disconnected');
  }

  /**
   * Get subsystem status
   */
  getStatus() {
    return {
      isInitialized: true,
      isCollecting: this.isCollecting,
      metricsCount: this.getTotalMetricsCount(),
      alertsCount: this.getActiveAlerts().length,
      subscribersCount: this.dashboardSubscribers.size,
      timestamp: new Date()
    };
  }
  getTotalMetricsCount() {
    let total = 0;
    Object.keys(this.metrics).forEach(main => {
      Object.keys(this.metrics[main]).forEach(sub => {
        total += this.metrics[main][sub].length;
      });
    });
    return total;
  }
}
exports.AnalyticsDashboardSubsystem = AnalyticsDashboardSubsystem;

},{}],80:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AuthManagementSubsystem = void 0;
/**
 * Authentication Management Subsystem
 * 
 * Handles all authentication-related operations including token management,
 * credential validation, and authentication state tracking.
 */

class AuthManagementSubsystem {
  constructor(logger, uiManager, localClient, settingsSubsystem) {
    this.logger = logger;
    this.uiManager = uiManager;
    this.localClient = localClient;
    this.settingsSubsystem = settingsSubsystem;

    // Authentication state
    this.isAuthenticated = false;
    this.tokenStatus = null;
    this.tokenExpiry = null;
    this.refreshTimer = null;
    this.logger.info('Authentication Management Subsystem initialized');
  }

  /**
   * Initialize the authentication subsystem
   */
  async init() {
    try {
      this.setupEventListeners();
      await this.checkInitialTokenStatus();
      this.setupTokenRefreshTimer();
      this.logger.info('Authentication Management Subsystem initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize Authentication Management Subsystem', error);
      throw error;
    }
  }

  /**
   * Set up event listeners for authentication-related elements
   */
  setupEventListeners() {
    // Get token button
    const getTokenBtn = document.getElementById('get-token-btn');
    if (getTokenBtn) {
      getTokenBtn.addEventListener('click', async e => {
        e.preventDefault();
        await this.getToken();
      });
    }

    // Test connection button
    const testConnectionBtn = document.getElementById('test-connection-btn');
    if (testConnectionBtn) {
      testConnectionBtn.addEventListener('click', async e => {
        e.preventDefault();
        await this.testConnection();
      });
    }

    // Global token refresh button
    const globalRefreshBtn = document.getElementById('global-refresh-token');
    if (globalRefreshBtn) {
      globalRefreshBtn.addEventListener('click', async e => {
        e.preventDefault();
        await this.refreshToken();
      });
    }

    // Settings form submission
    const settingsForm = document.getElementById('settings-form');
    if (settingsForm) {
      settingsForm.addEventListener('submit', async e => {
        e.preventDefault();
        await this.handleSettingsSubmit(e);
      });
    }
  }

  /**
   * Get a new authentication token
   */
  async getToken() {
    try {
      this.logger.info('Getting new authentication token');
      this.showTokenProgress('Getting token...');

      // Validate settings first
      await this.settingsSubsystem.loadCurrentSettings();
      const settings = this.settingsSubsystem.currentSettings;
      if (!this.validateSettings(settings)) {
        throw new Error('Invalid settings - please check your configuration');
      }

      // Request token from server
      const response = await this.localClient.post('/api/v1/auth/token', {
        clientId: settings.clientId,
        clientSecret: settings.clientSecret,
        environmentId: settings.environmentId,
        region: settings.region
      });
      if (!response.success) {
        throw new Error(response.error || 'Failed to get token');
      }

      // Update token status
      this.tokenStatus = response.token;
      this.tokenExpiry = response.expiry;
      this.isAuthenticated = true;

      // Update UI
      this.updateTokenStatusUI(true, 'Token obtained successfully');
      this.uiManager.showSuccess('Authentication successful');

      // Set up refresh timer
      this.setupTokenRefreshTimer();
      this.logger.info('Token obtained successfully');
    } catch (error) {
      this.logger.error('Failed to get token', error);
      this.updateTokenStatusUI(false, error.message);
      this.uiManager.showError('Authentication Failed', error.message);
    } finally {
      this.hideTokenProgress();
    }
  }

  /**
   * Test connection with current settings
   */
  async testConnection() {
    try {
      this.logger.info('Testing connection');
      this.showConnectionProgress('Testing connection...');

      // Get current settings
      await this.settingsSubsystem.loadCurrentSettings();
      const settings = this.settingsSubsystem.currentSettings;
      if (!this.validateSettings(settings)) {
        throw new Error('Invalid settings - please check your configuration');
      }

      // Test connection
      const response = await this.localClient.post('/api/test-connection', settings);
      if (!response.success) {
        throw new Error(response.error || 'Connection test failed');
      }

      // Update UI
      this.updateConnectionStatusUI(true, 'Connection successful');
      this.uiManager.showSuccess('Connection test successful');
      this.logger.info('Connection test successful');
    } catch (error) {
      this.logger.error('Connection test failed', error);
      this.updateConnectionStatusUI(false, error.message);
      this.uiManager.showError('Connection Test Failed', error.message);
    } finally {
      this.hideConnectionProgress();
    }
  }

  /**
   * Refresh the current token
   */
  async refreshToken() {
    try {
      this.logger.info('Refreshing authentication token');
      this.showTokenProgress('Refreshing token...');
      const response = await this.localClient.post('/api/v1/auth/refresh');
      if (!response.success) {
        throw new Error(response.error || 'Failed to refresh token');
      }

      // Update token status
      this.tokenStatus = response.token;
      this.tokenExpiry = response.expiry;
      this.isAuthenticated = true;

      // Update UI
      this.updateTokenStatusUI(true, 'Token refreshed successfully');
      this.uiManager.showSuccess('Token refreshed successfully');

      // Reset refresh timer
      this.setupTokenRefreshTimer();
      this.logger.info('Token refreshed successfully');
    } catch (error) {
      this.logger.error('Failed to refresh token', error);
      this.updateTokenStatusUI(false, error.message);
      this.uiManager.showError('Token Refresh Failed', error.message);

      // Clear authentication state
      this.clearAuthenticationState();
    } finally {
      this.hideTokenProgress();
    }
  }

  /**
   * Handle settings form submission
   */
  async handleSettingsSubmit(event) {
    try {
      const formData = new FormData(event.target);
      const settings = Object.fromEntries(formData.entries());
      this.logger.info('Saving settings');

      // Validate settings
      if (!this.validateSettings(settings)) {
        throw new Error('Invalid settings - please check all required fields');
      }

      // Save settings
      await this.settingsManager.saveSettings(settings);

      // Clear current authentication state since settings changed
      this.clearAuthenticationState();

      // Update UI
      this.uiManager.updateSettingsSaveStatus('Settings saved successfully', 'success');
      this.logger.info('Settings saved successfully');
    } catch (error) {
      this.logger.error('Failed to save settings', error);
      this.uiManager.updateSettingsSaveStatus(`Settings Save Failed: ${error.message}`, 'error');
    }
  }

  /**
   * Check initial token status
   */
  async checkInitialTokenStatus() {
    try {
      const response = await this.localClient.get('/api/v1/auth/status');
      if (response.success && response.isValid) {
        this.tokenStatus = response.status;
        this.tokenExpiry = response.expiresIn;
        this.isAuthenticated = true;
        this.updateTokenStatusUI(true, `Token is ${response.status}`);
      } else if (response.success && response.hasToken) {
        // Token exists but is expired
        this.tokenStatus = response.status;
        this.tokenExpiry = response.expiresIn;
        this.isAuthenticated = false;
        this.updateTokenStatusUI(false, `Token is ${response.status}`);
      } else {
        // No token available
        this.isAuthenticated = false;
        this.updateTokenStatusUI(false, response.status || 'No valid token');
      }
    } catch (error) {
      this.logger.error('Failed to check token status', error);
      this.isAuthenticated = false;
      this.updateTokenStatusUI(false, 'Token status unknown');
    }
  }

  /**
   * Set up automatic token refresh timer
   */
  setupTokenRefreshTimer() {
    // Clear existing timer
    if (this.refreshTimer) {
      clearTimeout(this.refreshTimer);
    }
    if (!this.tokenExpiry) {
      return;
    }

    // Calculate refresh time (5 minutes before expiry)
    const expiryTime = new Date(this.tokenExpiry).getTime();
    const refreshTime = expiryTime - 5 * 60 * 1000; // 5 minutes before
    const now = Date.now();
    if (refreshTime > now) {
      const delay = refreshTime - now;
      this.refreshTimer = setTimeout(() => {
        this.refreshToken();
      }, delay);
      this.logger.info('Token refresh timer set', {
        refreshIn: Math.round(delay / 1000 / 60),
        unit: 'minutes'
      });
    }
  }

  /**
   * Validate settings object
   */
  validateSettings(settings) {
    const required = ['clientId', 'clientSecret', 'environmentId', 'region'];
    for (const field of required) {
      if (!settings[field] || settings[field].trim() === '') {
        this.logger.error('Missing required setting', {
          field
        });
        return false;
      }
    }
    return true;
  }

  /**
   * Clear authentication state
   */
  clearAuthenticationState() {
    this.isAuthenticated = false;
    this.tokenStatus = null;
    this.tokenExpiry = null;
    if (this.refreshTimer) {
      clearTimeout(this.refreshTimer);
      this.refreshTimer = null;
    }
    this.updateTokenStatusUI(false, 'Authentication cleared');
  }

  /**
   * Update token status UI
   */
  updateTokenStatusUI(isValid, message) {
    // Update global token status
    const globalTokenStatus = document.getElementById('global-token-status');
    if (globalTokenStatus) {
      globalTokenStatus.className = `token-status ${isValid ? 'valid' : 'invalid'}`;
      globalTokenStatus.textContent = message;
    }

    // Update token indicator
    const tokenIndicator = document.getElementById('token-status-indicator');
    if (tokenIndicator) {
      tokenIndicator.className = `token-indicator ${isValid ? 'valid' : 'invalid'}`;
    }

    // Update get token button visibility
    const getTokenBtn = document.getElementById('get-token-btn');
    if (getTokenBtn) {
      getTokenBtn.style.display = isValid ? 'none' : 'inline-block';
    }

    // Update refresh token button visibility
    const refreshTokenBtn = document.getElementById('global-refresh-token');
    if (refreshTokenBtn) {
      refreshTokenBtn.style.display = isValid ? 'inline-block' : 'none';
    }
  }

  /**
   * Update connection status UI
   */
  updateConnectionStatusUI(isConnected, message) {
    const connectionStatus = document.getElementById('connection-status');
    if (connectionStatus) {
      connectionStatus.className = `connection-status ${isConnected ? 'connected' : 'disconnected'}`;
      connectionStatus.textContent = message;
    }
  }

  /**
   * Show token progress
   */
  showTokenProgress(message) {
    const getTokenBtn = document.getElementById('get-token-btn');
    if (getTokenBtn) {
      getTokenBtn.disabled = true;
      getTokenBtn.textContent = message;
    }
  }

  /**
   * Hide token progress
   */
  hideTokenProgress() {
    const getTokenBtn = document.getElementById('get-token-btn');
    if (getTokenBtn) {
      getTokenBtn.disabled = false;
      getTokenBtn.textContent = 'Get Token';
    }
  }

  /**
   * Show connection progress
   */
  showConnectionProgress(message) {
    const testConnectionBtn = document.getElementById('test-connection-btn');
    if (testConnectionBtn) {
      testConnectionBtn.disabled = true;
      testConnectionBtn.textContent = message;
    }
  }

  /**
   * Hide connection progress
   */
  hideConnectionProgress() {
    const testConnectionBtn = document.getElementById('test-connection-btn');
    if (testConnectionBtn) {
      testConnectionBtn.disabled = false;
      testConnectionBtn.textContent = 'Test Connection';
    }
  }

  /**
   * Get current authentication status
   */
  getAuthenticationStatus() {
    return {
      isAuthenticated: this.isAuthenticated,
      tokenStatus: this.tokenStatus,
      tokenExpiry: this.tokenExpiry,
      timeUntilExpiry: this.tokenExpiry ? Math.max(0, new Date(this.tokenExpiry).getTime() - Date.now()) : 0
    };
  }

  /**
   * Check if token is valid and not expired
   */
  isTokenValid() {
    if (!this.isAuthenticated || !this.tokenExpiry) {
      return false;
    }
    const now = Date.now();
    const expiry = new Date(this.tokenExpiry).getTime();
    return expiry > now;
  }
}
exports.AuthManagementSubsystem = AuthManagementSubsystem;

},{}],81:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConnectionManagerSubsystem = void 0;
var _browserLoggingService = require("../utils/browser-logging-service.js");
/**
 * Connection Manager Subsystem
 * 
 * Manages all PingOne connection functionality including token acquisition,
 * validation, connection testing, and credential management.
 * 
 * Features:
 * - Token acquisition and validation
 * - Connection testing and health checks
 * - Credential validation and storage
 * - Connection status monitoring
 * - Automatic token refresh
 * - Connection retry logic
 */

class ConnectionManagerSubsystem {
  constructor(logger, uiManager, settingsManager, apiClient) {
    this.logger = logger || (0, _browserLoggingService.createLogger)({
      serviceName: 'connection-manager-subsystem',
      environment: 'development'
    });
    this.uiManager = uiManager;
    this.settingsManager = settingsManager;
    this.apiClient = apiClient;

    // Connection state
    this.connectionStatus = 'disconnected';
    this.lastConnectionTest = null;
    this.tokenInfo = {
      token: null,
      expiresAt: null,
      isValid: false
    };

    // Connection monitoring
    this.healthCheckInterval = null;
    this.tokenRefreshInterval = null;
    this.connectionRetryCount = 0;
    this.maxRetryAttempts = 3;

    // Event listeners
    this.eventListeners = new Map();
    this.logger.info('Connection Manager subsystem initialized');
  }

  /**
   * Initialize the connection manager subsystem
   */
  async init() {
    try {
      this.logger.info('Initializing connection manager subsystem...');

      // Load existing token if available
      await this.loadExistingToken();

      // Start connection monitoring
      this.startConnectionMonitoring();

      // Set up automatic token refresh
      this.setupTokenRefresh();
      this.logger.info('Connection Manager subsystem initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize connection manager subsystem', {
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Test connection to PingOne
   * @param {Object} credentials - Optional credentials to test
   * @returns {Promise<Object>} - Connection test result
   */
  async testConnection() {
    let credentials = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    try {
      this.logger.info('Testing PingOne connection...');

      // Update UI to show testing state
      if (this.uiManager) {
        this.uiManager.updateConnectionStatus('testing', 'Testing connection...');
      }

      // Use provided credentials or get from settings
      const testCredentials = credentials || (await this.getCredentials());
      if (!testCredentials) {
        throw new Error('No credentials available for connection test');
      }

      // Validate credentials format
      this.validateCredentials(testCredentials);

      // Test connection by getting a token
      const tokenResult = await this.acquireToken(testCredentials);
      if (tokenResult.success) {
        this.connectionStatus = 'connected';
        this.lastConnectionTest = {
          timestamp: Date.now(),
          success: true,
          credentials: {
            clientId: testCredentials.clientId,
            environmentId: testCredentials.environmentId,
            region: testCredentials.region
          }
        };

        // Update UI
        if (this.uiManager) {
          this.uiManager.updateConnectionStatus('success', 'Connection successful');
        }
        this.logger.info('Connection test successful');

        // Emit connection success event
        this.emit('connectionSuccess', this.lastConnectionTest);
        return {
          success: true,
          message: 'Connection successful',
          token: tokenResult.token,
          expiresIn: tokenResult.expiresIn
        };
      } else {
        throw new Error(tokenResult.error || 'Failed to acquire token');
      }
    } catch (error) {
      this.logger.error('Connection test failed', {
        error: error.message
      });
      this.connectionStatus = 'disconnected';
      this.lastConnectionTest = {
        timestamp: Date.now(),
        success: false,
        error: error.message
      };

      // Update UI
      if (this.uiManager) {
        this.uiManager.updateConnectionStatus('error', `Connection failed: ${error.message}`);
      }

      // Emit connection failure event
      this.emit('connectionFailure', {
        error: error.message
      });
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Acquire a new token from PingOne
   * @param {Object} credentials - PingOne credentials
   * @returns {Promise<Object>} - Token acquisition result
   */
  async acquireToken() {
    let credentials = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    try {
      this.logger.info('Acquiring PingOne token...');

      // Use provided credentials or get from settings
      const tokenCredentials = credentials || (await this.getCredentials());
      if (!tokenCredentials) {
        throw new Error('No credentials available for token acquisition');
      }

      // Validate credentials
      this.validateCredentials(tokenCredentials);

      // Make token request
      const response = await this.apiClient.post('/api/auth/token', {
        clientId: tokenCredentials.clientId,
        clientSecret: tokenCredentials.clientSecret,
        environmentId: tokenCredentials.environmentId,
        region: tokenCredentials.region
      });
      if (response.success && response.token) {
        // Store token info
        this.tokenInfo = {
          token: response.token,
          expiresAt: Date.now() + response.expiresIn * 1000,
          isValid: true,
          acquiredAt: Date.now()
        };

        // Update connection status
        this.connectionStatus = 'connected';

        // Update UI
        if (this.uiManager) {
          this.uiManager.updateTokenStatus(true, 'Token acquired successfully');
        }
        this.logger.info('Token acquired successfully', {
          expiresIn: response.expiresIn
        });

        // Emit token acquired event
        this.emit('tokenAcquired', {
          token: response.token,
          expiresIn: response.expiresIn
        });
        return {
          success: true,
          token: response.token,
          expiresIn: response.expiresIn
        };
      } else {
        throw new Error(response.error || 'Failed to acquire token');
      }
    } catch (error) {
      this.logger.error('Token acquisition failed', {
        error: error.message
      });

      // Clear token info
      this.tokenInfo = {
        token: null,
        expiresAt: null,
        isValid: false
      };

      // Update connection status
      this.connectionStatus = 'disconnected';

      // Update UI
      if (this.uiManager) {
        this.uiManager.updateTokenStatus(false, `Token acquisition failed: ${error.message}`);
      }

      // Emit token acquisition failure event
      this.emit('tokenAcquisitionFailure', {
        error: error.message
      });
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Validate current token
   * @returns {Promise<boolean>} - Whether token is valid
   */
  async validateToken() {
    try {
      if (!this.tokenInfo.token) {
        this.logger.debug('No token to validate');
        return false;
      }

      // Check if token is expired
      if (this.tokenInfo.expiresAt && Date.now() >= this.tokenInfo.expiresAt) {
        this.logger.info('Token has expired');
        this.tokenInfo.isValid = false;
        return false;
      }

      // Test token with a simple API call
      const response = await this.apiClient.get('/api/auth/validate', {
        headers: {
          'Authorization': `Bearer ${this.tokenInfo.token}`
        }
      });
      const isValid = response.success;
      this.tokenInfo.isValid = isValid;
      if (isValid) {
        this.logger.debug('Token validation successful');
        this.connectionStatus = 'connected';
      } else {
        this.logger.info('Token validation failed');
        this.connectionStatus = 'disconnected';
      }
      return isValid;
    } catch (error) {
      this.logger.error('Token validation error', {
        error: error.message
      });
      this.tokenInfo.isValid = false;
      this.connectionStatus = 'disconnected';
      return false;
    }
  }

  /**
   * Refresh current token
   * @returns {Promise<Object>} - Token refresh result
   */
  async refreshToken() {
    try {
      this.logger.info('Refreshing token...');

      // Get current credentials
      const credentials = await this.getCredentials();
      if (!credentials) {
        throw new Error('No credentials available for token refresh');
      }

      // Acquire new token
      const result = await this.acquireToken(credentials);
      if (result.success) {
        this.logger.info('Token refreshed successfully');

        // Emit token refreshed event
        this.emit('tokenRefreshed', {
          token: result.token,
          expiresIn: result.expiresIn
        });
      }
      return result;
    } catch (error) {
      this.logger.error('Token refresh failed', {
        error: error.message
      });

      // Emit token refresh failure event
      this.emit('tokenRefreshFailure', {
        error: error.message
      });
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Get current credentials
   * @returns {Promise<Object|null>} - Current credentials
   */
  async getCredentials() {
    try {
      // Try to get from credentials manager first
      if (window.credentialsManager) {
        const credentials = window.credentialsManager.getCredentials();
        if (credentials && this.isValidCredentialSet(credentials)) {
          return credentials;
        }
      }

      // Fallback to settings manager
      if (this.settingsManager) {
        await this.settingsManager.loadCurrentSettings();
        const settings = this.settingsManager.currentSettings;
        if (settings && this.isValidCredentialSet(settings)) {
          return {
            clientId: settings.clientId,
            clientSecret: settings.clientSecret,
            environmentId: settings.environmentId,
            region: settings.region
          };
        }
      }
      return null;
    } catch (error) {
      this.logger.error('Failed to get credentials', {
        error: error.message
      });
      return null;
    }
  }

  /**
   * Validate credentials format
   * @param {Object} credentials - Credentials to validate
   */
  validateCredentials(credentials) {
    const required = ['clientId', 'clientSecret', 'environmentId'];
    const missing = required.filter(field => !credentials[field]);
    if (missing.length > 0) {
      throw new Error(`Missing required credentials: ${missing.join(', ')}`);
    }

    // Validate format
    if (!/^[a-f0-9-]{36}$/.test(credentials.clientId)) {
      throw new Error('Invalid client ID format');
    }
    if (!/^[a-f0-9-]{36}$/.test(credentials.environmentId)) {
      throw new Error('Invalid environment ID format');
    }
    if (credentials.clientSecret.length < 10) {
      throw new Error('Client secret appears to be invalid');
    }
  }

  /**
   * Check if credential set is valid
   * @param {Object} credentials - Credentials to check
   * @returns {boolean} - Whether credentials are valid
   */
  isValidCredentialSet(credentials) {
    try {
      this.validateCredentials(credentials);
      return true;
    } catch (error) {
      return false;
    }
  }

  /**
   * Load existing token from storage
   */
  async loadExistingToken() {
    try {
      // Try to load from token manager
      if (window.globalTokenManager && typeof window.globalTokenManager.getCachedToken === 'function') {
        const cachedToken = window.globalTokenManager.getCachedToken();
        if (cachedToken) {
          this.tokenInfo = {
            token: cachedToken.token,
            expiresAt: cachedToken.expiresAt,
            isValid: cachedToken.isValid,
            acquiredAt: cachedToken.acquiredAt
          };

          // Validate the loaded token
          const isValid = await this.validateToken();
          if (isValid) {
            this.connectionStatus = 'connected';
            this.logger.info('Existing token loaded and validated');
          } else {
            this.logger.info('Existing token loaded but invalid');
          }
        }
      }
    } catch (error) {
      this.logger.error('Failed to load existing token', {
        error: error.message
      });
    }
  }

  /**
   * Start connection monitoring
   */
  startConnectionMonitoring() {
    // Health check every 5 minutes
    this.healthCheckInterval = setInterval(async () => {
      if (this.connectionStatus === 'connected') {
        const isValid = await this.validateToken();
        if (!isValid) {
          this.logger.info('Connection lost during health check');
          this.emit('connectionLost');
        }
      }
    }, 5 * 60 * 1000);
    this.logger.debug('Connection monitoring started');
  }

  /**
   * Setup automatic token refresh
   */
  setupTokenRefresh() {
    // Check token expiry every minute
    this.tokenRefreshInterval = setInterval(async () => {
      if (this.tokenInfo.token && this.tokenInfo.expiresAt) {
        const timeUntilExpiry = this.tokenInfo.expiresAt - Date.now();
        const refreshThreshold = 5 * 60 * 1000; // 5 minutes

        if (timeUntilExpiry <= refreshThreshold && timeUntilExpiry > 0) {
          this.logger.info('Token expiring soon, attempting refresh...');
          await this.refreshToken();
        }
      }
    }, 60 * 1000);
    this.logger.debug('Automatic token refresh setup');
  }

  /**
   * Get connection status
   * @returns {string} - Current connection status
   */
  getConnectionStatus() {
    return this.connectionStatus;
  }

  /**
   * Get token info
   * @returns {Object} - Current token information
   */
  getTokenInfo() {
    return {
      hasToken: !!this.tokenInfo.token,
      isValid: this.tokenInfo.isValid,
      expiresAt: this.tokenInfo.expiresAt,
      timeUntilExpiry: this.tokenInfo.expiresAt ? this.tokenInfo.expiresAt - Date.now() : null
    };
  }

  /**
   * Get last connection test result
   * @returns {Object|null} - Last connection test result
   */
  getLastConnectionTest() {
    return this.lastConnectionTest;
  }

  /**
   * Check if currently connected
   * @returns {boolean} - Whether currently connected
   */
  isConnected() {
    return this.connectionStatus === 'connected' && this.tokenInfo.isValid;
  }

  /**
   * Check if token is valid and not expired
   * @returns {boolean} - Whether token is valid
   */
  hasValidToken() {
    return this.tokenInfo.isValid && this.tokenInfo.token && this.tokenInfo.expiresAt && Date.now() < this.tokenInfo.expiresAt;
  }

  /**
   * Disconnect and clear token
   */
  disconnect() {
    this.logger.info('Disconnecting...');

    // Clear token info
    this.tokenInfo = {
      token: null,
      expiresAt: null,
      isValid: false
    };

    // Update connection status
    this.connectionStatus = 'disconnected';

    // Update UI
    if (this.uiManager) {
      this.uiManager.updateConnectionStatus('disconnected', 'Disconnected');
      this.uiManager.updateTokenStatus(false, 'No token');
    }

    // Emit disconnected event
    this.emit('disconnected');
    this.logger.info('Disconnected successfully');
  }

  /**
   * Add event listener
   * @param {string} event - Event name
   * @param {Function} listener - Event listener function
   */
  on(event, listener) {
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, []);
    }
    this.eventListeners.get(event).push(listener);
  }

  /**
   * Remove event listener
   * @param {string} event - Event name
   * @param {Function} listener - Event listener function
   */
  off(event, listener) {
    if (this.eventListeners.has(event)) {
      const listeners = this.eventListeners.get(event);
      const index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    }
  }

  /**
   * Emit event
   * @param {string} event - Event name
   * @param {*} data - Event data
   */
  emit(event) {
    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (this.eventListeners.has(event)) {
      this.eventListeners.get(event).forEach(listener => {
        try {
          listener(data);
        } catch (error) {
          this.logger.error('Event listener error', {
            event,
            error: error.message
          });
        }
      });
    }
  }

  /**
   * Get connection statistics
   * @returns {Object} - Connection statistics
   */
  getConnectionStats() {
    return {
      status: this.connectionStatus,
      hasToken: !!this.tokenInfo.token,
      tokenValid: this.tokenInfo.isValid,
      tokenExpiresAt: this.tokenInfo.expiresAt,
      lastConnectionTest: this.lastConnectionTest,
      retryCount: this.connectionRetryCount
    };
  }

  /**
   * Clean up the connection manager subsystem
   */
  cleanup() {
    // Clear intervals
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
      this.healthCheckInterval = null;
    }
    if (this.tokenRefreshInterval) {
      clearInterval(this.tokenRefreshInterval);
      this.tokenRefreshInterval = null;
    }

    // Clear event listeners
    this.eventListeners.clear();

    // Disconnect
    this.disconnect();
    this.logger.info('Connection Manager subsystem cleaned up');
  }
}
exports.ConnectionManagerSubsystem = ConnectionManagerSubsystem;

},{"../utils/browser-logging-service.js":90}],82:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExportSubsystem = void 0;
/**
 * Export Management Subsystem
 * 
 * Handles all user export operations with proper separation of concerns.
 * Manages export configuration, progress tracking, and file generation.
 */

class ExportSubsystem {
  constructor(logger, uiManager, localClient, settingsManager, eventBus, populationService) {
    this.logger = logger;
    this.uiManager = uiManager;
    this.localClient = localClient;
    this.settingsManager = settingsManager;
    this.eventBus = eventBus;
    this.populationService = populationService;

    // Export state management
    this.isExporting = false;
    this.selectedPopulationId = null;
    this.selectedPopulationName = null;
    this.logger.info('Export Subsystem initialized');

    // Set up event listeners for cross-subsystem communication
    this.setupCrossSubsystemEvents();
  }

  /**
   * Initialize the export subsystem
   */
  async init() {
    try {
      this.setupEventListeners();
      await this.loadPopulations();
      this.logger.info('Export Subsystem initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize Export Subsystem', error);
      // TODO: Refactor: Use Notification or Modal from UI subsystem instead of alert.
      this.uiManager.showError('Failed to Initialize Export Subsystem', error.message);
    }
  }

  /**
   * Set up event listeners for export-related elements
   */
  setupEventListeners() {
    // Export button
    const exportBtn = document.getElementById('export-btn');
    if (exportBtn) {
      exportBtn.addEventListener('click', async e => {
        e.preventDefault();
        await this.startExport();
      });
    }

    // Population selection change
    const populationSelect = document.getElementById('export-population-select');
    if (populationSelect) {
      populationSelect.addEventListener('change', e => {
        this.handlePopulationChange(e.target.value);
      });
    }

    // Export format selection
    const formatSelect = document.getElementById('export-format');
    if (formatSelect) {
      formatSelect.addEventListener('change', e => {
        this.handleFormatChange(e.target.value);
      });
    }
  }

  /**
   * Start the export process
   */
  async startExport() {
    if (this.isExporting) {
      this.logger.warn('Export already in progress');
      return;
    }
    try {
      this.isExporting = true;
      this.logger.info('Starting export process');

      // Validate prerequisites
      if (!(await this.validateExportPrerequisites())) {
        return;
      }

      // Get export configuration
      const config = this.getExportConfiguration();

      // Show progress UI
      this.uiManager.showProgress('Exporting...');

      // Execute export
      await this.executeExport(config);
    } catch (error) {
      this.logger.error('Export process failed', error);
      // TODO: Refactor: Use Notification or Modal from UI subsystem instead of alert.
      this.uiManager.showError('Export Failed', error.message);
    } finally {
      this.isExporting = false;
      this.uiManager.hideProgress();
    }
  }

  /**
   * Validate export prerequisites
   */
  async validateExportPrerequisites() {
    // Check for valid token
    const hasValidToken = await this.checkTokenStatus();
    if (!hasValidToken) {
      this.logger.warn('Export cancelled - no valid token');
      // TODO: Refactor: Use Notification or Modal from UI subsystem instead of alert.
      this.uiManager.showError('Authentication Required', 'Please get a valid token first');
      return false;
    }

    // Check population selection
    const populationSelect = document.getElementById('export-population-select');
    if (!populationSelect || !populationSelect.value) {
      // TODO: Refactor: Use Notification or Modal from UI subsystem instead of alert.
      this.uiManager.showError('No Population Selected', 'Please select a population to export');
      return false;
    }
    return true;
  }

  /**
   * Get export configuration from form
   */
  getExportConfiguration() {
    const populationSelect = document.getElementById('export-population-select');
    const formatSelect = document.getElementById('export-format');
    const includeHeaders = document.getElementById('include-headers');
    const limitUsers = document.getElementById('limit-users');
    const userLimit = document.getElementById('user-limit');
    return {
      populationId: populationSelect?.value || '',
      populationName: populationSelect?.options[populationSelect.selectedIndex]?.text || '',
      format: formatSelect?.value || 'csv',
      includeHeaders: includeHeaders?.checked || true,
      limitUsers: limitUsers?.checked || false,
      userLimit: limitUsers?.checked ? parseInt(userLimit?.value) || 100 : null,
      timestamp: new Date().toISOString()
    };
  }

  /**
   * Execute the export process
   */
  async executeExport(config) {
    try {
      this.logger.info('Executing export with config', config);

      // Send export request
      const response = await this.localClient.post('/api/export', config);
      if (!response.success) {
        throw new Error(response.error || 'Export failed');
      }

      // Handle file download
      if (response.downloadUrl) {
        this.downloadFile(response.downloadUrl, response.filename);
      } else if (response.data) {
        this.downloadData(response.data, config.format, config.populationName);
      }
      this.logger.info('Export completed successfully');
      // TODO: Refactor: Use Notification or Modal from UI subsystem instead of alert.
      this.uiManager.showSuccess('Export completed successfully');
    } catch (error) {
      this.logger.error('Export execution failed', error);
      throw error;
    }
  }

  /**
   * Download file from URL
   */
  downloadFile(url, filename) {
    const link = document.createElement('a');
    link.href = url;
    link.download = filename || `export_${Date.now()}.csv`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  /**
   * Download data as file
   */
  downloadData(data, format, populationName) {
    let content, mimeType, extension;
    switch (format) {
      case 'json':
        content = JSON.stringify(data, null, 2);
        mimeType = 'application/json';
        extension = 'json';
        break;
      case 'csv':
      default:
        content = this.convertToCSV(data);
        mimeType = 'text/csv';
        extension = 'csv';
        break;
    }
    const blob = new Blob([content], {
      type: mimeType
    });
    const url = URL.createObjectURL(blob);
    const filename = `${populationName || 'export'}_${Date.now()}.${extension}`;
    this.downloadFile(url, filename);
    URL.revokeObjectURL(url);
  }

  /**
   * Convert data to CSV format
   */
  convertToCSV(data) {
    if (!Array.isArray(data) || data.length === 0) {
      return '';
    }

    // Get headers from first object
    const headers = Object.keys(data[0]);
    const csvHeaders = headers.join(',');

    // Convert data rows
    const csvRows = data.map(row => {
      return headers.map(header => {
        const value = row[header];
        // Escape commas and quotes
        if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
          return `"${value.replace(/"/g, '""')}"`;
        }
        return value || '';
      }).join(',');
    });
    return [csvHeaders, ...csvRows].join('\n');
  }

  /**
   * Load populations for dropdown
   */
  async loadPopulations() {
    try {
      const response = await this.localClient.get('/api/populations');
      if (response.success && response.populations) {
        this.populateDropdown(response.populations);
      }
    } catch (error) {
      this.logger.error('Failed to load populations', error);
      // TODO: Refactor: Use Notification or Modal from UI subsystem instead of alert.
      this.uiManager.showError('Failed to Load Populations', error.message);
    }
  }

  /**
   * Populate the population dropdown
   */
  populateDropdown(populations) {
    const select = document.getElementById('export-population-select');
    if (!select) return;

    // Clear existing options
    select.innerHTML = '<option value="">Select Population</option>';

    // Add population options
    populations.forEach(pop => {
      const option = document.createElement('option');
      option.value = pop.id;
      option.textContent = pop.name;
      select.appendChild(option);
    });
  }

  /**
   * Handle population selection change
   */
  handlePopulationChange(populationId) {
    this.selectedPopulationId = populationId;
    const select = document.getElementById('export-population-select');
    if (select) {
      const selectedOption = select.options[select.selectedIndex];
      this.selectedPopulationName = selectedOption?.text || '';
    }
    this.logger.info('Population selection changed', {
      id: this.selectedPopulationId,
      name: this.selectedPopulationName
    });

    // Update UI based on selection
    this.updateExportOptions();
  }

  /**
   * Handle export format change
   */
  handleFormatChange(format) {
    this.logger.info('Export format changed', {
      format
    });

    // Update UI based on format selection
    this.updateFormatOptions(format);
  }

  /**
   * Update export options based on population selection
   */
  updateExportOptions() {
    const exportBtn = document.getElementById('export-btn');
    if (exportBtn) {
      exportBtn.disabled = !this.selectedPopulationId;
    }

    // Show/hide additional options based on population
    if (this.selectedPopulationId) {
      this.showExportOptions();
    } else {
      this.hideExportOptions();
    }
  }

  /**
   * Update format-specific options
   */
  updateFormatOptions(format) {
    const headersOption = document.getElementById('headers-option');
    if (headersOption) {
      headersOption.style.display = format === 'csv' ? 'block' : 'none';
    }
  }

  /**
   * Show export options
   */
  showExportOptions() {
    const optionsContainer = document.getElementById('export-options');
    if (optionsContainer) {
      optionsContainer.style.display = 'block';
    }
  }

  /**
   * Hide export options
   */
  hideExportOptions() {
    const optionsContainer = document.getElementById('export-options');
    if (optionsContainer) {
      optionsContainer.style.display = 'none';
    }
  }

  /**
   * Show export progress
   */
  showExportProgress() {
    const progressContainer = document.getElementById('export-progress');
    if (progressContainer) {
      progressContainer.style.display = 'block';
    }
    const exportBtn = document.getElementById('export-btn');
    if (exportBtn) {
      exportBtn.disabled = true;
      exportBtn.textContent = 'Exporting...';
    }
  }

  /**
   * Hide export progress
   */
  hideExportProgress() {
    const progressContainer = document.getElementById('export-progress');
    if (progressContainer) {
      progressContainer.style.display = 'none';
    }
    const exportBtn = document.getElementById('export-btn');
    if (exportBtn) {
      exportBtn.disabled = false;
      exportBtn.textContent = 'Export Users';
    }
  }

  /**
   * Check token status
   */
  async checkTokenStatus() {
    try {
      const response = await this.localClient.get('/api/v1/auth/status');
      return response.valid;
    } catch (error) {
      this.logger.error('Token status check failed', error);
      return false;
    }
  }

  /**
   * Set up cross-subsystem event listeners
   */
  setupCrossSubsystemEvents() {
    if (!this.eventBus) {
      this.logger.warn('EventBus not available for cross-subsystem events');
      return;
    }

    // Listen for token expiration events
    this.eventBus.on('tokenExpired', data => {
      this.logger.warn('Token expired during export operation');
      if (this.isExporting) {
        this.isExporting = false;
        this.hideExportProgress();
        this.uiManager.showError('Session Expired', 'Your authentication token expired during the export. Please re-authenticate and try again.');
      }
    });

    // Listen for token error events
    this.eventBus.on('tokenError', data => {
      this.logger.error('Token error detected', data);
      if (this.isExporting) {
        this.isExporting = false;
        this.hideExportProgress();
        this.uiManager.showError('Authentication Error', `Authentication failed: ${data.error}`);
      }
    });

    // Listen for token refresh events
    this.eventBus.on('tokenRefreshed', data => {
      this.logger.info('Token refreshed successfully');
      // Token refresh is handled automatically, just log for now
    });

    // Listen for population change events
    this.eventBus.on('populationsChanged', data => {
      this.logger.info('Populations changed, refreshing export dropdown', {
        count: data.count
      });
      this.refreshPopulationDropdown();
    });
    this.logger.debug('Cross-subsystem event listeners set up for ExportSubsystem');
  }

  /**
   * Refresh the population dropdown for export
   */
  refreshPopulationDropdown() {
    // Use PopulationService directly instead of going through app
    if (this.populationService) {
      this.populationService.populateDropdown('export-population-select', {
        includeEmpty: true,
        emptyText: 'Select a population'
      }).then(() => {
        this.logger.debug('Export population dropdown refreshed successfully');
      }).catch(error => {
        this.logger.error('Failed to refresh export population dropdown', error);
        this.uiManager.showError('Population Refresh Failed', 'Failed to refresh population dropdown.');
      });
    } else {
      this.logger.warn('PopulationService not available for dropdown refresh');
    }
  }
}
exports.ExportSubsystem = ExportSubsystem;

},{}],83:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.GlobalTokenManagerSubsystem = void 0;
/**
 * Global Token Manager Subsystem
 * 
 * Provides a prominent global token status display in the sidebar
 * with real-time countdown timer and enhanced visibility across all windows.
 * 
 * Follows the subsystem architecture pattern with proper lifecycle management,
 * EventBus integration, and consistent initialization.
 */

class GlobalTokenManagerSubsystem {
  constructor(logger, eventBus) {
    this.logger = logger || console;
    this.eventBus = eventBus;

    // Subsystem state
    this.isInitialized = false;
    this.isDestroyed = false;

    // Timer for updating token status
    this.globalTokenTimer = null;
    this.updateInterval = 1000; // 1 second

    // Bind methods
    this.init = this.init.bind(this);
    this.destroy = this.destroy.bind(this);
    this.updateGlobalTokenStatus = this.updateGlobalTokenStatus.bind(this);
    this.setupGlobalTokenEventListeners = this.setupGlobalTokenEventListeners.bind(this);
    this.startGlobalTokenTimer = this.startGlobalTokenTimer.bind(this);
    this.getNewToken = this.getNewToken.bind(this);
    this.logger.debug('Global Token Manager Subsystem created');
  }

  /**
   * Initialize the subsystem
   */
  async init() {
    if (this.isInitialized) {
      this.logger.warn('Global Token Manager Subsystem already initialized');
      return;
    }
    try {
      this.logger.info('Initializing Global Token Manager Subsystem...');

      // Wait for DOM to be ready and token status element to exist
      await this.waitForTokenStatusElement();

      // Prevent conflicts with other token status systems
      this.preventTokenStatusConflicts();

      // Set up event listeners
      this.setupGlobalTokenEventListeners();

      // Set up EventBus listeners
      this.setupEventBusListeners();

      // Start the update timer
      this.startGlobalTokenTimer();

      // Initial status update
      this.updateGlobalTokenStatus();
      this.isInitialized = true;
      this.logger.info('Global Token Manager Subsystem initialized successfully');

      // Emit initialization event
      if (this.eventBus) {
        this.eventBus.emit('globalTokenManager:initialized');
      }
    } catch (error) {
      this.logger.error('Failed to initialize Global Token Manager Subsystem', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    }
  }

  /**
   * Destroy the subsystem and clean up resources
   */
  async destroy() {
    if (this.isDestroyed) {
      return;
    }
    this.logger.info('Destroying Global Token Manager Subsystem...');

    // Stop the timer
    if (this.globalTokenTimer) {
      clearInterval(this.globalTokenTimer);
      this.globalTokenTimer = null;
    }

    // Remove event listeners
    this.removeEventListeners();

    // Clean up DOM protection
    if (this.mutationObserver) {
      this.mutationObserver.disconnect();
      this.mutationObserver = null;
    }

    // Restore original UIManager methods
    this.restoreOriginalMethods();

    // Mark as destroyed
    this.isDestroyed = true;
    this.isInitialized = false;

    // Emit destruction event
    if (this.eventBus) {
      this.eventBus.emit('globalTokenManager:destroyed');
    }
    this.logger.info('Global Token Manager Subsystem destroyed');
  }

  /**
   * Wait for token status element to be available in DOM
   */
  async waitForTokenStatusElement() {
    const maxAttempts = 100;
    const delay = 100;
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      // Check if DOM is ready
      if (document.readyState !== 'complete' && document.readyState !== 'interactive') {
        this.logger.debug(`DOM not ready (${document.readyState}), waiting...`);
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }
      const element = document.getElementById('global-token-status');
      if (element) {
        // Verify all required child elements exist (they may be nested)
        const countdown = element.querySelector('.global-token-countdown');
        const icon = element.querySelector('.global-token-icon');
        const text = element.querySelector('.global-token-text');

        // If the main element exists, consider it ready even if some child elements are missing
        // The child elements will be populated by other methods
        if (element.id === 'global-token-status') {
          this.logger.debug('Global token status element found and ready', {
            attempt,
            elementId: element.id,
            hasCountdown: !!countdown,
            hasIcon: !!icon,
            hasText: !!text
          });
          return element;
        }
      } else {
        this.logger.debug(`Global token status element not found (attempt ${attempt}/${maxAttempts})`);
      }
      await new Promise(resolve => setTimeout(resolve, delay));
    }
    this.logger.error('Global token status element not found after waiting', {
      domState: document.readyState,
      bodyExists: !!document.body,
      sidebarExists: !!document.querySelector('.sidebar'),
      allElementsWithId: Array.from(document.querySelectorAll('[id]')).map(el => el.id)
    });
    throw new Error('Global token status element not found after waiting');
  }

  /**
   * Prevent conflicts with other token status systems
   */
  preventTokenStatusConflicts() {
    this.logger.debug('Preventing token status conflicts...');

    // Mark our global token status element as protected
    const statusElement = document.getElementById('global-token-status');
    if (statusElement) {
      statusElement.setAttribute('data-protected', 'true');
      statusElement.setAttribute('data-managed-by', 'GlobalTokenManagerSubsystem');

      // Add a mutation observer to prevent other systems from modifying our element
      this.setupDOMProtection(statusElement);
    }

    // Override conflicting UIManager methods if they exist
    this.overrideConflictingMethods();
    this.logger.debug('Token status conflicts prevention set up');
  }

  /**
   * Set up DOM protection to prevent other systems from modifying our widget
   */
  setupDOMProtection(element) {
    if (!window.MutationObserver) {
      return; // Skip if MutationObserver not supported
    }
    this.mutationObserver = new MutationObserver(mutations => {
      mutations.forEach(mutation => {
        // If our element was removed or modified by another system, restore it
        if (mutation.type === 'childList' && mutation.removedNodes.length > 0) {
          const removedOurElement = Array.from(mutation.removedNodes).some(node => node.id === 'global-token-status');
          if (removedOurElement) {
            this.logger.warn('Global token status element was removed by another system, will reinitialize');
            // Reinitialize after a short delay
            setTimeout(() => {
              if (!document.getElementById('global-token-status')) {
                this.logger.info('Reinitializing global token status element');
                this.waitForTokenStatusElement().then(() => {
                  this.updateGlobalTokenStatus();
                }).catch(error => {
                  this.logger.error('Failed to reinitialize token status element', error);
                });
              }
            }, 100);
          }
        }
      });
    });

    // Observe the parent container for changes
    const sidebar = element.parentElement;
    if (sidebar) {
      this.mutationObserver.observe(sidebar, {
        childList: true,
        subtree: true
      });
    }
  }

  /**
   * Override conflicting methods in other systems
   */
  overrideConflictingMethods() {
    // Check if UIManager exists and has conflicting methods
    if (window.app && window.app.uiManager) {
      const uiManager = window.app.uiManager;

      // Store original methods if they exist
      if (typeof uiManager.updateUniversalTokenStatus === 'function') {
        uiManager._originalUpdateUniversalTokenStatus = uiManager.updateUniversalTokenStatus;
        uiManager.updateUniversalTokenStatus = () => {
          this.logger.debug('UIManager.updateUniversalTokenStatus called - delegating to GlobalTokenManagerSubsystem');
          this.updateGlobalTokenStatus();
        };
      }
      if (typeof uiManager.updateHomeTokenStatus === 'function') {
        uiManager._originalUpdateHomeTokenStatus = uiManager.updateHomeTokenStatus;
        uiManager.updateHomeTokenStatus = () => {
          this.logger.debug('UIManager.updateHomeTokenStatus called - delegating to GlobalTokenManagerSubsystem');
          this.updateGlobalTokenStatus();
        };
      }
      this.logger.debug('Conflicting UIManager methods overridden');
    }
  }

  /**
   * Restore original methods in other systems
   */
  restoreOriginalMethods() {
    if (window.app && window.app.uiManager) {
      const uiManager = window.app.uiManager;

      // Restore original methods if they were overridden
      if (uiManager._originalUpdateUniversalTokenStatus) {
        uiManager.updateUniversalTokenStatus = uiManager._originalUpdateUniversalTokenStatus;
        delete uiManager._originalUpdateUniversalTokenStatus;
      }
      if (uiManager._originalUpdateHomeTokenStatus) {
        uiManager.updateHomeTokenStatus = uiManager._originalUpdateHomeTokenStatus;
        delete uiManager._originalUpdateHomeTokenStatus;
      }
      this.logger.debug('Original UIManager methods restored');
    }
  }

  /**
   * Set up EventBus listeners
   */
  setupEventBusListeners() {
    if (!this.eventBus) {
      return;
    }

    // Listen for token refresh events
    this.eventBus.on('token:refreshed', () => {
      this.logger.debug('Token refreshed event received, updating status');
      this.updateGlobalTokenStatus();
    });

    // Listen for token error events
    this.eventBus.on('token:error', data => {
      this.logger.debug('Token error event received', data);
      this.updateGlobalTokenStatus();
    });

    // Listen for settings changes that might affect token status
    this.eventBus.on('settings:updated', () => {
      this.logger.debug('Settings updated event received, updating token status');
      this.updateGlobalTokenStatus();
    });
    this.logger.debug('EventBus listeners set up for Global Token Manager');
  }

  /**
   * Update the global token status display
   */
  updateGlobalTokenStatus() {
    if (this.isDestroyed) {
      return;
    }
    const statusBox = document.getElementById('global-token-status');
    if (!statusBox) {
      // Only log warning once every 30 seconds to reduce spam
      if (!this.lastElementWarning || Date.now() - this.lastElementWarning > 30000) {
        this.logger.debug('Global token status box not found - widget may not be initialized yet');
        this.lastElementWarning = Date.now();
      }
      return;
    }
    const countdown = statusBox.querySelector('.global-token-countdown');
    const icon = statusBox.querySelector('.global-token-icon');
    const text = statusBox.querySelector('.global-token-text');
    const getTokenBtn = document.getElementById('global-get-token');

    // If child elements are missing, log debug message but continue with partial updates
    if (!countdown || !icon || !text) {
      // Only log debug message once every 30 seconds to reduce spam
      if (!this.lastChildElementWarning || Date.now() - this.lastChildElementWarning > 30000) {
        this.logger.debug('Some global token status child elements not found, will update what is available', {
          hasCountdown: !!countdown,
          hasIcon: !!icon,
          hasText: !!text,
          statusBoxFound: !!statusBox
        });
        this.lastChildElementWarning = Date.now();
      }
    }
    try {
      // Get current token info (sync version for now to avoid async issues during init)
      const tokenInfo = this.getTokenInfoSync();
      if (tokenInfo.hasToken) {
        // Token exists
        const timeLeft = tokenInfo.timeLeft;
        const formattedTime = this.formatTime(timeLeft);
        if (countdown) countdown.textContent = formattedTime;
        if (timeLeft <= 0) {
          // Token expired
          statusBox.className = 'global-token-status expired';
          if (icon) icon.textContent = '';
          if (text) text.textContent = 'Token expired';
          if (getTokenBtn) getTokenBtn.style.display = 'inline-block';
        } else if (timeLeft <= 300) {
          // 5 minutes
          // Token expiring soon
          statusBox.className = 'global-token-status expiring';
          if (icon) icon.textContent = '';
          if (text) text.textContent = 'Token expiring soon';
          if (getTokenBtn) getTokenBtn.style.display = 'none';
        } else {
          // Token valid
          statusBox.className = 'global-token-status valid';
          if (icon) icon.textContent = '';
          if (text) text.textContent = 'Token valid';
          if (getTokenBtn) getTokenBtn.style.display = 'none';
        }
      } else {
        // No token
        statusBox.className = 'global-token-status missing';
        if (icon) icon.textContent = '';
        if (text) text.textContent = 'No valid token';
        if (countdown) countdown.textContent = 'No Token';
        if (getTokenBtn) getTokenBtn.style.display = 'inline-block';
      }
    } catch (error) {
      // Reduce error logging frequency to prevent spam
      if (!this.lastErrorWarning || Date.now() - this.lastErrorWarning > 30000) {
        this.logger.debug('Error updating global token status', {
          error: error.message
        });
        this.lastErrorWarning = Date.now();
      }

      // Show error state only if elements exist
      if (statusBox) statusBox.className = 'global-token-status error';
      if (icon) icon.textContent = '';
      if (text) text.textContent = 'Status error';
      if (countdown) countdown.textContent = 'Error';
    }
  }

  /**
   * Format time in human-readable format
   */
  formatTime(seconds) {
    if (seconds <= 0) return '00:00';
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor(seconds % 3600 / 60);
    const secs = seconds % 60;
    if (hours > 0) {
      return `${hours}h ${minutes}m ${secs}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${secs}s`;
    } else {
      return `${secs}s`;
    }
  }

  /**
   * Get current token information (synchronous version for initialization)
   */
  getTokenInfoSync() {
    try {
      // Only check localStorage for sync version to avoid async issues during init
      const token = localStorage.getItem('pingone_worker_token');
      const expiry = localStorage.getItem('pingone_token_expiry');
      if (!token || !expiry) {
        return {
          hasToken: false,
          timeLeft: 0,
          source: 'localStorage'
        };
      }
      const expiryTime = parseInt(expiry);
      const currentTime = Date.now();
      const timeLeft = Math.floor((expiryTime - currentTime) / 1000);
      return {
        hasToken: true,
        timeLeft: Math.max(0, timeLeft),
        source: 'localStorage'
      };
    } catch (error) {
      this.logger.debug('Error getting sync token info', {
        error: error.message
      });
      return {
        hasToken: false,
        timeLeft: 0,
        source: 'error'
      };
    }
  }

  /**
   * Get current token information (async version with server fallback)
   */
  async getTokenInfo() {
    try {
      // First try to get token info from server API
      try {
        // Corrected endpoint to align with auth-subsystem API
        const response = await fetch('/api/v1/auth/token');
        if (response.ok) {
          const serverTokenInfo = await response.json();
          // The /token endpoint returns tokenInfo directly
          if (serverTokenInfo.success && serverTokenInfo.tokenInfo) {
            return {
              hasToken: serverTokenInfo.tokenInfo.isValid,
              timeLeft: serverTokenInfo.tokenInfo.timeLeft || 0,
              source: 'server'
            };
          }
        }
      } catch (serverError) {
        this.logger.debug('Could not fetch token info from server, checking localStorage', {
          error: serverError.message
        });
      }

      // Fallback to localStorage
      const token = localStorage.getItem('pingone_worker_token');
      const expiry = localStorage.getItem('pingone_token_expiry');
      if (!token || !expiry) {
        return {
          hasToken: false,
          timeLeft: 0,
          source: 'localStorage'
        };
      }
      const expiryTime = parseInt(expiry);
      const currentTime = Date.now();
      const timeLeft = Math.floor((expiryTime - currentTime) / 1000);
      return {
        hasToken: true,
        timeLeft: Math.max(0, timeLeft),
        source: 'localStorage'
      };
    } catch (error) {
      this.logger.error('Error getting token info', {
        error: error.message
      });
      return {
        hasToken: false,
        timeLeft: 0,
        source: 'error'
      };
    }
  }

  /**
   * Set up event listeners for global token buttons
   */
  setupGlobalTokenEventListeners() {
    // Refresh button
    const refreshBtn = document.getElementById('global-refresh-token');
    if (refreshBtn) {
      this.refreshBtnHandler = () => {
        this.logger.debug('Refresh token button clicked');
        this.updateGlobalTokenStatus();
      };
      refreshBtn.addEventListener('click', this.refreshBtnHandler);
    }

    // Get Token button
    const getTokenBtn = document.getElementById('global-get-token');
    if (getTokenBtn) {
      this.getTokenBtnHandler = () => {
        this.logger.debug('Get token button clicked');
        this.getNewToken();
      };
      getTokenBtn.addEventListener('click', this.getTokenBtnHandler);
    }
    this.logger.debug('Global token event listeners set up');
  }

  /**
   * Remove event listeners
   */
  removeEventListeners() {
    const refreshBtn = document.getElementById('global-refresh-token');
    if (refreshBtn && this.refreshBtnHandler) {
      refreshBtn.removeEventListener('click', this.refreshBtnHandler);
    }
    const getTokenBtn = document.getElementById('global-get-token');
    if (getTokenBtn && this.getTokenBtnHandler) {
      getTokenBtn.removeEventListener('click', this.getTokenBtnHandler);
    }
    this.logger.debug('Global token event listeners removed');
  }

  /**
   * Start the timer to update token status regularly
   */
  startGlobalTokenTimer() {
    if (this.globalTokenTimer) {
      clearInterval(this.globalTokenTimer);
    }
    this.globalTokenTimer = setInterval(() => {
      if (!this.isDestroyed) {
        this.updateGlobalTokenStatus();
      }
    }, this.updateInterval);
    this.logger.debug('Global token timer started', {
      interval: `${this.updateInterval}ms`
    });
  }

  /**
   * Get new token
   */
  async getNewToken() {
    if (this.isDestroyed) {
      return;
    }
    try {
      this.logger.info('Getting new token via global token manager subsystem...');

      // Show loading state
      const statusBox = document.getElementById('global-token-status');
      if (statusBox) {
        statusBox.className = 'global-token-status loading';
        const icon = statusBox.querySelector('.global-token-icon');
        const text = statusBox.querySelector('.global-token-text');
        if (icon) icon.textContent = '';
        if (text) text.textContent = 'Getting token...';
      }

      // Try to use the app's token refresh functionality
      if (window.app && typeof window.app.getToken === 'function') {
        await window.app.getToken();
        this.logger.info('Token refreshed successfully via app');
      } else {
        // Fallback: try to trigger token refresh through API
        const response = await fetch('/api/auth/refresh-token', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });
        if (response.ok) {
          const result = await response.json();
          this.logger.info('Token refreshed via API', result);
        } else {
          throw new Error(`API request failed: ${response.statusText}`);
        }
      }

      // Update status after token refresh
      this.updateGlobalTokenStatus();

      // Emit token refresh event
      if (this.eventBus) {
        this.eventBus.emit('globalTokenManager:tokenRefreshed');
      }
    } catch (error) {
      this.logger.error('Error getting new token', {
        error: error.message
      });

      // Show error state
      const statusBox = document.getElementById('global-token-status');
      if (statusBox) {
        statusBox.className = 'global-token-status error';
        const icon = statusBox.querySelector('.global-token-icon');
        const text = statusBox.querySelector('.global-token-text');
        if (icon) icon.textContent = '';
        if (text) text.textContent = 'Token error';
      }
    }
  }
  formatTime(seconds) {
    if (seconds <= 0) return '00:00';
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor(seconds % 3600 / 60);
    const secs = seconds % 60;
    if (hours > 0) {
      return `${hours}h ${minutes}m ${secs}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${secs}s`;
    } else {
      return `${secs}s`;
    }
  }

  /**
   * Get current token information
   */
  async getTokenInfo() {
    try {
      // First try to get token info from server API
      try {
        const response = await fetch('/api/token/status');
        if (response.ok) {
          const serverTokenInfo = await response.json();
          if (serverTokenInfo.hasToken) {
            return {
              hasToken: true,
              timeLeft: serverTokenInfo.timeLeft || 0,
              source: 'server'
            };
          }
        }
      } catch (serverError) {
        this.logger.debug('Could not fetch token info from server, checking localStorage', {
          error: serverError.message
        });
      }

      // Fallback to localStorage
      const token = localStorage.getItem('pingone_worker_token');
      const expiry = localStorage.getItem('pingone_token_expiry');
      if (!token || !expiry) {
        return {
          hasToken: false,
          timeLeft: 0,
          source: 'localStorage'
        };
      }
      const expiryTime = parseInt(expiry);
      const currentTime = Date.now();
      const timeLeft = Math.floor((expiryTime - currentTime) / 1000);
      return {
        hasToken: true,
        timeLeft: Math.max(0, timeLeft),
        source: 'localStorage'
      };
    } catch (error) {
      this.logger.error('Error getting token info', {
        error: error.message
      });
      return {
        hasToken: false,
        timeLeft: 0,
        source: 'error'
      };
    }
  }

  /**
   * Set up event listeners for global token buttons
   */
  setupGlobalTokenEventListeners() {
    // Refresh button
    const refreshBtn = document.getElementById('global-refresh-token');
    if (refreshBtn) {
      this.refreshBtnHandler = () => {
        this.logger.debug('Refresh token button clicked');
        this.updateGlobalTokenStatus();
      };
      refreshBtn.addEventListener('click', this.refreshBtnHandler);
    }

    // Get Token button
    const getTokenBtn = document.getElementById('global-get-token');
    if (getTokenBtn) {
      this.getTokenBtnHandler = () => {
        this.logger.debug('Get token button clicked');
        this.getNewToken();
      };
      getTokenBtn.addEventListener('click', this.getTokenBtnHandler);
    }
    this.logger.debug('Global token event listeners set up');
  }

  /**
   * Remove event listeners
   */
  removeEventListeners() {
    const refreshBtn = document.getElementById('global-refresh-token');
    if (refreshBtn && this.refreshBtnHandler) {
      refreshBtn.removeEventListener('click', this.refreshBtnHandler);
    }
    const getTokenBtn = document.getElementById('global-get-token');
    if (getTokenBtn && this.getTokenBtnHandler) {
      getTokenBtn.removeEventListener('click', this.getTokenBtnHandler);
    }
    this.logger.debug('Global token event listeners removed');
  }

  /**
   * Start the timer to update token status regularly
   */
  startGlobalTokenTimer() {
    if (this.globalTokenTimer) {
      clearInterval(this.globalTokenTimer);
    }
    this.globalTokenTimer = setInterval(() => {
      if (!this.isDestroyed) {
        this.updateGlobalTokenStatus();
      }
    }, this.updateInterval);
    this.logger.debug('Global token timer started', {
      interval: `${this.updateInterval}ms`
    });
  }

  /**
   * Get new token
   */
  async getNewToken() {
    if (this.isDestroyed) {
      return;
    }
    try {
      this.logger.info('Getting new token via global token manager subsystem...');

      // Show loading state
      const statusBox = document.getElementById('global-token-status');
      if (statusBox) {
        statusBox.className = 'global-token-status loading';
        const icon = statusBox.querySelector('.global-token-icon');
        const text = statusBox.querySelector('.global-token-text');
        if (icon) icon.textContent = '';
        if (text) text.textContent = 'Getting token...';
      }

      // Try to use the app's token refresh functionality
      if (window.app && typeof window.app.getToken === 'function') {
        await window.app.getToken();
        this.logger.info('Token refreshed successfully via app');
      } else {
        // Fallback: try to trigger token refresh through API
        const response = await fetch('/api/auth/refresh-token', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });
        if (response.ok) {
          const result = await response.json();
          this.logger.info('Token refreshed via API', result);
        } else {
          throw new Error(`API request failed: ${response.statusText}`);
        }
      }

      // Update status after token refresh
      this.updateGlobalTokenStatus();

      // Emit token refresh event
      if (this.eventBus) {
        this.eventBus.emit('globalTokenManager:tokenRefreshed');
      }
    } catch (error) {
      this.logger.error('Error getting new token', {
        error: error.message
      });

      // Show error state
      const statusBox = document.getElementById('global-token-status');
      if (statusBox) {
        statusBox.className = 'global-token-status error';
        const icon = statusBox.querySelector('.global-token-icon');
        const text = statusBox.querySelector('.global-token-text');
        if (icon) icon.textContent = '';
        if (text) text.textContent = 'Token error';
      }
    }
  }

  /**
   * Get subsystem status for health checks
   */
  getStatus() {
    return {
      name: 'GlobalTokenManagerSubsystem',
      initialized: this.isInitialized,
      destroyed: this.isDestroyed,
      timerActive: !!this.globalTokenTimer,
      updateInterval: this.updateInterval
    };
  }
}
exports.GlobalTokenManagerSubsystem = GlobalTokenManagerSubsystem;
var _default = exports.default = GlobalTokenManagerSubsystem;

},{}],84:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ImportSubsystem = void 0;
/**
 * Import Management Subsystem
 * 
 * Handles all user import operations with proper separation of concerns.
 * Manages file validation, progress tracking, real-time updates, and error handling.
 */

class ImportSubsystem {
  constructor(logger, uiManager, localClient, settingsManager, eventBus, populationService) {
    let authManagementSubsystem = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
    this.logger = logger;
    this.uiManager = uiManager;
    this.localClient = localClient;
    this.settingsManager = settingsManager;
    this.eventBus = eventBus;
    this.populationService = populationService;
    this.authManagementSubsystem = authManagementSubsystem;

    // Import state management
    this.isImporting = false;
    this.socket = null;
    this.selectedPopulationId = null;
    this.selectedPopulationName = null;
    this.fallbackPolling = null;
    this.logger.info('Import Subsystem initialized');

    // Set up event listeners for cross-subsystem communication
    this.setupCrossSubsystemEvents();
  }

  /**
   * Initialize the import subsystem
   */
  async init() {
    console.log(' [DEBUG] ImportSubsystem: init() method called');
    try {
      console.log(' [DEBUG] ImportSubsystem: Setting up event listeners');
      this.setupEventListeners();
      console.log(' [DEBUG] ImportSubsystem: About to refresh population dropdown');
      // Initialize population dropdown
      this.refreshPopulationDropdown();
      console.log(' [DEBUG] ImportSubsystem: Setting initial button state');
      // Set initial button state (should be disabled until form is complete)
      this.validateAndUpdateButtonState();
      console.log(' [DEBUG] ImportSubsystem: Init completed successfully');
      this.logger.info('Import Subsystem initialized successfully');
    } catch (error) {
      console.error(' [DEBUG] ImportSubsystem: Init failed with error:', error);
      this.logger.error('Failed to initialize Import Subsystem', error);
      throw error;
    }
  }

  /**
   * Set up event listeners for import-related elements
   */
  setupEventListeners() {
    // Import button (correct ID is 'start-import')
    const importBtn = document.getElementById('start-import');
    if (importBtn) {
      importBtn.addEventListener('click', async e => {
        e.preventDefault();
        await this.startImport();
      });
    }

    // CSV file input
    const csvFileInput = document.getElementById('csv-file');
    if (csvFileInput) {
      csvFileInput.addEventListener('change', async e => {
        const file = e.target.files[0];
        if (file) {
          await this.handleFileSelect(file);
          this.validateAndUpdateButtonState();
        }
      });
    }

    // Population dropdown change
    const populationSelect = document.getElementById('import-population-select');
    if (populationSelect) {
      populationSelect.addEventListener('change', e => {
        this.handlePopulationChange(e.target.value, e.target.selectedOptions[0]?.text);
        this.validateAndUpdateButtonState();
      });
    }

    // Drag & Drop functionality
    this.setupDragAndDropListeners();
  }

  /**
   * Set up drag and drop event listeners for CSV file upload
   */
  setupDragAndDropListeners() {
    const dropArea = document.getElementById('import-drop-zone');
    const fileInput = document.getElementById('csv-file');
    if (!dropArea) {
      this.logger.warn('Import drop zone not found in DOM');
      return;
    }

    // Prevent default drag behaviors
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      dropArea.addEventListener(eventName, e => {
        e.preventDefault();
        e.stopPropagation();
      }, false);
    });

    // Highlight drop area when item is dragged over it
    ['dragenter', 'dragover'].forEach(eventName => {
      dropArea.addEventListener(eventName, () => {
        dropArea.classList.add('drag-over');
      }, false);
    });
    ['dragleave', 'drop'].forEach(eventName => {
      dropArea.addEventListener(eventName, () => {
        dropArea.classList.remove('drag-over');
      }, false);
    });

    // Handle dropped files
    dropArea.addEventListener('drop', async e => {
      const dt = e.dataTransfer;
      const files = dt.files;
      if (files.length > 0) {
        const file = files[0];

        // Update the file input to reflect the dropped file
        if (fileInput) {
          // Create a new FileList-like object
          const dataTransfer = new DataTransfer();
          dataTransfer.items.add(file);
          fileInput.files = dataTransfer.files;
        }
        await this.handleFileSelect(file);
        this.validateAndUpdateButtonState();
      }
    }, false);

    // Handle click to browse files
    dropArea.addEventListener('click', () => {
      if (fileInput) {
        fileInput.click();
      }
    });
    this.logger.info('Drag and drop listeners set up successfully');
  }

  /**
   * Start the import process
   */
  async startImport() {
    if (this.isImporting) {
      this.uiManager.showNotification('An import is already in progress. Please wait for it to complete.', {
        type: 'warning',
        duration: 5000,
        title: 'Import In Progress'
      });
      return;
    }
    try {
      this.isImporting = true;
      this.logger.info('Starting import process');

      // Validate prerequisites
      if (!(await this.validateImportPrerequisites())) {
        return;
      }

      // Get population selection
      this.getPopulationSelection();

      // Show progress UI
      this.uiManager.showProgress();

      // Start real-time connection
      const sessionId = this.generateSessionId();
      await this.establishRealTimeConnection(sessionId);

      // Begin import process
      await this.executeImport(sessionId);
    } catch (error) {
      this.logger.error('Import process failed', error);
      this.uiManager.showError('Import Failed', error.message || 'An unexpected error occurred during the import process.');
    } finally {
      this.isImporting = false;
    }
  }

  /**
   * Validate import prerequisites
   */
  async validateImportPrerequisites() {
    // Check for valid token
    const hasValidToken = await this.checkTokenStatus();
    if (!hasValidToken) {
      // Show user-friendly authentication modal with "Go to Settings" button
      this.showAuthenticationModal('Import');
      return false;
    }

    // Check file selection
    const fileInput = document.getElementById('csv-file');
    if (!fileInput || !fileInput.files || !fileInput.files[0]) {
      this.uiManager.showError('No File Selected', 'Please select a CSV file to import.');
      return false;
    }
    return true;
  }

  /**
   * Get current population selection
   */
  getPopulationSelection() {
    const popSelect = document.getElementById('import-population-select');
    this.selectedPopulationId = popSelect?.value || '';
    if (popSelect) {
      const selectedOption = popSelect.options[popSelect.selectedIndex];
      this.selectedPopulationName = selectedOption?.text || '';
    }
    this.logger.info('Population selection', {
      id: this.selectedPopulationId,
      name: this.selectedPopulationName
    });
  }

  /**
   * Handle progress updates
   */
  handleProgressUpdate(data) {
    if (!data || data.current === undefined || data.total === undefined) {
      this.logger.error('Invalid progress data', data);
      return;
    }
    const percentage = Math.round(data.current / data.total * 100);

    // Update progress UI
    this.uiManager.updateProgress(percentage, data.message || `Processing ${data.current} of ${data.total} users...`);
    this.logger.info('Progress update', {
      current: data.current,
      total: data.total,
      percentage
    });
  }

  /**
   * Handle import completion
   */
  handleImportCompletion(data) {
    this.logger.info('Import completed', data);
    // TODO: Refactor: Use Notification from UI subsystem instead of alert.
    this.cleanupConnections();
  }

  /**
   * Handle import errors
   */
  handleImportError(data) {
    this.logger.error('Import error', data);
    // TODO: Refactor: Use Notification or Modal from UI subsystem instead of alert.
    this.cleanupConnections();
  }

  /**
   * Execute the import process
   */
  async executeImport(sessionId) {
    const fileInput = document.getElementById('csv-file');
    const file = fileInput.files[0];
    const formData = new FormData();
    formData.append('file', file);
    formData.append('populationId', this.selectedPopulationId);
    formData.append('sessionId', sessionId);
    try {
      const response = await this.localClient.post('/api/import', formData);
      if (!response.success) {
        throw new Error(response.error || 'Import failed');
      }
      this.logger.info('Import request sent successfully');
    } catch (error) {
      this.logger.error('Import request failed', error);
      throw error;
    }
  }

  /**
   * Generate unique session ID
   */
  generateSessionId() {
    return `import_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Check token status
   */
  async checkTokenStatus() {
    try {
      console.log(' [DEBUG] ImportSubsystem: checkTokenStatus called');
      console.log(' [DEBUG] ImportSubsystem: this.authManagementSubsystem =', this.authManagementSubsystem);
      console.log(' [DEBUG] ImportSubsystem: typeof this.authManagementSubsystem =', typeof this.authManagementSubsystem);
      if (!this.authManagementSubsystem) {
        this.logger.warn('AuthManagementSubsystem not available for token check');
        console.log(' [DEBUG] ImportSubsystem: AuthManagementSubsystem is null/undefined');
        return false;
      }
      console.log(' [DEBUG] ImportSubsystem: AuthManagementSubsystem is available, calling isTokenValid()');
      const isValid = this.authManagementSubsystem.isTokenValid();
      console.log(' [DEBUG] ImportSubsystem: isValid =', isValid);

      // Also get authentication status for additional info
      const authStatus = this.authManagementSubsystem.getAuthenticationStatus();
      console.log(' [DEBUG] ImportSubsystem: authStatus =', authStatus);
      return isValid;
    } catch (error) {
      this.logger.error('Error checking token status:', error);
      console.log(' [DEBUG] ImportSubsystem: Error in checkTokenStatus:', error);
      return false;
    }
  }

  /**
   * Show authentication modal with "Go to Settings" button
   */
  showAuthenticationModal() {
    let operation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Import';
    try {
      // Create authentication modal directly to avoid bundling issues
      this.createAuthenticationModal(operation);
    } catch (error) {
      this.logger.error('Error showing authentication modal:', error);
      // Fallback to generic error
      this.uiManager.showError('Authentication Required', `You must have a valid token to start an ${operation.toLowerCase()}. Please go to Settings to configure your credentials.`);
    }
  }

  /**
   * Create authentication modal with "Go to Settings" button
   */
  createAuthenticationModal(operation) {
    // Check if modal already exists
    const existingModal = document.querySelector('.token-alert-overlay');
    if (existingModal) {
      existingModal.remove();
    }

    // Create modal overlay
    const overlay = document.createElement('div');
    overlay.className = 'token-alert-overlay';
    overlay.setAttribute('role', 'dialog');
    overlay.setAttribute('aria-modal', 'true');
    overlay.setAttribute('aria-labelledby', 'token-alert-title');
    overlay.setAttribute('aria-describedby', 'token-alert-content');

    // Modal content with enhanced styling and action button
    overlay.innerHTML = `
            <div class="token-alert-modal" tabindex="-1">
                <div class="token-alert-header">
                    <h2 id="token-alert-title">
                        <span class="warning-icon" aria-hidden="true"></span>
                        <span>Authentication Required</span>
                    </h2>
                    <button type="button" class="token-alert-close" id="token-alert-close" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="token-alert-body">
                    <div id="token-alert-content" class="token-alert-content">
                        <div class="token-alert-icon">
                            <span aria-hidden="true"></span>
                        </div>
                        <h3>No Valid Token Available</h3>
                        <p class="token-alert-message">
                            <strong>Authentication is required to continue.</strong>
                            You need valid credentials to perform the "${operation}" operation.
                        </p>
                        <div class="token-status-info">
                            <p><strong>Current Status:</strong> No token available</p>
                        </div>
                        <div class="token-alert-actions">
                            <button type="button" class="btn btn-primary btn-lg" id="token-alert-settings-btn">
                                <span class="btn-icon"></span>
                                Go to Settings
                            </button>
                            <p class="token-alert-help">
                                Add your PingOne credentials in the Settings page to generate a new token.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        `;
    document.body.appendChild(overlay);

    // Bind events
    const settingsBtn = overlay.querySelector('#token-alert-settings-btn');
    const closeBtn = overlay.querySelector('#token-alert-close');

    // Settings button - navigate to settings
    settingsBtn.addEventListener('click', () => {
      overlay.remove();
      // Navigate to settings view
      if (window.app && window.app.showView) {
        window.app.showView('settings');
      } else {
        // Fallback: trigger the settings nav item
        const settingsNavItem = document.querySelector('[data-view="settings"]');
        if (settingsNavItem) {
          settingsNavItem.click();
        } else {
          // Final fallback: redirect to home page
          window.location.href = '/';
        }
      }
    });

    // Close button - allow manual dismissal
    closeBtn.addEventListener('click', () => {
      overlay.remove();
    });

    // Trap focus within modal
    overlay.addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        overlay.remove();
      }
    });

    // Show modal with animation
    overlay.style.display = 'flex';
    setTimeout(() => {
      overlay.classList.add('show');
    }, 10);
  }

  /**
   * Handle file selection
   */
  async handleFileSelect(file) {
    try {
      this.logger.info('File selected for import', {
        name: file.name,
        size: file.size,
        type: file.type
      });

      // Validate file
      if (!this.validateFile(file)) {
        return;
      }

      // Show file info
      this.displayFileInfo(file);
    } catch (error) {
      this.logger.error('File selection failed', error);
      this.uiManager.showError('File Selection Error', error.message);
    }
  }

  /**
   * Validate form state and update Import button enabled/disabled state
   */
  validateAndUpdateButtonState() {
    const importBtn = document.getElementById('start-import');
    if (!importBtn) {
      this.logger.warn('Import button not found for state validation');
      return;
    }

    // Check if file is selected
    const fileInput = document.getElementById('csv-file');
    const hasFile = fileInput && fileInput.files && fileInput.files.length > 0;

    // Check if population is selected
    const populationSelect = document.getElementById('import-population-select');
    const hasPopulation = populationSelect && populationSelect.value && populationSelect.value !== '';

    // Enable button only if both file and population are selected
    const shouldEnable = hasFile && hasPopulation;
    importBtn.disabled = !shouldEnable;
    this.logger.debug('Import button state updated', {
      hasFile,
      hasPopulation,
      shouldEnable,
      buttonDisabled: importBtn.disabled
    });

    // Update button appearance
    if (shouldEnable) {
      importBtn.classList.remove('btn-disabled');
      importBtn.classList.add('btn-primary');
    } else {
      importBtn.classList.add('btn-disabled');
      importBtn.classList.remove('btn-primary');
    }
  }

  /**
   * Validate selected file
   */
  validateFile(file) {
    if (!file.name.toLowerCase().endsWith('.csv')) {
      this.uiManager.showError('Invalid File Type', 'Please select a CSV file');
      return false;
    }
    if (file.size > 10 * 1024 * 1024) {
      // 10MB limit
      this.uiManager.showError('File Too Large', 'File size must be less than 10MB');
      return false;
    }
    return true;
  }

  /**
   * Display file information
   */
  displayFileInfo(file) {
    const fileInfoElement = document.getElementById('file-info');
    if (fileInfoElement) {
      fileInfoElement.innerHTML = `
                <div class="file-info">
                    <strong>Selected File:</strong> ${file.name}<br>
                    <strong>Size:</strong> ${(file.size / 1024).toFixed(2)} KB<br>
                    <strong>Type:</strong> ${file.type || 'CSV'}
                </div>
            `;
    }
  }

  /**
   * Clean up connections and resources
   */
  cleanupConnections() {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
    }
    if (this.fallbackPolling) {
      clearInterval(this.fallbackPolling);
      this.fallbackPolling = null;
    }
    this.isImporting = false;
  }

  /**
   * Set up fallback polling if Socket.IO fails
   */
  setupFallbackPolling(sessionId) {
    this.fallbackPolling = setInterval(async () => {
      try {
        const response = await this.localClient.get(`/api/import/status/${sessionId}`);
        if (response.data) {
          this.handleProgressUpdate(response.data);
        }
      } catch (error) {
        this.logger.error('Fallback polling failed', error);
      }
    }, 2000);
  }

  /**
   * Set up cross-subsystem event listeners
   */
  setupCrossSubsystemEvents() {
    if (!this.eventBus) {
      this.logger.warn('EventBus not available for cross-subsystem events');
      return;
    }

    // Listen for token expiration events
    this.eventBus.on('tokenExpired', data => {
      this.logger.warn('Token expired during import operation');
      if (this.isImporting) {
        this.cleanupConnections();
        this.uiManager.showError('Session Expired', 'Your authentication token expired during the import. Please re-authenticate and try again.');
      }
    });

    // Listen for token error events
    this.eventBus.on('tokenError', data => {
      this.logger.error('Token error detected', data);
      if (this.isImporting) {
        this.cleanupConnections();
        this.uiManager.showError('Authentication Error', `Authentication failed: ${data.error}`);
      }
    });

    // Listen for token refresh events
    this.eventBus.on('tokenRefreshed', data => {
      this.logger.info('Token refreshed successfully');
      // Token refresh is handled automatically, just log for now
    });

    // Listen for population change events
    this.eventBus.on('populationsChanged', data => {
      this.logger.info('Populations changed, refreshing import dropdown', {
        count: data.count
      });
      this.refreshPopulationDropdown();
    });
    this.logger.debug('Cross-subsystem event listeners set up for ImportSubsystem');
  }

  /**
   * Handle population selection change
   */
  handlePopulationChange(populationId, populationName) {
    this.logger.info(' [DEBUG] ImportSubsystem: Population changed', {
      populationId,
      populationName
    });

    // Update population name display with better visual distinction
    const populationNameDisplay = document.querySelector('.population-name-text');
    if (populationNameDisplay) {
      if (populationId && populationName) {
        populationNameDisplay.innerHTML = `<span class="population-label">Population:</span> <span class="population-value">${populationName}</span>`;
        this.logger.debug('Updated population name display', {
          populationName
        });
      } else {
        populationNameDisplay.innerHTML = `<span class="population-label">Population:</span> <span class="population-placeholder">Select a population</span>`;
      }
    }

    // Update API URL display
    const apiUrlDisplay = document.querySelector('.api-url-text');
    if (apiUrlDisplay) {
      if (populationId) {
        // Construct the API URL for the selected population
        const apiUrl = `/api/populations/${populationId}/users`;
        apiUrlDisplay.textContent = apiUrl;
        this.logger.debug('Updated API URL display', {
          apiUrl
        });
      } else {
        apiUrlDisplay.textContent = 'Select a population to see the API URL';
      }
    }

    // Store the selected population for import operations
    this.selectedPopulationId = populationId;
    this.selectedPopulationName = populationName;

    // Emit event for other subsystems
    if (this.eventBus) {
      this.eventBus.emit('importPopulationChanged', {
        populationId,
        populationName
      });
    }
  }

  /**
   * Refresh the population dropdown for import
   */
  refreshPopulationDropdown() {
    this.logger.info(' [DEBUG] ImportSubsystem: refreshPopulationDropdown called');

    // Use PopulationService directly instead of going through app
    if (this.populationService) {
      this.logger.info(' [DEBUG] ImportSubsystem: PopulationService available, calling populateDropdown');
      this.populationService.populateDropdown('import-population-select', {
        includeEmpty: true,
        emptyText: 'Select a population'
      }).then(() => {
        this.logger.info(' [DEBUG] ImportSubsystem: Import population dropdown refreshed successfully');
      }).catch(error => {
        this.logger.error(' [DEBUG] ImportSubsystem: Failed to refresh import population dropdown', error);
        this.uiManager.showError('Population Refresh Failed', 'Failed to refresh population dropdown.');
      });
    } else {
      this.logger.error(' [DEBUG] ImportSubsystem: PopulationService not available for dropdown refresh', {
        populationServiceType: typeof this.populationService,
        populationServiceExists: !!this.populationService
      });
    }
  }
}
exports.ImportSubsystem = ImportSubsystem;

},{}],85:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NavigationSubsystem = void 0;
var _browserLoggingService = require("../utils/browser-logging-service.js");
/**
 * Navigation Subsystem
 * 
 * Manages all navigation, routing, and view switching functionality.
 * Extracted from app.js to provide centralized navigation control.
 * 
 * Features:
 * - View switching and routing
 * - Navigation state management
 * - URL handling and deep linking
 * - View-specific initialization
 * - Navigation history tracking
 */

class NavigationSubsystem {
  constructor(logger, uiManager, settingsManager) {
    this.logger = logger || (0, _browserLoggingService.createLogger)({
      serviceName: 'navigation-subsystem',
      environment: 'development'
    });
    this.uiManager = uiManager;
    this.settingsManager = settingsManager;

    // Navigation state
    this.currentView = 'home'; // Default view
    this.previousView = null;
    this.navigationHistory = [];
    this.viewInitializers = new Map();
    this.viewCleanupHandlers = new Map();

    // Navigation elements
    this.navItems = null;
    this.viewContainers = null;
    this.logger.info('Navigation subsystem initialized');
  }

  /**
   * Initialize the navigation subsystem
   */
  async init() {
    try {
      this.logger.info('Initializing navigation subsystem...');

      // Find navigation elements
      this.navItems = document.querySelectorAll('[data-view]');
      this.viewContainers = document.querySelectorAll('.view-container, [id$="-view"]');
      this.logger.info('Navigation elements found', {
        navItems: this.navItems.length,
        viewContainers: this.viewContainers.length
      });

      // Set up navigation event listeners
      this.setupNavigationListeners();

      // Register default view initializers
      this.registerDefaultViewInitializers();

      // Initialize current view
      await this.showView(this.currentView);
      this.logger.info('Navigation subsystem initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize navigation subsystem', {
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Set up navigation event listeners
   */
  setupNavigationListeners() {
    this.navItems.forEach(item => {
      item.addEventListener('click', async e => {
        e.preventDefault();
        const view = item.getAttribute('data-view');
        this.logger.debug('Navigation item clicked', {
          view
        });
        if (view && view !== this.currentView) {
          await this.navigateToView(view);
        }
      });
    });

    // Handle browser back/forward buttons
    window.addEventListener('popstate', e => {
      if (e.state && e.state.view) {
        this.showView(e.state.view, false); // Don't push to history
      }
    });
    this.logger.debug('Navigation listeners set up');
  }

  /**
   * Navigate to a specific view
   * @param {string} view - The view to navigate to
   * @param {Object} options - Navigation options
   */
  async navigateToView(view) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    try {
      this.logger.info('Navigating to view', {
        from: this.currentView,
        to: view
      });

      // Validate view exists
      if (!this.isValidView(view)) {
        this.logger.warn('Invalid view requested', {
          view
        });
        return false;
      }

      // Check if navigation is allowed
      if (options.force !== true && !(await this.canNavigateFrom(this.currentView))) {
        this.logger.info('Navigation blocked by current view', {
          currentView: this.currentView
        });
        return false;
      }

      // Show the view
      const success = await this.showView(view, options.pushToHistory !== false);
      if (success) {
        this.logger.info('Navigation completed successfully', {
          view
        });
      }
      return success;
    } catch (error) {
      this.logger.error('Navigation failed', {
        view,
        error: error.message
      });
      return false;
    }
  }

  /**
   * Show a specific view
   * @param {string} view - The view to show
   * @param {boolean} pushToHistory - Whether to push to browser history
   */
  async showView(view) {
    let pushToHistory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    try {
      this.logger.debug('Showing view', {
        view,
        pushToHistory
      });

      // Store previous view
      this.previousView = this.currentView;

      // Run cleanup for previous view
      if (this.previousView && this.viewCleanupHandlers.has(this.previousView)) {
        try {
          await this.viewCleanupHandlers.get(this.previousView)();
          this.logger.debug('View cleanup completed', {
            view: this.previousView
          });
        } catch (error) {
          this.logger.warn('View cleanup failed', {
            view: this.previousView,
            error: error.message
          });
        }
      }

      // Hide all views
      this.hideAllViews();

      // Show target view
      const viewElement = document.getElementById(`${view}-view`);
      if (viewElement) {
        viewElement.style.display = 'block';
        viewElement.classList.add('active');
      } else {
        this.logger.warn('View element not found', {
          view
        });
        return false;
      }

      // Update navigation state
      this.updateNavigationState(view);

      // Run view initializer
      if (this.viewInitializers.has(view)) {
        try {
          await this.viewInitializers.get(view)();
          this.logger.debug('View initializer completed', {
            view
          });
        } catch (error) {
          this.logger.warn('View initializer failed', {
            view,
            error: error.message
          });
        }
      }

      // Update browser history
      if (pushToHistory && window.history) {
        const url = new URL(window.location);
        url.searchParams.set('view', view);
        window.history.pushState({
          view
        }, '', url);
      }

      // Update current view
      this.currentView = view;

      // Add to navigation history
      this.navigationHistory.push({
        view,
        timestamp: Date.now(),
        from: this.previousView
      });

      // Limit history size
      if (this.navigationHistory.length > 50) {
        this.navigationHistory = this.navigationHistory.slice(-50);
      }
      this.logger.info('View shown successfully', {
        view
      });
      return true;
    } catch (error) {
      this.logger.error('Failed to show view', {
        view,
        error: error.message
      });
      return false;
    }
  }

  /**
   * Hide all views
   */
  hideAllViews() {
    this.viewContainers.forEach(container => {
      container.style.display = 'none';
      container.classList.remove('active');
    });
    this.logger.debug('All views hidden');
  }

  /**
   * Update navigation state (active nav items, etc.)
   * @param {string} view - The active view
   */
  updateNavigationState(view) {
    // Update navigation items
    this.navItems.forEach(item => {
      item.classList.remove('active');
      if (item.getAttribute('data-view') === view) {
        item.classList.add('active');
      }
    });

    // Update page title if needed
    this.updatePageTitle(view);
    this.logger.debug('Navigation state updated', {
      view
    });
  }

  /**
   * Update page title based on current view
   * @param {string} view - The current view
   */
  updatePageTitle(view) {
    const titles = {
      'import': 'Import Users',
      'export': 'Export Users',
      'modify': 'Modify Users',
      'delete-csv': 'Delete Users',
      'settings': 'Settings',
      'logs': 'Logs',
      'history': 'History'
    };
    const baseTitle = 'PingOne User Import v6.2';
    const viewTitle = titles[view];
    if (viewTitle) {
      document.title = `${viewTitle} - ${baseTitle}`;
    } else {
      document.title = baseTitle;
    }
  }

  /**
   * Register a view initializer
   * @param {string} view - The view name
   * @param {Function} initializer - The initializer function
   */
  registerViewInitializer(view, initializer) {
    this.viewInitializers.set(view, initializer);
    this.logger.debug('View initializer registered', {
      view
    });
  }

  /**
   * Register a view cleanup handler
   * @param {string} view - The view name
   * @param {Function} cleanup - The cleanup function
   */
  registerViewCleanup(view, cleanup) {
    this.viewCleanupHandlers.set(view, cleanup);
    this.logger.debug('View cleanup handler registered', {
      view
    });
  }

  /**
   * Register default view initializers
   */
  registerDefaultViewInitializers() {
    // Import view initializer
    this.registerViewInitializer('import', async () => {
      if (typeof window.app?.loadPopulations === 'function') {
        await window.app.loadPopulations('import-population-select');
      }
    });

    // Export view initializer
    this.registerViewInitializer('export', async () => {
      if (window.exportManager && typeof window.exportManager.loadPopulations === 'function') {
        await window.exportManager.loadPopulations();
      }
    });

    // Delete view initializer
    this.registerViewInitializer('delete-csv', async () => {
      if (window.deleteManager && typeof window.deleteManager.loadPopulations === 'function') {
        await window.deleteManager.loadPopulations();
      }
    });

    // Modify view initializer
    this.registerViewInitializer('modify', async () => {
      if (typeof window.app?.loadPopulations === 'function') {
        await window.app.loadPopulations('modify-population-select');
      }
    });

    // Logs/History view initializer
    this.registerViewInitializer('logs', async () => {
      if (window.logManager && typeof window.logManager.loadLogs === 'function') {
        window.logManager.loadLogs();
      }
    });
    this.registerViewInitializer('history', async () => {
      if (window.logManager && typeof window.logManager.loadLogs === 'function') {
        window.logManager.loadLogs();
      }
    });
    this.logger.debug('Default view initializers registered');
  }

  /**
   * Check if a view is valid
   * @param {string} view - The view to validate
   * @returns {boolean} - Whether the view is valid
   */
  isValidView(view) {
    const validViews = ['home', 'import', 'export', 'modify', 'delete-csv', 'settings', 'logs', 'history', 'analytics'];
    return validViews.includes(view);
  }

  /**
   * Check if navigation is allowed from current view
   * @param {string} fromView - The view to navigate from
   * @returns {Promise<boolean>} - Whether navigation is allowed
   */
  async canNavigateFrom(fromView) {
    // Check for unsaved changes, running operations, etc.

    // Check if import is running
    if (fromView === 'import' && window.app?.isImportRunning) {
      const confirmed = confirm('Import is currently running. Are you sure you want to leave this page?');
      return confirmed;
    }

    // Check if export is running
    if (fromView === 'export' && window.exportManager?.isExportRunning) {
      const confirmed = confirm('Export is currently running. Are you sure you want to leave this page?');
      return confirmed;
    }

    // Check if delete is running
    if (fromView === 'delete-csv' && window.deleteManager?.isDeleteRunning) {
      const confirmed = confirm('Delete operation is currently running. Are you sure you want to leave this page?');
      return confirmed;
    }

    // Check for unsaved settings
    if (fromView === 'settings' && this.settingsManager?.hasUnsavedChanges?.()) {
      const confirmed = confirm('You have unsaved settings. Are you sure you want to leave without saving?');
      return confirmed;
    }
    return true;
  }

  /**
   * Get current view
   * @returns {string} - The current view
   */
  getCurrentView() {
    return this.currentView;
  }

  /**
   * Get previous view
   * @returns {string|null} - The previous view
   */
  getPreviousView() {
    return this.previousView;
  }

  /**
   * Get navigation history
   * @returns {Array} - The navigation history
   */
  getNavigationHistory() {
    return [...this.navigationHistory];
  }

  /**
   * Go back to previous view
   */
  async goBack() {
    if (this.previousView) {
      await this.navigateToView(this.previousView);
    } else if (this.navigationHistory.length > 1) {
      const previousEntry = this.navigationHistory[this.navigationHistory.length - 2];
      await this.navigateToView(previousEntry.view);
    }
  }

  /**
   * Refresh current view
   */
  async refreshCurrentView() {
    await this.showView(this.currentView, false);
  }

  /**
   * Get view statistics
   * @returns {Object} - View usage statistics
   */
  getViewStats() {
    const stats = {};
    this.navigationHistory.forEach(entry => {
      if (!stats[entry.view]) {
        stats[entry.view] = {
          count: 0,
          lastVisited: null
        };
      }
      stats[entry.view].count++;
      stats[entry.view].lastVisited = entry.timestamp;
    });
    return stats;
  }

  /**
   * Clean up the navigation subsystem
   */
  cleanup() {
    // Remove event listeners
    this.navItems.forEach(item => {
      item.removeEventListener('click', this.handleNavClick);
    });
    window.removeEventListener('popstate', this.handlePopState);

    // Clear state
    this.viewInitializers.clear();
    this.viewCleanupHandlers.clear();
    this.navigationHistory = [];
    this.logger.info('Navigation subsystem cleaned up');
  }
}
exports.NavigationSubsystem = NavigationSubsystem;

},{"../utils/browser-logging-service.js":90}],86:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OperationManagerSubsystem = void 0;
var _browserLoggingService = require("../utils/browser-logging-service.js");
/**
 * Operation Manager Subsystem
 * 
 * Manages all CRUD operations (Import, Export, Delete, Modify) with centralized
 * orchestration, validation, progress tracking, and error handling.
 * 
 * Features:
 * - Unified operation lifecycle management
 * - Operation validation and pre-checks
 * - Progress tracking and status updates
 * - Error handling and recovery
 * - Operation queuing and concurrency control
 * - Operation history and logging
 */

class OperationManagerSubsystem {
  constructor(logger, uiManager, settingsManager, apiClient) {
    this.logger = logger || (0, _browserLoggingService.createLogger)({
      serviceName: 'operation-manager-subsystem',
      environment: 'development'
    });
    this.uiManager = uiManager;
    this.settingsManager = settingsManager;
    this.apiClient = apiClient;

    // Operation state
    this.currentOperation = null;
    this.operationQueue = [];
    this.operationHistory = [];
    this.isOperationRunning = false;

    // Operation types
    this.operationTypes = {
      IMPORT: 'import',
      EXPORT: 'export',
      DELETE: 'delete',
      MODIFY: 'modify'
    };

    // Operation validators
    this.validators = new Map();
    this.preChecks = new Map();
    this.postChecks = new Map();
    this.logger.info('Operation Manager subsystem initialized');
  }

  /**
   * Initialize the operation manager subsystem
   */
  async init() {
    try {
      this.logger.info('Initializing operation manager subsystem...');

      // Register default validators and checks
      this.registerDefaultValidators();
      this.registerDefaultPreChecks();
      this.registerDefaultPostChecks();
      this.logger.info('Operation Manager subsystem initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize operation manager subsystem', {
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Start an operation
   * @param {string} type - Operation type (import, export, delete, modify)
   * @param {Object} options - Operation options
   * @returns {Promise<Object>} - Operation result
   */
  async startOperation(type) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    try {
      this.logger.info('Starting operation', {
        type,
        options
      });

      // Check if operation is already running
      if (this.isOperationRunning) {
        throw new Error('Another operation is already running');
      }

      // Validate operation type
      if (!Object.values(this.operationTypes).includes(type)) {
        throw new Error(`Invalid operation type: ${type}`);
      }

      // Create operation context
      const operation = {
        id: this.generateOperationId(),
        type,
        options,
        status: 'initializing',
        startTime: Date.now(),
        endTime: null,
        progress: {
          current: 0,
          total: 0,
          percentage: 0,
          message: 'Initializing...'
        },
        result: null,
        error: null
      };
      this.currentOperation = operation;
      this.isOperationRunning = true;

      // Run pre-checks
      await this.runPreChecks(operation);

      // Validate operation
      await this.validateOperation(operation);

      // Execute operation
      const result = await this.executeOperation(operation);

      // Run post-checks
      await this.runPostChecks(operation);

      // Complete operation
      operation.status = 'completed';
      operation.endTime = Date.now();
      operation.result = result;
      this.logger.info('Operation completed successfully', {
        type,
        duration: operation.endTime - operation.startTime
      });
      return result;
    } catch (error) {
      this.logger.error('Operation failed', {
        type,
        error: error.message
      });
      if (this.currentOperation) {
        this.currentOperation.status = 'failed';
        this.currentOperation.endTime = Date.now();
        this.currentOperation.error = error.message;
      }
      throw error;
    } finally {
      // Clean up
      this.finalizeOperation();
    }
  }

  /**
   * Execute the actual operation
   * @param {Object} operation - Operation context
   * @returns {Promise<Object>} - Operation result
   */
  async executeOperation(operation) {
    const {
      type,
      options
    } = operation;
    this.logger.debug('Executing operation', {
      type
    });
    switch (type) {
      case this.operationTypes.IMPORT:
        return await this.executeImport(operation);
      case this.operationTypes.EXPORT:
        return await this.executeExport(operation);
      case this.operationTypes.DELETE:
        return await this.executeDelete(operation);
      case this.operationTypes.MODIFY:
        return await this.executeModify(operation);
      default:
        throw new Error(`Unknown operation type: ${type}`);
    }
  }

  /**
   * Execute import operation
   * @param {Object} operation - Operation context
   * @returns {Promise<Object>} - Import result
   */
  async executeImport(operation) {
    const {
      options
    } = operation;
    this.logger.info('Executing import operation', {
      options
    });

    // Update progress
    this.updateOperationProgress(operation, 0, 100, 'Starting import...');

    // Prepare import data
    const importData = {
      file: options.file,
      populationId: options.populationId,
      populationName: options.populationName,
      skipDuplicates: options.skipDuplicates || false,
      updateExisting: options.updateExisting || false
    };

    // Start import via API
    const response = await this.apiClient.post('/api/import', importData);
    if (!response.success) {
      throw new Error(response.error || 'Import failed');
    }

    // Track progress via SSE or polling
    await this.trackOperationProgress(operation, response.sessionId);
    return {
      success: true,
      sessionId: response.sessionId,
      message: 'Import completed successfully'
    };
  }

  /**
   * Execute export operation
   * @param {Object} operation - Operation context
   * @returns {Promise<Object>} - Export result
   */
  async executeExport(operation) {
    const {
      options
    } = operation;
    this.logger.info('Executing export operation', {
      options
    });

    // Update progress
    this.updateOperationProgress(operation, 0, 100, 'Starting export...');

    // Prepare export data
    const exportData = {
      populationId: options.populationId,
      populationName: options.populationName,
      includeDisabled: options.includeDisabled || false,
      format: options.format || 'csv'
    };

    // Start export via API
    const response = await this.apiClient.post('/api/export', exportData);
    if (!response.success) {
      throw new Error(response.error || 'Export failed');
    }

    // Track progress
    await this.trackOperationProgress(operation, response.sessionId);
    return {
      success: true,
      sessionId: response.sessionId,
      downloadUrl: response.downloadUrl,
      message: 'Export completed successfully'
    };
  }

  /**
   * Execute delete operation
   * @param {Object} operation - Operation context
   * @returns {Promise<Object>} - Delete result
   */
  async executeDelete(operation) {
    const {
      options
    } = operation;
    this.logger.info('Executing delete operation', {
      options
    });

    // Update progress
    this.updateOperationProgress(operation, 0, 100, 'Starting delete...');

    // Prepare delete data
    const deleteData = {
      file: options.file,
      populationId: options.populationId,
      populationName: options.populationName,
      confirmDelete: true
    };

    // Start delete via API
    const response = await this.apiClient.post('/api/delete', deleteData);
    if (!response.success) {
      throw new Error(response.error || 'Delete failed');
    }

    // Track progress
    await this.trackOperationProgress(operation, response.sessionId);
    return {
      success: true,
      sessionId: response.sessionId,
      message: 'Delete completed successfully'
    };
  }

  /**
   * Execute modify operation
   * @param {Object} operation - Operation context
   * @returns {Promise<Object>} - Modify result
   */
  async executeModify(operation) {
    const {
      options
    } = operation;
    this.logger.info('Executing modify operation', {
      options
    });

    // Update progress
    this.updateOperationProgress(operation, 0, 100, 'Starting modify...');

    // Prepare modify data
    const modifyData = {
      file: options.file,
      populationId: options.populationId,
      populationName: options.populationName,
      updateFields: options.updateFields || []
    };

    // Start modify via API
    const response = await this.apiClient.post('/api/modify', modifyData);
    if (!response.success) {
      throw new Error(response.error || 'Modify failed');
    }

    // Track progress
    await this.trackOperationProgress(operation, response.sessionId);
    return {
      success: true,
      sessionId: response.sessionId,
      message: 'Modify completed successfully'
    };
  }

  /**
   * Track operation progress via SSE or polling
   * @param {Object} operation - Operation context
   * @param {string} sessionId - Session ID for tracking
   */
  async trackOperationProgress(operation, sessionId) {
    return new Promise((resolve, reject) => {
      // Try SSE first
      if (typeof EventSource !== 'undefined') {
        this.trackProgressViaSSE(operation, sessionId, resolve, reject);
      } else {
        // Fallback to polling
        this.trackProgressViaPolling(operation, sessionId, resolve, reject);
      }
    });
  }

  /**
   * Track progress via Server-Sent Events
   * @param {Object} operation - Operation context
   * @param {string} sessionId - Session ID
   * @param {Function} resolve - Promise resolve function
   * @param {Function} reject - Promise reject function
   */
  trackProgressViaSSE(operation, sessionId, resolve, reject) {
    const eventSource = new EventSource(`/api/progress/${sessionId}`);
    eventSource.onmessage = event => {
      try {
        const data = JSON.parse(event.data);
        this.handleProgressUpdate(operation, data);
        if (data.status === 'completed') {
          eventSource.close();
          resolve(data);
        } else if (data.status === 'failed') {
          eventSource.close();
          reject(new Error(data.error || 'Operation failed'));
        }
      } catch (error) {
        this.logger.error('Error parsing SSE data', {
          error: error.message
        });
      }
    };
    eventSource.onerror = error => {
      this.logger.error('SSE connection error', {
        error
      });
      eventSource.close();
      // Fallback to polling
      this.trackProgressViaPolling(operation, sessionId, resolve, reject);
    };
  }

  /**
   * Track progress via polling
   * @param {Object} operation - Operation context
   * @param {string} sessionId - Session ID
   * @param {Function} resolve - Promise resolve function
   * @param {Function} reject - Promise reject function
   */
  async trackProgressViaPolling(operation, sessionId, resolve, reject) {
    const pollInterval = 1000; // 1 second

    const poll = async () => {
      try {
        const response = await this.apiClient.get(`/api/progress/${sessionId}`);
        if (response.success) {
          this.handleProgressUpdate(operation, response.data);
          if (response.data.status === 'completed') {
            resolve(response.data);
          } else if (response.data.status === 'failed') {
            reject(new Error(response.data.error || 'Operation failed'));
          } else {
            setTimeout(poll, pollInterval);
          }
        } else {
          reject(new Error(response.error || 'Failed to get progress'));
        }
      } catch (error) {
        reject(error);
      }
    };
    poll();
  }

  /**
   * Handle progress update
   * @param {Object} operation - Operation context
   * @param {Object} progressData - Progress data from server
   */
  handleProgressUpdate(operation, progressData) {
    // Update operation progress
    operation.progress = {
      current: progressData.current || 0,
      total: progressData.total || 0,
      percentage: progressData.percentage || 0,
      message: progressData.message || 'Processing...'
    };

    // Update UI
    if (this.uiManager) {
      this.uiManager.updateProgress(operation.progress.current, operation.progress.total, operation.progress.message);
    }
    this.logger.debug('Progress updated', {
      type: operation.type,
      progress: operation.progress
    });
  }

  /**
   * Update operation progress
   * @param {Object} operation - Operation context
   * @param {number} current - Current progress
   * @param {number} total - Total progress
   * @param {string} message - Progress message
   */
  updateOperationProgress(operation, current, total, message) {
    const percentage = total > 0 ? Math.round(current / total * 100) : 0;
    operation.progress = {
      current,
      total,
      percentage,
      message
    };

    // Update UI
    if (this.uiManager) {
      this.uiManager.updateProgress(current, total, message);
    }
    this.logger.debug('Operation progress updated', {
      type: operation.type,
      progress: operation.progress
    });
  }

  /**
   * Run pre-checks for operation
   * @param {Object} operation - Operation context
   */
  async runPreChecks(operation) {
    const preCheck = this.preChecks.get(operation.type);
    if (preCheck) {
      this.logger.debug('Running pre-checks', {
        type: operation.type
      });
      await preCheck(operation);
    }
  }

  /**
   * Validate operation
   * @param {Object} operation - Operation context
   */
  async validateOperation(operation) {
    const validator = this.validators.get(operation.type);
    if (validator) {
      this.logger.debug('Validating operation', {
        type: operation.type
      });
      await validator(operation);
    }
  }

  /**
   * Run post-checks for operation
   * @param {Object} operation - Operation context
   */
  async runPostChecks(operation) {
    const postCheck = this.postChecks.get(operation.type);
    if (postCheck) {
      this.logger.debug('Running post-checks', {
        type: operation.type
      });
      await postCheck(operation);
    }
  }

  /**
   * Finalize operation
   */
  finalizeOperation() {
    if (this.currentOperation) {
      // Add to history
      this.operationHistory.push({
        ...this.currentOperation
      });

      // Limit history size
      if (this.operationHistory.length > 100) {
        this.operationHistory = this.operationHistory.slice(-100);
      }

      // Clear current operation
      this.currentOperation = null;
    }
    this.isOperationRunning = false;
    this.logger.debug('Operation finalized');
  }

  /**
   * Register default validators
   */
  registerDefaultValidators() {
    // Import validator
    this.validators.set(this.operationTypes.IMPORT, async operation => {
      const {
        options
      } = operation;
      if (!options.file) {
        throw new Error('No file selected for import');
      }
      if (!options.populationId) {
        throw new Error('No population selected for import');
      }
    });

    // Export validator
    this.validators.set(this.operationTypes.EXPORT, async operation => {
      const {
        options
      } = operation;
      if (!options.populationId) {
        throw new Error('No population selected for export');
      }
    });

    // Delete validator
    this.validators.set(this.operationTypes.DELETE, async operation => {
      const {
        options
      } = operation;
      if (!options.file) {
        throw new Error('No file selected for delete');
      }
      if (!options.populationId) {
        throw new Error('No population selected for delete');
      }
    });

    // Modify validator
    this.validators.set(this.operationTypes.MODIFY, async operation => {
      const {
        options
      } = operation;
      if (!options.file) {
        throw new Error('No file selected for modify');
      }
      if (!options.populationId) {
        throw new Error('No population selected for modify');
      }
    });
  }

  /**
   * Register default pre-checks
   */
  registerDefaultPreChecks() {
    // Common pre-check for all operations
    const commonPreCheck = async operation => {
      // Check token validity
      if (window.app && typeof window.app.checkTokenAndRedirect === 'function') {
        const hasValidToken = await window.app.checkTokenAndRedirect(operation.type);
        if (!hasValidToken) {
          throw new Error('Invalid or expired token');
        }
      }
    };

    // Register for all operation types
    Object.values(this.operationTypes).forEach(type => {
      this.preChecks.set(type, commonPreCheck);
    });
  }

  /**
   * Register default post-checks
   */
  registerDefaultPostChecks() {
    // Common post-check for all operations
    const commonPostCheck = async operation => {
      // Log operation completion
      this.logger.info('Operation completed', {
        type: operation.type,
        duration: operation.endTime - operation.startTime,
        status: operation.status
      });
    };

    // Register for all operation types
    Object.values(this.operationTypes).forEach(type => {
      this.postChecks.set(type, commonPostCheck);
    });
  }

  /**
   * Generate unique operation ID
   * @returns {string} - Unique operation ID
   */
  generateOperationId() {
    return `op_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Cancel current operation
   */
  async cancelOperation() {
    if (this.currentOperation && this.isOperationRunning) {
      this.logger.info('Cancelling operation', {
        type: this.currentOperation.type
      });
      try {
        // Try to cancel via API
        if (this.currentOperation.sessionId) {
          await this.apiClient.post(`/api/cancel/${this.currentOperation.sessionId}`);
        }
        this.currentOperation.status = 'cancelled';
        this.currentOperation.endTime = Date.now();
        this.logger.info('Operation cancelled successfully');
      } catch (error) {
        this.logger.error('Failed to cancel operation', {
          error: error.message
        });
      } finally {
        this.finalizeOperation();
      }
    }
  }

  /**
   * Get current operation status
   * @returns {Object|null} - Current operation or null
   */
  getCurrentOperation() {
    return this.currentOperation ? {
      ...this.currentOperation
    } : null;
  }

  /**
   * Get operation history
   * @returns {Array} - Operation history
   */
  getOperationHistory() {
    return [...this.operationHistory];
  }

  /**
   * Check if operation is running
   * @returns {boolean} - Whether operation is running
   */
  isRunning() {
    return this.isOperationRunning;
  }

  /**
   * Get operation statistics
   * @returns {Object} - Operation statistics
   */
  getOperationStats() {
    const stats = {
      total: this.operationHistory.length,
      byType: {},
      byStatus: {},
      averageDuration: 0
    };
    let totalDuration = 0;
    this.operationHistory.forEach(op => {
      // By type
      if (!stats.byType[op.type]) {
        stats.byType[op.type] = 0;
      }
      stats.byType[op.type]++;

      // By status
      if (!stats.byStatus[op.status]) {
        stats.byStatus[op.status] = 0;
      }
      stats.byStatus[op.status]++;

      // Duration
      if (op.endTime && op.startTime) {
        totalDuration += op.endTime - op.startTime;
      }
    });
    if (this.operationHistory.length > 0) {
      stats.averageDuration = Math.round(totalDuration / this.operationHistory.length);
    }
    return stats;
  }
}
exports.OperationManagerSubsystem = OperationManagerSubsystem;

},{"../utils/browser-logging-service.js":90}],87:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RealtimeCommunicationSubsystem = void 0;
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * Real-time Communication Subsystem
 * 
 * Handles all real-time communication including Socket.IO connections,
 * WebSocket fallbacks, and Server-Sent Events for progress updates.
 */

class RealtimeCommunicationSubsystem {
  constructor(logger, uiManager) {
    this.logger = logger;
    this.uiManager = uiManager;

    // Connection state management
    this.socket = null;
    this.eventSource = null;
    this.fallbackPolling = null;
    this.connectionType = null;
    this.isConnected = false;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    this.reconnectDelay = 1000;

    // Event handlers
    this.eventHandlers = new Map();
    this.logger.info('Real-time Communication Subsystem initialized');
  }

  /**
   * Initialize the real-time communication subsystem
   */
  async init() {
    try {
      this.setupConnectionMonitoring();
      this.logger.info('Real-time Communication Subsystem initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize Real-time Communication Subsystem', error);
      throw error;
    }
  }

  /**
   * Establish real-time connection with fallback strategy
   */
  async establishConnection(sessionId) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const {
      preferredTransport = 'socketio',
      enableFallback = true,
      timeout = 10000
    } = options;
    this.logger.info('Establishing real-time connection', {
      sessionId,
      preferredTransport,
      enableFallback
    });
    try {
      // Try primary transport first
      if (preferredTransport === 'socketio') {
        await this.connectSocketIO(sessionId, timeout);
      } else if (preferredTransport === 'sse') {
        await this.connectSSE(sessionId, timeout);
      } else if (preferredTransport === 'websocket') {
        await this.connectWebSocket(sessionId, timeout);
      }
    } catch (error) {
      this.logger.warn('Primary transport failed', {
        error: error.message
      });
      if (enableFallback) {
        await this.tryFallbackConnections(sessionId);
      } else {
        throw error;
      }
    }
  }

  /**
   * Connect using Socket.IO
   */
  async connectSocketIO(sessionId) {
    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10000;
    return new Promise(async (resolve, reject) => {
      try {
        // Import Socket.IO dynamically
        const {
          io
        } = await Promise.resolve().then(() => _interopRequireWildcard(require('socket.io-client')));
        this.socket = io({
          transports: ['polling'],
          reconnectionAttempts: this.maxReconnectAttempts,
          reconnectionDelay: this.reconnectDelay,
          timeout: timeout,
          forceNew: true,
          autoConnect: true
        });

        // Set up connection timeout
        const connectionTimeout = setTimeout(() => {
          reject(new Error('Socket.IO connection timeout'));
        }, timeout);

        // Connection success
        this.socket.on('connect', () => {
          clearTimeout(connectionTimeout);
          this.connectionType = 'socketio';
          this.isConnected = true;
          this.reconnectAttempts = 0;

          // Register session
          this.socket.emit('registerSession', sessionId);
          this.logger.info('Socket.IO connected successfully');
          this.uiManager.showSuccess('Real-time connection established (Socket.IO)');
          resolve();
        });

        // Connection error
        this.socket.on('connect_error', error => {
          clearTimeout(connectionTimeout);
          this.logger.error('Socket.IO connection error', error);
          reject(error);
        });

        // Set up event handlers
        this.setupSocketIOHandlers();
      } catch (error) {
        this.logger.error('Failed to initialize Socket.IO', error);
        reject(error);
      }
    });
  }

  /**
   * Connect using Server-Sent Events
   */
  async connectSSE(sessionId) {
    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10000;
    return new Promise((resolve, reject) => {
      try {
        const sseUrl = `/api/progress/stream/${sessionId}`;
        this.eventSource = new EventSource(sseUrl);

        // Set up connection timeout
        const connectionTimeout = setTimeout(() => {
          reject(new Error('SSE connection timeout'));
        }, timeout);

        // Connection success
        this.eventSource.onopen = () => {
          clearTimeout(connectionTimeout);
          this.connectionType = 'sse';
          this.isConnected = true;
          this.reconnectAttempts = 0;
          this.logger.info('SSE connected successfully');
          this.uiManager.showSuccess('Real-time connection established (SSE)');
          resolve();
        };

        // Connection error
        this.eventSource.onerror = error => {
          clearTimeout(connectionTimeout);
          this.logger.error('SSE connection error', error);
          reject(error);
        };

        // Set up event handlers
        this.setupSSEHandlers();
      } catch (error) {
        this.logger.error('Failed to initialize SSE', error);
        reject(error);
      }
    });
  }

  /**
   * Connect using WebSocket
   */
  async connectWebSocket(sessionId) {
    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10000;
    return new Promise((resolve, reject) => {
      try {
        const wsUrl = `ws://${window.location.host}/ws/${sessionId}`;
        this.websocket = new WebSocket(wsUrl);

        // Set up connection timeout
        const connectionTimeout = setTimeout(() => {
          reject(new Error('WebSocket connection timeout'));
        }, timeout);

        // Connection success
        this.websocket.onopen = () => {
          clearTimeout(connectionTimeout);
          this.connectionType = 'websocket';
          this.isConnected = true;
          this.reconnectAttempts = 0;
          this.logger.info('WebSocket connected successfully');
          this.uiManager.showSuccess('Real-time connection established (WebSocket)');
          resolve();
        };

        // Connection error
        this.websocket.onerror = error => {
          clearTimeout(connectionTimeout);
          this.logger.error('WebSocket connection error', error);
          reject(error);
        };

        // Set up event handlers
        this.setupWebSocketHandlers();
      } catch (error) {
        this.logger.error('Failed to initialize WebSocket', error);
        reject(error);
      }
    });
  }

  /**
   * Try fallback connections in order
   */
  async tryFallbackConnections(sessionId) {
    const fallbackOrder = ['sse', 'websocket', 'polling'];
    for (const transport of fallbackOrder) {
      if (transport === this.connectionType) {
        continue; // Skip the one that already failed
      }
      try {
        this.logger.info(`Trying fallback transport: ${transport}`);
        if (transport === 'sse') {
          await this.connectSSE(sessionId);
        } else if (transport === 'websocket') {
          await this.connectWebSocket(sessionId);
        } else if (transport === 'polling') {
          await this.setupFallbackPolling(sessionId);
        }
        return; // Success, exit loop
      } catch (error) {
        this.logger.warn(`Fallback transport ${transport} failed`, error);
      }
    }
    throw new Error('All connection methods failed');
  }

  /**
   * Set up Socket.IO event handlers
   */
  setupSocketIOHandlers() {
    this.socket.on('progress', data => {
      this.handleProgressEvent(data);
    });
    this.socket.on('completion', data => {
      this.handleCompletionEvent(data);
    });
    this.socket.on('error', data => {
      this.handleErrorEvent(data);
    });
    this.socket.on('disconnect', reason => {
      this.handleDisconnection(reason);
    });
    this.socket.on('reconnect', () => {
      this.handleReconnection();
    });
  }

  /**
   * Set up SSE event handlers
   */
  setupSSEHandlers() {
    this.eventSource.addEventListener('progress', event => {
      const data = JSON.parse(event.data);
      this.handleProgressEvent(data);
    });
    this.eventSource.addEventListener('completion', event => {
      const data = JSON.parse(event.data);
      this.handleCompletionEvent(data);
    });
    this.eventSource.addEventListener('error', event => {
      const data = JSON.parse(event.data);
      this.handleErrorEvent(data);
    });
  }

  /**
   * Set up WebSocket event handlers
   */
  setupWebSocketHandlers() {
    this.websocket.onmessage = event => {
      try {
        const message = JSON.parse(event.data);
        switch (message.type) {
          case 'progress':
            this.handleProgressEvent(message.data);
            break;
          case 'completion':
            this.handleCompletionEvent(message.data);
            break;
          case 'error':
            this.handleErrorEvent(message.data);
            break;
        }
      } catch (error) {
        this.logger.error('Failed to parse WebSocket message', error);
      }
    };
    this.websocket.onclose = () => {
      this.handleDisconnection('WebSocket closed');
    };
  }

  /**
   * Set up fallback polling
   */
  async setupFallbackPolling(sessionId) {
    this.connectionType = 'polling';
    this.isConnected = true;
    this.fallbackPolling = setInterval(async () => {
      try {
        const response = await fetch(`/api/progress/poll/${sessionId}`);
        const data = await response.json();
        if (data.events && data.events.length > 0) {
          data.events.forEach(event => {
            switch (event.type) {
              case 'progress':
                this.handleProgressEvent(event.data);
                break;
              case 'completion':
                this.handleCompletionEvent(event.data);
                break;
              case 'error':
                this.handleErrorEvent(event.data);
                break;
            }
          });
        }
      } catch (error) {
        this.logger.error('Polling request failed', error);
      }
    }, 2000);
    this.logger.info('Fallback polling established');
    this.uiManager.showInfo('Using polling for updates (limited real-time capability)');
  }

  /**
   * Handle progress events
   */
  handleProgressEvent(data) {
    this.logger.info('Progress event received', data);
    this.triggerEvent('progress', data);
  }

  /**
   * Handle completion events
   */
  handleCompletionEvent(data) {
    this.logger.info('Completion event received', data);
    this.triggerEvent('completion', data);
    this.disconnect();
  }

  /**
   * Handle error events
   */
  handleErrorEvent(data) {
    this.logger.error('Error event received', data);
    this.triggerEvent('error', data);
  }

  /**
   * Handle disconnection
   */
  handleDisconnection(reason) {
    this.isConnected = false;
    this.logger.warn('Connection lost', {
      reason,
      type: this.connectionType
    });
    this.uiManager.showWarning('Real-time connection lost');

    // Attempt reconnection
    this.attemptReconnection();
  }

  /**
   * Handle reconnection
   */
  handleReconnection() {
    this.isConnected = true;
    this.reconnectAttempts = 0;
    this.logger.info('Connection restored');
    this.uiManager.showSuccess('Real-time connection restored');
  }

  /**
   * Attempt reconnection
   */
  async attemptReconnection() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      this.logger.error('Max reconnection attempts reached');
      this.uiManager.showError('Connection Lost', 'Unable to restore real-time connection');
      return;
    }
    this.reconnectAttempts++;
    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
    this.logger.info('Attempting reconnection', {
      attempt: this.reconnectAttempts,
      delay
    });
    setTimeout(async () => {
      try {
        // Reconnection logic depends on connection type
        if (this.connectionType === 'socketio' && this.socket) {
          this.socket.connect();
        } else {
          // For other types, we'd need the session ID
          // This would typically be handled by the calling code
        }
      } catch (error) {
        this.logger.error('Reconnection failed', error);
        this.attemptReconnection();
      }
    }, delay);
  }

  /**
   * Set up connection monitoring
   */
  setupConnectionMonitoring() {
    // Monitor connection health
    setInterval(() => {
      if (this.isConnected) {
        this.checkConnectionHealth();
      }
    }, 30000); // Check every 30 seconds
  }

  /**
   * Check connection health
   */
  checkConnectionHealth() {
    if (this.connectionType === 'socketio' && this.socket) {
      // Socket.IO has built-in heartbeat
      if (!this.socket.connected) {
        this.handleDisconnection('Health check failed');
      }
    } else if (this.connectionType === 'sse' && this.eventSource) {
      if (this.eventSource.readyState === EventSource.CLOSED) {
        this.handleDisconnection('SSE connection closed');
      }
    } else if (this.connectionType === 'websocket' && this.websocket) {
      if (this.websocket.readyState === WebSocket.CLOSED) {
        this.handleDisconnection('WebSocket connection closed');
      }
    }
  }

  /**
   * Register event handler
   */
  on(event, handler) {
    if (!this.eventHandlers.has(event)) {
      this.eventHandlers.set(event, []);
    }
    this.eventHandlers.get(event).push(handler);
  }

  /**
   * Remove event handler
   */
  off(event, handler) {
    if (this.eventHandlers.has(event)) {
      const handlers = this.eventHandlers.get(event);
      const index = handlers.indexOf(handler);
      if (index > -1) {
        handlers.splice(index, 1);
      }
    }
  }

  /**
   * Trigger event
   */
  triggerEvent(event, data) {
    if (this.eventHandlers.has(event)) {
      this.eventHandlers.get(event).forEach(handler => {
        try {
          handler(data);
        } catch (error) {
          this.logger.error('Event handler error', {
            event,
            error: error.message
          });
        }
      });
    }
  }

  /**
   * Disconnect all connections
   */
  disconnect() {
    this.isConnected = false;
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
    }
    if (this.eventSource) {
      this.eventSource.close();
      this.eventSource = null;
    }
    if (this.websocket) {
      this.websocket.close();
      this.websocket = null;
    }
    if (this.fallbackPolling) {
      clearInterval(this.fallbackPolling);
      this.fallbackPolling = null;
    }
    this.connectionType = null;
    this.logger.info('All real-time connections closed');
  }

  /**
   * Get connection status
   */
  getConnectionStatus() {
    return {
      isConnected: this.isConnected,
      connectionType: this.connectionType,
      reconnectAttempts: this.reconnectAttempts
    };
  }
}
exports.RealtimeCommunicationSubsystem = RealtimeCommunicationSubsystem;

},{"socket.io-client":31}],88:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TokenNotificationSubsystem = void 0;
var _winstonLogger = require("../utils/winston-logger.js");
/**
 * Token Notification Subsystem
 * Handles user notifications for invalid/missing tokens and disabled functionality
 */

class TokenNotificationSubsystem {
  constructor(logger, eventBus, navigationSubsystem) {
    this.logger = logger || (0, _winstonLogger.createLogger)({
      serviceName: 'token-notification-subsystem',
      environment: 'development'
    });
    this.eventBus = eventBus;
    this.navigationSubsystem = navigationSubsystem;
    this.isInitialized = false;
    this.isDestroyed = false;

    // Notification state
    this.currentNotification = null;
    this.notificationElement = null;
    this.lastTokenCheck = null;
    this.checkInterval = null;
    this.logger.info('Token Notification Subsystem initialized');
  }

  /**
   * Initialize the subsystem
   */
  async init() {
    if (this.isInitialized || this.isDestroyed) {
      return;
    }
    try {
      this.logger.debug('Initializing Token Notification Subsystem...');

      // Create notification container
      this.createNotificationContainer();

      // Set up event listeners
      this.setupEventListeners();

      // Start token monitoring
      this.startTokenMonitoring();

      // Initial token check
      this.checkTokenStatus();
      this.isInitialized = true;
      this.eventBus.emit('tokenNotification:initialized');
      this.logger.info('Token Notification Subsystem initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize Token Notification Subsystem', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    }
  }

  /**
   * Destroy the subsystem
   */
  destroy() {
    if (this.isDestroyed) {
      return;
    }
    this.logger.debug('Destroying Token Notification Subsystem...');

    // Clear monitoring
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }

    // Remove notification
    this.hideNotification();

    // Remove notification container
    if (this.notificationElement) {
      this.notificationElement.remove();
      this.notificationElement = null;
    }

    // Mark as destroyed
    this.isDestroyed = true;
    this.isInitialized = false;
    this.logger.info('Token Notification Subsystem destroyed');
  }

  /**
   * Create notification container in DOM
   */
  createNotificationContainer() {
    // Remove existing container if it exists
    const existing = document.getElementById('token-notification-container');
    if (existing) {
      existing.remove();
    }

    // Create new container
    this.notificationElement = document.createElement('div');
    this.notificationElement.id = 'token-notification-container';
    this.notificationElement.className = 'token-notification-container';
    this.notificationElement.style.display = 'none';

    // Insert at top of main content area
    const mainContent = document.querySelector('.main-content') || document.body;
    mainContent.insertBefore(this.notificationElement, mainContent.firstChild);
    this.logger.debug('Token notification container created');
  }

  /**
   * Set up event listeners
   */
  setupEventListeners() {
    // Listen for token events
    this.eventBus.on('token:refreshed', () => {
      this.logger.debug('Token refreshed event received');
      this.checkTokenStatus();
    });
    this.eventBus.on('token:expired', () => {
      this.logger.debug('Token expired event received');
      this.showTokenExpiredNotification();
    });
    this.eventBus.on('token:error', () => {
      this.logger.debug('Token error event received');
      this.showTokenErrorNotification();
    });

    // Listen for settings changes
    this.eventBus.on('settings:updated', () => {
      this.logger.debug('Settings updated event received');
      this.checkTokenStatus();
    });
    this.logger.debug('Token notification event listeners set up');
  }

  /**
   * Start token monitoring
   */
  startTokenMonitoring() {
    // Check token status every 30 seconds
    this.checkInterval = setInterval(() => {
      this.checkTokenStatus();
    }, 30000);
    this.logger.debug('Token monitoring started');
  }

  /**
   * Check current token status and show appropriate notification
   */
  checkTokenStatus() {
    try {
      const tokenInfo = this.getTokenInfo();
      if (!tokenInfo.hasToken) {
        this.showNoTokenNotification();
      } else if (tokenInfo.timeLeft <= 0) {
        this.showTokenExpiredNotification();
      } else if (tokenInfo.timeLeft <= 300) {
        // 5 minutes
        this.showTokenExpiringNotification(tokenInfo.timeLeft);
      } else {
        this.hideNotification();
      }
      this.lastTokenCheck = Date.now();
    } catch (error) {
      this.logger.error('Error checking token status', {
        error: error.message
      });
      this.showTokenErrorNotification();
    }
  }

  /**
   * Get token information from localStorage
   */
  getTokenInfo() {
    try {
      const token = localStorage.getItem('pingone_worker_token');
      const expiry = localStorage.getItem('pingone_token_expiry');
      if (!token || !expiry) {
        return {
          hasToken: false,
          timeLeft: 0
        };
      }
      const expiryTime = parseInt(expiry, 10);
      const currentTime = Math.floor(Date.now() / 1000);
      const timeLeft = expiryTime - currentTime;
      return {
        hasToken: true,
        timeLeft: Math.max(0, timeLeft),
        token: token.substring(0, 20) + '...' // Truncated for logging
      };
    } catch (error) {
      this.logger.error('Error getting token info', {
        error: error.message
      });
      return {
        hasToken: false,
        timeLeft: 0
      };
    }
  }

  /**
   * Show notification for missing token
   */
  showNoTokenNotification() {
    const message = `
            <div class="token-notification-content">
                <div class="token-notification-icon"></div>
                <div class="token-notification-text">
                    <h4>Authentication Required</h4>
                    <p>No valid PingOne token found. Most functionality is disabled until you authenticate.</p>
                    <p><strong>What you can do:</strong></p>
                    <ul>
                        <li>Go to <strong>Settings</strong> to configure your PingOne credentials</li>
                        <li>Use the <strong>Get Token</strong> button to authenticate</li>
                        <li>Check the token status widget in the sidebar</li>
                    </ul>
                </div>
                <div class="token-notification-actions">
                    <button id="go-to-settings-btn" class="btn btn-primary btn-sm">Go to Settings</button>
                    <button onclick="this.parentElement.parentElement.parentElement.style.display='none'" class="btn btn-secondary btn-sm">Dismiss</button>
                </div>
            </div>
        `;
    this.showNotification(message, 'no-token');
  }

  /**
   * Show notification for expired token
   */
  showTokenExpiredNotification() {
    const message = `
            <div class="token-notification-content">
                <div class="token-notification-icon"></div>
                <div class="token-notification-text">
                    <h4>Token Expired</h4>
                    <p>Your PingOne authentication token has expired. Please get a new token to continue using the application.</p>
                </div>
                <div class="token-notification-actions">
                    <button onclick="window.app?.subsystems?.globalTokenManager?.refreshToken?.()" class="btn btn-warning btn-sm">Refresh Token</button>
                    <button onclick="this.parentElement.parentElement.parentElement.style.display='none'" class="btn btn-secondary btn-sm">Dismiss</button>
                </div>
            </div>
        `;
    this.showNotification(message, 'expired-token');
  }

  /**
   * Show notification for expiring token
   */
  showTokenExpiringNotification(timeLeft) {
    const minutes = Math.floor(timeLeft / 60);
    const seconds = timeLeft % 60;
    const timeString = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
    const message = `
            <div class="token-notification-content">
                <div class="token-notification-icon"></div>
                <div class="token-notification-text">
                    <h4>Token Expiring Soon</h4>
                    <p>Your PingOne token will expire in <strong>${timeString}</strong>. Consider refreshing it to avoid interruption.</p>
                </div>
                <div class="token-notification-actions">
                    <button onclick="window.app?.subsystems?.globalTokenManager?.refreshToken?.()" class="btn btn-warning btn-sm">Refresh Now</button>
                    <button onclick="this.parentElement.parentElement.parentElement.style.display='none'" class="btn btn-secondary btn-sm">Dismiss</button>
                </div>
            </div>
        `;
    this.showNotification(message, 'expiring-token');
  }

  /**
   * Show notification for token error
   */
  showTokenErrorNotification() {
    const message = `
            <div class="token-notification-content">
                <div class="token-notification-icon"></div>
                <div class="token-notification-text">
                    <h4>Token Error</h4>
                    <p>There was an error with your authentication token. Please check your settings and try again.</p>
                </div>
                <div class="token-notification-actions">
                    <button onclick="window.location.hash='settings'" class="btn btn-primary btn-sm">Check Settings</button>
                    <button onclick="this.parentElement.parentElement.parentElement.style.display='none'" class="btn btn-secondary btn-sm">Dismiss</button>
                </div>
            </div>
        `;
    this.showNotification(message, 'error-token');
  }

  /**
   * Show notification with given content and type
   */
  showNotification(content, type) {
    if (!this.notificationElement) {
      this.logger.warn('Notification element not available');
      return;
    }

    // Don't show the same notification repeatedly
    if (this.currentNotification === type) {
      return;
    }
    this.notificationElement.innerHTML = content;
    this.notificationElement.className = `token-notification-container ${type}`;
    this.notificationElement.style.display = 'block';
    this.currentNotification = type;
    this.logger.debug('Token notification shown', {
      type
    });

    // Add event listener for the 'Go to Settings' button if it exists
    const goToSettingsBtn = this.notificationElement.querySelector('#go-to-settings-btn');
    if (goToSettingsBtn) {
      goToSettingsBtn.addEventListener('click', e => {
        e.preventDefault();
        if (this.navigationSubsystem) {
          this.navigationSubsystem.navigateToView('settings');
        } else {
          this.logger.error('NavigationSubsystem not available.');
          // Fallback for safety
          window.location.hash = 'settings';
        }
      });
    }
  }

  /**
   * Hide current notification
   */
  hideNotification() {
    if (this.notificationElement) {
      this.notificationElement.style.display = 'none';
      this.notificationElement.innerHTML = '';
    }
    this.currentNotification = null;
    this.logger.debug('Token notification hidden');
  }
}
exports.TokenNotificationSubsystem = TokenNotificationSubsystem;
var _default = exports.default = TokenNotificationSubsystem;

},{"../utils/winston-logger.js":92}],89:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ViewManagementSubsystem = void 0;
/**
 * View Management Subsystem
 * 
 * Handles all view transitions, navigation, and view-specific initialization.
 * Manages the single-page application navigation and view state.
 */

class ViewManagementSubsystem {
  constructor(logger, uiManager) {
    this.logger = logger;
    this.uiManager = uiManager;

    // View state management
    this.currentView = 'home';
    this.previousView = null;
    this.viewHistory = [];
    this.viewInitializers = new Map();
    this.logger.info('View Management Subsystem initialized with default home view');
  }

  /**
   * Initialize the view management subsystem
   */
  async init() {
    try {
      this.setupNavigationListeners();
      this.registerViewInitializers();
      await this.showInitialView();
      this.logger.info('View Management Subsystem initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize View Management Subsystem', error);
      throw error;
    }
  }

  /**
   * Set up navigation event listeners
   */
  setupNavigationListeners() {
    // Navigation items
    const navItems = document.querySelectorAll('[data-view]');
    navItems.forEach(item => {
      item.addEventListener('click', async e => {
        e.preventDefault();
        const view = item.getAttribute('data-view');
        await this.showView(view);
      });
    });

    // Browser back/forward buttons
    window.addEventListener('popstate', e => {
      if (e.state && e.state.view) {
        this.showView(e.state.view, false);
      }
    });

    // Keyboard navigation
    document.addEventListener('keydown', e => {
      if (e.ctrlKey || e.metaKey) {
        this.handleKeyboardNavigation(e);
      }
    });
  }

  /**
   * Register view initializers
   */
  registerViewInitializers() {
    // Import view initializer
    this.viewInitializers.set('import', async () => {
      await this.initializeImportView();
    });

    // Export view initializer
    this.viewInitializers.set('export', async () => {
      await this.initializeExportView();
    });

    // Modify view initializer
    this.viewInitializers.set('modify', async () => {
      await this.initializeModifyView();
    });

    // Delete view initializer
    this.viewInitializers.set('delete-csv', async () => {
      await this.initializeDeleteView();
    });

    // Settings view initializer
    this.viewInitializers.set('settings', async () => {
      await this.initializeSettingsView();
    });

    // Logs view initializer
    this.viewInitializers.set('logs', async () => {
      await this.initializeLogsView();
    });

    // History view initializer
    this.viewInitializers.set('history', async () => {
      await this.initializeHistoryView();
    });
  }

  /**
   * Show a specific view
   */
  async showView(view) {
    let updateHistory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    if (!view || view === this.currentView) {
      return;
    }
    try {
      this.logger.info('Switching to view', {
        from: this.currentView,
        to: view
      });

      // Validate view exists
      if (!this.isValidView(view)) {
        if (this.uiManager && typeof this.uiManager.showError === 'function') {
          this.uiManager.showError('Navigation Error', `Invalid view: ${view}`);
        }
        return;
      }

      // Store previous view
      this.previousView = this.currentView;

      // Hide current view
      this.hideCurrentView();

      // Show new view
      await this.displayView(view);

      // Update navigation state
      this.updateNavigationState(view);

      // Update browser history
      if (updateHistory) {
        this.updateBrowserHistory(view);
      }

      // Initialize view-specific logic
      await this.initializeView(view);

      // Update view state
      this.currentView = view;
      this.viewHistory.push(view);

      // Update page title
      this.updatePageTitle(view);

      // Trigger view change event
      this.triggerViewChangeEvent(view, this.previousView);
    } catch (error) {
      this.logger.error('Failed to switch view', {
        view,
        error: error.message
      });
      if (this.uiManager && typeof this.uiManager.showError === 'function') {
        this.uiManager.showError('Navigation Error', `Failed to switch to ${view} view: ${error.message}`);
      }
    }
  }

  /**
   * Hide the current view
   */
  hideCurrentView() {
    const currentViewElement = document.getElementById(`${this.currentView}-view`);
    if (currentViewElement) {
      currentViewElement.style.display = 'none';
      currentViewElement.classList.remove('active');
    }
  }

  /**
   * Display the specified view
   */
  async displayView(view) {
    const viewElement = document.getElementById(`${view}-view`);
    if (!viewElement) {
      throw new Error(`View element not found: ${view}-view`);
    }

    // Show view with animation
    viewElement.style.display = 'block';
    viewElement.classList.add('active');

    // Add fade-in animation
    viewElement.style.opacity = '0';
    viewElement.style.transition = 'opacity 0.3s ease-in-out';

    // Trigger reflow and fade in
    requestAnimationFrame(() => {
      viewElement.style.opacity = '1';
    });
  }

  /**
   * Update navigation state
   */
  updateNavigationState(view) {
    // Update navigation items
    const navItems = document.querySelectorAll('[data-view]');
    navItems.forEach(item => {
      const itemView = item.getAttribute('data-view');
      if (itemView === view) {
        item.classList.add('active');
      } else {
        item.classList.remove('active');
      }
    });

    // Update page title
    this.updatePageTitle(view);
  }

  /**
   * Update browser history
   */
  updateBrowserHistory(view) {
    const state = {
      view,
      timestamp: Date.now()
    };
    const title = this.getViewTitle(view);
    const url = `#${view}`;
    history.pushState(state, title, url);
  }

  /**
   * Initialize view-specific functionality
   */
  async initializeView(view) {
    const initializer = this.viewInitializers.get(view);
    if (initializer) {
      try {
        await initializer();
      } catch (error) {
        this.logger.error('View initialization failed', {
          view,
          error: error.message
        });
      }
    }
  }

  /**
   * Initialize import view
   */
  async initializeImportView() {
    // Load populations for import dropdown
    if (window.app && typeof window.app.loadPopulations === 'function') {
      await window.app.loadPopulations('import-population-select');
    }

    // Reset file input
    const fileInput = document.getElementById('csv-file');
    if (fileInput) {
      fileInput.value = '';
    }

    // Reset progress display
    this.resetProgressDisplay();
  }

  /**
   * Initialize export view
   */
  async initializeExportView() {
    // Load populations for export dropdown
    if (window.exportManager && typeof window.exportManager.loadPopulations === 'function') {
      await window.exportManager.loadPopulations();
    }
  }

  /**
   * Initialize modify view
   */
  async initializeModifyView() {
    // Load populations for modify dropdown
    if (window.app && typeof window.app.loadPopulations === 'function') {
      await window.app.loadPopulations('modify-population-select');
    }

    // Reset file input
    const fileInput = document.getElementById('modify-csv-file');
    if (fileInput) {
      fileInput.value = '';
    }
  }

  /**
   * Initialize delete view
   */
  async initializeDeleteView() {
    // Load populations for delete dropdown
    if (window.deleteManager && typeof window.deleteManager.loadPopulations === 'function') {
      await window.deleteManager.loadPopulations();
    }
  }

  /**
   * Initialize settings view
   */
  async initializeSettingsView() {
    // Load current settings
    if (window.app && typeof window.app.loadSettings === 'function') {
      await window.app.loadSettings();
    }
  }

  /**
   * Initialize logs view
   */
  async initializeLogsView() {
    // Load logs
    if (window.logManager && typeof window.logManager.loadLogs === 'function') {
      await window.logManager.loadLogs();
    }
  }

  /**
   * Initialize history view
   */
  async initializeHistoryView() {
    try {
      // Initialize history UI component if available
      if (this.app && this.app.subsystems && this.app.subsystems.history) {
        this.logger.debug('Initializing history view with HistorySubsystem');

        // The history UI component will be initialized by the main app
        // Just ensure the view container exists
        const historyView = document.getElementById('history-view');
        if (!historyView) {
          this.logger.warn('History view container not found');
        }
      } else {
        this.logger.warn('HistorySubsystem not available for history view initialization');
      }
    } catch (error) {
      this.logger.error('Failed to initialize history view:', error);
    }
  }

  /**
   * Show initial view based on URL hash or default
   */
  async showInitialView() {
    let initialView = 'home';

    // Check URL hash for the initial view
    const hash = window.location.hash.substring(1);
    if (hash && this.isValidView(hash)) {
      initialView = hash;
    }
    await this.showView(initialView, false);
  }

  /**
   * Check if view is valid
   */
  isValidView(view) {
    const validViews = ['home', 'import', 'export', 'modify', 'delete-csv', 'settings', 'logs', 'history'];
    return validViews.includes(view);
  }

  /**
   * Get view title
   */
  getViewTitle(view) {
    const titles = {
      'import': 'Import Users',
      'export': 'Export Users',
      'modify': 'Modify Users',
      'delete-csv': 'Delete Users',
      'settings': 'Settings',
      'logs': 'Logs',
      'history': 'History'
    };
    return titles[view] || 'PingOne Import Tool';
  }

  /**
   * Update page title
   */
  updatePageTitle(view) {
    const title = this.getViewTitle(view);
    document.title = `${title} - PingOne Import Tool`;
  }

  /**
   * Handle keyboard navigation
   */
  handleKeyboardNavigation(e) {
    const keyMap = {
      '1': 'import',
      '2': 'export',
      '3': 'modify',
      '4': 'delete-csv',
      '5': 'settings',
      '6': 'logs',
      '7': 'history'
    };
    const view = keyMap[e.key];
    if (view) {
      e.preventDefault();
      this.showView(view);
    }
  }

  /**
   * Reset progress display
   */
  resetProgressDisplay() {
    // Use uiManager to hide progress and reset bar
    if (this.uiManager && typeof this.uiManager.hideProgress === 'function') {
      this.uiManager.hideProgress();
    }
    if (this.uiManager && typeof this.uiManager.updateProgress === 'function') {
      this.uiManager.updateProgress(0, 1, ''); // Reset bar
    }
  }

  /**
   * Trigger view change event
   */
  triggerViewChangeEvent(newView, oldView) {
    const event = new CustomEvent('viewChanged', {
      detail: {
        newView,
        oldView,
        timestamp: Date.now()
      }
    });
    document.dispatchEvent(event);
  }

  /**
   * Go back to previous view
   */
  async goBack() {
    if (this.previousView) {
      await this.showView(this.previousView);
    }
  }

  /**
   * Get current view
   */
  getCurrentView() {
    return this.currentView;
  }

  /**
   * Get view history
   */
  getViewHistory() {
    return [...this.viewHistory];
  }

  /**
   * Clear view history
   */
  clearViewHistory() {
    this.viewHistory = [];
  }
}
exports.ViewManagementSubsystem = ViewManagementSubsystem;

},{}],90:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BrowserLoggingService = void 0;
exports.createLogger = createLogger;
exports.logger = exports.default = void 0;
/**
 * Browser-Compatible Logging Service
 * 
 * Provides unified logging for browser environment with:
 * - Correlation IDs for request tracking
 * - Structured logging with metadata
 * - Console and server transports
 * - Log level filtering
 * - Performance monitoring
 */

class BrowserLoggingService {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.serviceName = options.serviceName || 'pingone-import-client';
    this.environment = options.environment || 'development';
    this.logLevel = options.logLevel || this.getDefaultLogLevel();
    this.enableConsole = options.enableConsole !== false;
    this.enableServer = options.enableServer !== false;

    // Log levels hierarchy
    this.levels = {
      error: 0,
      warn: 1,
      info: 2,
      debug: 3
    };

    // Correlation ID for request tracking
    this.correlationId = this.generateCorrelationId();

    // Performance tracking
    this.performanceMarks = new Map();
    this.initializeTransports();
  }

  /**
   * Get default log level based on environment
   */
  getDefaultLogLevel() {
    switch (this.environment) {
      case 'production':
        return 'info';
      case 'test':
        return 'warn';
      default:
        return 'debug';
    }
  }

  /**
   * Generate correlation ID for request tracking
   */
  generateCorrelationId() {
    return `${this.serviceName}-${Date.now()}-${Math.random().toString(36).substr(2, 8)}`;
  }

  /**
   * Initialize logging transports
   */
  initializeTransports() {
    this.transports = [];
    if (this.enableConsole) {
      this.transports.push({
        name: 'console',
        log: this.logToConsole.bind(this)
      });
    }
    if (this.enableServer) {
      this.transports.push({
        name: 'server',
        log: this.logToServer.bind(this)
      });
    }
  }

  /**
   * Check if log level should be processed
   */
  shouldLog(level) {
    return this.levels[level] <= this.levels[this.logLevel];
  }

  /**
   * Format log entry with metadata
   */
  formatLogEntry(level, message) {
    let meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return {
      timestamp: new Date().toISOString(),
      level: level.toUpperCase(),
      message,
      service: this.serviceName,
      environment: this.environment,
      correlationId: this.correlationId,
      source: 'client',
      url: window.location.href,
      userAgent: navigator.userAgent,
      ...meta
    };
  }

  /**
   * Log to console with formatting
   */
  logToConsole(level, message) {
    let meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (!this.shouldLog(level)) return;
    const entry = this.formatLogEntry(level, message, meta);
    const timestamp = entry.timestamp;
    const correlationId = entry.correlationId.slice(-8);
    let consoleMessage = `[${timestamp}] [${correlationId}] [${entry.service}] ${level.toUpperCase()}: ${message}`;
    if (Object.keys(meta).length > 0) {
      consoleMessage += `\n${JSON.stringify(meta, null, 2)}`;
    }
    switch (level) {
      case 'error':
        console.error(consoleMessage);
        break;
      case 'warn':
        console.warn(consoleMessage);
        break;
      case 'info':
        console.info(consoleMessage);
        break;
      case 'debug':
        console.debug(consoleMessage);
        break;
      default:
        console.log(consoleMessage);
    }
  }

  /**
   * Log to server via API endpoint
   */
  async logToServer(level, message) {
    let meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    try {
      const entry = this.formatLogEntry(level, message, meta);
      await fetch('/api/logs/client', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(entry)
      });
    } catch (error) {
      // Silently fail to avoid infinite loops
      if (this.enableConsole) {
        console.warn('Failed to send log to server:', error.message);
      }
    }
  }

  /**
   * Main logging method
   */
  log(level, message) {
    let meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (!this.shouldLog(level)) return;
    this.transports.forEach(transport => {
      try {
        transport.log(level, message, meta);
      } catch (error) {
        console.error(`Error in ${transport.name} transport:`, error);
      }
    });
  }

  /**
   * Convenience methods
   */
  error(message) {
    let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.log('error', message, meta);
  }
  warn(message) {
    let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.log('warn', message, meta);
  }
  info(message) {
    let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.log('info', message, meta);
  }
  debug(message) {
    let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.log('debug', message, meta);
  }

  /**
   * Performance monitoring
   */
  startTimer(label) {
    this.performanceMarks.set(label, performance.now());
    this.debug(`Timer started: ${label}`);
  }
  endTimer(label) {
    let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const startTime = this.performanceMarks.get(label);
    if (!startTime) {
      this.warn(`Timer not found: ${label}`);
      return 0;
    }
    const duration = performance.now() - startTime;
    this.performanceMarks.delete(label);
    this.info(`Timer completed: ${label}`, {
      duration: `${duration.toFixed(2)}ms`,
      ...meta
    });
    return duration;
  }

  /**
   * Create child logger with additional context
   */
  child() {
    let additionalMeta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const childLogger = new BrowserLoggingService({
      serviceName: this.serviceName,
      environment: this.environment,
      logLevel: this.logLevel,
      enableConsole: this.enableConsole,
      enableServer: this.enableServer
    });

    // Override formatLogEntry to include additional metadata
    const originalFormatLogEntry = childLogger.formatLogEntry.bind(childLogger);
    childLogger.formatLogEntry = function (level, message) {
      let meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return originalFormatLogEntry(level, message, {
        ...additionalMeta,
        ...meta
      });
    };
    return childLogger;
  }

  /**
   * Set correlation ID (useful for request tracking)
   */
  setCorrelationId(correlationId) {
    this.correlationId = correlationId;
  }

  /**
   * Get current correlation ID
   */
  getCorrelationId() {
    return this.correlationId;
  }
}

/**
 * Create logger instance
 */
exports.BrowserLoggingService = BrowserLoggingService;
function createLogger() {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return new BrowserLoggingService(options);
}

/**
 * Default logger instance
 */
const logger = exports.logger = createLogger({
  serviceName: 'pingone-import-client'
});
var _default = exports.default = BrowserLoggingService;

},{}],91:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.debugLog = void 0;
exports.getClientDebugLogger = getClientDebugLogger;
/**
 * Client-Side Debug Logger
 * 
 * Browser-compatible version of the debug logger that sends logs to the server.
 */

class ClientDebugLogger {
  constructor() {
    this.sessionId = this.generateSessionId();
    this.isClient = true;

    // Initialize with session start
    this.log('SESSION_START', 'Client debug logging session started', {
      timestamp: new Date().toISOString(),
      sessionId: this.sessionId,
      userAgent: navigator.userAgent,
      url: window.location.href
    });
  }
  generateSessionId() {
    return 'client_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  }
  formatLogEntry(level, category, message) {
    let data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    const timestamp = new Date().toISOString();
    const entry = {
      timestamp,
      sessionId: this.sessionId,
      level: level.toUpperCase(),
      category: category.toUpperCase(),
      message,
      environment: 'client',
      url: window.location.href,
      data: data || {}
    };

    // Format as readable string
    const formattedEntry = `[${timestamp}] [${this.sessionId}] [CLIENT] [${level.toUpperCase()}] [${category.toUpperCase()}] ${message}`;
    const dataString = Object.keys(data).length > 0 ? `\n  Data: ${JSON.stringify(data, null, 2)}` : '';
    return formattedEntry + dataString + '\n' + '-'.repeat(80) + '\n';
  }
  async sendToServer(entry) {
    try {
      await fetch('/api/debug-log', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          entry
        })
      });
    } catch (error) {
      console.error('Failed to send debug log to server:', error);
    }
  }

  // Main logging method
  log(category, message) {
    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const entry = this.formatLogEntry('info', category, message, data);
    this.sendToServer(entry);

    // Also log to console in development
    console.log(` [${category.toUpperCase()}] ${message}`, data);
  }

  // Error logging
  error(category, message) {
    let error = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    let data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    const errorData = {
      ...data,
      error: error ? {
        message: error.message,
        stack: error.stack,
        name: error.name
      } : null
    };
    const entry = this.formatLogEntry('error', category, message, errorData);
    this.sendToServer(entry);

    // Always log errors to console
    console.error(` [${category.toUpperCase()}] ${message}`, errorData);
  }

  // Warning logging
  warn(category, message) {
    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const entry = this.formatLogEntry('warn', category, message, data);
    this.sendToServer(entry);
    console.warn(` [${category.toUpperCase()}] ${message}`, data);
  }

  // Debug logging
  debug(category, message) {
    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const entry = this.formatLogEntry('debug', category, message, data);
    this.sendToServer(entry);
    console.debug(` [${category.toUpperCase()}] ${message}`, data);
  }

  // Event logging
  event(category, eventName) {
    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const eventData = {
      eventName,
      ...data
    };
    const entry = this.formatLogEntry('event', category, `Event: ${eventName}`, eventData);
    this.sendToServer(entry);
    console.log(` [${category.toUpperCase()}] Event: ${eventName}`, eventData);
  }

  // Performance logging
  performance(category, operation, duration) {
    let data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    const perfData = {
      operation,
      duration: `${duration}ms`,
      ...data
    };
    const entry = this.formatLogEntry('perf', category, `Performance: ${operation}`, perfData);
    this.sendToServer(entry);
    console.log(` [${category.toUpperCase()}] Performance: ${operation} (${duration}ms)`, perfData);
  }

  // Navigation logging
  navigation(from, to) {
    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    this.event('navigation', 'view_change', {
      from,
      to,
      ...data
    });
  }

  // API logging
  api(method, url, status, duration) {
    let data = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    this.event('api', 'request', {
      method,
      url,
      status,
      duration: `${duration}ms`,
      ...data
    });
  }

  // User action logging
  userAction(action, element) {
    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    this.event('user', action, {
      element,
      ...data
    });
  }

  // System state logging
  systemState(component, state) {
    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    this.log('system', `${component} state: ${state}`, data);
  }

  // Feature flag logging
  featureFlag(flag, enabled) {
    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    this.log('feature', `Feature flag ${flag}: ${enabled ? 'enabled' : 'disabled'}`, data);
  }

  // Subsystem logging
  subsystem(name, action) {
    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    this.log('subsystem', `${name}: ${action}`, data);
  }
}

// Create singleton instance
let clientDebugLogger = null;
function getClientDebugLogger() {
  if (!clientDebugLogger) {
    clientDebugLogger = new ClientDebugLogger();
  }
  return clientDebugLogger;
}

// Convenience exports
const debugLog = exports.debugLog = {
  log: (category, message, data) => getClientDebugLogger().log(category, message, data),
  error: (category, message, error, data) => getClientDebugLogger().error(category, message, error, data),
  warn: (category, message, data) => getClientDebugLogger().warn(category, message, data),
  debug: (category, message, data) => getClientDebugLogger().debug(category, message, data),
  event: (category, eventName, data) => getClientDebugLogger().event(category, eventName, data),
  performance: (category, operation, duration, data) => getClientDebugLogger().performance(category, operation, duration, data),
  navigation: (from, to, data) => getClientDebugLogger().navigation(from, to, data),
  api: (method, url, status, duration, data) => getClientDebugLogger().api(method, url, status, duration, data),
  userAction: (action, element, data) => getClientDebugLogger().userAction(action, element, data),
  systemState: (component, state, data) => getClientDebugLogger().systemState(component, state, data),
  featureFlag: (flag, enabled, data) => getClientDebugLogger().featureFlag(flag, enabled, data),
  subsystem: (name, action, data) => getClientDebugLogger().subsystem(name, action, data)
};
var _default = exports.default = debugLog;

},{}],92:[function(require,module,exports){
arguments[4][70][0].apply(exports,arguments)
},{"_process":29,"dup":70}],93:[function(require,module,exports){
(function (process){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FEATURE_FLAGS = void 0;
exports.getEnabledFeatures = getEnabledFeatures;
exports.getFeatureFlagStatus = getFeatureFlagStatus;
exports.isFeatureEnabled = isFeatureEnabled;
exports.setFeatureFlag = setFeatureFlag;
/**
 * Feature Flags Configuration
 * 
 * Centralized feature flag management for gradual subsystem rollout
 * and A/B testing capabilities.
 */

const FEATURE_FLAGS = exports.FEATURE_FLAGS = {
  // Logging and monitoring
  USE_CENTRALIZED_LOGGING: true,
  ENABLE_PERFORMANCE_MONITORING: true,
  ENABLE_ERROR_TRACKING: true,
  // Subsystem rollout flags
  USE_NAVIGATION_SUBSYSTEM: false,
  // Disabled to avoid conflict with ViewManagementSubsystem
  USE_CONNECTION_MANAGER: true,
  USE_AUTH_MANAGEMENT: true,
  USE_VIEW_MANAGEMENT: true,
  USE_OPERATION_MANAGER: true,
  USE_IMPORT_SUBSYSTEM: true,
  USE_EXPORT_SUBSYSTEM: true,
  USE_REALTIME_SUBSYSTEM: true,
  // UI enhancements
  ENABLE_ADVANCED_PROGRESS_UI: true,
  ENABLE_DRAG_DROP_IMPROVEMENTS: true,
  ENABLE_KEYBOARD_SHORTCUTS: false,
  // API optimizations
  ENABLE_REQUEST_BATCHING: false,
  ENABLE_RESPONSE_CACHING: false,
  ENABLE_RETRY_LOGIC: true,
  // Development and debugging
  ENABLE_DEBUG_MODE: process.env.NODE_ENV === 'development',
  ENABLE_VERBOSE_LOGGING: process.env.NODE_ENV === 'development',
  SHOW_PERFORMANCE_METRICS: process.env.NODE_ENV === 'development'
};

/**
 * Check if a feature is enabled
 */
function isFeatureEnabled(featureName) {
  return FEATURE_FLAGS[featureName] === true;
}

/**
 * Get all enabled features
 */
function getEnabledFeatures() {
  return Object.entries(FEATURE_FLAGS).filter(_ref => {
    let [_, enabled] = _ref;
    return enabled;
  }).map(_ref2 => {
    let [feature, _] = _ref2;
    return feature;
  });
}

/**
 * Get feature flag status for debugging
 */
function getFeatureFlagStatus() {
  return {
    total: Object.keys(FEATURE_FLAGS).length,
    enabled: getEnabledFeatures().length,
    flags: FEATURE_FLAGS,
    environment: process.env.NODE_ENV || 'development'
  };
}

/**
 * Runtime feature flag override (for testing)
 */
function setFeatureFlag(featureName, enabled) {
  if (process.env.NODE_ENV === 'development') {
    FEATURE_FLAGS[featureName] = enabled;
    console.log(`Feature flag ${featureName} set to ${enabled}`);
  } else {
    console.warn('Feature flags can only be modified in development mode');
  }
}
var _default = exports.default = FEATURE_FLAGS;

}).call(this)}).call(this,require('_process'))
},{"_process":29}]},{},[71]);
