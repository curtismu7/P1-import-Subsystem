/**
 * UI Components
 * 
 * Consolidated JavaScript for PingOne Import Tool
 * Generated: 2025-08-06T19:05:53.924Z
 * 
 * This file was automatically generated by js-cleanup-script.js
 * Organized for better maintainability and performance
 */


/* From: public/js/modules/ui-manager.js */
/**
 * UI Manager for PingOne Import Tool
 * 
 * Handles all UI interactions including:
 * - Status bar notifications
 * - Progress indicators
 * - Error handling and display
 * - View management
 * - Centralized logging and error reporting
 */

import { ElementRegistry } from './element-registry.js';
import { createSafeLogger } from '../../../src/client/utils/safe-logger.js';

class UIManager {
    /**
     * Create a new UIManager instance
     * @param {Object} options - Configuration options
     * @param {Object} options.errorManager - Error manager instance
     * @param {Object} options.logManager - Log manager instance
     * @param {string} options.instanceId - Unique identifier for this UIManager instance
     */
    constructor({ errorManager, logManager, instanceId = 'default' } = {}) {
        // Initialize safe logger with context
        this.logger = createSafeLogger(logManager?.getLogger('UIManager') || console, {
            level: process.env.LOG_LEVEL || 'INFO',
            defaultMeta: {
                component: 'UIManager',
                instanceId,
                env: process.env.NODE_ENV || 'development'
            }
        });
        
        // Initialize error manager with safe logging
        this.errorManager = errorManager || {
            handleError: (error, context = {}) => {
                this.logger.error('Unhandled error', { 
                    error: error instanceof Error ? error.message : String(error),
                    stack: error.stack,
                    ...context 
                });
                
                // Show error in UI if possible
                if (this.statusBarElement) {
                    this.showError(error.message || 'An error occurred', {
                        autoDismiss: false,
                        errorId: context.errorId || 'unhandled-error'
                    });
                }
            }
        };
        
        // Initialize UI element references
        this.notificationContainer = null;
        this.progressContainer = null;
        this.tokenStatusElement = null;
        this.connectionStatusElement = null;
        this.statusBarElement = null;
        this.statusBarTimeout = null;
        
        // Initialize the UI manager
        this.initialize();
    }
    
    /**
     * Initialize the UI manager
     */
    initialize() {
        try {
            this.setupElements();
            this.logger.log('[UIManager] Initialized successfully');
        } catch (error) {
            this.logger.error('[UIManager] Error during initialization:', error);
        }
    }
    
    /**
     * Set up DOM element references
     */
    setupElements() {
        try {
            // Status bar element
            this.statusBarElement = document.getElementById('global-status-bar');
            
            // If status bar doesn't exist, create it
            if (!this.statusBarElement) {
                this.createStatusBar();
            }
            
            // Other UI elements
            this.notificationContainer = ElementRegistry.notificationContainer?.() || 
                                      document.querySelector('.notification-container');
            
            this.progressContainer = ElementRegistry.progressContainer?.() || 
                                   document.querySelector('.progress-container');
            
            this.tokenStatusElement = ElementRegistry.tokenStatus?.() || 
                                    document.querySelector('.token-status');
            
            this.connectionStatusElement = ElementRegistry.connectionStatus?.() || 
                                         document.querySelector('.connection-status');
            
            this.logger.log('[UIManager] UI elements initialized');
            
        } catch (error) {
            this.logger.error('[UIManager] Error setting up UI elements:', error);
        }
    }
    
    /**
     * Create a status bar if it doesn't exist
     */
    createStatusBar() {
        try {
            this.statusBarElement = document.createElement('div');
            this.statusBarElement.id = 'global-status-bar';
            this.statusBarElement.className = 'global-status-bar';
            this.statusBarElement.style.display = 'none';
            this.statusBarElement.setAttribute('role', 'status');
            this.statusBarElement.setAttribute('aria-live', 'polite');
            
            const container = document.createElement('div');
            container.className = 'status-container';
            
            const content = document.createElement('div');
            content.className = 'status-content';
            
            const icon = document.createElement('i');
            icon.className = 'status-icon fas';
            
            const text = document.createElement('span');
            text.className = 'status-text';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'status-close';
            closeBtn.setAttribute('aria-label', 'Dismiss message');
            closeBtn.innerHTML = '<i class="fas fa-times"></i>';
            closeBtn.addEventListener('click', () => this.clearStatusBar());
            
            content.appendChild(icon);
            content.appendChild(text);
            content.appendChild(closeBtn);
            container.appendChild(content);
            this.statusBarElement.appendChild(container);
            
            // Add to the top of the main content or body
            const mainContent = document.querySelector('main') || document.body;
            mainContent.insertBefore(this.statusBarElement, mainContent.firstChild);
            
            this.logger.log('[UIManager] Created status bar element');
            
        } catch (error) {
            this.logger.error('[UIManager] Error creating status bar:', error);
        }
    }
    
    /**
     * Show a status message in the status bar
     * @param {string} message - The message to display
     * @param {string} [type='info'] - Message type (info, success, warning, error)
     * @param {Object} [options] - Additional options
     * @param {number} [options.duration=5000] - Duration in milliseconds to show the message
     * @param {boolean} [options.autoDismiss=true] - Whether to auto-dismiss the message
     * @param {string} [options.errorId] - Unique error ID for tracking
     * @param {Object} [options.context] - Additional context for the message
     * @param {string} [options.source] - Source of the status message
     */
    showStatusBar(message, type = 'info', options = {}) {
        const { 
            duration = 5000, 
            autoDismiss = true, 
            errorId, 
            context = {},
            source = 'ui'
        } = options;
        
        // Log the status update
        const logContext = {
            type,
            duration,
            autoDismiss,
            errorId,
            source,
            ...context
        };
        
        switch (type) {
            case 'error':
                this.logger.error(message, logContext);
                break;
            case 'warn':
            case 'warning':
                this.logger.warn(message, logContext);
                break;
            case 'success':
                this.logger.info(`SUCCESS: ${message}`, logContext);
                break;
            case 'debug':
                this.logger.debug(message, logContext);
                break;
            default:
                this.logger.info(message, logContext);
        }
        if (!this.statusBarElement) {
            this.logger.warn('[UIManager] Status bar not available');
            return;
        }
        
        try {
            // Update status bar content
            const content = this.statusBarElement.querySelector('.status-content');
            const icon = this.statusBarElement.querySelector('.status-icon');
            const text = this.statusBarElement.querySelector('.status-text');
            
            if (content && icon && text) {
                // Update classes based on message type
                content.className = 'status-content';
                content.classList.add(`status-${type}`);
                
                // Set appropriate icon
                const iconMap = {
                    'success': 'check-circle',
                    'warning': 'exclamation-triangle',
                    'error': 'exclamation-circle',
                    'info': 'info-circle'
                };
                
                const iconClass = iconMap[type] || 'info-circle';
                icon.className = `status-icon fas fa-${iconClass}`;
                
                // Set message text
                text.textContent = message;
                
                // Show the status bar
                this.statusBarElement.style.display = 'block';
                
                // Auto-dismiss if enabled
                if (autoDismiss) {
                    this.scheduleStatusBarClear(duration);
                }
                
                this.logger.log(`[UIManager] Status bar updated (${type}):`, message);
            }
            
        } catch (error) {
            this.logger.error('[UIManager] Error showing status bar:', error);
        }
    }
    
    /**
     * Handle and display an error
     * @param {Error|string|Object} error - The error to handle
     * @param {Object} [context={}] - Additional context about the error
     * @param {string} [context.errorId] - Unique error identifier for tracking
     * @param {boolean} [context.showInUI=true] - Whether to show the error in the UI
     * @param {string} [context.source] - Source of the error
     * @returns {Error} The processed error object
     */
    handleError(error, context = {}) {
        const { 
            errorId = `err-${Date.now()}`,
            showInUI = true,
            source = 'ui',
            ...restContext 
        } = context;
        
        let errorMessage;
        let errorObj;
        
        // Normalize the error
        if (error instanceof Error) {
            errorMessage = error.message;
            errorObj = error;
        } else if (typeof error === 'object' && error !== null) {
            errorMessage = error.message || JSON.stringify(error);
            errorObj = new Error(errorMessage);
            Object.assign(errorObj, error);
        } else {
            errorMessage = String(error);
            errorObj = new Error(errorMessage);
        }
        
        // Add error ID to the error object
        errorObj.errorId = errorId;
        
        // Prepare error context for logging
        const errorContext = {
            errorId,
            source,
            showInUI,
            stack: errorObj.stack,
            ...restContext
        };
        
        // Log the error
        this.logger.error(errorMessage, errorContext);
        
        // Show in UI if enabled
        if (showInUI) {
            this.showStatusBar(errorMessage, 'error', {
                autoDismiss: false,
                errorId,
                source,
                context: errorContext
            });
        }
        
        // Pass to error manager if available
        if (this.errorManager) {
            this.errorManager.handleError(errorObj, errorContext);
        } else {
            // Fallback error handling
            console.error(`[${errorId}] ${errorMessage}`, errorContext);
        }
        
        return errorObj;
    }
    
    /**
     * Schedule the status bar to be cleared after a delay
     * @param {number} duration - Delay in milliseconds
     */
    scheduleStatusBarClear(duration) {
        // Clear any existing timeout
        if (this.statusBarTimeout) {
            clearTimeout(this.statusBarTimeout);
        }
        
        // Set new timeout
        this.statusBarTimeout = setTimeout(() => {
            this.clearStatusBar();
        }, duration);
    }
    
    /**
     * Clear the status bar with animation and proper cleanup
     * @param {Object} [options] - Additional options
     * @param {boolean} [options.force=false] - Force immediate hide without animation
     */
    clearStatusBar(options = {}) {
        const { force = false } = options;
        
        if (!this.statusBarElement) {
            this.logger.debug('Status bar element not available for clearing');
            return;
        }
        
        // Clear any pending timeout to prevent race conditions
        this.cancelPendingStatusBarClear();
        
        try {
            if (force) {
                // Immediate hide without animation
                this.statusBarElement.style.display = 'none';
                this.cleanupStatusBarContent();
            } else {
                // Animated fade out
                this.statusBarElement.style.transition = 'opacity 0.3s ease-in-out';
                this.statusBarElement.style.opacity = '0';
                
                // Wait for animation to complete before hiding and cleaning up
                this.statusBarTimeout = setTimeout(() => {
                    this.statusBarElement.style.display = 'none';
                    this.statusBarElement.style.opacity = '1';
                    this.cleanupStatusBarContent();
                    this.statusBarTimeout = null;
                }, 300);
            }
        } catch (error) {
            this.logger.error('Failed to clear status bar', { 
                error: error.message,
                stack: error.stack,
                force
            });
            // Fallback to immediate hide
            if (this.statusBarElement) {
                this.statusBarElement.style.display = 'none';
                this.cleanupStatusBarContent();
            }
        }
    }
    
    /**
     * Clean up status bar content and reset its state
     * @private
     */
    cleanupStatusBarContent() {
        if (!this.statusBarElement) return;
        
        try {
            // Clear text content
            const textElements = this.statusBarElement.querySelectorAll('.status-text, .status-icon');
            textElements.forEach(el => {
                if (el) el.textContent = '';
            });
            
            // Reset classes and attributes
            const content = this.statusBarElement.querySelector('.status-content');
            if (content) {
                content.className = 'status-content';
                content.removeAttribute('title');
                content.removeAttribute('aria-label');
            }
            
            // Reset any inline styles
            this.statusBarElement.style.cssText = '';
            
        } catch (error) {
            this.logger.error('Failed to clean up status bar content', {
                error: error.message,
                stack: error.stack
            });
        }
    }
    
    /**
     * Cancel any pending status bar clear timeout
     * @private
     */
    cancelPendingStatusBarClear() {
        if (this.statusBarTimeout) {
            clearTimeout(this.statusBarTimeout);
            this.statusBarTimeout = null;
        }
    }
    
    /**
     * Clean up all UI resources and event listeners
     * @returns {Promise<void>}
     */
    async cleanup() {
        try {
            this.logger.debug('Starting UIManager cleanup');
            
            // Clear any pending timeouts
            this.cancelPendingStatusBarClear();
            
            // Reset status bar
            this.clearStatusBar({ force: true });
            
            // Clean up any active notifications
            if (this.notificationContainer) {
                try {
                    this.notificationContainer.innerHTML = '';
                } catch (error) {
                    this.logger.error('Failed to clean up notifications', { error: error.message });
                }
            }
            
            // Clean up progress indicators
            if (this.progressContainer) {
                try {
                    this.progressContainer.innerHTML = '';
                } catch (error) {
                    this.logger.error('Failed to clean up progress indicators', { error: error.message });
                }
            }
            
            // Reset element references (but don't remove from DOM)
            this.statusBarElement = null;
            this.notificationContainer = null;
            this.progressContainer = null;
            this.tokenStatusElement = null;
            this.connectionStatusElement = null;
            
            this.logger.info('UIManager cleanup completed');
        } catch (error) {
            this.logger.error('Error during UIManager cleanup', { 
                error: error.message,
                stack: error.stack
            });
            throw error;
        }
    }
    
    // Helper methods for different message types
    showInfo(message, options) {
        this.showStatusBar(message, 'info', options);
    }
    
    showSuccess(message, options) {
        this.showStatusBar(message, 'success', options);
    }
    
    showWarning(message, options) {
        this.showStatusBar(message, 'warning', options);
    }
    
    showError(message, options) {
        this.showStatusBar(message, 'error', { ...options, autoDismiss: false });
    }
}

// Export the UIManager class
export { UIManager };



/* From: public/js/modules/ui-manager-fixed.js */
/**
 * UI Manager for PingOne Import Tool
 * 
 * Handles all UI interactions including:
 * - Status bar notifications
 * - Progress indicators
 * - Error handling and display
 * - View management
 * - Centralized logging and error reporting
 */

import { ElementRegistry } from './element-registry.js';
import { createSafeLogger } from '../../src/client/utils/safe-logger.js';

class UIManager {
    /**
     * Create a new UIManager instance
     * @param {Object} options - Configuration options
     * @param {Object} options.errorManager - Error manager instance
     * @param {Object} options.logManager - Log manager instance
     * @param {string} options.instanceId - Unique identifier for this UIManager instance
     */
    constructor({ errorManager, logManager, instanceId = 'default' } = {}) {
        // Initialize safe logger with context
        this.logger = createSafeLogger(logManager?.getLogger('UIManager') || console, {
            level: process.env.LOG_LEVEL || 'INFO',
            defaultMeta: {
                component: 'UIManager',
                instanceId,
                env: process.env.NODE_ENV || 'development'
            }
        });
        
        // Initialize error manager with safe logging
        this.errorManager = errorManager || {
            handleError: (error, context = {}) => {
                this.logger.error('Unhandled error', { 
                    error: error instanceof Error ? error.message : String(error),
                    stack: error.stack,
                    ...context 
                });
                
                // Show error in UI if possible
                if (this.statusBarElement) {
                    this.showError(error.message || 'An error occurred', {
                        autoDismiss: false,
                        errorId: context.errorId || 'unhandled-error'
                    });
                }
            }
        };
        
        // Initialize UI element references
        this.notificationContainer = null;
        this.progressContainer = null;
        this.tokenStatusElement = null;
        this.connectionStatusElement = null;
        this.statusBarElement = null;
        this.statusBarTimeout = null;
        
        // Initialize the UI manager
        this.initialize();
    }
    
    /**
     * Initialize the UI manager
     */
    initialize() {
        try {
            this.setupElements();
            this.setupEventListeners();
            this.logger.info('UIManager initialized successfully');
        } catch (error) {
            this.logger.error('Failed to initialize UIManager', { error: error.message });
            throw error;
        }
    }
    
    /**
     * Set up DOM element references
     */
    setupElements() {
        try {
            // Main containers
            this.notificationContainer = document.getElementById('notifications');
            this.progressContainer = document.getElementById('progress-container');
            this.tokenStatusElement = document.getElementById('token-status');
            this.connectionStatusElement = document.getElementById('connection-status');
            
            // Create status bar if it doesn't exist
            this.createStatusBar();
            
            this.logger.debug('UI elements initialized');
        } catch (error) {
            this.logger.error('Failed to set up UI elements', { error: error.message });
            throw error;
        }
    }
    
    /**
     * Set up event listeners
     */
    setupEventListeners() {
        // Add any global event listeners here
        document.addEventListener('click', this.handleGlobalClick.bind(this));
    }
    
    /**
     * Handle global click events
     * @param {Event} event - The click event
     */
    handleGlobalClick(event) {
        // Handle global click events if needed
    }
    
    /**
     * Create a status bar if it doesn't exist
     */
    createStatusBar() {
        try {
            // Check if status bar already exists
            let statusBar = document.getElementById('global-status-bar');
            
            if (!statusBar) {
                // Create status bar element
                statusBar = document.createElement('div');
                statusBar.id = 'global-status-bar';
                statusBar.className = 'global-status-bar';
                statusBar.setAttribute('role', 'status');
                statusBar.setAttribute('aria-live', 'polite');
                statusBar.style.display = 'none';
                
                // Create status content
                const statusContent = document.createElement('div');
                statusContent.className = 'status-content';
                
                // Create status icon
                const statusIcon = document.createElement('i');
                statusIcon.className = 'status-icon fas';
                
                // Create status text
                const statusText = document.createElement('span');
                statusText.className = 'status-text';
                
                // Create close button
                const closeButton = document.createElement('button');
                closeButton.className = 'status-close';
                closeButton.innerHTML = '&times;';
                closeButton.setAttribute('aria-label', 'Close notification');
                closeButton.addEventListener('click', () => this.clearStatusBar());
                
                // Assemble status bar
                statusContent.appendChild(statusIcon);
                statusContent.appendChild(statusText);
                statusContent.appendChild(closeButton);
                statusBar.appendChild(statusContent);
                
                // Add to DOM
                document.body.insertBefore(statusBar, document.body.firstChild);
                
                this.logger.debug('Status bar created');
            }
            
            this.statusBarElement = statusBar;
            
        } catch (error) {
            this.logger.error('Failed to create status bar', { error: error.message });
            throw error;
        }
    }
    
    /**
     * Show a status message in the status bar
     * @param {string} message - The message to display
     * @param {string} [type='info'] - Message type (info, success, warning, error)
     * @param {Object} [options] - Additional options
     * @param {number} [options.duration=5000] - Duration in milliseconds to show the message
     * @param {boolean} [options.autoDismiss=true] - Whether to auto-dismiss the message
     * @param {string} [options.errorId] - Unique error ID for tracking
     * @param {Object} [options.context] - Additional context for the message
     * @param {string} [options.source] - Source of the status message
     */
    showStatusBar(message, type = 'info', options = {}) {
        const { 
            duration = 5000, 
            autoDismiss = true, 
            errorId, 
            context = {},
            source = 'ui'
        } = options;
        
        // Ensure status bar exists
        if (!this.statusBarElement) {
            this.createStatusBar();
            
            // If still no status bar after creation, log and return
            if (!this.statusBarElement) {
                this.logger.error('Failed to create status bar');
                return;
            }
        }
        
        try {
            // Get status bar elements
            const statusBar = this.statusBarElement;
            const statusText = statusBar.querySelector('.status-text');
            const statusIcon = statusBar.querySelector('.status-icon');
            
            if (!statusText || !statusIcon) {
                this.logger.error('Status bar elements not found');
                return;
            }
            
            // Set message and type
            statusText.textContent = message;
            
            // Clear previous classes
            statusBar.className = 'global-status-bar';
            statusIcon.className = 'status-icon fas';
            
            // Set type-specific styling and icon
            switch (type) {
                case 'success':
                    statusBar.classList.add('success');
                    statusIcon.classList.add('fa-check-circle');
                    this.logger.info(`SUCCESS: ${message}`, { type, duration, ...context });
                    break;
                    
                case 'error':
                    statusBar.classList.add('error');
                    statusIcon.classList.add('fa-exclamation-circle');
                    this.logger.error(message, { type, duration, errorId, ...context });
                    break;
                    
                case 'warning':
                case 'warn':
                    statusBar.classList.add('warning');
                    statusIcon.classList.add('fa-exclamation-triangle');
                    this.logger.warn(message, { type, duration, ...context });
                    break;
                    
                case 'info':
                default:
                    statusBar.classList.add('info');
                    statusIcon.classList.add('fa-info-circle');
                    this.logger.info(message, { type, duration, ...context });
            }
            
            // Show the status bar with animation
            statusBar.classList.add('visible', 'slide-in');
            statusBar.style.display = 'flex';
            
            // Auto-dismiss if enabled
            if (autoDismiss) {
                this.scheduleStatusBarClear(duration);
            }
            
            // Log the status update
            this.logger.debug(`Status bar updated: ${type}`, {
                message,
                type,
                duration,
                autoDismiss,
                errorId,
                source,
                ...context
            });
            
        } catch (error) {
            this.logger.error('Error showing status bar:', error, { message, type, ...options });
        }
    }
    
    /**
     * Schedule the status bar to be cleared after a delay
     * @param {number} duration - Delay in milliseconds
     */
    scheduleStatusBarClear(duration) {
        // Clear any existing timeout
        if (this.statusBarTimeout) {
            clearTimeout(this.statusBarTimeout);
        }
        
        // Set new timeout
        this.statusBarTimeout = setTimeout(() => {
            if (this.statusBarElement) {
                this.clearStatusBar();
            }
            this.statusBarTimeout = null;
        }, duration);
    }
    
    /**
     * Clear the status bar with animation and proper cleanup
     * @param {Object} [options] - Additional options
     * @param {boolean} [options.force=false] - Force immediate hide without animation
     */
    clearStatusBar(options = {}) {
        const { force = false } = options;
        
        if (!this.statusBarElement) {
            this.logger.debug('Status bar element not available for clearing');
            return;
        }
        
        // Clear any pending timeout to prevent race conditions
        this.cancelPendingStatusBarClear();
        
        try {
            if (force) {
                // Immediate hide without animation
                this.statusBarElement.style.display = 'none';
                this.cleanupStatusBarContent();
            } else {
                // Animated fade out
                this.statusBarElement.style.transition = 'opacity 0.3s ease-in-out';
                this.statusBarElement.style.opacity = '0';
                
                // Wait for animation to complete before hiding and cleaning up
                this.statusBarTimeout = setTimeout(() => {
                    if (this.statusBarElement) {
                        this.statusBarElement.style.display = 'none';
                        this.statusBarElement.style.opacity = '1';
                        this.cleanupStatusBarContent();
                    }
                    this.statusBarTimeout = null;
                }, 300);
            }
        } catch (error) {
            this.logger.error('Failed to clear status bar', { 
                error: error.message,
                stack: error.stack,
                force
            });
            // Fallback to immediate hide
            if (this.statusBarElement) {
                this.statusBarElement.style.display = 'none';
                this.cleanupStatusBarContent();
            }
        }
    }
    
    /**
     * Clean up status bar content and reset its state
     * @private
     */
    cleanupStatusBarContent() {
        if (!this.statusBarElement) return;
        
        try {
            // Clear text content
            const textElements = this.statusBarElement.querySelectorAll('.status-text, .status-icon');
            textElements.forEach(el => {
                if (el) el.textContent = '';
            });
            
            // Reset classes and attributes
            const content = this.statusBarElement.querySelector('.status-content');
            if (content) {
                content.className = 'status-content';
                content.removeAttribute('title');
                content.removeAttribute('aria-label');
            }
            
            // Reset any inline styles
            this.statusBarElement.style.cssText = '';
            
        } catch (error) {
            this.logger.error('Failed to clean up status bar content', {
                error: error.message,
                stack: error.stack
            });
        }
    }
    
    /**
     * Cancel any pending status bar clear timeout
     * @private
     */
    cancelPendingStatusBarClear() {
        if (this.statusBarTimeout) {
            clearTimeout(this.statusBarTimeout);
            this.statusBarTimeout = null;
        }
    }
    
    /**
     * Clean up all UI resources and event listeners
     * @returns {Promise<void>}
     */
    async cleanup() {
        try {
            this.logger.debug('Starting UIManager cleanup');
            
            // Clear any pending timeouts
            this.cancelPendingStatusBarClear();
            
            // Reset status bar
            this.clearStatusBar({ force: true });
            
            // Clean up any active notifications
            if (this.notificationContainer) {
                try {
                    this.notificationContainer.innerHTML = '';
                } catch (error) {
                    this.logger.error('Failed to clean up notifications', { error: error.message });
                }
            }
            
            // Clean up progress indicators
            if (this.progressContainer) {
                try {
                    this.progressContainer.innerHTML = '';
                } catch (error) {
                    this.logger.error('Failed to clean up progress indicators', { error: error.message });
                }
            }
            
            // Reset element references (but don't remove from DOM)
            this.statusBarElement = null;
            this.notificationContainer = null;
            this.progressContainer = null;
            this.tokenStatusElement = null;
            this.connectionStatusElement = null;
            
            this.logger.info('UIManager cleanup completed');
        } catch (error) {
            this.logger.error('Error during UIManager cleanup', { 
                error: error.message,
                stack: error.stack
            });
            throw error;
        }
    }
    
    // Helper methods for different message types
    showInfo(message, options = {}) {
        this.showStatusBar(message, 'info', options);
    }
    
    showSuccess(message, options = {}) {
        this.showStatusBar(message, 'success', options);
    }
    
    showWarning(message, options = {}) {
        this.showStatusBar(message, 'warning', options);
    }
    
    showError(message, options = {}) {
        this.showStatusBar(message, 'error', { ...options, autoDismiss: false });
    }
}

// Export the UIManager class
export { UIManager };



/* From: public/js/modules/ui-manager-updated.js */
/**
 * UI Manager - Updated with Error Handling and Logging Subsystem Integration
 * 
 * This module manages the UI components and interactions for the PingOne Import Tool.
 * It has been updated to use the new Error Handling and Logging Subsystem.
 */

class UIManager {
    /**
     * Create a new UIManager instance
     * @param {ErrorManager} errorManager - The error manager instance
     * @param {LogManager} logManager - The log manager instance
     */
    constructor(errorManager, logManager) {
        // Initialize error handling and logging
        this.errorManager = errorManager;
        this.logger = logManager.getLogger('UIManager');
        this.errorReporter = this.errorManager.getErrorReporter();
        
        // Initialize UI elements
        this.notificationContainer = null;
        this.statusBar = null;
        this.progressContainer = null;
        this.modalContainer = null;
        
        this.logger.debug('UIManager instance created');
    }

    /**
     * Initialize the UI manager
     * @returns {boolean} True if initialization was successful
     */
    initialize() {
        try {
            this.logger.info('Initializing UI Manager');
            this.setupElements();
            this.logger.info('UI Manager initialized successfully');
            return true;
        } catch (error) {
            this.errorManager.handleError(error, {
                component: 'UIManager',
                operation: 'initialize'
            });
            return false;
        }
    }

    /**
     * Set up UI elements
     * @private
     */
    setupElements() {
        try {
            this.logger.debug('Setting up UI elements');
            
            // Initialize core UI elements with safe fallbacks
            this.notificationContainer = ElementRegistry.notificationContainer ? ElementRegistry.notificationContainer() : null;
            this.statusBar = ElementRegistry.statusBar ? ElementRegistry.statusBar() : null;
            this.progressContainer = ElementRegistry.progressContainer ? ElementRegistry.progressContainer() : null;
            this.modalContainer = ElementRegistry.modalContainer ? ElementRegistry.modalContainer() : null;
            
            // Validate critical elements
            if (!this.notificationContainer) {
                throw this.errorManager.createError(
                    'Notification container not found',
                    'UI_ELEMENT_NOT_FOUND',
                    { elementType: 'notificationContainer' }
                );
            }
            
            if (!this.statusBar) {
                throw this.errorManager.createError(
                    'Status bar not found',
                    'UI_ELEMENT_NOT_FOUND',
                    { elementType: 'statusBar' }
                );
            }
            
            this.logger.debug('UI elements set up successfully', {
                notificationContainer: !!this.notificationContainer,
                statusBar: !!this.statusBar,
                progressContainer: !!this.progressContainer,
                modalContainer: !!this.modalContainer
            });
        } catch (error) {
            this.logger.error('Failed to set up UI elements', { error });
            throw error; // Re-throw for higher-level handling
        }
    }

    /**
     * Show an error message
     * @param {string} title - Error title
     * @param {string} message - Error message
     */
    showError(title, message) {
        try {
            this.logger.debug('Showing error', { title, message });
            
            if (this.errorReporter) {
                // Use the ErrorReporter if available
                this.errorReporter.showNotification(message, {
                    title,
                    type: 'error',
                    autoDismiss: false
                });
            } else {
                // Fallback to status bar if ErrorReporter is not available
                const errorMessage = title && message ? `${title}: ${message}` : title || message;
                this.showStatusBar(errorMessage, 'error', { autoDismiss: false });
            }
            
            this.logger.info('Error displayed to user', { title, message });
        } catch (error) {
            // Last resort error handling
            this.logger.error('Failed to show error message', { 
                error,
                originalTitle: title,
                originalMessage: message
            });
            
            // Try direct DOM manipulation as a last resort
            try {
                const fallbackContainer = document.getElementById('notification-area') || document.body;
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.textContent = `${title}: ${message}`;
                fallbackContainer.appendChild(errorDiv);
            } catch (e) {
                // Nothing more we can do
                console.error('Critical UI failure:', e);
            }
        }
    }

    /**
     * Show a status bar message
     * @param {string} message - Status message
     * @param {string} type - Message type (info, success, warning, error)
     * @param {Object} options - Display options
     */
    showStatusBar(message, type = 'info', options = {}) {
        try {
            this.logger.debug('Showing status bar', { message, type, options });
            
            if (!this.statusBar) {
                throw this.errorManager.createError(
                    'Status bar not found',
                    'UI_ELEMENT_NOT_FOUND',
                    { elementType: 'statusBar' }
                );
            }
            
            // Clear existing status
            this.statusBar.innerHTML = '';
            
            // Create status message
            const statusMessage = document.createElement('div');
            statusMessage.className = `status-message ${type}`;
            statusMessage.textContent = message;
            
            // Add close button if not auto-dismiss
            if (!options.autoDismiss) {
                const closeButton = document.createElement('button');
                closeButton.className = 'close-button';
                closeButton.innerHTML = '&times;';
                closeButton.addEventListener('click', () => this.clearStatusBar());
                statusMessage.appendChild(closeButton);
            }
            
            // Add to status bar
            this.statusBar.appendChild(statusMessage);
            this.statusBar.classList.add('visible');
            
            // Auto-dismiss if specified
            if (options.autoDismiss) {
                setTimeout(() => this.clearStatusBar(), options.duration || 5000);
            }
            
            this.logger.info('Status bar message displayed', { message, type });
        } catch (error) {
            this.errorManager.handleError(error, {
                component: 'UIManager',
                operation: 'showStatusBar',
                message,
                type,
                options
            });
        }
    }

    /**
     * Clear the status bar
     */
    clearStatusBar() {
        try {
            this.logger.debug('Clearing status bar');
            
            if (!this.statusBar) {
                return;
            }
            
            this.statusBar.innerHTML = '';
            this.statusBar.classList.remove('visible');
            
            this.logger.debug('Status bar cleared');
        } catch (error) {
            this.errorManager.handleError(error, {
                component: 'UIManager',
                operation: 'clearStatusBar'
            });
        }
    }

    /**
     * Update progress display
     * @param {number} current - Current progress value
     * @param {number} total - Total progress value
     * @param {string} message - Progress message
     */
    updateProgress(current, total, message = '') {
        try {
            this.logger.debug('Updating progress', { current, total, message });
            
            if (!this.progressContainer) {
                throw this.errorManager.createError(
                    'Progress container not found',
                    'UI_ELEMENT_NOT_FOUND',
                    { elementType: 'progressContainer' }
                );
            }
            
            const percentage = total > 0 ? Math.round((current / total) * 100) : 0;
            
            // Update progress bar
            const progressBar = this.progressContainer.querySelector('.progress-bar-fill');
            if (progressBar) {
                progressBar.style.width = `${percentage}%`;
            } else {
                this.logger.warn('Progress bar element not found');
            }
            
            // Update percentage text
            const percentageElement = this.progressContainer.querySelector('.progress-percentage');
            if (percentageElement) {
                percentageElement.textContent = `${percentage}%`;
            } else {
                this.logger.warn('Percentage element not found');
            }
            
            // Update progress text
            const progressText = this.progressContainer.querySelector('.progress-text');
            if (progressText && message) {
                progressText.textContent = message;
            } else if (!progressText) {
                this.logger.warn('Progress text element not found');
            }
            
            this.logger.info('Progress updated', { 
                current, 
                total, 
                percentage, 
                message,
                progressBarUpdated: !!progressBar,
                percentageElementUpdated: !!percentageElement,
                progressTextUpdated: !!(progressText && message)
            });
        } catch (error) {
            this.errorManager.handleError(error, {
                component: 'UIManager',
                operation: 'updateProgress',
                current,
                total,
                message
            });
        }
    }

    /**
     * Show the progress container
     */
    showProgress() {
        try {
            this.logger.debug('Showing progress container');
            
            // Try multiple ways to get the progress container
            let progressContainer = this.progressContainer;
            
            if (!progressContainer) {
                this.logger.debug('Progress container not found in UI manager, trying direct access');
                progressContainer = document.getElementById('progress-container');
            }
            
            if (!progressContainer) {
                this.logger.debug('Progress container not found by ID, trying ElementRegistry');
                if (typeof ElementRegistry !== 'undefined' && ElementRegistry.progressContainer) {
                    progressContainer = ElementRegistry.progressContainer();
                }
            }
            
            if (!progressContainer) {
                this.logger.debug('Progress container not found by ElementRegistry, trying class selector');
                progressContainer = document.querySelector('.progress-container');
            }
            
            if (!progressContainer) {
                throw this.errorManager.createError(
                    'Progress container not found by any method',
                    'UI_ELEMENT_NOT_FOUND',
                    { 
                        elementType: 'progressContainer',
                        elementsWithProgressInId: Array.from(document.querySelectorAll('[id*="progress"]')).map(el => el.id),
                        elementsWithProgressInClass: Array.from(document.querySelectorAll('[class*="progress"]')).map(el => ({ id: el.id, className: el.className }))
                    }
                );
            }
            
            // Store the found progress container
            this.progressContainer = progressContainer;
            
            // Force show the progress container
            progressContainer.style.display = 'block';
            progressContainer.classList.add('visible');
            
            // Force browser reflow to ensure the transition works
            progressContainer.offsetHeight;
            
            // Verify visibility
            setTimeout(() => {
                const isVisible = progressContainer.offsetParent !== null;
                const rect = progressContainer.getBoundingClientRect();
                
                this.logger.debug('Progress container visibility check', {
                    isVisible,
                    dimensions: { width: rect.width, height: rect.height },
                    display: progressContainer.style.display,
                    classList: progressContainer.className
                });
                
                if (!isVisible) {
                    this.logger.warn('Progress container may not be visible despite being shown');
                }
            }, 100);
            
            this.logger.info('Progress container shown');
        } catch (error) {
            this.errorManager.handleError(error, {
                component: 'UIManager',
                operation: 'showProgress'
            });
        }
    }

    /**
     * Hide the progress container
     */
    hideProgress() {
        try {
            this.logger.debug('Hiding progress container');
            
            if (!this.progressContainer) {
                this.logger.warn('Progress container not found, cannot hide');
                return;
            }
            
            this.progressContainer.classList.remove('visible');
            
            // Hide after transition
            setTimeout(() => {
                if (this.progressContainer) {
                    this.progressContainer.style.display = 'none';
                }
            }, 300);
            
            this.logger.info('Progress container hidden');
        } catch (error) {
            this.errorManager.handleError(error, {
                component: 'UIManager',
                operation: 'hideProgress'
            });
        }
    }

    /**
     * Start an import operation
     * @param {Object} options - Import options
     * @param {string} options.operationType - Type of operation (Import, Export, Modify, Delete)
     * @param {number} options.totalUsers - Total number of users
     * @param {string} options.populationName - Population name
     * @param {string} options.populationId - Population ID
     * @param {string} options.fileName - File name
     */
    startImportOperation(options = {}) {
        try {
            this.logger.info('Starting import operation', options);
            
            const { operationType, totalUsers, populationName, populationId, fileName } = options;
            
            this.showProgress();
            this.updateProgress(0, totalUsers || 0, 'Starting import operation...');
            
            // Update operation details
            const operationTypeElement = document.querySelector('.detail-value.operation-type');
            if (operationTypeElement) {
                operationTypeElement.textContent = operationType || 'Import';
            } else {
                this.logger.warn('Operation type element not found');
            }
            
            // Update population name
            const populationNameElement = document.querySelector('.detail-value.population-name');
            if (populationNameElement) {
                populationNameElement.textContent = populationName || 'N/A';
            } else {
                this.logger.warn('Population name element not found');
            }
            
            // Update file name
            const fileNameElement = document.querySelector('.detail-value.file-name');
            if (fileNameElement) {
                fileNameElement.textContent = fileName || 'N/A';
            } else {
                this.logger.warn('File name element not found');
            }
            
            this.logger.info('Import operation started', { 
                operationType, 
                totalUsers, 
                populationName, 
                populationId,
                fileName,
                detailsUpdated: {
                    operationType: !!operationTypeElement,
                    populationName: !!populationNameElement,
                    fileName: !!fileNameElement
                }
            });
        } catch (error) {
            this.errorManager.handleError(error, {
                component: 'UIManager',
                operation: 'startImportOperation',
                options
            });
        }
    }

    /**
     * Complete an import operation
     * @param {Object} options - Completion options
     * @param {boolean} options.success - Whether the operation was successful
     * @param {string} options.message - Completion message
     * @param {Object} options.stats - Operation statistics
     */
    completeImportOperation(options = {}) {
        try {
            this.logger.info('Completing import operation', options);
            
            const { success, message, stats } = options;
            
            // Update progress to 100%
            this.updateProgress(100, 100, message || (success ? 'Operation completed successfully' : 'Operation failed'));
            
            // Show completion message
            this.showStatusBar(
                message || (success ? 'Operation completed successfully' : 'Operation failed'),
                success ? 'success' : 'error',
                { autoDismiss: success }
            );
            
            // Update statistics if provided
            if (stats) {
                const statsElement = document.querySelector('.operation-stats');
                if (statsElement) {
                    // Clear existing stats
                    statsElement.innerHTML = '';
                    
                    // Add new stats
                    Object.entries(stats).forEach(([key, value]) => {
                        const statItem = document.createElement('div');
                        statItem.className = 'stat-item';
                        statItem.innerHTML = `<span class="stat-label">${key}:</span> <span class="stat-value">${value}</span>`;
                        statsElement.appendChild(statItem);
                    });
                } else {
                    this.logger.warn('Statistics element not found');
                }
            }
            
            // Hide progress after a delay
            setTimeout(() => this.hideProgress(), 3000);
            
            this.logger.info('Import operation completed', { 
                success, 
                message, 
                stats
            });
        } catch (error) {
            this.errorManager.handleError(error, {
                component: 'UIManager',
                operation: 'completeImportOperation',
                options
            });
            
            // Try to hide progress even if there was an error
            try {
                setTimeout(() => this.hideProgress(), 3000);
            } catch (e) {
                // Ignore
            }
        }
    }
}

/**
 * Create a new UIManager with the Error Handling and Logging Subsystem
 * @param {ErrorManager} errorManager - The error manager instance
 * @param {LogManager} logManager - The log manager instance
 * @returns {UIManager} A new UIManager instance
 */
export function createUIManager(errorManager, logManager) {
    return new UIManager(errorManager, logManager);
}

export default UIManager;


/* From: public/js/modules/credentials-modal.js */
/**
 * @module
 * @description ES Module (converted from CommonJS)
 */

/**
 * Credentials Modal Module
 * Shows current PingOne credentials and asks user if they want to use them or configure new ones
 */
class CredentialsModal {
    constructor() {
        this.isActive = false;
        this.focusableElements = [];
        this.firstFocusableElement = null;
        this.lastFocusableElement = null;
        this.previousActiveElement = null;
        this.credentials = null;
        
        this.init();
    }

    async init() {
        await this.loadCredentials();
        this.createModal();
        this.bindEvents();
        this.showModal();
    }

    async loadCredentials() {
        try {
            const response = await fetch('/api/settings');
            if (response.ok) {
                const data = await response.json();
                const settings = data.data || data.settings || {};
                this.credentials = {
                    environmentId: settings.environmentId || settings['environment-id'] || '',
                    clientId: settings.apiClientId || settings['api-client-id'] || '',
                    clientSecret: settings.apiSecret || settings['api-secret'] || '',
                    region: settings.region || 'NorthAmerica',
                    populationId: settings.populationId || settings['population-id'] || '',
                    rateLimit: settings.rateLimit || settings['rate-limit'] || 90
                };
                if (this.credentials.environmentId && this.credentials.clientId && this.credentials.clientSecret) {
                    this.logCredentialSource('server');
                    return;
                }
            }
            // Fallback to localStorage
            var localCreds = window.localStorage.getItem('pingone-credentials');
            if (localCreds) {
                try {
                    var creds = JSON.parse(localCreds);
                    this.credentials = {
                        environmentId: creds.environmentId || '',
                        clientId: creds.clientId || '',
                        clientSecret: creds.clientSecret || '',
                        region: creds.region || 'NorthAmerica',
                        populationId: creds.populationId || '',
                        rateLimit: creds.rateLimit || 90
                    };
                    if (this.credentials.environmentId && this.credentials.clientId && this.credentials.clientSecret) {
                        this.logCredentialSource('localStorage');
                        return;
                    }
                } catch (e) {
                    // Ignore parse errors
                }
            }
            // No credentials found, prompt user
            this.credentials = null;
            this.logCredentialSource('prompt');
        } catch (error) {
            this.credentials = null;
            this.logCredentialSource('error');
        }
    }

    logCredentialSource(source) {
        var msg = '[ CREDENTIAL-MANAGER] [' + new Date().toISOString() + '] [ui] INFO: Credential source: ' + source;
        if (window.sessionStorage) {
            var logs = [];
            try {
                logs = JSON.parse(window.sessionStorage.getItem('credential-logs') || '[]');
            } catch (e) {}
            logs.push(msg);
            window.sessionStorage.setItem('credential-logs', JSON.stringify(logs));
        }
        console.log(msg);
    }
    }

    createModal() {
        // Create modal overlay
        const overlay = document.createElement('div');
        overlay.className = 'credentials-modal-overlay';
        overlay.setAttribute('role', 'dialog');
        overlay.setAttribute('aria-modal', 'true');
        overlay.setAttribute('aria-labelledby', 'credentials-title');
        overlay.setAttribute('aria-describedby', 'credentials-content');

        const hasCredentials = this.credentials && this.credentials.environmentId && this.credentials.clientId;
        
        // Create modal content
        overlay.innerHTML = `
            <div class="credentials-modal" tabindex="-1">
                <div class="credentials-modal-body">
                    <div id="credentials-content" class="credentials-content">
                        ${hasCredentials ? this.createCredentialsContent() : this.createNoCredentialsContent()}
                    </div>
                </div>
                
                <div class="credentials-modal-footer">
                    <div class="credentials-actions">
                        ${hasCredentials ? this.createCredentialsActions() : this.createNoCredentialsActions()}
                    </div>
                </div>
            </div>
        `;

        document.body.appendChild(overlay);
        this.overlay = overlay;
        this.modal = overlay.querySelector('.credentials-modal');
        this.useCredentialsBtn = overlay.querySelector('#use-credentials-btn');
        this.configureBtn = overlay.querySelector('#configure-credentials-btn');
        this.skipBtn = overlay.querySelector('#skip-credentials-btn');
    }

    createCredentialsContent() {
        return `
            <h3> PingOne Credentials Found</h3>
            <p>The following PingOne credentials are available. Would you like to use them or configure new ones?</p>
            
            <div class="credentials-display">
                <div class="credential-item">
                    <label>Environment ID:</label>
                    <div class="credential-value">
                        <code class="credential-visible">${this.credentials.environmentId}</code>
                        <button class="btn btn-sm btn-outline-secondary copy-btn" data-value="${this.credentials.environmentId}" title="Copy Environment ID">
                            <i class="fas fa-copy"></i>
                        </button>
                    </div>
                </div>
                
                <div class="credential-item">
                    <label>Client ID:</label>
                    <div class="credential-value">
                        <code class="credential-visible">${this.credentials.clientId}</code>
                        <button class="btn btn-sm btn-outline-secondary copy-btn" data-value="${this.credentials.clientId}" title="Copy Client ID">
                            <i class="fas fa-copy"></i>
                        </button>
                    </div>
                </div>
                
                <div class="credential-item">
                    <label>Client Secret:</label>
                    <div class="credential-value">
                        <code class="credential-masked">${this.credentials.clientSecret ? this.credentials.clientSecret.substring(0, 5) + ''.repeat(Math.max(0, 15)) : ''}</code>
                        <span class="credential-status"> Configured</span>
                    </div>
                </div>
                
                <div class="credential-item">
                    <label>Region:</label>
                    <div class="credential-value">
                        <code class="credential-visible">${this.credentials.region}</code>
                    </div>
                </div>
            </div>
            
            <div class="credentials-info">
                <h4> What would you like to do?</h4>
                <ul>
                    <li><strong>Use These Credentials:</strong> Continue with the stored credentials</li>
                    <li><strong>Go to Settings:</strong> Configure new or different credentials</li>
                </ul>
            </div>
        `;
    }

    createNoCredentialsContent() {
        return `
            <h3> No Credentials Found</h3>
            <p>No PingOne credentials were found in your settings. You'll need to configure them to use this tool.</p>
            
            <div class="credentials-info">
                <h4> Required Information:</h4>
                <ul>
                    <li><strong>Environment ID:</strong> Your PingOne environment identifier</li>
                    <li><strong>Client ID:</strong> Your PingOne API client identifier</li>
                    <li><strong>Client Secret:</strong> Your PingOne API client secret</li>
                    <li><strong>Region:</strong> Your PingOne environment region</li>
                </ul>
            </div>
            
            <div class="credentials-help">
                <h4> How to Get Credentials:</h4>
                <ol>
                    <li>Log into your PingOne Admin Console</li>
                    <li>Navigate to Applications  Applications</li>
                    <li>Create a new application or use an existing one</li>
                    <li>Copy the Environment ID, Client ID, and Client Secret</li>
                    <li>Configure them in the Settings page</li>
                </ol>
            </div>
        `;
    }

    createCredentialsActions() {
        return `
            <button type="button" class="credentials-btn credentials-btn-primary" id="use-credentials-btn">
                <i class="fas fa-play"></i>
                Use These Credentials
            </button>
            <button type="button" class="credentials-btn credentials-btn-secondary" id="configure-credentials-btn">
                <i class="fas fa-cog"></i>
                Go to Settings
            </button>
            <button type="button" class="credentials-btn credentials-btn-outline" id="skip-credentials-btn">
                <i class="fas fa-times"></i>
                Skip for Now
            </button>
        `;
    }

    createNoCredentialsActions() {
        return `
            <button type="button" class="credentials-btn credentials-btn-primary" id="configure-credentials-btn">
                <i class="fas fa-cog"></i>
                Go to Settings
            </button>
            <button type="button" class="credentials-btn credentials-btn-secondary" id="skip-credentials-btn">
                <i class="fas fa-times"></i>
                Skip for Now
            </button>
        `;
    }

    maskCredential(value) {
        if (!value) return 'Not set';
        if (value.length <= 8) return value;
        return value.substring(0, 8) + '...' + value.substring(value.length - 4);
    }

    bindEvents() {
        // Use credentials button
        if (this.useCredentialsBtn) {
            this.useCredentialsBtn.addEventListener('click', async () => {
                await this.useCurrentCredentials();
            });
        }

        // Configure credentials button
        if (this.configureBtn) {
            this.configureBtn.addEventListener('click', () => {
                this.goToSettings();
            });
        }

        // Skip button
        if (this.skipBtn) {
            this.skipBtn.addEventListener('click', () => {
                this.skipCredentials();
            });
        }

        // Copy buttons
        this.modal.querySelectorAll('.copy-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const value = e.target.closest('.copy-btn').dataset.value;
                this.copyToClipboard(value, e.target.closest('.copy-btn'));
            });
        });

        // Keyboard events for accessibility
        this.overlay.addEventListener('keydown', (e) => {
            this.handleKeyboardNavigation(e);
        });

        // Prevent clicks outside modal from closing it
        this.overlay.addEventListener('click', (e) => {
            if (e.target === this.overlay) {
                // Don't close on outside click - require explicit action
                this.logEvent('credentials_outside_click_prevented');
            }
        });

        // Escape key handling
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && this.isActive) {
                e.preventDefault();
                this.skipCredentials();
            }
        });
    }

    handleKeyboardNavigation(e) {
        if (!this.isActive) return;

        const focusableElements = this.getFocusableElements();
        const firstElement = focusableElements[0];
        const lastElement = focusableElements[focusableElements.length - 1];

        // Tab key navigation with focus trapping
        if (e.key === 'Tab') {
            if (e.shiftKey) {
                if (document.activeElement === firstElement) {
                    e.preventDefault();
                    lastElement.focus();
                }
            } else {
                if (document.activeElement === lastElement) {
                    e.preventDefault();
                    firstElement.focus();
                }
            }
        }
    }

    getFocusableElements() {
        const focusableSelectors = [
            'button:not([disabled])',
            'input:not([disabled])',
            'select:not([disabled])',
            'textarea:not([disabled])',
            'a[href]',
            '[tabindex]:not([tabindex="-1"])'
        ];

        return Array.from(this.modal.querySelectorAll(focusableSelectors.join(', ')));
    }

    showModal() {
        this.isActive = true;
        this.previousActiveElement = document.activeElement;
        
        // Add classes to body and app container
        document.body.classList.add('credentials-modal-open');
        const appContainer = document.querySelector('.app-container');
        if (appContainer) {
            appContainer.classList.add('credentials-modal-active');
        }

        // Show modal with animation
        this.overlay.classList.add('active');
        
        // Focus management
        this.modal.focus();
        this.setupFocusTrap();
        
        this.logEvent('credentials_modal_shown');
        
        // Announce to screen readers
        this.announceToScreenReader('Credentials configuration modal opened. Please review your PingOne credentials and choose an action.');
    }

    setupFocusTrap() {
        this.focusableElements = this.getFocusableElements();
        this.firstFocusableElement = this.focusableElements[0];
        this.lastFocusableElement = this.focusableElements[this.focusableElements.length - 1];
    }

    async useCurrentCredentials() {
        this.logEvent('credentials_used', { 
            hasCredentials: !!this.credentials,
            environmentId: (this.credentials && this.credentials.environmentId) ? 'set' : 'not_set',
            clientId: (this.credentials && this.credentials.clientId) ? 'set' : 'not_set'
        });
        
        // Show loading state on button
        const useButton = document.getElementById('use-credentials-btn');
        if (useButton) {
            useButton.disabled = true;
            useButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Validating Credentials...';
        }
        
        try {
            // Just save credentials without trying to get a token
            await this.saveCredentialsOnly();
            
            // Mark modal as shown since credentials are now saved
            CredentialsModal.setCredentialsModalShown();
            
            this.hideModal();
            this.enableApplication();
            
            // Update token status to reflect that credentials are now being used
            this.updateTokenStatusAfterCredentialsUse();
            
            // Show success message
            this.showSuccessMessage('Credentials saved successfully!');
            
        } catch (error) {
            // Restore button state on error
            const useButton = document.getElementById('use-credentials-btn');
            if (useButton) {
                useButton.disabled = false;
                useButton.innerHTML = '<i class="fas fa-play"></i> Use These Credentials';
            }
            console.error('Error using credentials:', error);
            
            // Show user-friendly error messages
            let userMessage = '';
            let userTitle = 'Credentials Error';
            
            if (error.message.includes('PingOne client not available')) {
                userTitle = 'Authentication System Not Ready';
                userMessage = 'The PingOne authentication system is not fully initialized. Please refresh the page and try again, or go to Settings to configure credentials manually.';
            } else if (error.message.includes('Missing required credentials')) {
                userTitle = 'Incomplete Credentials';
                userMessage = 'Some required credential fields are missing. Please go to Settings to complete your PingOne configuration.';
            } else if (error.message.includes('Failed to get token')) {
                userTitle = 'Authentication Failed';
                userMessage = 'Unable to authenticate with PingOne using these credentials. Please verify your credentials in Settings.';
            } else if (error.message.includes('Failed to save credentials')) {
                userTitle = 'Save Failed';
                userMessage = 'Unable to save credentials to the server. Please try again or go to Settings to configure manually.';
            } else {
                userTitle = 'Credentials Error';
                userMessage = 'There was a problem using these credentials. Please go to Settings to verify your PingOne configuration.';
            }
            
            // Show the user-friendly error in the modal
            this.showModalError(userTitle, userMessage);
        }
    }
    
    async saveCredentialsAndGetToken() {
        if (!this.credentials) {
            throw new Error('No credentials available to save');
        }
        
        // Convert credentials to settings format
        const settings = {
            environmentId: this.credentials.environmentId,
            apiClientId: this.credentials.clientId,
            apiSecret: this.credentials.clientSecret,
            populationId: this.credentials.populationId || '',
            region: this.credentials.region || 'NorthAmerica',
            rateLimit: this.credentials.rateLimit || 90
        };
        
        // Validate required fields before saving
        if (!settings.environmentId || !settings.apiClientId || !settings.apiSecret) {
            throw new Error('Missing required credentials: Environment ID, Client ID, and Client Secret are required');
        }
        
        // Save to server via API endpoint - this is the critical fix
        try {
            console.log('Saving credentials to server...', {
                hasEnvironmentId: !!settings.environmentId,
                hasApiClientId: !!settings.apiClientId,
                hasApiSecret: !!settings.apiSecret,
                region: settings.region
            });
            
            const response = await fetch('/api/settings', {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(settings)
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(`Failed to save credentials to server: ${errorData.error || response.statusText}`);
            }
            
            const result = await response.json();
            console.log('Credentials saved to server successfully:', result);
            
            // Verify the save was successful by reading back the settings
            const verifyResponse = await fetch('/api/settings');
            if (verifyResponse.ok) {
                const verifyData = await verifyResponse.json();
                const savedSettings = verifyData.data || verifyData.settings || {};
                console.log('Verified credentials saved to server:', {
                    hasEnvironmentId: !!savedSettings.environmentId,
                    hasApiClientId: !!savedSettings.apiClientId,
                    hasApiSecret: !!savedSettings.apiSecret
                });
            }
        } catch (error) {
            console.error('Failed to save credentials to server:', error);
            throw new Error(`Failed to save credentials: ${error.message}`);
        }
        
        // Save to credentials manager if available
        if (window.credentialsManager) {
            try {
                window.credentialsManager.saveCredentials(settings);
                console.log('Credentials saved to credentials manager');
            } catch (error) {
                console.warn('Failed to save to credentials manager:', error);
            }
        }
        
        // Save to localStorage as backup
        try {
            localStorage.setItem('pingone_credentials', JSON.stringify(settings));
            console.log('Credentials saved to localStorage as backup');
        } catch (error) {
            console.warn('Failed to save to localStorage:', error);
        }
        
        // Update settings form if on settings page
        if (window.app && window.app.populateSettingsForm) {
            try {
                window.app.populateSettingsForm(settings);
                console.log('Settings form updated with credentials');
            } catch (error) {
                console.warn('Failed to update settings form:', error);
            }
        }
        
        // Get a new token with the saved credentials - with retry logic
        let tokenResult = null;
        let lastError = null;
        
        // Wait a moment for credentials to be processed by the server
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Try multiple approaches to get a token
        for (let attempt = 1; attempt <= 3; attempt++) {
            console.log(`Token acquisition attempt ${attempt}/3`);
            
            // First try: Direct API call (most reliable)
            try {
                console.log('Trying direct API call approach...');
                const response = await fetch('/api/pingone/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const tokenData = await response.json();
                    if (tokenData.access_token) {
                        console.log('Token acquired via direct API call');
                        tokenResult = tokenData.access_token;
                        break; // Success!
                    }
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    lastError = new Error(errorData.error || 'Failed to get token from API');
                    console.error(`Direct API approach failed (attempt ${attempt}):`, lastError.message);
                }
            } catch (apiError) {
                console.error(`Direct API approach failed (attempt ${attempt}):`, apiError);
                lastError = apiError;
            }
            
            // Second try: Use PingOne client if available (fallback)
            if (!tokenResult && window.app && window.app.pingOneClient) {
                try {
                    console.log('Trying PingOne client approach as fallback...');
                    // Update the PingOne client with new credentials
                    if (typeof window.app.pingOneClient.updateCredentials === 'function') {
                        window.app.pingOneClient.updateCredentials(settings);
                    }
                    
                    // Get a new token
                    const token = await window.app.pingOneClient.getAccessToken();
                    console.log('New token acquired with saved credentials via PingOne client');
                    
                    tokenResult = token;
                    break; // Success!
                } catch (error) {
                    console.error(`PingOne client approach failed (attempt ${attempt}):`, error);
                    lastError = error;
                }
            } else if (!tokenResult) {
                console.log('PingOne client not available, skipping client approach');
            }
            
            // Third try: Enhanced server auth endpoint
            if (!tokenResult) {
                try {
                    console.log('Trying enhanced server auth approach...');
                    const response = await fetch('/api/v1/auth/token', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            environmentId: settings.environmentId,
                            clientId: settings.apiClientId,
                            clientSecret: settings.apiSecret,
                            region: settings.region
                        })
                    });
                    
                    if (response.ok) {
                        const tokenData = await response.json();
                        if (tokenData.access_token || tokenData.token) {
                            console.log('Token acquired via enhanced server auth');
                            tokenResult = tokenData.access_token || tokenData.token;
                            break; // Success!
                        }
                    } else {
                        const errorData = await response.json().catch(() => ({}));
                        lastError = new Error(errorData.error || 'Failed to get token from enhanced auth');
                        console.error(`Enhanced server auth approach failed (attempt ${attempt}):`, lastError.message);
                    }
                } catch (authError) {
                    console.error(`Enhanced server auth approach failed (attempt ${attempt}):`, authError);
                    lastError = authError;
                }
            }
            
            // Wait before retry (exponential backoff)
            if (attempt < 3 && !tokenResult) {
                const waitTime = 1000 * attempt;
                console.log(`Waiting ${waitTime}ms before retry...`);
                await new Promise(resolve => setTimeout(resolve, waitTime));
            }
        }
        
        // Check if we got a token
        if (!tokenResult) {
            console.error('All token acquisition attempts failed');
            
            // Provide helpful error message based on the last error
            let errorMessage = 'Unable to acquire PingOne access token after multiple attempts.';
            
            if (lastError) {
                if (lastError.message.includes('401') || lastError.message.includes('unauthorized')) {
                    errorMessage = 'Invalid credentials. Please verify your PingOne Client ID and Secret are correct.';
                } else if (lastError.message.includes('404') || lastError.message.includes('not found')) {
                    errorMessage = 'PingOne environment not found. Please verify your Environment ID is correct.';
                } else if (lastError.message.includes('network') || lastError.message.includes('fetch')) {
                    errorMessage = 'Network error connecting to PingOne. Please check your internet connection.';
                } else if (lastError.message.includes('PingOne client not available')) {
                    errorMessage = 'PingOne authentication system is not properly initialized. Please refresh the page and try again.';
                } else {
                    errorMessage = `Authentication failed: ${lastError.message}`;
                }
            }
            
            throw new Error(errorMessage);
        }
        
        console.log('Token acquisition successful');
        return tokenResult;
    }
    
    async saveCredentialsOnly() {
        if (!this.credentials) {
            throw new Error('No credentials available to save');
        }
        
        // Convert credentials to settings format
        const settings = {
            environmentId: this.credentials.environmentId,
            apiClientId: this.credentials.clientId,
            apiSecret: this.credentials.clientSecret,
            populationId: this.credentials.populationId || '',
            region: this.credentials.region || 'NorthAmerica',
            rateLimit: this.credentials.rateLimit || 90
        };
        
        // Validate required fields before saving
        if (!settings.environmentId || !settings.apiClientId || !settings.apiSecret) {
            throw new Error('Missing required credentials: Environment ID, Client ID, and Client Secret are required');
        }
        
        // Save to server via API endpoint
        try {
            console.log('Saving credentials to server...', {
                hasEnvironmentId: !!settings.environmentId,
                hasApiClientId: !!settings.apiClientId,
                hasApiSecret: !!settings.apiSecret,
                region: settings.region
            });
            
            const response = await fetch('/api/settings', {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(settings)
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(`Failed to save credentials to server: ${errorData.error || response.statusText}`);
            }
            
            const result = await response.json();
            console.log('Credentials saved to server successfully:', result);
            
        } catch (error) {
            console.error('Failed to save credentials to server:', error);
            throw new Error(`Failed to save credentials: ${error.message}`);
        }
        
        // Save to credentials manager if available
        if (window.credentialsManager) {
            try {
                window.credentialsManager.saveCredentials(settings);
                console.log('Credentials saved to credentials manager');
            } catch (error) {
                console.warn('Failed to save to credentials manager:', error);
            }
        }
        
        // Save to localStorage as backup
        try {
            localStorage.setItem('pingone_credentials', JSON.stringify(settings));
            console.log('Credentials saved to localStorage as backup');
        } catch (error) {
            console.warn('Failed to save to localStorage:', error);
        }
        
        // Update settings form if on settings page
        if (window.app && window.app.populateSettingsForm) {
            try {
                window.app.populateSettingsForm(settings);
                console.log('Settings form updated with credentials');
            } catch (error) {
                console.warn('Failed to update settings form:', error);
            }
        }
        
        console.log('Credentials saved successfully without token acquisition');
        return true;
    }
    
    showError(title, message) {
        // Create and show an error notification
        const notification = document.createElement('div');
        notification.className = 'notification notification-error';
        notification.innerHTML = `
            <i class="fas fa-exclamation-circle"></i>
            <span><strong>${title}:</strong> ${message}</span>
        `;
        
        const notificationArea = document.getElementById('notification-area');
        if (notificationArea) {
            notificationArea.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 8000);
        }
    }
    
    showModalError(title, message) {
        // Show error directly in the modal
        const modal = document.querySelector('.credentials-modal');
        if (!modal) return;
        
        // Remove any existing error messages
        const existingError = modal.querySelector('.credentials-error-message');
        if (existingError) {
            existingError.remove();
        }
        
        // Create error message element
        const errorDiv = document.createElement('div');
        errorDiv.className = 'credentials-error-message';
        errorDiv.innerHTML = `
            <div class="error-content">
                <i class="fas fa-exclamation-triangle error-icon"></i>
                <div class="error-text">
                    <h4>${title}</h4>
                    <p>${message}</p>
                </div>
            </div>
            <div class="error-actions">
                <button type="button" class="btn btn-primary" onclick="this.closest('.credentials-modal-overlay').querySelector('#configure-credentials-btn').click()">
                    <i class="fas fa-cog"></i> Go to Settings
                </button>
                <button type="button" class="btn btn-secondary" onclick="this.closest('.credentials-error-message').remove()">
                    <i class="fas fa-times"></i> Dismiss
                </button>
            </div>
        `;
        
        // Insert error message after the modal body
        const modalBody = modal.querySelector('.credentials-modal-body');
        if (modalBody) {
            modalBody.insertAdjacentElement('afterend', errorDiv);
        }
        
        // Also call the regular showError for notifications
        this.showError(title, message);
    }
    
    updateTokenStatusAfterCredentialsUse() {
        try {
            console.log('Credentials Modal: Updating token status after credentials use');
            
            // Force a token refresh to get current status
            if (window.app && window.app.pingOneClient) {
                // Clear any existing token to force refresh
                window.app.pingOneClient.clearToken();
                
                // Get a fresh token
                window.app.pingOneClient.getAccessToken().then(token => {
                    console.log('Credentials Modal: Fresh token acquired');
                    
                    // Update the universal token status
                    if (typeof window.app.updateUniversalTokenStatus === 'function') {
                        window.app.updateUniversalTokenStatus();
                    }
                }).catch(error => {
                    console.warn('Credentials Modal: Could not get fresh token:', error);
                });
            }
            
            // Also try to update status directly
            if (window.app && typeof window.app.updateUniversalTokenStatus === 'function') {
                setTimeout(() => {
                    window.app.updateUniversalTokenStatus();
                }, 1000);
            }
            
        } catch (error) {
            console.error('Credentials Modal: Error updating token status:', error);
        }
    }

    goToSettings() {
        this.logEvent('credentials_configure_clicked');
        
        this.hideModal();
        this.enableApplication();
        
        // Navigate to settings
        setTimeout(() => {
            const settingsNav = document.querySelector('[data-view="settings"]');
            if (settingsNav) {
                settingsNav.click();
            }
        }, 100);
    }

    skipCredentials() {
        this.logEvent('credentials_skipped');
        
        this.hideModal();
        this.enableApplication();
        
        // Show info message
        this.showInfoMessage('You can configure credentials later in the Settings page.');
    }

    hideModal() {
        this.isActive = false;
        
        // Remove classes
        document.body.classList.remove('credentials-modal-open');
        const appContainer = document.querySelector('.app-container');
        if (appContainer) {
            appContainer.classList.remove('credentials-modal-active');
        }

        // Hide modal with animation
        this.overlay.classList.remove('active');
        
        // Restore focus
        if (this.previousActiveElement) {
            this.previousActiveElement.focus();
        }
        
        // Clean up
        setTimeout(() => {
            if (this.overlay && this.overlay.parentNode) {
                this.overlay.parentNode.removeChild(this.overlay);
            }
        }, 300);
        
        this.logEvent('credentials_modal_hidden');
    }

    enableApplication() {
        // Enable the application
        const appContainer = document.querySelector('.app-container');
        if (appContainer) {
            appContainer.classList.remove('credentials-modal-active');
        }
        
        this.logEvent('application_enabled_after_credentials');
    }

    copyToClipboard(text, button) {
        navigator.clipboard.writeText(text).then(() => {
            // Show success feedback
            const originalIcon = button.innerHTML;
            button.innerHTML = '<i class="fas fa-check"></i>';
            button.classList.add('copied');
            
            setTimeout(() => {
                button.innerHTML = originalIcon;
                button.classList.remove('copied');
            }, 2000);
            
            this.logEvent('credential_copied');
        }).catch(err => {
            console.error('Failed to copy to clipboard:', err);
            this.logEvent('credential_copy_failed', { error: err.message });
        });
    }

    showSuccessMessage(message) {
        // Create and show a success notification
        const notification = document.createElement('div');
        notification.className = 'notification notification-success';
        notification.innerHTML = `
            <i class="fas fa-check-circle"></i>
            <span>${message}</span>
        `;
        
        const notificationArea = document.getElementById('notification-area');
        if (notificationArea) {
            notificationArea.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 5000);
        }
    }

    showInfoMessage(message) {
        // Create and show an info notification
        const notification = document.createElement('div');
        notification.className = 'notification notification-info';
        notification.innerHTML = `
            <i class="fas fa-info-circle"></i>
            <span>${message}</span>
        `;
        
        const notificationArea = document.getElementById('notification-area');
        if (notificationArea) {
            notificationArea.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 5000);
        }
    }

    announceToScreenReader(message) {
        // Create a temporary element for screen reader announcements
        const announcement = document.createElement('div');
        announcement.setAttribute('aria-live', 'polite');
        announcement.setAttribute('aria-atomic', 'true');
        announcement.style.position = 'absolute';
        announcement.style.left = '-10000px';
        announcement.style.width = '1px';
        announcement.style.height = '1px';
        announcement.style.overflow = 'hidden';
        
        announcement.textContent = message;
        document.body.appendChild(announcement);
        
        setTimeout(() => {
            document.body.removeChild(announcement);
        }, 1000);
    }

    logEvent(eventName, data = {}) {
        const eventData = {
            event: eventName,
            timestamp: new Date().toISOString(),
            hasCredentials: !!this.credentials,
            environmentId: this.credentials?.environmentId ? 'set' : 'not_set',
            clientId: this.credentials?.clientId ? 'set' : 'not_set',
            ...data
        };
        
        console.log('Credentials Modal Event:', eventData);
        
        // You can also send this to your logging system
        // fetch('/api/logs', { method: 'POST', body: JSON.stringify(eventData) });
    }

    /**
     * Check if credentials are already properly saved and working
     * @returns {Promise<boolean>} True if credentials are saved and working
     */
    static async areCredentialsSaved() {
        try {
            const response = await fetch('/api/settings');
            if (!response.ok) {
                return false;
            }
            
            const data = await response.json();
            const settings = data.data || data.settings || {};
            
            // Check if we have all required credentials
            const hasRequiredCredentials = settings.environmentId && 
                                        settings.apiClientId && 
                                        settings.apiSecret;
            
            if (!hasRequiredCredentials) {
                return false;
            }
            
            // Try to get a token to verify credentials work
            if (window.app && window.app.pingOneClient) {
                try {
                    const token = await window.app.pingOneClient.getAccessToken();
                    return !!token;
                } catch (error) {
                    console.warn('Credentials exist but token acquisition failed:', error);
                    return false;
                }
            }
            
            return true;
        } catch (error) {
            console.error('Error checking if credentials are saved:', error);
            return false;
        }
    }

    /**
     * Check if the credentials modal should be shown
     * @returns {Promise<boolean>} True if modal should be shown
     */
    static async shouldShowCredentialsModal() {
        // TEMPORARY: Disable credentials modal for import UI testing
        console.log('DEBUGGING: Disabling credentials modal for import UI testing');
        return false;
        
        // Original logic (commented out for debugging):
        try {
            // Check if modal was already shown in this session
            const modalShown = sessionStorage.getItem('credentials_modal_shown');
            if (modalShown === 'true') {
                console.log('Credentials modal already shown in this session');
                return false;
            }

            // Check settings.json flag via API
            const response = await fetch('/api/settings');
            if (response.ok) {
                const data = await response.json();
                const settings = data.data || data.settings || {};
                if (settings.showCredentialConfirmationModal === false) {
                    console.log('Credentials modal disabled by settings.json flag');
                    return false;
                }
            }

            // Always show modal on startup to ask user about stored credentials
            // This gives users the choice to use stored credentials or configure new ones
            console.log('Showing credentials modal on startup to ask about stored credentials');
            return true;
        } catch (error) {
            console.error('Error checking if credentials modal should be shown:', error);
            return true; // Show modal on error to be safe
        }
    }

    /**
     * Mark that the credentials modal has been shown
     */
    static setCredentialsModalShown() {
        sessionStorage.setItem('credentials_modal_shown', 'true');
        console.log('Credentials modal marked as shown for this session');
    }

    /**
     * Reset the credentials modal state (for testing or re-showing)
     */
    static resetCredentialsModal() {
        sessionStorage.removeItem('credentials_modal_shown');
        console.log('Credentials modal state reset');
    }

    // Static method to check if there's a valid token
    static hasValidToken() {
        try {
            const token = localStorage.getItem('pingone_worker_token');
            const expiry = localStorage.getItem('pingone_token_expiry');
            
            if (!token || !expiry) {
                return false;
            }
            
            const expiryTime = parseInt(expiry, 10);
            const now = Date.now();
            const timeRemaining = expiryTime - now;
            
            return timeRemaining > 0;
        } catch (error) {
            console.error('Error checking token validity:', error);
            return false;
        }
    }
}

// Initialize credentials modal when DOM is loaded
document.addEventListener('DOMContentLoaded', async () => {
    console.log('Credentials Modal: DOMContentLoaded event fired');
    console.log('Disclaimer accepted:', DisclaimerModal.isDisclaimerAccepted());
    console.log('Credentials modal shown:', sessionStorage.getItem('credentials_modal_shown'));
    
    // Check if disclaimer is already accepted (user returning)
    if (DisclaimerModal.isDisclaimerAccepted()) {
        const shouldShow = await CredentialsModal.shouldShowCredentialsModal();
        console.log('Should show credentials modal:', shouldShow);
        
        if (shouldShow) {
            console.log('Credentials Modal: Showing modal for returning user');
            // Small delay to ensure disclaimer modal is fully closed
            setTimeout(() => {
                new CredentialsModal();
                CredentialsModal.setCredentialsModalShown();
            }, 1000);
        }
    }
});

// Listen for disclaimer completion events
document.addEventListener('disclaimerAccepted', async (event) => {
    console.log('Credentials Modal: Disclaimer accepted event received', event.detail);
    // Wait a bit longer for disclaimer modal to fully close
    setTimeout(async () => {
        console.log('Credentials Modal: Checking if should show after disclaimer');
        const shouldShow = await CredentialsModal.shouldShowCredentialsModal();
        console.log('Should show credentials modal:', shouldShow);
        
        if (shouldShow) {
            console.log('Credentials Modal: Creating modal after disclaimer acceptance');
            new CredentialsModal();
            CredentialsModal.setCredentialsModalShown();
        }
    }, 1500);
});

// Listen for token status changes
document.addEventListener('token-updated', async (event) => {
    console.log('Credentials Modal: Token updated event received', event.detail);
    // Check if we should show credentials modal when token changes
    setTimeout(async () => {
        const shouldShow = await CredentialsModal.shouldShowCredentialsModal();
        console.log('Should show credentials modal after token update:', shouldShow);
        
        if (shouldShow) {
            console.log('Credentials Modal: Creating modal after token update');
            new CredentialsModal();
            CredentialsModal.setCredentialsModalShown();
        }
    }, 1000);
});

// Periodic check for token status (every 5 minutes)
setInterval(async () => {
    if (DisclaimerModal.isDisclaimerAccepted()) {
        const shouldShow = await CredentialsModal.shouldShowCredentialsModal();
        if (shouldShow) {
            console.log('Credentials Modal: Periodic check - showing modal');
            new CredentialsModal();
            CredentialsModal.setCredentialsModalShown();
        }
    }
}, 5 * 60 * 1000); // 5 minutes

// Export for testing
if (typeof module !== 'undefined' && module.exports) {
    export default CredentialsModal;;
} 


/* From: public/js/modules/disclaimer-modal.js */
/**
 * @module
 * @description ES Module (converted from CommonJS)
 */

/**
 * Disclaimer Modal Module
 * Enforces user acknowledgment before allowing access to the application
 */
class DisclaimerModal {
    constructor() {
        this.isActive = false;
        this.focusableElements = [];
        this.firstFocusableElement = null;
        this.lastFocusableElement = null;
        this.previousActiveElement = null;
        
        this.init();
    }

    init() {
        this.createModal();
        this.bindEvents();
        this.showModal();
    }

    createModal() {
        // Create modal overlay
        const overlay = document.createElement('div');
        overlay.className = 'disclaimer-modal-overlay';
        overlay.setAttribute('role', 'dialog');
        overlay.setAttribute('aria-modal', 'true');
        overlay.setAttribute('aria-labelledby', 'disclaimer-title');
        overlay.setAttribute('aria-describedby', 'disclaimer-content');

        // Create modal content
        overlay.innerHTML = `
            <div class="disclaimer-modal" tabindex="-1">
                <div class="disclaimer-modal-header">
                    <h2 id="disclaimer-title">
                        <span class="warning-icon" aria-hidden="true"></span>
                        <span>Important Disclaimer</span>
                    </h2>
                </div>
                
                <div class="disclaimer-modal-body">
                    <div id="disclaimer-content" class="disclaimer-content">
                        <h3> UNSUPPORTED TOOL WARNING</h3>
                        <p>
                            <strong>This tool is NOT an official Ping Identity product</strong> and is provided 
                            <span class="highlight">without any warranty or support</span>. Use at your own risk.
                        </p>
                        
                        <h3> CRITICAL DISCLAIMERS:</h3>
                        <ul>
                            <li><strong>No technical support</strong> is available from Ping Identity</li>
                            <li><strong>No updates or bug fixes</strong> are guaranteed</li>
                            <li><strong>No compatibility</strong> with future PingOne versions is assured</li>
                            <li><strong>No documentation or training</strong> is provided by Ping Identity</li>
                            <li>This tool may <strong>stop working at any time</strong> without notice</li>
                            <li>Use of this tool is <strong>not recommended for production environments</strong></li>
                            <li>You are <strong>responsible for testing and validating</strong> all operations</li>
                            <li><strong>Backup your PingOne account</strong> before using this tool</li>
                            <li><strong>Test in non-production environments</strong> only</li>
                        </ul>
                        
                        <p>
                            <strong>By continuing, you acknowledge that:</strong>
                        </p>
                        <ul>
                            <li>You understand this tool is unsupported and use it at your own risk</li>
                            <li>You have backed up your PingOne account data</li>
                            <li>You will test operations in non-production environments first</li>
                            <li>You accept full responsibility for any data loss or issues</li>
                        </ul>
                    </div>
                </div>
                
                <div class="disclaimer-modal-footer">
                    <div class="disclaimer-agreement">
                        <div class="disclaimer-checkbox">
                            <input type="checkbox" id="disclaimer-agreement-checkbox" required>
                            <label for="disclaimer-agreement-checkbox">
                                <span class="required-indicator">*</span>
                                I acknowledge and accept the above disclaimer. I understand this tool is unsupported and I use it at my own risk.
                            </label>
                        </div>
                    </div>
                    
                    <div class="disclaimer-actions">
                        <button type="button" class="disclaimer-btn disclaimer-btn-secondary" id="disclaimer-cancel">
                            Cancel
                        </button>
                        <button type="button" class="disclaimer-btn disclaimer-btn-primary" id="disclaimer-continue" disabled>
                            Continue
                        </button>
                    </div>
                </div>
            </div>
        `;

        document.body.appendChild(overlay);
        this.overlay = overlay;
        this.modal = overlay.querySelector('.disclaimer-modal');
        this.checkbox = overlay.querySelector('#disclaimer-agreement-checkbox');
        this.continueBtn = overlay.querySelector('#disclaimer-continue');
        this.cancelBtn = overlay.querySelector('#disclaimer-cancel');
    }

    bindEvents() {
        // Checkbox change event
        this.checkbox.addEventListener('change', (e) => {
            this.continueBtn.disabled = !e.target.checked;
            this.logEvent('disclaimer_checkbox_changed', { checked: e.target.checked });
        });

        // Continue button click
        this.continueBtn.addEventListener('click', () => {
            this.acceptDisclaimer();
        });

        // Cancel button click
        this.cancelBtn.addEventListener('click', () => {
            this.cancelDisclaimer();
        });

        // Keyboard events for accessibility
        this.overlay.addEventListener('keydown', (e) => {
            this.handleKeyboardNavigation(e);
        });

        // Prevent clicks outside modal from closing it
        this.overlay.addEventListener('click', (e) => {
            if (e.target === this.overlay) {
                // Don't close on outside click - require explicit action
                this.logEvent('disclaimer_outside_click_prevented');
            }
        });

        // Escape key handling
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && this.isActive) {
                e.preventDefault();
                this.cancelDisclaimer();
            }
        });
    }

    handleKeyboardNavigation(e) {
        if (!this.isActive) return;

        const focusableElements = this.getFocusableElements();
        const firstElement = focusableElements[0];
        const lastElement = focusableElements[focusableElements.length - 1];

        // Tab key navigation with focus trapping
        if (e.key === 'Tab') {
            if (e.shiftKey) {
                if (document.activeElement === firstElement) {
                    e.preventDefault();
                    lastElement.focus();
                }
            } else {
                if (document.activeElement === lastElement) {
                    e.preventDefault();
                    firstElement.focus();
                }
            }
        }
    }

    getFocusableElements() {
        const focusableSelectors = [
            'button:not([disabled])',
            'input:not([disabled])',
            'select:not([disabled])',
            'textarea:not([disabled])',
            'a[href]',
            '[tabindex]:not([tabindex="-1"])'
        ];

        return Array.from(this.modal.querySelectorAll(focusableSelectors.join(', ')));
    }

    showModal() {
        this.isActive = true;
        this.previousActiveElement = document.activeElement;
        
        // Add classes to body and app container
        document.body.classList.add('disclaimer-modal-open');
        const appContainer = document.querySelector('.app-container');
        if (appContainer) {
            appContainer.classList.add('disclaimer-modal-active');
        }

        // Show modal with animation
        this.overlay.classList.add('active');
        
        // Focus management
        this.modal.focus();
        this.setupFocusTrap();
        
        this.logEvent('disclaimer_modal_shown');
        
        // Announce to screen readers
        this.announceToScreenReader('Disclaimer modal opened. You must read and accept the disclaimer to continue.');
    }

    setupFocusTrap() {
        this.focusableElements = this.getFocusableElements();
        this.firstFocusableElement = this.focusableElements[0];
        this.lastFocusableElement = this.focusableElements[this.focusableElements.length - 1];
    }

    acceptDisclaimer() {
        if (!this.checkbox.checked) {
            this.logEvent('disclaimer_acceptance_attempted_without_checkbox');
            return;
        }

        this.logEvent('disclaimer_accepted');
        this.hideModal();
        
        // Enable application functionality
        this.enableApplication();
        
        // Call the app's enableToolAfterDisclaimer function to show startup screen
        if (typeof window.enableToolAfterDisclaimer === 'function') {
            console.log('[STARTUP] [DEBUG] Disclaimer accepted, calling enableToolAfterDisclaimer');
            window.enableToolAfterDisclaimer();
        } else {
            console.warn('[STARTUP] [DEBUG] enableToolAfterDisclaimer function not found');
        }
        
        // Dispatch custom event for other components to listen to
        document.dispatchEvent(new CustomEvent('disclaimerAccepted', {
            detail: { timestamp: new Date().toISOString() }
        }));
        
        // Announce to screen readers
        this.announceToScreenReader('Disclaimer accepted. Application is now enabled.');
    }

    cancelDisclaimer() {
        this.logEvent('disclaimer_cancelled');
        this.hideModal();
        
        // Show warning that application cannot be used without accepting
        this.showCancellationWarning();
    }

    hideModal() {
        this.isActive = false;
        
        // Remove classes
        document.body.classList.remove('disclaimer-modal-open');
        const appContainer = document.querySelector('.app-container');
        if (appContainer) {
            appContainer.classList.remove('disclaimer-modal-active');
        }

        // Hide modal with animation
        this.overlay.classList.remove('active');
        
        // Restore focus
        if (this.previousActiveElement) {
            this.previousActiveElement.focus();
        }
        
        // Announce to screen readers
        this.announceToScreenReader('Disclaimer modal closed.');
    }

    enableApplication() {
        // Remove disabled state from all interactive elements
        const disabledElements = document.querySelectorAll('[disabled]');
        disabledElements.forEach(el => {
            if (el.classList.contains('disclaimer-disabled')) {
                el.disabled = false;
                el.classList.remove('disclaimer-disabled');
            }
        });

        // Enable navigation
        const navItems = document.querySelectorAll('.nav-item');
        navItems.forEach(item => {
            item.style.pointerEvents = 'auto';
            item.style.opacity = '1';
        });

        // Enable feature cards
        const featureCards = document.querySelectorAll('.feature-card');
        featureCards.forEach(card => {
            card.style.pointerEvents = 'auto';
            card.style.opacity = '1';
        });

        // Store acceptance
        DisclaimerModal.setDisclaimerAccepted();
        this.logEvent('application_enabled_after_disclaimer');
    }

    showCancellationWarning() {
        // Create a temporary warning message
        const warning = document.createElement('div');
        warning.className = 'alert alert-warning alert-dismissible fade show';
        warning.style.position = 'fixed';
        warning.style.top = '20px';
        warning.style.left = '50%';
        warning.style.transform = 'translateX(-50%)';
        warning.style.zIndex = '10000';
        warning.style.maxWidth = '500px';
        warning.innerHTML = `
            <strong> Disclaimer Required</strong>
            <br>You must accept the disclaimer to use this tool. The application will remain disabled until you acknowledge the terms.
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        `;

        document.body.appendChild(warning);

        // Auto-remove after 10 seconds
        setTimeout(() => {
            if (warning.parentNode) {
                warning.remove();
            }
        }, 10000);

        this.logEvent('disclaimer_cancellation_warning_shown');
    }

    announceToScreenReader(message) {
        // Create temporary element for screen reader announcement
        const announcement = document.createElement('div');
        announcement.setAttribute('aria-live', 'polite');
        announcement.setAttribute('aria-atomic', 'true');
        announcement.className = 'sr-only';
        announcement.textContent = message;
        
        document.body.appendChild(announcement);
        
        // Remove after announcement
        setTimeout(() => {
            if (announcement.parentNode) {
                announcement.remove();
            }
        }, 1000);
    }

    logEvent(eventName, data = {}) {
        // Log to console for debugging
        console.log(`[DisclaimerModal] ${eventName}:`, data);
        
        // Send to server if logging is available and properly initialized
        try {
            // Check if logManager exists and has the log method
            if (window.logManager && typeof window.logManager.log === 'function') {
                window.logManager.log('info', `Disclaimer modal: ${eventName}`, {
                    source: 'disclaimer-modal',
                    type: 'ui',
                    ...data
                });
            } else if (window.logManager) {
                // logManager exists but doesn't have log method - initialize it
                if (typeof window.logManager.log !== 'function') {
                    window.logManager.log = function(level, message, data) {
                        const timestamp = new Date().toISOString();
                        const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message}`;
                        if (data) {
                            console.log(logMessage, data);
                        } else {
                            console.log(logMessage);
                        }
                    };
                    // Now try logging again
                    window.logManager.log('info', `Disclaimer modal: ${eventName}`, {
                        source: 'disclaimer-modal',
                        type: 'ui',
                        ...data
                    });
                }
            } else {
                // logManager not available - create a basic one
                window.logManager = {
                    log: function(level, message, data) {
                        const timestamp = new Date().toISOString();
                        const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message}`;
                        if (data) {
                            console.log(logMessage, data);
                        } else {
                            console.log(logMessage);
                        }
                    }
                };
                // Now try logging
                window.logManager.log('info', `Disclaimer modal: ${eventName}`, {
                    source: 'disclaimer-modal',
                    type: 'ui',
                    ...data
                });
            }
        } catch (error) {
            // Graceful fallback if logging fails
            console.warn('[DisclaimerModal] Logging failed:', error);
        }
    }

    // === CONFIGURATION ===
    // Set to true for session-only disclaimer (shows once per browser session)
    static DISCLAIMER_SESSION_ONLY = false; // set true for sessionStorage, false for localStorage
    
    // Static method to check if disclaimer was previously accepted
    static isDisclaimerAccepted() {
        // DEVELOPMENT MODE: Always return true to skip disclaimer during testing
        return true;
    }

    // Static method to set acceptance (handles session/local/expiry)
    static setDisclaimerAccepted() {
        if (DisclaimerModal.DISCLAIMER_SESSION_ONLY) {
            sessionStorage.setItem('disclaimerAccepted', 'true');
        } else {
            localStorage.setItem('disclaimerAccepted', 'true');
            localStorage.setItem('disclaimerAcceptedAt', new Date().toISOString());
        }
    }

    // Static method to reset disclaimer acceptance
    static resetDisclaimerAcceptance() {
        if (DisclaimerModal.DISCLAIMER_SESSION_ONLY) {
            sessionStorage.removeItem('disclaimerAccepted');
        } else {
            localStorage.removeItem('disclaimerAccepted');
            localStorage.removeItem('disclaimerAcceptedAt');
        }
    }
}

// Initialize disclaimer modal immediately (DOM is already loaded when bundle executes)
// Initialize disclaimer modal immediately (DOM is already loaded when bundle executes)
(function() {
    console.log('[DISCLAIMER DEBUG] Modal initialization starting immediately');
    let disclaimerInitialized = false;
    async function initializeDisclaimer() {
        if (disclaimerInitialized) return;
        // Ensure logManager is available before proceeding
        if (!window.logManager) {
            window.logManager = {
                log: function(level, message, data) {
                    const timestamp = new Date().toISOString();
                    const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message}`;
                    if (data) {
                        console.log(logMessage, data);
                    } else {
                        console.log(logMessage);
                    }
                }
            };
        }
        // Fetch settings from server
        let showDisclaimerModal = true;
        try {
            const response = await fetch('/api/settings');
            if (response.ok) {
                const result = await response.json();
                if (result && typeof result.showDisclaimerModal !== 'undefined') {
                    showDisclaimerModal = result.showDisclaimerModal;
                }
            }
        } catch (err) {
            console.warn('[DISCLAIMER DEBUG] Failed to fetch settings, defaulting showDisclaimerModal to true:', err);
        }
        // Check disclaimer acceptance status
        const isAccepted = DisclaimerModal.isDisclaimerAccepted();
        // Only show disclaimer if not previously accepted and flag is true
        if (!isAccepted && showDisclaimerModal) {
            new DisclaimerModal();
            disclaimerInitialized = true;
        } else {
            if (typeof window.enableToolAfterDisclaimer === 'function') {
                window.enableToolAfterDisclaimer();
            }
            disclaimerInitialized = true;
        }
    }
    // Try to initialize immediately
    initializeDisclaimer();
    // Also try after a short delay to ensure app components are loaded
    setTimeout(initializeDisclaimer, 100);
    setTimeout(initializeDisclaimer, 1000);
    setTimeout(initializeDisclaimer, 2000);
})();

// Export for global access
window.DisclaimerModal = DisclaimerModal; 


/* From: public/js/modules/disclaimer-banner.js */
/**
 * Ping Identity Disclaimer Banner Module
 * 
 * Provides a dismissible disclaimer banner that matches Ping Identity's design
 * and automatically hides after user acknowledgment.
 */

class DisclaimerBanner {
  constructor() {
    this.storageKey = 'ping-disclaimer-dismissed';
    this.banner = null;
    this.isVisible = false;
    this.autoHideTimeout = null;
    this.init();
  }

  /**
   * Initialize the disclaimer banner
   */
  init() {
    // Check if banner should be shown
    if (this.shouldShowBanner()) {
      this.createBanner();
      this.showBanner();
    }
  }

  /**
   * Check if the banner should be displayed
   * @returns {boolean}
   */
  shouldShowBanner() {
    // Don't show on internal tools
    const currentPath = window.location.pathname;
    const internalTools = [
      '/api-tester.html',
      '/logs',
      '/test-',
      '/swagger/'
    ];

    // Check if current page is an internal tool
    const isInternalTool = internalTools.some(tool => currentPath.includes(tool));
    if (isInternalTool) {
      return false;
    }

    // Check if banner was previously dismissed
    const dismissed = this.getDismissalStatus();
    return !dismissed;
  }

  /**
   * Create the disclaimer banner HTML
   */
  createBanner() {
    // Create banner element
    this.banner = document.createElement('div');
    this.banner.className = 'ping-disclaimer-banner';
    this.banner.id = 'ping-disclaimer-banner';
    this.banner.setAttribute('role', 'alert');
    this.banner.setAttribute('aria-live', 'polite');

    // Banner content
    this.banner.innerHTML = `
      <div class="ping-disclaimer-content">
        <div class="ping-disclaimer-text">
          <span class="ping-disclaimer-icon" aria-hidden="true"></span>
          <div class="ping-disclaimer-message">
            <strong>DISCLAIMER:</strong> This tool is unsupported and provided as-is. 
            Ping Identity is not liable for any harm or data loss. 
            Please backup your PingOne account and test in non-production environments only.
          </div>
        </div>
        <button class="ping-disclaimer-dismiss" id="ping-disclaimer-dismiss" type="button">
          I Understand
        </button>
      </div>
    `;

    // Add banner to page
    document.body.appendChild(this.banner);

    // Add body class for spacing
    document.body.classList.add('has-disclaimer-banner');

    // Bind event listeners
    this.bindEvents();
  }

  /**
   * Bind event listeners for the banner
   */
  bindEvents() {
    const dismissButton = this.banner.querySelector('#ping-disclaimer-dismiss');
    
    if (dismissButton) {
      // Click to dismiss
      dismissButton.addEventListener('click', () => {
        this.dismissBanner();
      });

      // Keyboard support
      dismissButton.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          this.dismissBanner();
        }
      });
    }

    // Auto-hide after 2 seconds if not dismissed
    this.autoHideTimeout = setTimeout(() => {
      if (this.isVisible) {
        this.dismissBanner();
      }
    }, 2000);
  }

  /**
   * Show the disclaimer banner with animation
   */
  showBanner() {
    if (!this.banner) return;

    // Trigger reflow for animation
    this.banner.offsetHeight;
    
    // Show banner
    this.banner.classList.add('show');
    this.isVisible = true;

    // Announce to screen readers
    this.announceToScreenReader();
  }

  /**
   * Dismiss the disclaimer banner
   */
  dismissBanner() {
    if (!this.banner || !this.isVisible) return;

    // Clear auto-hide timeout
    if (this.autoHideTimeout) {
      clearTimeout(this.autoHideTimeout);
      this.autoHideTimeout = null;
    }

    // Hide banner with animation
    this.banner.classList.add('hide');
    this.isVisible = false;

    // Store dismissal in localStorage
    this.setDismissalStatus(true);

    // Remove banner after animation
    setTimeout(() => {
      this.removeBanner();
    }, 400);
  }

  /**
   * Remove the banner from DOM
   */
  removeBanner() {
    if (this.banner && this.banner.parentNode) {
      this.banner.parentNode.removeChild(this.banner);
      this.banner = null;
    }

    // Remove body class
    document.body.classList.remove('has-disclaimer-banner');
  }

  /**
   * Get dismissal status from localStorage
   * @returns {boolean}
   */
  getDismissalStatus() {
    try {
      const dismissed = localStorage.getItem(this.storageKey);
      return dismissed === 'true';
    } catch (error) {
      console.warn('Could not access localStorage for disclaimer status:', error);
      return false;
    }
  }

  /**
   * Set dismissal status in localStorage
   * @param {boolean} dismissed
   */
  setDismissalStatus(dismissed) {
    try {
      localStorage.setItem(this.storageKey, dismissed.toString());
    } catch (error) {
      console.warn('Could not save disclaimer status to localStorage:', error);
    }
  }

  /**
   * Announce banner to screen readers
   */
  announceToScreenReader() {
    const message = 'Disclaimer: This tool is unsupported and provided as-is. Ping Identity is not liable for any harm or data loss. Please backup your PingOne account and test in non-production environments only.';
    
    // Create temporary element for announcement
    const announcement = document.createElement('div');
    announcement.setAttribute('aria-live', 'assertive');
    announcement.setAttribute('aria-atomic', 'true');
    announcement.style.position = 'absolute';
    announcement.style.left = '-10000px';
    announcement.style.width = '1px';
    announcement.style.height = '1px';
    announcement.style.overflow = 'hidden';
    announcement.textContent = message;
    
    document.body.appendChild(announcement);
    
    // Remove after announcement
    setTimeout(() => {
      if (announcement.parentNode) {
        announcement.parentNode.removeChild(announcement);
      }
    }, 1000);
  }

  /**
   * Reset dismissal status (for testing)
   */
  reset() {
    this.setDismissalStatus(false);
    if (this.banner) {
      this.removeBanner();
    }
    this.init();
  }

  /**
   * Force show banner (for testing)
   */
  forceShow() {
    this.setDismissalStatus(false);
    if (this.banner) {
      this.removeBanner();
    }
    this.init();
  }

  /**
   * Set dismissal status in localStorage
   * @param {boolean} dismissed
   */
  setDismissalStatus(dismissed) {
    try {
      localStorage.setItem(this.storageKey, dismissed.toString());
    } catch (error) {
      console.warn('Could not save disclaimer status to localStorage:', error);
    }
  }

  /**
   * Announce banner to screen readers
   */
  announceToScreenReader() {
    const message = 'Disclaimer: This tool is unsupported and provided as-is. Ping Identity is not liable for any harm or data loss. Please backup your PingOne account and test in non-production environments only.';
    
    // Create temporary element for announcement
    const announcement = document.createElement('div');
    announcement.setAttribute('aria-live', 'assertive');
    announcement.setAttribute('aria-atomic', 'true');
    announcement.style.position = 'absolute';
    announcement.style.left = '-10000px';
    announcement.style.width = '1px';
    announcement.style.height = '1px';
    announcement.style.overflow = 'hidden';
    announcement.textContent = message;
    
    document.body.appendChild(announcement);
    
    // Remove after announcement
    setTimeout(() => {
      if (announcement.parentNode) {
        announcement.parentNode.removeChild(announcement);
      }
    }, 1000);
  }

  /**
   * Reset dismissal status (for testing)
   */
  reset() {
    this.setDismissalStatus(false);
    if (this.banner) {
      this.removeBanner();
    }
    this.init();
  }

  /**
   * Force show banner (for testing)
   */
  forceShow() {
    this.setDismissalStatus(false);
    if (this.banner) {
      this.removeBanner();
    }
    this.init();
  }
}

// Export for use in other modules
export { DisclaimerBanner };
export default DisclaimerBanner;

// Browser global fallback for legacy compatibility
if (typeof window !== 'undefined') {
  window.DisclaimerBanner = DisclaimerBanner;
}

// Auto-initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    window.pingDisclaimerBanner = new DisclaimerBanner();
  });
} else {
  window.pingDisclaimerBanner = new DisclaimerBanner();
} 


/* From: public/js/modules/circular-progress.js */
/**
 * Circular Progress Spinner Component
 * Usage: createCircularProgress({ value, label, state, id })
 * - value: 0-100 (percent)
 * - label: status message (optional)
 * - state: '', 'error', 'warning', 'complete', 'ready' (optional)
 * - id: DOM id (optional)
 * 
 * Fixes visual duplication and rendering bugs in progress spinner during async operations
 */
export function createCircularProgress({ value = 0, label = '', state = '', id = '' } = {}) {
  // Ensure proper sizing and rendering calculations
  const size = 80;
  const stroke = 8;
  const radius = (size - stroke) / 2;
  const circumference = 2 * Math.PI * radius;
  
  // Clamp value between 0 and 100
  const percent = Math.max(0, Math.min(100, value));
  
  // Calculate stroke dash array for proper circular progress
  const dashOffset = circumference - (percent / 100) * circumference;
  
  // Generate unique ID if not provided
  const elementId = id || `circular-progress-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  
  // Create wrapper element with proper state management
  const wrapper = document.createElement('div');
  wrapper.className = `circular-progress${state ? ' ' + state : ''}`;
  wrapper.id = elementId;
  wrapper.setAttribute('role', 'progressbar');
  wrapper.setAttribute('aria-valuenow', percent);
  wrapper.setAttribute('aria-valuemin', 0);
  wrapper.setAttribute('aria-valuemax', 100);
  wrapper.setAttribute('aria-label', label ? `${label} ${percent}%` : `${percent}%`);
  
  // Add data attributes for debugging and state tracking
  wrapper.setAttribute('data-percent', percent);
  wrapper.setAttribute('data-state', state);
  wrapper.setAttribute('data-created', new Date().toISOString());

  // Create SVG with proper viewBox and dimensions
  wrapper.innerHTML = `
    <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg">
      <!-- Background circle -->
      <circle 
        class="circular-bg" 
        cx="${size/2}" 
        cy="${size/2}" 
        r="${radius}" 
        fill="none"
        stroke="#e0e0e0"
        stroke-width="${stroke}"
      />
      <!-- Foreground progress circle -->
      <circle 
        class="circular-fg" 
        cx="${size/2}" 
        cy="${size/2}" 
        r="${radius}" 
        fill="none"
        stroke="var(--brand-color, #7c3aed)"
        stroke-width="${stroke}"
        stroke-linecap="round"
        stroke-dasharray="${circumference}"
        stroke-dashoffset="${dashOffset}"
        transform="rotate(-90 ${size/2} ${size/2})"
      />
    </svg>
    <!-- Percentage label -->
    <span class="circular-label">${Math.round(percent)}%</span>
    ${label ? `<span class="circular-status">${label}</span>` : ''}
  `;
  
  // Add debug logging for spinner creation
  console.debug('Circular Progress Created:', {
    id: elementId,
    percent,
    state,
    size,
    stroke,
    radius,
    circumference,
    dashOffset,
    label
  });
  
  return wrapper;
} 


/* From: public/js/modules/message-formatter.js */
/**
 * Enhanced Message Formatter Module
 * 
 * Improves readability of server messages with:
 * - Visual separators and formatting
 * - Structured message blocks
 * - Event grouping and labeling
 * - Timestamp formatting
 * - Color coding and styling
 * 
 * Features:
 * - Message block separation with asterisks
 * - Event start/end markers
 * - Structured formatting with line breaks
 * - Timestamp and label formatting
 * - Consistent styling across all message types
 */

import { createWinstonLogger } from './winston-logger.js';

/**
 * Enhanced Message Formatter Class
 * 
 * Formats server messages for improved readability in logs and progress windows
 */
class MessageFormatter {
    constructor() {
        this.logger = createWinstonLogger({
            service: 'pingone-message-formatter',
            environment: process.env.NODE_ENV || 'development'
        });

        // Message formatting options
        this.formattingOptions = {
            showTimestamps: true,
            showEventMarkers: true,
            showSeparators: true,
            maxMessageLength: 200,
            separatorChar: '*',
            separatorLength: 50
        };

        // Event type configurations
        this.eventTypes = {
            import: {
                start: 'IMPORT STARTED',
                end: 'IMPORT COMPLETED',
                error: 'IMPORT ERROR',
                color: '#3498db'
            },
            export: {
                start: 'EXPORT STARTED',
                end: 'EXPORT COMPLETED',
                error: 'EXPORT ERROR',
                color: '#27ae60'
            },
            modify: {
                start: 'MODIFY STARTED',
                end: 'MODIFY COMPLETED',
                error: 'MODIFY ERROR',
                color: '#f39c12'
            },
            delete: {
                start: 'DELETE STARTED',
                end: 'DELETE COMPLETED',
                error: 'DELETE ERROR',
                color: '#e74c3c'
            },
            validation: {
                start: 'VALIDATION STARTED',
                end: 'VALIDATION COMPLETED',
                error: 'VALIDATION ERROR',
                color: '#9b59b6'
            },
            connection: {
                start: 'CONNECTION ESTABLISHED',
                end: 'CONNECTION CLOSED',
                error: 'CONNECTION ERROR',
                color: '#1abc9c'
            }
        };
    }

    /**
     * Format a message block with visual separators
     * @param {string} eventType - Type of event (import, export, etc.)
     * @param {string} eventStage - Stage of the event (start, end, error, progress)
     * @param {string} message - The main message
     * @param {Object} details - Additional details
     * @returns {string} Formatted message block
     */
    formatMessageBlock(eventType, eventStage, message, details = {}) {
        try {
            const eventConfig = this.eventTypes[eventType] || this.eventTypes.import;
            const timestamp = this.formatTimestamp(new Date());
            const separator = this.createSeparator();
            
            let formattedMessage = '';

            // Add separator at the beginning
            if (this.formattingOptions.showSeparators) {
                formattedMessage += separator + '\n';
            }

            // Add event marker
            if (this.formattingOptions.showEventMarkers) {
                const marker = this.getEventMarker(eventConfig, eventStage);
                formattedMessage += `${marker}\n`;
            }

            // Add timestamp
            if (this.formattingOptions.showTimestamps) {
                formattedMessage += `[${timestamp}] `;
            }

            // Add main message
            formattedMessage += message + '\n';

            // Add details if present
            if (details && Object.keys(details).length > 0) {
                formattedMessage += this.formatDetails(details);
            }

            // Add separator at the end
            if (this.formattingOptions.showSeparators) {
                formattedMessage += separator + '\n';
            }

            this.logger.debug('Message block formatted', { 
                eventType, 
                eventStage, 
                messageLength: message.length 
            });

            return formattedMessage;
        } catch (error) {
            this.logger.error('Error formatting message block', { error: error.message });
            return message; // Fallback to original message
        }
    }

    /**
     * Format a progress update message
     * @param {string} operation - Operation type
     * @param {number} current - Current progress
     * @param {number} total - Total items
     * @param {string} message - Progress message
     * @param {Object} stats - Progress statistics
     * @returns {string} Formatted progress message
     */
    formatProgressMessage(operation, current, total, message, stats = {}) {
        try {
            const timestamp = this.formatTimestamp(new Date());
            const percentage = total > 0 ? Math.round((current / total) * 100) : 0;
            
            let formattedMessage = '';

            // Add timestamp
            if (this.formattingOptions.showTimestamps) {
                formattedMessage += `[${timestamp}] `;
            }

            // Add progress indicator
            formattedMessage += `PROGRESS: ${current}/${total} (${percentage}%)`;

            // Add message if provided
            if (message) {
                formattedMessage += ` - ${message}`;
            }

            // Add stats if available
            if (stats && Object.keys(stats).length > 0) {
                formattedMessage += '\n' + this.formatProgressStats(stats);
            }

            return formattedMessage;
        } catch (error) {
            this.logger.error('Error formatting progress message', { error: error.message });
            return message || `Progress: ${current}/${total}`;
        }
    }

    /**
     * Format an error message with context
     * @param {string} operation - Operation type
     * @param {string} errorMessage - Error message
     * @param {Object} errorDetails - Error details
     * @returns {string} Formatted error message
     */
    formatErrorMessage(operation, errorMessage, errorDetails = {}) {
        try {
            const eventConfig = this.eventTypes[operation] || this.eventTypes.import;
            const timestamp = this.formatTimestamp(new Date());
            const separator = this.createSeparator();
            
            let formattedMessage = '';

            // Add separator
            if (this.formattingOptions.showSeparators) {
                formattedMessage += separator + '\n';
            }

            // Add error marker
            formattedMessage += `${eventConfig.error}\n`;

            // Add timestamp and error message
            if (this.formattingOptions.showTimestamps) {
                formattedMessage += `[${timestamp}] `;
            }
            formattedMessage += `ERROR: ${errorMessage}\n`;

            // Add error details if present
            if (errorDetails && Object.keys(errorDetails).length > 0) {
                formattedMessage += this.formatErrorDetails(errorDetails);
            }

            // Add separator
            if (this.formattingOptions.showSeparators) {
                formattedMessage += separator + '\n';
            }

            return formattedMessage;
        } catch (error) {
            this.logger.error('Error formatting error message', { error: error.message });
            return `ERROR: ${errorMessage}`;
        }
    }

    /**
     * Format a completion message with results
     * @param {string} operation - Operation type
     * @param {Object} results - Operation results
     * @returns {string} Formatted completion message
     */
    formatCompletionMessage(operation, results = {}) {
        try {
            const eventConfig = this.eventTypes[operation] || this.eventTypes.import;
            const timestamp = this.formatTimestamp(new Date());
            const separator = this.createSeparator();
            
            let formattedMessage = '';

            // Add separator
            if (this.formattingOptions.showSeparators) {
                formattedMessage += separator + '\n';
            }

            // Add completion marker
            formattedMessage += `${eventConfig.end}\n`;

            // Add timestamp
            if (this.formattingOptions.showTimestamps) {
                formattedMessage += `[${timestamp}] `;
            }

            // Add completion message
            formattedMessage += `Operation completed successfully\n`;

            // Add results if present
            if (results && Object.keys(results).length > 0) {
                formattedMessage += this.formatResults(results);
            }

            // Add separator
            if (this.formattingOptions.showSeparators) {
                formattedMessage += separator + '\n';
            }

            return formattedMessage;
        } catch (error) {
            this.logger.error('Error formatting completion message', { error: error.message });
            return 'Operation completed successfully';
        }
    }

    /**
     * Format SSE event data for display
     * @param {Object} eventData - SSE event data
     * @returns {string} Formatted event message
     */
    formatSSEEvent(eventData) {
        try {
            const { type, message, current, total, counts, error } = eventData;
            const timestamp = this.formatTimestamp(new Date());

            let formattedMessage = '';

            // Add timestamp
            if (this.formattingOptions.showTimestamps) {
                formattedMessage += `[${timestamp}] `;
            }

            // Format based on event type
            switch (type) {
                case 'progress':
                    formattedMessage += this.formatProgressMessage('import', current, total, message, counts);
                    break;
                case 'completion':
                    formattedMessage += this.formatCompletionMessage('import', eventData);
                    break;
                case 'error':
                    formattedMessage += this.formatErrorMessage('import', message, eventData);
                    break;
                default:
                    formattedMessage += `SSE EVENT [${type.toUpperCase()}]: ${message || 'No message'}`;
            }

            return formattedMessage;
        } catch (error) {
            this.logger.error('Error formatting SSE event', { error: error.message });
            return eventData.message || 'SSE event received';
        }
    }

    /**
     * Create a visual separator line
     * @returns {string} Separator string
     */
    createSeparator() {
        const char = this.formattingOptions.separatorChar;
        const length = this.formattingOptions.separatorLength;
        return char.repeat(length);
    }

    /**
     * Get event marker based on event type and stage
     * @param {Object} eventConfig - Event configuration
     * @param {string} stage - Event stage
     * @returns {string} Event marker
     */
    getEventMarker(eventConfig, stage) {
        switch (stage) {
            case 'start':
                return eventConfig.start;
            case 'end':
                return eventConfig.end;
            case 'error':
                return eventConfig.error;
            default:
                return eventConfig.start;
        }
    }

    /**
     * Format timestamp for display
     * @param {Date} date - Date to format
     * @returns {string} Formatted timestamp
     */
    formatTimestamp(date) {
        return date.toLocaleTimeString('en-US', {
            hour12: false,
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });
    }

    /**
     * Format details object for display
     * @param {Object} details - Details object
     * @returns {string} Formatted details
     */
    formatDetails(details) {
        try {
            let formatted = '';
            for (const [key, value] of Object.entries(details)) {
                if (value !== null && value !== undefined) {
                    formatted += `  ${key}: ${value}\n`;
                }
            }
            return formatted;
        } catch (error) {
            this.logger.error('Error formatting details', { error: error.message });
            return '';
        }
    }

    /**
     * Format progress statistics
     * @param {Object} stats - Progress statistics
     * @returns {string} Formatted statistics
     */
    formatProgressStats(stats) {
        try {
            let formatted = '  Statistics:\n';
            const statLabels = {
                processed: 'Processed',
                success: 'Success',
                failed: 'Failed',
                skipped: 'Skipped',
                duplicates: 'Duplicates'
            };

            for (const [key, value] of Object.entries(stats)) {
                if (value !== null && value !== undefined && statLabels[key]) {
                    formatted += `    ${statLabels[key]}: ${value}\n`;
                }
            }

            return formatted;
        } catch (error) {
            this.logger.error('Error formatting progress stats', { error: error.message });
            return '';
        }
    }

    /**
     * Format error details
     * @param {Object} errorDetails - Error details
     * @returns {string} Formatted error details
     */
    formatErrorDetails(errorDetails) {
        try {
            let formatted = '  Error Details:\n';
            for (const [key, value] of Object.entries(errorDetails)) {
                if (value !== null && value !== undefined) {
                    formatted += `    ${key}: ${value}\n`;
                }
            }
            return formatted;
        } catch (error) {
            this.logger.error('Error formatting error details', { error: error.message });
            return '';
        }
    }

    /**
     * Format operation results
     * @param {Object} results - Operation results
     * @returns {string} Formatted results
     */
    formatResults(results) {
        try {
            let formatted = '  Results:\n';
            const resultLabels = {
                total: 'Total Records',
                success: 'Successful',
                failed: 'Failed',
                skipped: 'Skipped',
                duplicates: 'Duplicates',
                duration: 'Duration'
            };

            for (const [key, value] of Object.entries(results)) {
                if (value !== null && value !== undefined && resultLabels[key]) {
                    let displayValue = value;
                    if (key === 'duration' && typeof value === 'number') {
                        displayValue = this.formatDuration(value);
                    }
                    formatted += `    ${resultLabels[key]}: ${displayValue}\n`;
                }
            }

            return formatted;
        } catch (error) {
            this.logger.error('Error formatting results', { error: error.message });
            return '';
        }
    }

    /**
     * Format duration in milliseconds to human readable format
     * @param {number} milliseconds - Duration in milliseconds
     * @returns {string} Formatted duration
     */
    formatDuration(milliseconds) {
        try {
            const seconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);

            if (hours > 0) {
                return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
            } else if (minutes > 0) {
                return `${minutes}m ${seconds % 60}s`;
            } else {
                return `${seconds}s`;
            }
        } catch (error) {
            this.logger.error('Error formatting duration', { error: error.message });
            return `${milliseconds}ms`;
        }
    }

    /**
     * Update formatting options
     * @param {Object} options - New formatting options
     */
    updateFormattingOptions(options) {
        try {
            this.formattingOptions = { ...this.formattingOptions, ...options };
            this.logger.debug('Formatting options updated', { options });
        } catch (error) {
            this.logger.error('Error updating formatting options', { error: error.message });
        }
    }

    /**
     * Get current formatting options
     * @returns {Object} Current formatting options
     */
    getFormattingOptions() {
        return { ...this.formattingOptions };
    }
}

// Create and export singleton instance
const messageFormatter = new MessageFormatter();

export { messageFormatter as default, MessageFormatter }; 

