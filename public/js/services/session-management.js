/**
 * Session management Module
 * 
 * Consolidated JavaScript for PingOne Import Tool
 * Generated: 2025-08-06T19:08:20.696Z
 * 
 * This file was automatically generated by js-final-cleanup.js
 * Organized for better maintainability and performance
 */


/* From: public/js/modules/session-manager.js */
/**
 * Session Manager for PingOne Import Tool
 * 
 * Handles session ID generation, validation, and management for SSE connections
 * across all operations (import, export, modify, delete).
 * 
 * Features:
 * - Centralized session ID generation
 * - Session ID validation and format checking
 * - Session tracking and cleanup
 * - Error handling for missing/invalid session IDs
 */

import { createWinstonLogger } from './winston-logger.js';

/**
 * Session Manager Class
 */
class SessionManager {
    constructor() {
        this.logger = createWinstonLogger({
            service: 'pingone-import-session',
            environment: process.env.NODE_ENV || 'development'
        });
        
        this.activeSessions = new Map();
        this.sessionCounter = 0;
    }

    /**
     * Generate a unique session ID
     * @returns {string} Unique session identifier
     */
    generateSessionId() {
        try {
            const timestamp = Date.now();
            const random = Math.random().toString(36).substring(2, 15);
            const counter = ++this.sessionCounter;
            const sessionId = `session_${timestamp}_${random}_${counter}`;
            
            this.logger.debug('Session ID generated', { sessionId });
            return sessionId;
        } catch (error) {
            this.logger.error('Error generating session ID', { error: error.message });
            // Fallback to simple timestamp-based ID
            return `session_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
        }
    }

    /**
     * Validate session ID format and structure
     * @param {string} sessionId - Session ID to validate
     * @returns {boolean} True if valid, false otherwise
     */
    validateSessionId(sessionId) {
        try {
            if (!sessionId || typeof sessionId !== 'string') {
                this.logger.warn('Session ID validation failed: null/undefined/non-string', { sessionId, type: typeof sessionId });
                return false;
            }

            if (sessionId.trim() === '') {
                this.logger.warn('Session ID validation failed: empty string');
                return false;
            }

            // Check for minimum length (should be at least 8 characters)
            if (sessionId.length < 8) {
                this.logger.warn('Session ID validation failed: too short', { length: sessionId.length });
                return false;
            }

            // Check for valid characters (alphanumeric, underscore, hyphen)
            const validPattern = /^[a-zA-Z0-9_-]+$/;
            if (!validPattern.test(sessionId)) {
                this.logger.warn('Session ID validation failed: invalid characters', { sessionId });
                return false;
            }

            this.logger.debug('Session ID validation passed', { sessionId });
            return true;
        } catch (error) {
            this.logger.error('Error validating session ID', { error: error.message, sessionId });
            return false;
        }
    }

    /**
     * Register an active session
     * @param {string} sessionId - Session ID to register
     * @param {string} operationType - Type of operation (import, export, etc.)
     * @param {Object} metadata - Additional session metadata
     */
    registerSession(sessionId, operationType, metadata = {}) {
        try {
            if (!this.validateSessionId(sessionId)) {
                this.logger.error('Cannot register invalid session ID', { sessionId, operationType });
                return false;
            }

            const sessionData = {
                sessionId,
                operationType,
                createdAt: Date.now(),
                lastActivity: Date.now(),
                metadata
            };

            this.activeSessions.set(sessionId, sessionData);
            this.logger.info('Session registered', { sessionId, operationType, metadata });
            return true;
        } catch (error) {
            this.logger.error('Error registering session', { error: error.message, sessionId, operationType });
            return false;
        }
    }

    /**
     * Update session activity timestamp
     * @param {string} sessionId - Session ID to update
     */
    updateSessionActivity(sessionId) {
        try {
            const session = this.activeSessions.get(sessionId);
            if (session) {
                session.lastActivity = Date.now();
                this.logger.debug('Session activity updated', { sessionId });
            } else {
                this.logger.warn('Session not found for activity update', { sessionId });
            }
        } catch (error) {
            this.logger.error('Error updating session activity', { error: error.message, sessionId });
        }
    }

    /**
     * Unregister a session
     * @param {string} sessionId - Session ID to unregister
     */
    unregisterSession(sessionId) {
        try {
            const session = this.activeSessions.get(sessionId);
            if (session) {
                this.activeSessions.delete(sessionId);
                this.logger.info('Session unregistered', { sessionId, operationType: session.operationType });
            } else {
                this.logger.warn('Session not found for unregistration', { sessionId });
            }
        } catch (error) {
            this.logger.error('Error unregistering session', { error: error.message, sessionId });
        }
    }

    /**
     * Get session information
     * @param {string} sessionId - Session ID to retrieve
     * @returns {Object|null} Session data or null if not found
     */
    getSession(sessionId) {
        try {
            return this.activeSessions.get(sessionId) || null;
        } catch (error) {
            this.logger.error('Error getting session', { error: error.message, sessionId });
            return null;
        }
    }

    /**
     * Get all active sessions
     * @returns {Array} Array of active session data
     */
    getActiveSessions() {
        try {
            return Array.from(this.activeSessions.values());
        } catch (error) {
            this.logger.error('Error getting active sessions', { error: error.message });
            return [];
        }
    }

    /**
     * Clean up expired sessions
     * @param {number} maxAge - Maximum age in milliseconds (default: 1 hour)
     */
    cleanupExpiredSessions(maxAge = 60 * 60 * 1000) {
        try {
            const now = Date.now();
            const expiredSessions = [];

            for (const [sessionId, session] of this.activeSessions.entries()) {
                if (now - session.lastActivity > maxAge) {
                    expiredSessions.push(sessionId);
                }
            }

            expiredSessions.forEach(sessionId => {
                this.unregisterSession(sessionId);
            });

            if (expiredSessions.length > 0) {
                this.logger.info('Cleaned up expired sessions', { count: expiredSessions.length });
            }
        } catch (error) {
            this.logger.error('Error cleaning up expired sessions', { error: error.message });
        }
    }

    /**
     * Get session statistics
     * @returns {Object} Session statistics
     */
    getSessionStats() {
        try {
            const sessions = this.getActiveSessions();
            const stats = {
                total: sessions.length,
                byOperation: {},
                oldest: null,
                newest: null
            };

            sessions.forEach(session => {
                // Count by operation type
                stats.byOperation[session.operationType] = (stats.byOperation[session.operationType] || 0) + 1;

                // Track oldest and newest
                if (!stats.oldest || session.createdAt < stats.oldest.createdAt) {
                    stats.oldest = session;
                }
                if (!stats.newest || session.createdAt > stats.newest.createdAt) {
                    stats.newest = session;
                }
            });

            return stats;
        } catch (error) {
            this.logger.error('Error getting session stats', { error: error.message });
            return { total: 0, byOperation: {}, oldest: null, newest: null };
        }
    }
}

// Export singleton instance
export const sessionManager = new SessionManager();
export default sessionManager; 


/* From: public/js/modules/session-subsystem.js */
/**
 * Session Management Subsystem
 * Modern replacement for legacy SessionManager
 * Handles session lifecycle, activity tracking, and cleanup
 */

export class SessionSubsystem {
    constructor(logger, settingsSubsystem, eventBus) {
        this.logger = logger;
        this.settingsSubsystem = settingsSubsystem;
        this.eventBus = eventBus;

        // Session state
        this.currentSession = null;
        this.activeSessions = new Map();
        this.sessionTimeout = 30 * 60 * 1000; // 30 minutes default
        this.cleanupInterval = null;
        this.activityTimer = null;

        // Session configuration
        this.config = {
            maxSessions: 10,
            sessionTimeout: 30 * 60 * 1000,
            activityCheckInterval: 60 * 1000, // 1 minute
            autoCleanup: true
        };

        this.setupEventListeners();
        this.logger.info('Session Subsystem initialized');
    }

    /**
     * Initialize the session subsystem
     */
    async init() {
        try {
            await this.loadConfiguration();
            this.startActivityMonitoring();
            this.startCleanupProcess();
            
            // Create initial session
            await this.createSession();
            
            this.logger.info('Session Subsystem initialized successfully');
        } catch (error) {
            this.logger.error('Failed to initialize Session Subsystem', error);
            throw error;
        }
    }

    /**
     * Load session configuration
     */
    async loadConfiguration() {
        try {
            await this.settingsSubsystem.loadCurrentSettings();
            const settings = this.settingsSubsystem.currentSettings;
            if (settings.session) {
                this.config = { ...this.config, ...settings.session };
                this.sessionTimeout = this.config.sessionTimeout;
            }
        } catch (error) {
            this.logger.warn('Failed to load session configuration, using defaults', error);
        }
    }

    /**
     * Setup event listeners
     */
    setupEventListeners() {
        // Listen for user activity events
        this.eventBus.on('user:activity', () => {
            this.updateActivity();
        });

        // Listen for authentication events
        this.eventBus.on('auth:login', (data) => {
            this.handleLogin(data);
        });

        this.eventBus.on('auth:logout', () => {
            this.handleLogout();
        });

        // Listen for settings changes
        this.eventBus.on('settings:updated', (data) => {
            if (data.session) {
                this.updateConfiguration(data.session);
            }
        });

        // Browser events
        window.addEventListener('beforeunload', () => {
            this.handleBeforeUnload();
        });

        window.addEventListener('focus', () => {
            this.updateActivity();
        });

        // Activity detection events
        const activityEvents = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'];
        activityEvents.forEach(event => {
            document.addEventListener(event, () => {
                this.updateActivity();
            }, { passive: true });
        });
    }

    /**
     * Create a new session
     */
    async createSession(userId = null) {
        const sessionId = this.generateSessionId();
        const session = {
            id: sessionId,
            userId: userId,
            createdAt: Date.now(),
            lastActivity: Date.now(),
            expiresAt: Date.now() + this.sessionTimeout,
            isActive: true,
            metadata: {
                userAgent: navigator.userAgent,
                timestamp: new Date().toISOString(),
                url: window.location.href
            }
        };

        this.activeSessions.set(sessionId, session);
        this.currentSession = session;

        // Cleanup old sessions if needed
        if (this.activeSessions.size > this.config.maxSessions) {
            this.cleanupOldSessions();
        }

        this.logger.info('Session created', { 
            sessionId, 
            userId,
            totalSessions: this.activeSessions.size 
        });

        this.eventBus.emit('session:created', { session });
        return session;
    }

    /**
     * Update session activity
     */
    updateActivity() {
        if (!this.currentSession) return;

        const now = Date.now();
        this.currentSession.lastActivity = now;
        this.currentSession.expiresAt = now + this.sessionTimeout;

        // Update in sessions map
        this.activeSessions.set(this.currentSession.id, this.currentSession);

        this.logger.debug('Session activity updated', { 
            sessionId: this.currentSession.id,
            lastActivity: new Date(now).toISOString()
        });

        this.eventBus.emit('session:activity', { 
            sessionId: this.currentSession.id,
            timestamp: now 
        });
    }

    /**
     * Handle user login
     */
    async handleLogin(data) {
        if (this.currentSession) {
            this.currentSession.userId = data.userId;
            this.currentSession.lastActivity = Date.now();
            this.activeSessions.set(this.currentSession.id, this.currentSession);
        } else {
            await this.createSession(data.userId);
        }

        this.logger.info('User logged in', { 
            userId: data.userId,
            sessionId: this.currentSession?.id 
        });

        this.eventBus.emit('session:login', { 
            userId: data.userId,
            sessionId: this.currentSession?.id 
        });
    }

    /**
     * Handle user logout
     */
    handleLogout() {
        if (this.currentSession) {
            this.endSession(this.currentSession.id);
        }

        this.logger.info('User logged out');
        this.eventBus.emit('session:logout');
    }

    /**
     * End a session
     */
    endSession(sessionId) {
        const session = this.activeSessions.get(sessionId);
        if (session) {
            session.isActive = false;
            session.endedAt = Date.now();
            
            this.activeSessions.delete(sessionId);
            
            if (this.currentSession && this.currentSession.id === sessionId) {
                this.currentSession = null;
            }

            this.logger.info('Session ended', { sessionId });
            this.eventBus.emit('session:ended', { sessionId, session });
        }
    }

    /**
     * Start activity monitoring
     */
    startActivityMonitoring() {
        if (this.activityTimer) {
            clearInterval(this.activityTimer);
        }

        this.activityTimer = setInterval(() => {
            this.checkSessionExpiry();
        }, this.config.activityCheckInterval);

        this.logger.debug('Activity monitoring started');
    }

    /**
     * Check for expired sessions
     */
    checkSessionExpiry() {
        const now = Date.now();
        const expiredSessions = [];

        this.activeSessions.forEach((session, sessionId) => {
            if (session.expiresAt < now) {
                expiredSessions.push(sessionId);
            }
        });

        expiredSessions.forEach(sessionId => {
            this.logger.info('Session expired', { sessionId });
            this.endSession(sessionId);
            this.eventBus.emit('session:expired', { sessionId });
        });

        if (expiredSessions.length > 0) {
            this.logger.info('Expired sessions cleaned up', { count: expiredSessions.length });
        }
    }

    /**
     * Start cleanup process
     */
    startCleanupProcess() {
        if (!this.config.autoCleanup) return;

        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
        }

        // Run cleanup every 5 minutes
        this.cleanupInterval = setInterval(() => {
            this.cleanupOldSessions();
        }, 5 * 60 * 1000);

        this.logger.debug('Cleanup process started');
    }

    /**
     * Cleanup old sessions
     */
    cleanupOldSessions() {
        const sessions = Array.from(this.activeSessions.values());
        const sortedSessions = sessions.sort((a, b) => b.lastActivity - a.lastActivity);
        
        // Keep only the most recent sessions up to maxSessions
        const sessionsToRemove = sortedSessions.slice(this.config.maxSessions);
        
        sessionsToRemove.forEach(session => {
            this.endSession(session.id);
        });

        if (sessionsToRemove.length > 0) {
            this.logger.info('Old sessions cleaned up', { count: sessionsToRemove.length });
        }
    }

    /**
     * Update configuration
     */
    updateConfiguration(newConfig) {
        this.config = { ...this.config, ...newConfig };
        this.sessionTimeout = this.config.sessionTimeout;

        // Restart monitoring with new config
        this.startActivityMonitoring();
        this.startCleanupProcess();

        this.logger.info('Session configuration updated', this.config);
        this.eventBus.emit('session:config-updated', this.config);
    }

    /**
     * Handle before unload
     */
    handleBeforeUnload() {
        if (this.currentSession) {
            // Mark session as potentially ending
            this.eventBus.emit('session:before-unload', { 
                sessionId: this.currentSession.id 
            });
        }
    }

    /**
     * Generate unique session ID
     */
    generateSessionId() {
        const timestamp = Date.now().toString(36);
        const random = Math.random().toString(36).substr(2, 9);
        return `session_${timestamp}_${random}`;
    }

    /**
     * Get current session
     */
    getCurrentSession() {
        return this.currentSession;
    }

    /**
     * Get session by ID
     */
    getSession(sessionId) {
        return this.activeSessions.get(sessionId);
    }

    /**
     * Get all active sessions
     */
    getActiveSessions() {
        return Array.from(this.activeSessions.values());
    }

    /**
     * Get active session count
     */
    getActiveSessionCount() {
        return this.activeSessions.size;
    }

    /**
     * Get session statistics
     */
    getSessionStats() {
        const sessions = this.getActiveSessions();
        const now = Date.now();

        return {
            totalSessions: sessions.length,
            activeSessions: sessions.filter(s => s.isActive).length,
            expiredSessions: sessions.filter(s => s.expiresAt < now).length,
            averageSessionDuration: this.calculateAverageSessionDuration(sessions),
            oldestSession: sessions.reduce((oldest, session) => 
                (!oldest || session.createdAt < oldest.createdAt) ? session : oldest, null
            ),
            newestSession: sessions.reduce((newest, session) => 
                (!newest || session.createdAt > newest.createdAt) ? session : newest, null
            )
        };
    }

    /**
     * Calculate average session duration
     */
    calculateAverageSessionDuration(sessions) {
        if (sessions.length === 0) return 0;

        const totalDuration = sessions.reduce((total, session) => {
            const endTime = session.endedAt || Date.now();
            return total + (endTime - session.createdAt);
        }, 0);

        return Math.round(totalDuration / sessions.length);
    }

    /**
     * Export session data
     */
    exportSessionData() {
        const sessions = this.getActiveSessions();
        const stats = this.getSessionStats();

        return {
            currentSession: this.currentSession,
            sessions: sessions.map(session => ({
                ...session,
                duration: (session.endedAt || Date.now()) - session.createdAt
            })),
            statistics: stats,
            configuration: this.config,
            exportedAt: new Date().toISOString()
        };
    }

    /**
     * Destroy the session subsystem
     */
    destroy() {
        // Clear timers
        if (this.activityTimer) {
            clearInterval(this.activityTimer);
            this.activityTimer = null;
        }

        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
            this.cleanupInterval = null;
        }

        // End all sessions
        this.activeSessions.forEach((session, sessionId) => {
            this.endSession(sessionId);
        });

        this.currentSession = null;
        this.activeSessions.clear();

        this.logger.info('Session Subsystem destroyed');
        this.eventBus.emit('session:destroyed');
    }
}

// Export for ES modules
export default SessionSubsystem;



/* From: public/js/modules/connection-manager-subsystem.js */
import { TokenAccess } from '../../../src/shared/token-integration-helper.js';
/**
 * Connection Manager Subsystem
 * 
 * Manages all PingOne connection functionality including token acquisition,
 * validation, connection testing, and credential management.
 * 
 * Features:
 * - Token acquisition and validation
 * - Connection testing and health checks
 * - Credential validation and storage
 * - Connection status monitoring
 * - Automatic token refresh
 * - Connection retry logic
 */

import { createWinstonLogger } from './winston-logger.js';

export class ConnectionManagerSubsystem {
    constructor(logger, uiManager, settingsSubsystem, apiClient) {
        this.logger = logger || createWinstonLogger({
            service: 'connection-manager-subsystem',
            environment: process.env.NODE_ENV || 'development'
        });
        
        this.uiManager = uiManager;
        this.settingsSubsystem = settingsSubsystem;
        this.apiClient = apiClient;
        
        // Connection state
        this.connectionStatus = 'disconnected';
        this.lastConnectionTest = null;
        this.tokenInfo = {
            token: null,
            expiresAt: null,
            isValid: false
        };
        
        // Connection monitoring
        this.healthCheckInterval = null;
        this.tokenRefreshInterval = null;
        this.connectionRetryCount = 0;
        this.maxRetryAttempts = 3;
        
        // Event listeners
        this.eventListeners = new Map();
        
        this.logger.info('Connection Manager subsystem initialized');
    }
    
    /**
     * Initialize the connection manager subsystem
     */
    async init() {
        try {
            this.logger.info('Initializing connection manager subsystem...');
            
            // Load existing token if available
            await this.loadExistingToken();
            
            // Start connection monitoring
            this.startConnectionMonitoring();
            
            // Set up automatic token refresh
            this.setupTokenRefresh();
            
            this.logger.info('Connection Manager subsystem initialized successfully');
        } catch (error) {
            this.logger.error('Failed to initialize connection manager subsystem', { error: error.message });
            throw error;
        }
    }
    
    /**
     * Test connection to PingOne
     * @param {Object} credentials - Optional credentials to test
     * @returns {Promise<Object>} - Connection test result
     */
    async testConnection(credentials = null) {
        try {
            this.logger.info('Testing PingOne connection...');
            
            // Update UI to show testing state
            if (this.uiManager) {
                this.uiManager.updateConnectionStatus('testing', 'Testing connection...');
            }
            
            // Use provided credentials or get from settings
            const testCredentials = credentials || await this.getCredentials();
            
            if (!testCredentials) {
                throw new Error('No credentials available for connection test');
            }
            
            // Validate credentials format
            this.validateCredentials(testCredentials);
            
            // Test connection by getting a token
            const tokenResult = await this.acquireToken(testCredentials);
            
            if (tokenResult.success) {
                this.connectionStatus = 'connected';
                this.lastConnectionTest = {
                    timestamp: Date.now(),
                    success: true,
                    credentials: {
                        clientId: testCredentials.clientId,
                        environmentId: testCredentials.environmentId,
                        region: testCredentials.region
                    }
                };
                
                // Update UI
                if (this.uiManager) {
                    this.uiManager.updateConnectionStatus('success', 'Connection successful');
                }
                
                this.logger.info('Connection test successful');
                
                // Emit connection success event
                this.emit('connectionSuccess', this.lastConnectionTest);
                
                return {
                    success: true,
                    message: 'Connection successful',
                    token: tokenResult.token,
                    expiresIn: tokenResult.expiresIn
                };
            } else {
                throw new Error(tokenResult.error || 'Failed to acquire token');
            }
            
        } catch (error) {
            this.logger.error('Connection test failed', { error: error.message });
            
            this.connectionStatus = 'disconnected';
            this.lastConnectionTest = {
                timestamp: Date.now(),
                success: false,
                error: error.message
            };
            
            // Update UI
            if (this.uiManager) {
                this.uiManager.updateConnectionStatus('error', `Connection failed: ${error.message}`);
            }
            
            // Emit connection failure event
            this.emit('connectionFailure', { error: error.message });
            
            return {
                success: false,
                error: error.message
            };
        }
    }
    
    /**
     * Acquire a new token from PingOne
     * @param {Object} credentials - PingOne credentials
     * @returns {Promise<Object>} - Token acquisition result
     */
    async acquireToken(credentials = null) {
        try {
            this.logger.info('Acquiring PingOne token...');
            
            // Use provided credentials or get from settings
            const tokenCredentials = credentials || await this.getCredentials();
            
            if (!tokenCredentials) {
                throw new Error('No credentials available for token acquisition');
            }
            
            // Validate credentials
            this.validateCredentials(tokenCredentials);
            
            // Make token request
            const response = await this.apiClient.post('/api/auth/token', {
                clientId: tokenCredentials.clientId,
                clientSecret: tokenCredentials.clientSecret,
                environmentId: tokenCredentials.environmentId,
                region: tokenCredentials.region
            });
            
            if (response.success && response.token) {
                // Store token info
                this.tokenInfo = {
                    token: response.token,
                    expiresAt: Date.now() + (response.expiresIn * 1000),
                    isValid: true,
                    acquiredAt: Date.now()
                };
                
                // Update connection status
                this.connectionStatus = 'connected';
                
                // Update UI
                if (this.uiManager) {
                    this.uiManager.updateTokenStatus(true, 'Token acquired successfully');
                }
                
                this.logger.info('Token acquired successfully', {
                    expiresIn: response.expiresIn
                });
                
                // Emit token acquired event
                this.emit('tokenAcquired', {
                    token: response.token,
                    expiresIn: response.expiresIn
                });
                
                return {
                    success: true,
                    token: response.token,
                    expiresIn: response.expiresIn
                };
            } else {
                throw new Error(response.error || 'Failed to acquire token');
            }
            
        } catch (error) {
            this.logger.error('Token acquisition failed', { error: error.message });
            
            // Clear token info
            this.tokenInfo = {
                token: null,
                expiresAt: null,
                isValid: false
            };
            
            // Update connection status
            this.connectionStatus = 'disconnected';
            
            // Update UI
            if (this.uiManager) {
                this.uiManager.updateTokenStatus(false, `Token acquisition failed: ${error.message}`);
            }
            
            // Emit token acquisition failure event
            this.emit('tokenAcquisitionFailure', { error: error.message });
            
            return {
                success: false,
                error: error.message
            };
        }
    }
    
    /**
     * Validate current token
     * @returns {Promise<boolean>} - Whether token is valid
     */
    async validateToken() {
        try {
            if (!this.tokenInfo.token) {
                this.logger.debug('No token to validate');
                return false;
            }
            
            // Check if token is expired
            if (this.tokenInfo.expiresAt && Date.now() >= this.tokenInfo.expiresAt) {
                this.logger.info('Token has expired');
                this.tokenInfo.isValid = false;
                return false;
            }
            
            // Test token with a simple API call
            const response = await this.apiClient.get('/api/auth/validate', {
                headers: {
                    'Authorization': `Bearer ${this.tokenInfo.token}`
                }
            });
            
            const isValid = response.success;
            this.tokenInfo.isValid = isValid;
            
            if (isValid) {
                this.logger.debug('Token validation successful');
                this.connectionStatus = 'connected';
            } else {
                this.logger.info('Token validation failed');
                this.connectionStatus = 'disconnected';
            }
            
            return isValid;
            
        } catch (error) {
            this.logger.error('Token validation error', { error: error.message });
            this.tokenInfo.isValid = false;
            this.connectionStatus = 'disconnected';
            return false;
        }
    }
    
    /**
     * Refresh current token
     * @returns {Promise<Object>} - Token refresh result
     */
    async refreshToken() {
        try {
            this.logger.info('Refreshing token...');
            
            // Get current credentials
            const credentials = await this.getCredentials();
            if (!credentials) {
                throw new Error('No credentials available for token refresh');
            }
            
            // Acquire new token
            const result = await this.acquireToken(credentials);
            
            if (result.success) {
                this.logger.info('Token refreshed successfully');
                
                // Emit token refreshed event
                this.emit('tokenRefreshed', {
                    token: result.token,
                    expiresIn: result.expiresIn
                });
            }
            
            return result;
            
        } catch (error) {
            this.logger.error('Token refresh failed', { error: error.message });
            
            // Emit token refresh failure event
            this.emit('tokenRefreshFailure', { error: error.message });
            
            return {
                success: false,
                error: error.message
            };
        }
    }
    
    /**
     * Get current credentials
     * @returns {Promise<Object|null>} - Current credentials
     */
    async getCredentials() {
        try {
            // Try to get from credentials manager first
            if (window.credentialsManager) {
                const credentials = window.credentialsManager.getCredentials();
                if (credentials && this.isValidCredentialSet(credentials)) {
                    return credentials;
                }
            }
            
            // Fallback to settings manager
            if (this.settingsSubsystem) {
                const settings = await this.settingsSubsystem.getSettings();
                if (settings && this.isValidCredentialSet(settings)) {
                    return {
                        clientId: settings.clientId,
                        clientSecret: settings.clientSecret,
                        environmentId: settings.environmentId,
                        region: settings.region
                    };
                }
            }
            
            return null;
        } catch (error) {
            this.logger.error('Failed to get credentials', { error: error.message });
            return null;
        }
    }
    
    /**
     * Validate credentials format
     * @param {Object} credentials - Credentials to validate
     */
    validateCredentials(credentials) {
        const required = ['clientId', 'clientSecret', 'environmentId'];
        const missing = required.filter(field => !credentials[field]);
        
        if (missing.length > 0) {
            throw new Error(`Missing required credentials: ${missing.join(', ')}`);
        }
        
        // Validate format
        if (!/^[a-f0-9-]{36}$/.test(credentials.clientId)) {
            throw new Error('Invalid client ID format');
        }
        
        if (!/^[a-f0-9-]{36}$/.test(credentials.environmentId)) {
            throw new Error('Invalid environment ID format');
        }
        
        if (credentials.clientSecret.length < 10) {
            throw new Error('Client secret appears to be invalid');
        }
    }
    
    /**
     * Check if credential set is valid
     * @param {Object} credentials - Credentials to check
     * @returns {boolean} - Whether credentials are valid
     */
    isValidCredentialSet(credentials) {
        try {
            this.validateCredentials(credentials);
            return true;
        } catch (error) {
            return false;
        }
    }
    
    /**
     * Load existing token from storage
     */
    async loadExistingToken() {
        try {
            // Try to load from token manager
            if (window.globalTokenManager && typeof window.globalTokenManager.getCachedToken === 'function') {
                const cachedToken = window.globalTokenManager.getCachedToken();
                if (cachedToken) {
                    this.tokenInfo = {
                        token: cachedToken.token,
                        expiresAt: cachedToken.expiresAt,
                        isValid: cachedToken.isValid,
                        acquiredAt: cachedToken.acquiredAt
                    };
                    
                    // Validate the loaded token
                    const isValid = await this.validateToken();
                    if (isValid) {
                        this.connectionStatus = 'connected';
                        this.logger.info('Existing token loaded and validated');
                    } else {
                        this.logger.info('Existing token loaded but invalid');
                    }
                }
            }
        } catch (error) {
            this.logger.error('Failed to load existing token', { error: error.message });
        }
    }
    
    /**
     * Start connection monitoring
     */
    startConnectionMonitoring() {
        // Health check every 5 minutes
        this.healthCheckInterval = setInterval(async () => {
            if (this.connectionStatus === 'connected') {
                const isValid = await this.validateToken();
                if (!isValid) {
                    this.logger.info('Connection lost during health check');
                    this.emit('connectionLost');
                }
            }
        }, 5 * 60 * 1000);
        
        this.logger.debug('Connection monitoring started');
    }
    
    /**
     * Setup automatic token refresh
     */
    setupTokenRefresh() {
        // Check token expiry every minute
        this.tokenRefreshInterval = setInterval(async () => {
            if (this.tokenInfo.token && this.tokenInfo.expiresAt) {
                const timeUntilExpiry = this.tokenInfo.expiresAt - Date.now();
                const refreshThreshold = 5 * 60 * 1000; // 5 minutes
                
                if (timeUntilExpiry <= refreshThreshold && timeUntilExpiry > 0) {
                    this.logger.info('Token expiring soon, attempting refresh...');
                    await this.refreshToken();
                }
            }
        }, 60 * 1000);
        
        this.logger.debug('Automatic token refresh setup');
    }
    
    /**
     * Get connection status
     * @returns {string} - Current connection status
     */
    getConnectionStatus() {
        return this.connectionStatus;
    }
    
    /**
     * Get token info
     * @returns {Object} - Current token information
     */
    getTokenInfo() {
        return {
            hasToken: !!this.tokenInfo.token,
            isValid: this.tokenInfo.isValid,
            expiresAt: this.tokenInfo.expiresAt,
            timeUntilExpiry: this.tokenInfo.expiresAt ? this.tokenInfo.expiresAt - Date.now() : null
        };
    }
    
    /**
     * Get last connection test result
     * @returns {Object|null} - Last connection test result
     */
    getLastConnectionTest() {
        return this.lastConnectionTest;
    }
    
    /**
     * Check if currently connected
     * @returns {boolean} - Whether currently connected
     */
    isConnected() {
        return this.connectionStatus === 'connected' && this.tokenInfo.isValid;
    }
    
    /**
     * Check if token is valid and not expired
     * @returns {boolean} - Whether token is valid
     */
    hasValidToken() {
        return this.tokenInfo.isValid && 
               this.tokenInfo.token && 
               this.tokenInfo.expiresAt && 
               Date.now() < this.tokenInfo.expiresAt;
    }
    
    /**
     * Disconnect and clear token
     */
    disconnect() {
        this.logger.info('Disconnecting...');
        
        // Clear token info
        this.tokenInfo = {
            token: null,
            expiresAt: null,
            isValid: false
        };
        
        // Update connection status
        this.connectionStatus = 'disconnected';
        
        // Update UI
        if (this.uiManager) {
            this.uiManager.updateConnectionStatus('disconnected', 'Disconnected');
            this.uiManager.updateTokenStatus(false, 'No token');
        }
        
        // Emit disconnected event
        this.emit('disconnected');
        
        this.logger.info('Disconnected successfully');
    }
    
    /**
     * Add event listener
     * @param {string} event - Event name
     * @param {Function} listener - Event listener function
     */
    on(event, listener) {
        if (!this.eventListeners.has(event)) {
            this.eventListeners.set(event, []);
        }
        this.eventListeners.get(event).push(listener);
    }
    
    /**
     * Remove event listener
     * @param {string} event - Event name
     * @param {Function} listener - Event listener function
     */
    off(event, listener) {
        if (this.eventListeners.has(event)) {
            const listeners = this.eventListeners.get(event);
            const index = listeners.indexOf(listener);
            if (index > -1) {
                listeners.splice(index, 1);
            }
        }
    }
    
    /**
     * Emit event
     * @param {string} event - Event name
     * @param {*} data - Event data
     */
    emit(event, data = null) {
        if (this.eventListeners.has(event)) {
            this.eventListeners.get(event).forEach(listener => {
                try {
                    listener(data);
                } catch (error) {
                    this.logger.error('Event listener error', { event, error: error.message });
                }
            });
        }
    }
    
    /**
     * Get connection statistics
     * @returns {Object} - Connection statistics
     */
    getConnectionStats() {
        return {
            status: this.connectionStatus,
            hasToken: !!this.tokenInfo.token,
            tokenValid: this.tokenInfo.isValid,
            tokenExpiresAt: this.tokenInfo.expiresAt,
            lastConnectionTest: this.lastConnectionTest,
            retryCount: this.connectionRetryCount
        };
    }
    
    /**
     * Clean up the connection manager subsystem
     */
    cleanup() {
        // Clear intervals
        if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
        }
        
        if (this.tokenRefreshInterval) {
            clearInterval(this.tokenRefreshInterval);
            this.tokenRefreshInterval = null;
        }
        
        // Clear event listeners
        this.eventListeners.clear();
        
        // Disconnect
        this.disconnect();
        
        this.logger.info('Connection Manager subsystem cleaned up');
    }
}

