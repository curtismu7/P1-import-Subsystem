/**
 * Advanced Token Management Module
 * 
 * Consolidated JavaScript for PingOne Import Tool
 * Generated: 2025-08-06T19:09:11.425Z
 * 
 * This file was automatically generated by js-final-consolidation.js
 * Organized for better maintainability and performance
 */


/* From: public/js/modules/token-management/example.js */
/**
 * @module
 * @description ES Module (converted from CommonJS)
 */

/**
 * Token Management Subsystem - Example Usage
 * 
 * This file demonstrates how to use the Token Management Subsystem.
 */

import { 
  createPingOneTokenProvider,
  createJWTTokenValidator,
  createSimpleTokenStorage,
  createTokenService,
  createTokenManager,
  TokenStatus
} from './index.js';

/**
 * Example encryption service (simplified for demonstration)
 */
class SimpleEncryptionService {
  /**
   * Encrypt a string
   * @param {string} data - Data to encrypt
   * @returns {Promise<string>} Encrypted data
   */
  async encrypt(data) {
    // In a real implementation, this would use proper encryption
    return btoa(`encrypted:${data}`);
  }
  
  /**
   * Decrypt a string
   * @param {string} data - Data to decrypt
   * @returns {Promise<string>} Decrypted data
   */
  async decrypt(data) {
    // In a real implementation, this would use proper decryption
    const decoded = atob(data);
    return decoded.replace('encrypted:', '');
  }
}

/**
 * Example API client (simplified for demonstration)
 */
class SimpleApiClient {
  /**
   * Make a request
   * @param {string} url - URL to request
   * @param {Object} options - Request options
   * @returns {Promise<Object>} Response object
   */
  async request(url, options) {
    console.log(`Making request to ${url}`, options);
    
    // In a real implementation, this would make an actual HTTP request
    // For this example, we'll simulate a token response
    if (url.includes('/as/token')) {
      return {
        ok: true,
        json: async () => ({
          access_token: 'example_access_token',
          refresh_token: 'example_refresh_token',
          token_type: 'Bearer',
          expires_in: 3600,
          scope: 'openid profile'
        })
      };
    }
    
    return {
      ok: false,
      status: 404,
      text: async () => 'Not Found'
    };
  }
}

/**
 * Example logger (simplified for demonstration)
 */
class SimpleLogger {
  debug(message, data) {
    console.log(`[DEBUG] ${message}`, data);
  }
  
  info(message, data) {
    console.log(`[INFO] ${message}`, data);
  }
  
  warn(message, data) {
    console.warn(`[WARN] ${message}`, data);
  }
  
  error(message, data) {
    console.error(`[ERROR] ${message}`, data);
  }
}

/**
 * Example usage of the Token Management Subsystem
 */
async function exampleUsage() {
  // Create dependencies
  const apiClient = new SimpleApiClient();
  const encryptionService = new SimpleEncryptionService();
  const logger = new SimpleLogger();
  
  // Create token provider
  const tokenProvider = createPingOneTokenProvider(
    apiClient,
    {
      clientId: 'example_client_id',
      clientSecret: 'example_client_secret',
      environmentId: 'example_environment_id',
      region: 'na'
    },
    logger
  );
  
  // Create token validator
  const tokenValidator = createJWTTokenValidator({}, logger);
  
  // Create token storage
  const tokenStorage = createSimpleTokenStorage({}, logger);
  
  // Create token service
  const tokenService = createTokenService(
    tokenProvider,
    tokenValidator,
    tokenStorage,
    logger,
    {
      autoRefreshThreshold: 300, // 5 minutes
      refreshRetryLimit: 3
    }
  );
  
  // Create token manager
  const tokenManager = createTokenManager(
    tokenService,
    null, // No status provider yet
    logger,
    {
      autoInitialize: true,
      autoRefresh: true
    }
  );
  
  // Register for token status changes
  tokenManager.onTokenStatusChange(status => {
    console.log(`Token status changed to: ${status}`);
  });
  
  try {
    // Get a token
    console.log('Getting token...');
    const token = await tokenManager.getToken();
    console.log('Token acquired:', token);
    
    // Get token status
    const status = await tokenManager.getTokenStatus();
    console.log('Token status:', status);
    
    // Refresh token
    console.log('Refreshing token...');
    const refreshedToken = await tokenManager.refreshToken();
    console.log('Token refreshed:', refreshedToken);
    
    // Ensure valid token
    console.log('Ensuring valid token...');
    const validToken = await tokenManager.ensureValidToken();
    console.log('Valid token:', validToken);
    
    // Clear token
    console.log('Clearing token...');
    await tokenManager.clearToken();
    console.log('Token cleared');
    
    // Get token status after clearing
    const finalStatus = await tokenManager.getTokenStatus();
    console.log('Final token status:', finalStatus);
  } catch (error) {
    console.error('Error in example:', error);
  } finally {
    // Clean up
    tokenManager.dispose();
  }
}

// Run the example
exampleUsage().catch(error => {
  console.error('Unhandled error in example:', error);
});


/* From: public/js/modules/token-management/index.js */
/**
 * Token Management Subsystem
 * 
 * This module exports all components of the Token Management Subsystem.
 */

// Export models
export * from './models.js';

// Export token provider
export * from './token-provider.js';

// Export token validator
export * from './token-validator.js';

// Export token storage
export * from './token-storage.js';

// Export token service
export * from './token-service.js';

// Export token manager
export * from './token-manager.js';

// Export token status provider
export * from './token-status-provider.js';

// Import all components for convenience
import { TokenStatus, TokenError, convertTokenResponse } from './models.js';
import { TokenProvider, PingOneTokenProvider, createPingOneTokenProvider } from './token-provider.js';
import { TokenValidator, JWTTokenValidator, createJWTTokenValidator } from './token-validator.js';
import { TokenStorage, SecureTokenStorage, SimpleTokenStorage, createSecureTokenStorage, createSimpleTokenStorage } from './token-storage.js';
import { TokenService, createTokenService } from './token-service.js';
import { TokenManager, createTokenManager } from './token-manager.js';
import { TokenStatusProvider, createTokenStatusProvider } from './token-status-provider.js';

/**
 * Create a complete token management system with all components
 * @param {Object} apiClient - API client for making requests
 * @param {Object} encryptionService - Service for encrypting/decrypting data
 * @param {Object} uiManager - UI manager for notifications
 * @param {Object} logger - Logger instance
 * @param {Object} options - Options for all components
 * @returns {Object} The token management system
 */
export function createTokenManagementSystem(apiClient, encryptionService, uiManager, logger, options = {}) {
  // Create token provider
  const tokenProvider = createPingOneTokenProvider(
    apiClient,
    options.provider || {},
    logger
  );
  
  // Create token validator
  const tokenValidator = createJWTTokenValidator(
    options.validator || {},
    logger
  );
  
  // Create token storage
  const tokenStorage = encryptionService
    ? createSecureTokenStorage(encryptionService, options.storage || {}, logger)
    : createSimpleTokenStorage(options.storage || {}, logger);
  
  // Create token service
  const tokenService = createTokenService(
    tokenProvider,
    tokenValidator,
    tokenStorage,
    logger,
    options.service || {}
  );
  
  // Create token status provider if UI manager is available
  let tokenStatusProvider = null;
  if (uiManager) {
    tokenStatusProvider = createTokenStatusProvider(
      tokenService,
      uiManager,
      logger,
      options.statusProvider || {}
    );
  }
  
  // Create token manager
  const tokenManager = createTokenManager(
    tokenService,
    tokenStatusProvider,
    logger,
    options.manager || {}
  );
  
  return {
    tokenProvider,
    tokenValidator,
    tokenStorage,
    tokenService,
    tokenStatusProvider,
    tokenManager
  };
}


/* From: public/js/modules/token-management/models.js */
/**
 * Token Management Subsystem - Models
 * 
 * This module defines the data models used throughout the Token Management Subsystem.
 */

/**
 * Enum representing the possible states of a token
 * @enum {string}
 */
export const TokenStatus = {
  VALID: 'valid',
  EXPIRING_SOON: 'expiring_soon',
  EXPIRED: 'expired',
  REFRESHING: 'refreshing',
  ERROR: 'error',
  NONE: 'none'
};

/**
 * Class representing a token error
 */
export class TokenError extends Error {
  /**
   * Create a token error
   * @param {string} code - Error code
   * @param {string} message - Error message
   * @param {number} [status] - HTTP status code if applicable
   */
  constructor(code, message, status) {
    super(message);
    this.name = 'TokenError';
    this.code = code;
    this.status = status;
  }
}

/**
 * Interface for token information
 * @typedef {Object} TokenInfo
 * @property {string} accessToken - The access token
 * @property {string} [refreshToken] - The refresh token (if available)
 * @property {string} tokenType - The token type (e.g., "Bearer")
 * @property {number} expiresIn - Token lifetime in seconds
 * @property {Date} expiresAt - Date when the token expires
 * @property {string} [scope] - Token scope (if available)
 * @property {string} [idToken] - ID token (if available)
 */

/**
 * Interface for token response from authentication server
 * @typedef {Object} TokenResponse
 * @property {string} access_token - The access token
 * @property {string} [refresh_token] - The refresh token (if available)
 * @property {string} token_type - The token type (e.g., "Bearer")
 * @property {number} expires_in - Token lifetime in seconds
 * @property {string} [scope] - Token scope (if available)
 * @property {string} [id_token] - ID token (if available)
 */

/**
 * Convert a TokenResponse to TokenInfo
 * @param {TokenResponse} response - The token response from the server
 * @returns {TokenInfo} The token information
 */
export function convertTokenResponse(response) {
  return {
    accessToken: response.access_token,
    refreshToken: response.refresh_token,
    tokenType: response.token_type,
    expiresIn: response.expires_in,
    expiresAt: new Date(Date.now() + response.expires_in * 1000),
    scope: response.scope,
    idToken: response.id_token
  };
}

/**
 * Check if a token is expired
 * @param {TokenInfo} tokenInfo - The token information
 * @param {number} [bufferSeconds=0] - Buffer time in seconds
 * @returns {boolean} True if the token is expired
 */
export function isTokenExpired(tokenInfo, bufferSeconds = 0) {
  if (!tokenInfo || !tokenInfo.expiresAt) {
    return true;
  }
  
  const now = new Date();
  const expiresAt = new Date(tokenInfo.expiresAt);
  
  // Add buffer time
  expiresAt.setSeconds(expiresAt.getSeconds() - bufferSeconds);
  
  return now >= expiresAt;
}

/**
 * Check if a token is expiring soon
 * @param {TokenInfo} tokenInfo - The token information
 * @param {number} thresholdSeconds - Threshold in seconds
 * @returns {boolean} True if the token is expiring soon
 */
export function isTokenExpiringSoon(tokenInfo, thresholdSeconds) {
  if (!tokenInfo || !tokenInfo.expiresAt) {
    return false;
  }
  
  const now = new Date();
  const expiresAt = new Date(tokenInfo.expiresAt);
  const thresholdDate = new Date(now);
  
  thresholdDate.setSeconds(thresholdDate.getSeconds() + thresholdSeconds);
  
  return now < expiresAt && thresholdDate >= expiresAt;
}

/**
 * Get the remaining time for a token in seconds
 * @param {TokenInfo} tokenInfo - The token information
 * @returns {number} Remaining time in seconds, or 0 if expired
 */
export function getTokenRemainingTime(tokenInfo) {
  if (!tokenInfo || !tokenInfo.expiresAt) {
    return 0;
  }
  
  const now = Date.now();
  const expiresAt = new Date(tokenInfo.expiresAt).getTime();
  const remainingMs = expiresAt - now;
  
  return Math.max(0, Math.floor(remainingMs / 1000));
}

/**
 * Format remaining time for display
 * @param {number} seconds - Remaining time in seconds
 * @returns {string} Formatted time string (e.g., "5m 30s")
 */
export function formatRemainingTime(seconds) {
  if (seconds <= 0) {
    return 'Expired';
  }
  
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  
  if (minutes > 0) {
    return `${minutes}m ${remainingSeconds}s`;
  }
  
  return `${remainingSeconds}s`;
}


/* From: public/js/modules/token-management/token-manager.js */
/**
 * Token Management Subsystem - Token Manager
 * 
 * This module defines the TokenManager class, which provides a simplified facade
 * for token operations and coordinates with the TokenStatusProvider.
 */

import { TokenStatus, TokenError } from './models.js';

/**
 * Options for TokenManager
 * @typedef {Object} TokenManagerOptions
 * @property {boolean} [autoInitialize=true] - Whether to initialize automatically
 * @property {boolean} [autoRefresh=true] - Whether to enable auto-refresh
 */

/**
 * Facade for token operations
 */
export class TokenManager {
  /**
   * Create a TokenManager
   * @param {import('./token-service.js').TokenService} tokenService - The token service
   * @param {Object} [tokenStatusProvider] - Optional provider for token status display
   * @param {Object} [logger] - Logger instance
   * @param {TokenManagerOptions} [options] - Manager options
   */
  constructor(tokenService, tokenStatusProvider = null, logger, options = {}) {
    if (!tokenService) {
      throw new Error('Token service is required for TokenManager');
    }
    
    this.tokenService = tokenService;
    this.tokenStatusProvider = tokenStatusProvider;
    this.logger = logger || console;
    
    this.options = {
      autoInitialize: true,
      autoRefresh: true,
      ...options
    };
    
    // Status listeners
    this.statusListeners = [];
    
    // Current status
    this.currentStatus = TokenStatus.NONE;
    
    // Initialize if auto-initialize is enabled
    if (this.options.autoInitialize) {
      this.initialize();
    }
    
    this.logger.debug('TokenManager created', {
      autoInitialize: this.options.autoInitialize,
      autoRefresh: this.options.autoRefresh,
      hasStatusProvider: !!this.tokenStatusProvider
    });
  }
  
  /**
   * Initialize the token manager
   * Sets up event listeners and checks initial token status
   */
  initialize() {
    this.logger.debug('Initializing TokenManager');
    
    // Set up token service event listeners
    this.tokenService.onTokenRefresh(token => {
      this.logger.debug('Token refreshed event received');
      this.updateTokenStatus();
      
      // Update status provider if available
      if (this.tokenStatusProvider) {
        this.tokenStatusProvider.showTokenRefreshSuccess();
      }
    });
    
    this.tokenService.onTokenExpired(() => {
      this.logger.debug('Token expired event received');
      this.updateTokenStatus();
      
      // Update status provider if available
      if (this.tokenStatusProvider) {
        this.tokenStatusProvider.showTokenExpiredError();
      }
    });
    
    this.tokenService.onTokenError(error => {
      this.logger.debug('Token error event received', { error });
      this.updateTokenStatus();
      
      // Update status provider if available
      if (this.tokenStatusProvider) {
        this.tokenStatusProvider.showTokenRefreshError(error);
      }
    });
    
    // Check initial token status
    this.updateTokenStatus();
    
    // Start status provider if available
    if (this.tokenStatusProvider) {
      this.tokenStatusProvider.startStatusMonitoring();
    }
    
    this.logger.info('TokenManager initialized');
  }
  
  /**
   * Get a valid token
   * @param {boolean} [forceRefresh=false] - Whether to force a refresh
   * @returns {Promise<string>} The token
   * @throws {TokenError} If token acquisition fails
   */
  async getToken(forceRefresh = false) {
    try {
      this.logger.debug('Getting token', { forceRefresh });
      
      // Update status provider if available
      if (forceRefresh && this.tokenStatusProvider) {
        this.tokenStatusProvider.showTokenRefreshInProgress();
      }
      
      const token = await this.tokenService.getToken(forceRefresh);
      
      // Update token status after getting token
      this.updateTokenStatus();
      
      return token;
    } catch (error) {
      this.logger.error('Failed to get token', { error });
      
      // Update token status after error
      this.updateTokenStatus();
      
      throw error;
    }
  }
  
  /**
   * Ensure a valid token is available
   * If the current token is expired or expiring soon, it will be refreshed
   * @returns {Promise<string>} The token
   * @throws {TokenError} If token acquisition fails
   */
  async ensureValidToken() {
    try {
      this.logger.debug('Ensuring valid token');
      
      const status = await this.tokenService.getTokenStatus();
      const needsRefresh = status === TokenStatus.EXPIRED || status === TokenStatus.EXPIRING_SOON;
      
      return this.getToken(needsRefresh);
    } catch (error) {
      this.logger.error('Failed to ensure valid token', { error });
      throw error;
    }
  }
  
  /**
   * Refresh the token
   * @returns {Promise<string>} The new token
   * @throws {TokenError} If token refresh fails
   */
  async refreshToken() {
    try {
      this.logger.debug('Refreshing token');
      
      // Update status provider if available
      if (this.tokenStatusProvider) {
        this.tokenStatusProvider.showTokenRefreshInProgress();
      }
      
      const token = await this.tokenService.refreshToken();
      
      // Update token status after refreshing
      this.updateTokenStatus();
      
      return token;
    } catch (error) {
      this.logger.error('Failed to refresh token', { error });
      
      // Update token status after error
      this.updateTokenStatus();
      
      throw error;
    }
  }
  
  /**
   * Clear the stored token
   * @returns {Promise<void>}
   */
  async clearToken() {
    try {
      this.logger.debug('Clearing token');
      await this.tokenService.clearToken();
      
      // Update token status after clearing
      this.updateTokenStatus();
      
      this.logger.info('Token cleared successfully');
    } catch (error) {
      this.logger.error('Failed to clear token', { error });
      throw error;
    }
  }
  
  /**
   * Get the current token status
   * @returns {Promise<TokenStatus>} The token status
   */
  async getTokenStatus() {
    return this.tokenService.getTokenStatus();
  }
  
  /**
   * Update the token status and notify listeners
   * @private
   */
  async updateTokenStatus() {
    try {
      const status = await this.tokenService.getTokenStatus();
      
      // If status changed, notify listeners
      if (status !== this.currentStatus) {
        this.currentStatus = status;
        this.notifyStatusListeners(status);
      }
      
      return status;
    } catch (error) {
      this.logger.error('Failed to update token status', { error });
      return TokenStatus.ERROR;
    }
  }
  
  /**
   * Register a listener for token status changes
   * @param {Function} callback - Callback function that receives the new status
   * @returns {Function} Function to unregister the listener
   */
  onTokenStatusChange(callback) {
    this.statusListeners.push(callback);
    
    // Immediately notify with current status
    if (this.currentStatus) {
      try {
        callback(this.currentStatus);
      } catch (error) {
        this.logger.error('Error in token status listener', { error });
      }
    }
    
    return () => {
      this.statusListeners = this.statusListeners.filter(cb => cb !== callback);
    };
  }
  
  /**
   * Notify status listeners
   * @param {TokenStatus} status - The new status
   * @private
   */
  notifyStatusListeners(status) {
    this.logger.debug('Token status changed', { status });
    
    this.statusListeners.forEach(callback => {
      try {
        callback(status);
      } catch (error) {
        this.logger.error('Error in token status listener', { error });
      }
    });
  }
  
  /**
   * Dispose of the token manager
   * This cleans up any listeners and disposes the token service
   */
  dispose() {
    this.logger.debug('Disposing TokenManager');
    
    // Clear status listeners
    this.statusListeners = [];
    
    // Stop status provider if available
    if (this.tokenStatusProvider) {
      this.tokenStatusProvider.stopStatusMonitoring();
    }
    
    // Dispose token service
    this.tokenService.dispose();
    
    this.logger.info('TokenManager disposed');
  }
}

/**
 * Create a TokenManager with the given dependencies
 * @param {import('./token-service.js').TokenService} tokenService - The token service
 * @param {Object} [tokenStatusProvider] - Optional provider for token status display
 * @param {Object} [logger] - Logger instance
 * @param {TokenManagerOptions} [options] - Manager options
 * @returns {TokenManager} The token manager
 */
export function createTokenManager(tokenService, tokenStatusProvider, logger, options) {
  return new TokenManager(tokenService, tokenStatusProvider, logger, options);
}


/* From: public/js/modules/token-management/token-provider.js */
/**
 * Token Management Subsystem - Token Provider
 * 
 * This module defines the TokenProvider interface and implementations.
 * TokenProviders are responsible for acquiring tokens from authentication sources.
 */

import { TokenError, convertTokenResponse } from './models.js';

/**
 * Interface for token providers
 * @interface
 */
export class TokenProvider {
  /**
   * Acquire a token from the authentication source
   * @param {Object} [credentials] - Optional credentials for authentication
   * @returns {Promise<import('./models.js').TokenResponse>} The token response
   * @throws {TokenError} If token acquisition fails
   */
  async acquireToken(credentials) {
    throw new Error('TokenProvider.acquireToken() must be implemented by subclass');
  }
}

/**
 * Options for PingOneTokenProvider
 * @typedef {Object} PingOneTokenProviderOptions
 * @property {string} clientId - PingOne client ID
 * @property {string} clientSecret - PingOne client secret
 * @property {string} environmentId - PingOne environment ID
 * @property {string} region - PingOne region
 * @property {string} [grantType='client_credentials'] - OAuth grant type
 * @property {string} [tokenEndpoint='/as/token'] - Token endpoint path
 */

/**
 * PingOne implementation of TokenProvider
 * @extends TokenProvider
 */
export class PingOneTokenProvider extends TokenProvider {
  /**
   * Create a PingOneTokenProvider
   * @param {Object} apiClient - API client for making requests
   * @param {PingOneTokenProviderOptions} options - Provider options
   * @param {Object} logger - Logger instance
   */
  constructor(apiClient, options, logger) {
    super();
    
    if (!apiClient) {
      throw new Error('API client is required for PingOneTokenProvider');
    }
    
    if (!options || !options.clientId || !options.clientSecret || !options.environmentId || !options.region) {
      throw new Error('Required options missing for PingOneTokenProvider');
    }
    
    this.apiClient = apiClient;
    this.options = {
      grantType: 'client_credentials',
      tokenEndpoint: '/as/token',
      ...options
    };
    this.logger = logger || console;
  }
  
  /**
   * Acquire a token from PingOne
   * @param {Object} [credentials] - Optional credentials for authentication
   * @returns {Promise<import('./models.js').TokenResponse>} The token response
   * @throws {TokenError} If token acquisition fails
   */
  async acquireToken(credentials) {
    try {
      this.logger.debug('Acquiring token from PingOne', { 
        clientId: this.options.clientId,
        environmentId: this.options.environmentId,
        region: this.options.region,
        grantType: this.options.grantType
      });
      
      // Prepare request body based on grant type
      const body = new URLSearchParams();
      body.append('grant_type', this.options.grantType);
      body.append('client_id', this.options.clientId);
      body.append('client_secret', this.options.clientSecret);
      
      // Add additional parameters based on grant type
      if (this.options.grantType === 'refresh_token' && credentials?.refreshToken) {
        body.append('refresh_token', credentials.refreshToken);
      } else if (this.options.grantType === 'password' && credentials) {
        if (credentials.username) body.append('username', credentials.username);
        if (credentials.password) body.append('password', credentials.password);
      }
      
      // Determine the base URL based on region
      const baseUrl = this.getBaseUrl();
      const url = `${baseUrl}${this.options.tokenEndpoint}`;
      
      // Make the request
      const response = await this.apiClient.request(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: body.toString()
      });
      
      // Handle error responses
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ 
          error: 'unknown_error',
          error_description: `HTTP error ${response.status}`
        }));
        
        throw new TokenError(
          errorData.error || 'token_acquisition_failed',
          errorData.error_description || 'Failed to acquire token',
          response.status
        );
      }
      
      // Parse the response
      const tokenResponse = await response.json();
      
      this.logger.info('Token acquired successfully', { 
        tokenType: tokenResponse.token_type,
        expiresIn: tokenResponse.expires_in,
        hasRefreshToken: !!tokenResponse.refresh_token
      });
      
      return tokenResponse;
    } catch (error) {
      // Convert regular errors to TokenError
      if (!(error instanceof TokenError)) {
        this.logger.error('Token acquisition failed', { error });
        throw new TokenError(
          'token_acquisition_failed',
          `Failed to acquire token: ${error.message}`,
          error.status
        );
      }
      
      throw error;
    }
  }
  
  /**
   * Get the base URL for PingOne API based on region
   * @returns {string} The base URL
   * @private
   */
  getBaseUrl() {
    const region = this.options.region.toLowerCase();
    
    // Map of regions to base URLs
    const regionMap = {
      'na': 'https://auth.pingone.com',
      'eu': 'https://auth.pingone.eu',
      'ap': 'https://auth.pingone.asia',
      'ca': 'https://auth.pingone.ca'
    };
    
    return regionMap[region] || regionMap.na;
  }
}

/**
 * Create a PingOneTokenProvider with the given options
 * @param {Object} apiClient - API client for making requests
 * @param {PingOneTokenProviderOptions} options - Provider options
 * @param {Object} logger - Logger instance
 * @returns {PingOneTokenProvider} The token provider
 */
export function createPingOneTokenProvider(apiClient, options, logger) {
  return new PingOneTokenProvider(apiClient, options, logger);
}


/* From: public/js/modules/token-management/token-service.js */
/**
 * Token Management Subsystem - Token Service
 * 
 * This module defines the TokenService class, which is the central service
 * responsible for coordinating all token-related operations.
 */

import { TokenStatus, TokenError, convertTokenResponse, isTokenExpired, isTokenExpiringSoon, getTokenRemainingTime } from './models.js';

/**
 * Options for TokenService
 * @typedef {Object} TokenServiceOptions
 * @property {number} [autoRefreshThreshold=60] - Seconds before expiration to trigger refresh
 * @property {number} [refreshRetryLimit=3] - Maximum number of refresh retries
 * @property {number} [refreshRetryDelay=1000] - Delay between refresh retries in milliseconds
 * @property {number} [tokenExpirationBuffer=30] - Extra buffer to consider a token expired in seconds
 */

/**
 * Central service for token management
 */
export class TokenService {
  /**
   * Create a TokenService
   * @param {import('./token-provider.js').TokenProvider} tokenProvider - Provider for acquiring tokens
   * @param {import('./token-validator.js').TokenValidator} tokenValidator - Validator for token validation
   * @param {import('./token-storage.js').TokenStorage} tokenStorage - Storage for tokens
   * @param {Object} [logger] - Logger instance
   * @param {TokenServiceOptions} [options] - Service options
   */
  constructor(tokenProvider, tokenValidator, tokenStorage, logger, options = {}) {
    if (!tokenProvider) {
      throw new Error('Token provider is required for TokenService');
    }
    
    if (!tokenValidator) {
      throw new Error('Token validator is required for TokenService');
    }
    
    if (!tokenStorage) {
      throw new Error('Token storage is required for TokenService');
    }
    
    this.tokenProvider = tokenProvider;
    this.tokenValidator = tokenValidator;
    this.tokenStorage = tokenStorage;
    this.logger = logger || console;
    
    this.options = {
      autoRefreshThreshold: 60, // 1 minute
      refreshRetryLimit: 3,
      refreshRetryDelay: 1000, // 1 second
      tokenExpirationBuffer: 30, // 30 seconds
      ...options
    };
    
    // Token refresh state
    this.isRefreshing = false;
    this.refreshPromise = null;
    this.refreshCallbacks = [];
    
    // Event listeners
    this.tokenRefreshListeners = [];
    this.tokenExpiredListeners = [];
    this.tokenErrorListeners = [];
    
    // Refresh timer
    this.refreshTimer = null;
    
    this.logger.debug('TokenService initialized', {
      autoRefreshThreshold: this.options.autoRefreshThreshold,
      refreshRetryLimit: this.options.refreshRetryLimit,
      tokenExpirationBuffer: this.options.tokenExpirationBuffer
    });
  }
  
  /**
   * Get a valid token
   * @param {boolean} [forceRefresh=false] - Whether to force a refresh
   * @returns {Promise<string>} The token
   * @throws {TokenError} If token acquisition fails
   */
  async getToken(forceRefresh = false) {
    try {
      this.logger.debug('Getting token', { forceRefresh });
      
      // If a refresh is already in progress, wait for it to complete
      if (this.isRefreshing) {
        this.logger.debug('Token refresh already in progress, waiting for completion');
        return this.waitForRefresh();
      }
      
      // Get the stored token
      const storedToken = await this.tokenStorage.getToken();
      const tokenInfo = await this.tokenStorage.getTokenInfo();
      
      // If we have a token and it's not expired and we're not forcing a refresh, use it
      if (
        storedToken && 
        tokenInfo && 
        !forceRefresh && 
        !isTokenExpired(tokenInfo, this.options.tokenExpirationBuffer)
      ) {
        this.logger.debug('Using stored token', {
          expiresAt: tokenInfo.expiresAt,
          remainingTime: getTokenRemainingTime(tokenInfo)
        });
        
        // Schedule refresh if token is expiring soon
        this.scheduleRefreshIfNeeded(tokenInfo);
        
        return storedToken;
      }
      
      // If we have a refresh token, try to refresh
      if (tokenInfo && tokenInfo.refreshToken) {
        try {
          this.logger.debug('Refreshing token using refresh token');
          return await this.refreshToken(tokenInfo.refreshToken);
        } catch (error) {
          this.logger.warn('Token refresh failed, acquiring new token', { error });
          // Fall through to acquire a new token
        }
      }
      
      // Acquire a new token
      this.logger.debug('Acquiring new token');
      const tokenResponse = await this.tokenProvider.acquireToken();
      const token = tokenResponse.access_token;
      
      // Validate the token
      const isValid = await this.tokenValidator.validateToken(token);
      if (!isValid) {
        throw new TokenError('invalid_token', 'Acquired token is invalid');
      }
      
      // Convert the response to token info
      const newTokenInfo = convertTokenResponse(tokenResponse);
      
      // Store the token
      await this.tokenStorage.saveToken(token, newTokenInfo);
      
      // Schedule refresh if needed
      this.scheduleRefreshIfNeeded(newTokenInfo);
      
      this.logger.info('New token acquired and stored', {
        tokenType: newTokenInfo.tokenType,
        expiresAt: newTokenInfo.expiresAt,
        hasRefreshToken: !!newTokenInfo.refreshToken
      });
      
      return token;
    } catch (error) {
      // Convert regular errors to TokenError
      if (!(error instanceof TokenError)) {
        this.logger.error('Token acquisition failed', { error });
        error = new TokenError(
          'token_acquisition_failed',
          `Failed to acquire token: ${error.message}`
        );
      }
      
      // Notify error listeners
      this.notifyTokenErrorListeners(error);
      
      throw error;
    }
  }
  
  /**
   * Validate a token
   * @param {string} token - The token to validate
   * @returns {Promise<boolean>} True if the token is valid
   */
  async validateToken(token) {
    try {
      this.logger.debug('Validating token');
      return await this.tokenValidator.validateToken(token);
    } catch (error) {
      this.logger.error('Token validation failed', { error });
      return false;
    }
  }
  
  /**
   * Refresh the token
   * @param {string} [refreshToken] - Optional refresh token to use
   * @returns {Promise<string>} The new token
   * @throws {TokenError} If token refresh fails
   */
  async refreshToken(refreshToken) {
    // If a refresh is already in progress, wait for it to complete
    if (this.isRefreshing) {
      this.logger.debug('Token refresh already in progress, waiting for completion');
      return this.waitForRefresh();
    }
    
    try {
      this.isRefreshing = true;
      this.refreshPromise = this._refreshToken(refreshToken);
      const token = await this.refreshPromise;
      return token;
    } finally {
      this.isRefreshing = false;
      this.refreshPromise = null;
    }
  }
  
  /**
   * Internal method to refresh the token
   * @param {string} [refreshToken] - Optional refresh token to use
   * @returns {Promise<string>} The new token
   * @throws {TokenError} If token refresh fails
   * @private
   */
  async _refreshToken(refreshToken) {
    try {
      this.logger.debug('Refreshing token');
      
      // If no refresh token is provided, try to get it from storage
      if (!refreshToken) {
        const tokenInfo = await this.tokenStorage.getTokenInfo();
        refreshToken = tokenInfo?.refreshToken;
        
        if (!refreshToken) {
          throw new TokenError('no_refresh_token', 'No refresh token available');
        }
      }
      
      // Try to refresh the token with retries
      let lastError;
      for (let attempt = 0; attempt <= this.options.refreshRetryLimit; attempt++) {
        try {
          if (attempt > 0) {
            this.logger.debug(`Retry attempt ${attempt}/${this.options.refreshRetryLimit}`);
            await new Promise(resolve => setTimeout(resolve, this.options.refreshRetryDelay * attempt));
          }
          
          // Acquire a new token using the refresh token
          const tokenResponse = await this.tokenProvider.acquireToken({ refreshToken });
          const token = tokenResponse.access_token;
          
          // Validate the token
          const isValid = await this.tokenValidator.validateToken(token);
          if (!isValid) {
            throw new TokenError('invalid_token', 'Refreshed token is invalid');
          }
          
          // Convert the response to token info
          const newTokenInfo = convertTokenResponse(tokenResponse);
          
          // Store the token
          await this.tokenStorage.saveToken(token, newTokenInfo);
          
          // Schedule refresh if needed
          this.scheduleRefreshIfNeeded(newTokenInfo);
          
          this.logger.info('Token refreshed successfully', {
            tokenType: newTokenInfo.tokenType,
            expiresAt: newTokenInfo.expiresAt,
            hasRefreshToken: !!newTokenInfo.refreshToken
          });
          
          // Notify refresh listeners
          this.notifyTokenRefreshListeners(token);
          
          // Resolve any pending callbacks
          this.resolveRefreshCallbacks(token);
          
          return token;
        } catch (error) {
          lastError = error;
          this.logger.warn(`Token refresh attempt ${attempt + 1} failed`, { error });
          
          // If this is an auth error, don't retry
          if (
            error instanceof TokenError && 
            (error.code === 'invalid_grant' || error.status === 401)
          ) {
            break;
          }
        }
      }
      
      // All retries failed
      throw lastError || new TokenError('refresh_failed', 'Token refresh failed after retries');
    } catch (error) {
      // Convert regular errors to TokenError
      if (!(error instanceof TokenError)) {
        this.logger.error('Token refresh failed', { error });
        error = new TokenError(
          'token_refresh_failed',
          `Failed to refresh token: ${error.message}`
        );
      }
      
      // Notify error listeners
      this.notifyTokenErrorListeners(error);
      
      // Reject any pending callbacks
      this.rejectRefreshCallbacks(error);
      
      throw error;
    }
  }
  
  /**
   * Wait for an ongoing refresh to complete
   * @returns {Promise<string>} The refreshed token
   * @private
   */
  waitForRefresh() {
    return new Promise((resolve, reject) => {
      this.refreshCallbacks.push({ resolve, reject });
    });
  }
  
  /**
   * Resolve all pending refresh callbacks
   * @param {string} token - The refreshed token
   * @private
   */
  resolveRefreshCallbacks(token) {
    this.refreshCallbacks.forEach(callback => callback.resolve(token));
    this.refreshCallbacks = [];
  }
  
  /**
   * Reject all pending refresh callbacks
   * @param {Error} error - The error that occurred
   * @private
   */
  rejectRefreshCallbacks(error) {
    this.refreshCallbacks.forEach(callback => callback.reject(error));
    this.refreshCallbacks = [];
  }
  
  /**
   * Schedule a token refresh if needed
   * @param {import('./models.js').TokenInfo} tokenInfo - The token information
   * @private
   */
  scheduleRefreshIfNeeded(tokenInfo) {
    // Clear any existing timer
    if (this.refreshTimer) {
      clearTimeout(this.refreshTimer);
      this.refreshTimer = null;
    }
    
    // If the token is already expired, don't schedule a refresh
    if (isTokenExpired(tokenInfo)) {
      this.logger.debug('Token is already expired, not scheduling refresh');
      this.notifyTokenExpiredListeners();
      return;
    }
    
    // Calculate when to refresh
    const remainingTime = getTokenRemainingTime(tokenInfo);
    const refreshTime = Math.max(0, remainingTime - this.options.autoRefreshThreshold);
    
    this.logger.debug('Scheduling token refresh', {
      remainingTime,
      refreshTime,
      refreshIn: new Date(Date.now() + refreshTime * 1000).toISOString()
    });
    
    // Schedule the refresh
    this.refreshTimer = setTimeout(() => {
      this.logger.debug('Auto-refresh timer triggered');
      this.refreshToken().catch(error => {
        this.logger.error('Auto-refresh failed', { error });
      });
    }, refreshTime * 1000);
  }
  
  /**
   * Get the token expiration date
   * @returns {Date|null} The expiration date, or null if not available
   */
  async getTokenExpiration() {
    try {
      const tokenInfo = await this.tokenStorage.getTokenInfo();
      return tokenInfo?.expiresAt || null;
    } catch (error) {
      this.logger.error('Failed to get token expiration', { error });
      return null;
    }
  }
  
  /**
   * Get the current token status
   * @returns {TokenStatus} The token status
   */
  async getTokenStatus() {
    try {
      // If a refresh is in progress, return REFRESHING
      if (this.isRefreshing) {
        return TokenStatus.REFRESHING;
      }
      
      const token = await this.tokenStorage.getToken();
      const tokenInfo = await this.tokenStorage.getTokenInfo();
      
      // If no token, return NONE
      if (!token || !tokenInfo) {
        return TokenStatus.NONE;
      }
      
      // If token is expired, return EXPIRED
      if (isTokenExpired(tokenInfo, this.options.tokenExpirationBuffer)) {
        return TokenStatus.EXPIRED;
      }
      
      // If token is expiring soon, return EXPIRING_SOON
      if (isTokenExpiringSoon(tokenInfo, this.options.autoRefreshThreshold)) {
        return TokenStatus.EXPIRING_SOON;
      }
      
      // Otherwise, return VALID
      return TokenStatus.VALID;
    } catch (error) {
      this.logger.error('Failed to get token status', { error });
      return TokenStatus.ERROR;
    }
  }
  
  /**
   * Get the token information
   * @returns {Promise<import('./models.js').TokenInfo|null>} The token information, or null if not available
   */
  async getTokenInfo() {
    try {
      return await this.tokenStorage.getTokenInfo();
    } catch (error) {
      this.logger.error('Failed to get token info', { error });
      return null;
    }
  }
  
  /**
   * Clear the stored token
   * @returns {Promise<void>}
   */
  async clearToken() {
    try {
      this.logger.debug('Clearing token');
      await this.tokenStorage.clearToken();
      this.logger.info('Token cleared successfully');
    } catch (error) {
      this.logger.error('Failed to clear token', { error });
      throw error;
    }
  }
  
  /**
   * Register a listener for token refresh events
   * @param {Function} callback - Callback function that receives the new token
   * @returns {Function} Function to unregister the listener
   */
  onTokenRefresh(callback) {
    this.tokenRefreshListeners.push(callback);
    return () => {
      this.tokenRefreshListeners = this.tokenRefreshListeners.filter(cb => cb !== callback);
    };
  }
  
  /**
   * Register a listener for token expired events
   * @param {Function} callback - Callback function
   * @returns {Function} Function to unregister the listener
   */
  onTokenExpired(callback) {
    this.tokenExpiredListeners.push(callback);
    return () => {
      this.tokenExpiredListeners = this.tokenExpiredListeners.filter(cb => cb !== callback);
    };
  }
  
  /**
   * Register a listener for token error events
   * @param {Function} callback - Callback function that receives the error
   * @returns {Function} Function to unregister the listener
   */
  onTokenError(callback) {
    this.tokenErrorListeners.push(callback);
    return () => {
      this.tokenErrorListeners = this.tokenErrorListeners.filter(cb => cb !== callback);
    };
  }
  
  /**
   * Notify token refresh listeners
   * @param {string} token - The new token
   * @private
   */
  notifyTokenRefreshListeners(token) {
    this.tokenRefreshListeners.forEach(callback => {
      try {
        callback(token);
      } catch (error) {
        this.logger.error('Error in token refresh listener', { error });
      }
    });
  }
  
  /**
   * Notify token expired listeners
   * @private
   */
  notifyTokenExpiredListeners() {
    this.tokenExpiredListeners.forEach(callback => {
      try {
        callback();
      } catch (error) {
        this.logger.error('Error in token expired listener', { error });
      }
    });
  }
  
  /**
   * Notify token error listeners
   * @param {Error} error - The error that occurred
   * @private
   */
  notifyTokenErrorListeners(error) {
    this.tokenErrorListeners.forEach(callback => {
      try {
        callback(error);
      } catch (callbackError) {
        this.logger.error('Error in token error listener', { error: callbackError });
      }
    });
  }
  
  /**
   * Dispose of the token service
   * This cleans up any timers and listeners
   */
  dispose() {
    this.logger.debug('Disposing TokenService');
    
    // Clear refresh timer
    if (this.refreshTimer) {
      clearTimeout(this.refreshTimer);
      this.refreshTimer = null;
    }
    
    // Clear listeners
    this.tokenRefreshListeners = [];
    this.tokenExpiredListeners = [];
    this.tokenErrorListeners = [];
    
    // Clear refresh callbacks
    this.rejectRefreshCallbacks(new Error('TokenService disposed'));
  }
}

/**
 * Create a TokenService with the given dependencies
 * @param {import('./token-provider.js').TokenProvider} tokenProvider - Provider for acquiring tokens
 * @param {import('./token-validator.js').TokenValidator} tokenValidator - Validator for token validation
 * @param {import('./token-storage.js').TokenStorage} tokenStorage - Storage for tokens
 * @param {Object} [logger] - Logger instance
 * @param {TokenServiceOptions} [options] - Service options
 * @returns {TokenService} The token service
 */
export function createTokenService(tokenProvider, tokenValidator, tokenStorage, logger, options) {
  return new TokenService(tokenProvider, tokenValidator, tokenStorage, logger, options);
}


/* From: public/js/modules/token-management/token-status-provider.js */
/**
 * Token Management Subsystem - Token Status Provider
 * 
 * This module defines the TokenStatusProvider class, which is responsible for
 * displaying token status information to the user and providing notifications
 * about token events.
 */

import { TokenStatus, getTokenRemainingTime, formatRemainingTime } from './models.js';

/**
 * Options for TokenStatusProvider
 * @typedef {Object} TokenStatusProviderOptions
 * @property {number} [updateInterval=10000] - Milliseconds between status updates
 * @property {boolean} [showExpirationWarning=true] - Whether to show expiration warnings
 * @property {number} [warningThreshold=300] - Seconds before expiration to show warning
 * @property {string} [statusElementId='token-status-indicator'] - ID of status element
 * @property {string} [countdownElementId='token-countdown'] - ID of countdown element
 */

/**
 * Provider for token status display and notifications
 */
export class TokenStatusProvider {
  /**
   * Create a TokenStatusProvider
   * @param {import('./token-service.js').TokenService} tokenService - The token service
   * @param {Object} uiManager - UI manager for notifications
   * @param {Object} [logger] - Logger instance
   * @param {TokenStatusProviderOptions} [options] - Provider options
   */
  constructor(tokenService, uiManager, logger, options = {}) {
    if (!tokenService) {
      throw new Error('Token service is required for TokenStatusProvider');
    }
    
    if (!uiManager) {
      throw new Error('UI manager is required for TokenStatusProvider');
    }
    
    this.tokenService = tokenService;
    this.uiManager = uiManager;
    this.logger = logger || console;
    
    this.options = {
      updateInterval: 10000, // 10 seconds
      showExpirationWarning: true,
      warningThreshold: 300, // 5 minutes
      statusElementId: 'token-status-indicator',
      countdownElementId: 'token-countdown',
      ...options
    };
    
    // Status update timer
    this.updateTimer = null;
    
    // Last known status
    this.lastStatus = null;
    
    // Whether a warning has been shown
    this.warningShown = false;
    
    this.logger.debug('TokenStatusProvider created', {
      updateInterval: this.options.updateInterval,
      showExpirationWarning: this.options.showExpirationWarning,
      warningThreshold: this.options.warningThreshold
    });
  }
  
  /**
   * Start monitoring token status
   */
  startStatusMonitoring() {
    this.logger.debug('Starting token status monitoring');
    
    // Clear any existing timer
    this.stopStatusMonitoring();
    
    // Update status immediately
    this.updateTokenStatus();
    
    // Set up timer for regular updates
    this.updateTimer = setInterval(() => {
      this.updateTokenStatus();
    }, this.options.updateInterval);
    
    // Set up token service event listeners
    this.tokenService.onTokenRefresh(() => {
      this.logger.debug('Token refresh event received');
      this.updateTokenStatus();
    });
    
    this.tokenService.onTokenExpired(() => {
      this.logger.debug('Token expired event received');
      this.updateTokenStatus();
    });
    
    this.tokenService.onTokenError(() => {
      this.logger.debug('Token error event received');
      this.updateTokenStatus();
    });
    
    this.logger.info('Token status monitoring started');
  }
  
  /**
   * Stop monitoring token status
   */
  stopStatusMonitoring() {
    this.logger.debug('Stopping token status monitoring');
    
    // Clear update timer
    if (this.updateTimer) {
      clearInterval(this.updateTimer);
      this.updateTimer = null;
    }
    
    this.logger.info('Token status monitoring stopped');
  }
  
  /**
   * Update the token status display
   */
  async updateTokenStatus() {
    try {
      this.logger.debug('Updating token status display');
      
      // Get current token status
      const status = await this.tokenService.getTokenStatus();
      
      // Update status element if available
      this.updateStatusElement(status);
      
      // Update countdown if available
      this.updateCountdownElement();
      
      // Show warnings if needed
      if (status !== this.lastStatus) {
        this.handleStatusChange(status);
        this.lastStatus = status;
      }
      
      this.logger.debug('Token status display updated', { status });
    } catch (error) {
      this.logger.error('Failed to update token status display', { error });
    }
  }
  
  /**
   * Update the status element
   * @param {TokenStatus} status - The current token status
   * @private
   */
  updateStatusElement(status) {
    try {
      const statusElement = document.getElementById(this.options.statusElementId);
      
      if (!statusElement) {
        this.logger.debug('Status element not found', { elementId: this.options.statusElementId });
        return;
      }
      
      // Clear existing classes
      statusElement.classList.remove('valid', 'expiring', 'expired', 'refreshing', 'error', 'none');
      
      // Add appropriate class and text
      switch (status) {
        case TokenStatus.VALID:
          statusElement.classList.add('valid');
          statusElement.textContent = 'Token Valid';
          break;
        case TokenStatus.EXPIRING_SOON:
          statusElement.classList.add('expiring');
          statusElement.textContent = 'Token Expiring Soon';
          break;
        case TokenStatus.EXPIRED:
          statusElement.classList.add('expired');
          statusElement.textContent = 'Token Expired';
          break;
        case TokenStatus.REFRESHING:
          statusElement.classList.add('refreshing');
          statusElement.textContent = 'Refreshing Token...';
          break;
        case TokenStatus.ERROR:
          statusElement.classList.add('error');
          statusElement.textContent = 'Token Error';
          break;
        case TokenStatus.NONE:
          statusElement.classList.add('none');
          statusElement.textContent = 'No Token';
          break;
      }
      
      this.logger.debug('Status element updated', { status });
    } catch (error) {
      this.logger.error('Failed to update status element', { error });
    }
  }
  
  /**
   * Update the countdown element
   * @private
   */
  async updateCountdownElement() {
    try {
      const countdownElement = document.getElementById(this.options.countdownElementId);
      
      if (!countdownElement) {
        this.logger.debug('Countdown element not found', { elementId: this.options.countdownElementId });
        return;
      }
      
      // Get token info
      const tokenInfo = await this.tokenService.getTokenInfo();
      
      if (!tokenInfo || !tokenInfo.expiresAt) {
        countdownElement.textContent = 'N/A';
        return;
      }
      
      // Calculate remaining time
      const remainingTime = getTokenRemainingTime(tokenInfo);
      
      // Format and display
      countdownElement.textContent = formatRemainingTime(remainingTime);
      
      // Add appropriate class
      countdownElement.classList.remove('warning', 'critical');
      
      if (remainingTime <= 60) { // 1 minute
        countdownElement.classList.add('critical');
      } else if (remainingTime <= this.options.warningThreshold) {
        countdownElement.classList.add('warning');
      }
      
      this.logger.debug('Countdown element updated', { remainingTime });
    } catch (error) {
      this.logger.error('Failed to update countdown element', { error });
    }
  }
  
  /**
   * Handle a status change
   * @param {TokenStatus} status - The new status
   * @private
   */
  handleStatusChange(status) {
    this.logger.debug('Handling status change', { status });
    
    switch (status) {
      case TokenStatus.EXPIRING_SOON:
        if (this.options.showExpirationWarning && !this.warningShown) {
          this.showTokenExpirationWarning();
          this.warningShown = true;
        }
        break;
      case TokenStatus.EXPIRED:
        this.showTokenExpiredError();
        this.warningShown = false;
        break;
      case TokenStatus.VALID:
        // Reset warning flag when token becomes valid again
        this.warningShown = false;
        break;
    }
  }
  
  /**
   * Show a warning that the token is expiring soon
   */
  async showTokenExpirationWarning() {
    try {
      this.logger.debug('Showing token expiration warning');
      
      // Get token info
      const tokenInfo = await this.tokenService.getTokenInfo();
      
      if (!tokenInfo || !tokenInfo.expiresAt) {
        return;
      }
      
      // Calculate remaining time
      const remainingTime = getTokenRemainingTime(tokenInfo);
      const formattedTime = formatRemainingTime(remainingTime);
      
      // Show warning notification
      this.uiManager.showNotification(
        `Your authentication token will expire in ${formattedTime}. Please save your work.`,
        {
          type: 'warning',
          duration: 10000, // 10 seconds
          title: 'Token Expiring Soon'
        }
      );
      
      this.logger.info('Token expiration warning shown', { remainingTime });
    } catch (error) {
      this.logger.error('Failed to show token expiration warning', { error });
    }
  }
  
  /**
   * Show an error that the token has expired
   */
  showTokenExpiredError() {
    try {
      this.logger.debug('Showing token expired error');
      
      // Show error notification
      this.uiManager.showNotification(
        'Your authentication token has expired. Please refresh the token to continue.',
        {
          type: 'error',
          duration: 0, // Don't auto-dismiss
          title: 'Token Expired',
          actions: [
            {
              label: 'Refresh Token',
              callback: async () => {
                try {
                  await this.tokenService.refreshToken();
                } catch (error) {
                  this.logger.error('Failed to refresh token from notification', { error });
                  this.uiManager.showError('Failed to refresh token', error.message);
                }
              }
            }
          ]
        }
      );
      
      this.logger.info('Token expired error shown');
    } catch (error) {
      this.logger.error('Failed to show token expired error', { error });
    }
  }
  
  /**
   * Show that a token refresh is in progress
   */
  showTokenRefreshInProgress() {
    try {
      this.logger.debug('Showing token refresh in progress');
      
      // Update status element if available
      const statusElement = document.getElementById(this.options.statusElementId);
      
      if (statusElement) {
        statusElement.classList.remove('valid', 'expiring', 'expired', 'error', 'none');
        statusElement.classList.add('refreshing');
        statusElement.textContent = 'Refreshing Token...';
      }
      
      this.logger.info('Token refresh in progress shown');
    } catch (error) {
      this.logger.error('Failed to show token refresh in progress', { error });
    }
  }
  
  /**
   * Show that a token refresh was successful
   */
  async showTokenRefreshSuccess() {
    try {
      this.logger.debug('Showing token refresh success');
      
      // Update status immediately
      await this.updateTokenStatus();
      
      // Show success notification
      this.uiManager.showNotification(
        'Your authentication token has been refreshed successfully.',
        {
          type: 'success',
          duration: 5000, // 5 seconds
          title: 'Token Refreshed'
        }
      );
      
      this.logger.info('Token refresh success shown');
    } catch (error) {
      this.logger.error('Failed to show token refresh success', { error });
    }
  }
  
  /**
   * Show that a token refresh failed
   * @param {Error} error - The error that occurred
   */
  showTokenRefreshError(error) {
    try {
      this.logger.debug('Showing token refresh error', { error });
      
      // Show error notification
      this.uiManager.showNotification(
        `Failed to refresh token: ${error.message}. Please try again or re-authenticate.`,
        {
          type: 'error',
          duration: 0, // Don't auto-dismiss
          title: 'Token Refresh Failed',
          actions: [
            {
              label: 'Try Again',
              callback: async () => {
                try {
                  await this.tokenService.refreshToken();
                } catch (refreshError) {
                  this.logger.error('Failed to refresh token from notification', { error: refreshError });
                  this.uiManager.showError('Failed to refresh token', refreshError.message);
                }
              }
            },
            {
              label: 'Re-authenticate',
              callback: () => {
                // Clear token and redirect to login
                this.tokenService.clearToken().then(() => {
                  window.location.reload();
                });
              }
            }
          ]
        }
      );
      
      this.logger.info('Token refresh error shown', { error });
    } catch (showError) {
      this.logger.error('Failed to show token refresh error', { error: showError });
    }
  }
}

/**
 * Create a TokenStatusProvider with the given dependencies
 * @param {import('./token-service.js').TokenService} tokenService - The token service
 * @param {Object} uiManager - UI manager for notifications
 * @param {Object} [logger] - Logger instance
 * @param {TokenStatusProviderOptions} [options] - Provider options
 * @returns {TokenStatusProvider} The token status provider
 */
export function createTokenStatusProvider(tokenService, uiManager, logger, options) {
  return new TokenStatusProvider(tokenService, uiManager, logger, options);
}


/* From: public/js/modules/token-management/token-storage.js */
/**
 * Token Management Subsystem - Token Storage
 * 
 * This module defines the TokenStorage interface and implementations.
 * TokenStorage is responsible for securely storing and retrieving tokens.
 */

/**
 * Interface for token storage
 * @interface
 */
export class TokenStorage {
  /**
   * Save a token and its information
   * @param {string} token - The token to save
   * @param {import('./models.js').TokenInfo} tokenInfo - The token information
   * @returns {Promise<void>}
   */
  async saveToken(token, tokenInfo) {
    throw new Error('TokenStorage.saveToken() must be implemented by subclass');
  }
  
  /**
   * Get the stored token
   * @returns {Promise<string|null>} The token, or null if not found
   */
  async getToken() {
    throw new Error('TokenStorage.getToken() must be implemented by subclass');
  }
  
  /**
   * Get the stored token information
   * @returns {Promise<import('./models.js').TokenInfo|null>} The token information, or null if not found
   */
  async getTokenInfo() {
    throw new Error('TokenStorage.getTokenInfo() must be implemented by subclass');
  }
  
  /**
   * Clear the stored token
   * @returns {Promise<void>}
   */
  async clearToken() {
    throw new Error('TokenStorage.clearToken() must be implemented by subclass');
  }
}

/**
 * Options for SecureTokenStorage
 * @typedef {Object} SecureTokenStorageOptions
 * @property {string} [tokenKey='auth_token'] - Key for storing the token
 * @property {string} [tokenInfoKey='auth_token_info'] - Key for storing the token information
 * @property {string} [storageType='localStorage'] - Storage type ('localStorage' or 'sessionStorage')
 * @property {boolean} [encrypt=true] - Whether to encrypt the token
 */

/**
 * Secure implementation of TokenStorage
 * @extends TokenStorage
 */
export class SecureTokenStorage extends TokenStorage {
  /**
   * Create a SecureTokenStorage
   * @param {Object} encryptionService - Service for encrypting/decrypting data
   * @param {SecureTokenStorageOptions} [options] - Storage options
   * @param {Object} [logger] - Logger instance
   */
  constructor(encryptionService, options = {}, logger) {
    super();
    
    if (!encryptionService) {
      throw new Error('Encryption service is required for SecureTokenStorage');
    }
    
    this.encryptionService = encryptionService;
    this.options = {
      tokenKey: 'auth_token',
      tokenInfoKey: 'auth_token_info',
      storageType: 'localStorage',
      encrypt: true,
      ...options
    };
    
    this.logger = logger || console;
    
    // Get the storage object
    this.storage = this.options.storageType === 'sessionStorage' 
      ? sessionStorage 
      : localStorage;
  }
  
  /**
   * Save a token and its information
   * @param {string} token - The token to save
   * @param {import('./models.js').TokenInfo} tokenInfo - The token information
   * @returns {Promise<void>}
   */
  async saveToken(token, tokenInfo) {
    try {
      this.logger.debug('Saving token', { 
        tokenType: tokenInfo.tokenType,
        expiresAt: tokenInfo.expiresAt,
        hasRefreshToken: !!tokenInfo.refreshToken
      });
      
      // Store the token
      let tokenToStore = token;
      if (this.options.encrypt) {
        tokenToStore = await this.encryptionService.encrypt(token);
      }
      
      this.storage.setItem(this.options.tokenKey, tokenToStore);
      
      // Store token info
      const tokenInfoToStore = {
        ...tokenInfo,
        // Convert Date to ISO string for storage
        expiresAt: tokenInfo.expiresAt instanceof Date 
          ? tokenInfo.expiresAt.toISOString() 
          : tokenInfo.expiresAt
      };
      
      // Remove the actual tokens from the stored info for security
      delete tokenInfoToStore.accessToken;
      delete tokenInfoToStore.refreshToken;
      
      this.storage.setItem(
        this.options.tokenInfoKey, 
        JSON.stringify(tokenInfoToStore)
      );
      
      this.logger.debug('Token saved successfully');
    } catch (error) {
      this.logger.error('Failed to save token', { error });
      throw new Error(`Failed to save token: ${error.message}`);
    }
  }
  
  /**
   * Get the stored token
   * @returns {Promise<string|null>} The token, or null if not found
   */
  async getToken() {
    try {
      const storedToken = this.storage.getItem(this.options.tokenKey);
      
      if (!storedToken) {
        this.logger.debug('No token found in storage');
        return null;
      }
      
      // Decrypt if necessary
      if (this.options.encrypt) {
        try {
          const decryptedToken = await this.encryptionService.decrypt(storedToken);
          this.logger.debug('Token retrieved and decrypted successfully');
          return decryptedToken;
        } catch (error) {
          this.logger.error('Failed to decrypt token', { error });
          return null;
        }
      }
      
      this.logger.debug('Token retrieved successfully');
      return storedToken;
    } catch (error) {
      this.logger.error('Failed to get token', { error });
      return null;
    }
  }
  
  /**
   * Get the stored token information
   * @returns {Promise<import('./models.js').TokenInfo|null>} The token information, or null if not found
   */
  async getTokenInfo() {
    try {
      const storedTokenInfo = this.storage.getItem(this.options.tokenInfoKey);
      
      if (!storedTokenInfo) {
        this.logger.debug('No token info found in storage');
        return null;
      }
      
      const tokenInfo = JSON.parse(storedTokenInfo);
      
      // Convert ISO string back to Date
      if (tokenInfo.expiresAt) {
        tokenInfo.expiresAt = new Date(tokenInfo.expiresAt);
      }
      
      this.logger.debug('Token info retrieved successfully', {
        tokenType: tokenInfo.tokenType,
        expiresAt: tokenInfo.expiresAt
      });
      
      return tokenInfo;
    } catch (error) {
      this.logger.error('Failed to get token info', { error });
      return null;
    }
  }
  
  /**
   * Clear the stored token
   * @returns {Promise<void>}
   */
  async clearToken() {
    try {
      this.logger.debug('Clearing token from storage');
      
      this.storage.removeItem(this.options.tokenKey);
      this.storage.removeItem(this.options.tokenInfoKey);
      
      this.logger.debug('Token cleared successfully');
    } catch (error) {
      this.logger.error('Failed to clear token', { error });
      throw new Error(`Failed to clear token: ${error.message}`);
    }
  }
}

/**
 * Simple implementation of TokenStorage that doesn't use encryption
 * @extends TokenStorage
 */
export class SimpleTokenStorage extends TokenStorage {
  /**
   * Create a SimpleTokenStorage
   * @param {Object} [options] - Storage options
   * @param {Object} [logger] - Logger instance
   */
  constructor(options = {}, logger) {
    super();
    
    this.options = {
      tokenKey: 'auth_token',
      tokenInfoKey: 'auth_token_info',
      storageType: 'localStorage',
      ...options
    };
    
    this.logger = logger || console;
    
    // Get the storage object
    this.storage = this.options.storageType === 'sessionStorage' 
      ? sessionStorage 
      : localStorage;
  }
  
  /**
   * Save a token and its information
   * @param {string} token - The token to save
   * @param {import('./models.js').TokenInfo} tokenInfo - The token information
   * @returns {Promise<void>}
   */
  async saveToken(token, tokenInfo) {
    try {
      this.logger.debug('Saving token', { 
        tokenType: tokenInfo.tokenType,
        expiresAt: tokenInfo.expiresAt,
        hasRefreshToken: !!tokenInfo.refreshToken
      });
      
      // Store the token
      this.storage.setItem(this.options.tokenKey, token);
      
      // Store token info
      const tokenInfoToStore = {
        ...tokenInfo,
        // Convert Date to ISO string for storage
        expiresAt: tokenInfo.expiresAt instanceof Date 
          ? tokenInfo.expiresAt.toISOString() 
          : tokenInfo.expiresAt
      };
      
      // Remove the actual tokens from the stored info for security
      delete tokenInfoToStore.accessToken;
      delete tokenInfoToStore.refreshToken;
      
      this.storage.setItem(
        this.options.tokenInfoKey, 
        JSON.stringify(tokenInfoToStore)
      );
      
      this.logger.debug('Token saved successfully');
    } catch (error) {
      this.logger.error('Failed to save token', { error });
      throw new Error(`Failed to save token: ${error.message}`);
    }
  }
  
  /**
   * Get the stored token
   * @returns {Promise<string|null>} The token, or null if not found
   */
  async getToken() {
    try {
      const storedToken = this.storage.getItem(this.options.tokenKey);
      
      if (!storedToken) {
        this.logger.debug('No token found in storage');
        return null;
      }
      
      this.logger.debug('Token retrieved successfully');
      return storedToken;
    } catch (error) {
      this.logger.error('Failed to get token', { error });
      return null;
    }
  }
  
  /**
   * Get the stored token information
   * @returns {Promise<import('./models.js').TokenInfo|null>} The token information, or null if not found
   */
  async getTokenInfo() {
    try {
      const storedTokenInfo = this.storage.getItem(this.options.tokenInfoKey);
      
      if (!storedTokenInfo) {
        this.logger.debug('No token info found in storage');
        return null;
      }
      
      const tokenInfo = JSON.parse(storedTokenInfo);
      
      // Convert ISO string back to Date
      if (tokenInfo.expiresAt) {
        tokenInfo.expiresAt = new Date(tokenInfo.expiresAt);
      }
      
      this.logger.debug('Token info retrieved successfully', {
        tokenType: tokenInfo.tokenType,
        expiresAt: tokenInfo.expiresAt
      });
      
      return tokenInfo;
    } catch (error) {
      this.logger.error('Failed to get token info', { error });
      return null;
    }
  }
  
  /**
   * Clear the stored token
   * @returns {Promise<void>}
   */
  async clearToken() {
    try {
      this.logger.debug('Clearing token from storage');
      
      this.storage.removeItem(this.options.tokenKey);
      this.storage.removeItem(this.options.tokenInfoKey);
      
      this.logger.debug('Token cleared successfully');
    } catch (error) {
      this.logger.error('Failed to clear token', { error });
      throw new Error(`Failed to clear token: ${error.message}`);
    }
  }
}

/**
 * Create a SecureTokenStorage with the given options
 * @param {Object} encryptionService - Service for encrypting/decrypting data
 * @param {SecureTokenStorageOptions} [options] - Storage options
 * @param {Object} [logger] - Logger instance
 * @returns {SecureTokenStorage} The token storage
 */
export function createSecureTokenStorage(encryptionService, options, logger) {
  return new SecureTokenStorage(encryptionService, options, logger);
}

/**
 * Create a SimpleTokenStorage with the given options
 * @param {Object} [options] - Storage options
 * @param {Object} [logger] - Logger instance
 * @returns {SimpleTokenStorage} The token storage
 */
export function createSimpleTokenStorage(options, logger) {
  return new SimpleTokenStorage(options, logger);
}


/* From: public/js/modules/token-management/token-validator.js */
/**
 * Token Management Subsystem - Token Validator
 * 
 * This module defines the TokenValidator interface and implementations.
 * TokenValidators are responsible for validating tokens and checking their expiration status.
 */

import { isTokenExpired, isTokenExpiringSoon } from './models.js';

/**
 * Interface for token validators
 * @interface
 */
export class TokenValidator {
  /**
   * Validate a token
   * @param {string} token - The token to validate
   * @returns {Promise<boolean>} True if the token is valid
   */
  async validateToken(token) {
    throw new Error('TokenValidator.validateToken() must be implemented by subclass');
  }
  
  /**
   * Check if a token is expired
   * @param {string} token - The token to check
   * @param {number} [bufferSeconds=0] - Buffer time in seconds
   * @returns {boolean} True if the token is expired
   */
  isTokenExpired(token, bufferSeconds = 0) {
    throw new Error('TokenValidator.isTokenExpired() must be implemented by subclass');
  }
  
  /**
   * Check if a token is expiring soon
   * @param {string} token - The token to check
   * @param {number} thresholdSeconds - Threshold in seconds
   * @returns {boolean} True if the token is expiring soon
   */
  isTokenExpiringSoon(token, thresholdSeconds) {
    throw new Error('TokenValidator.isTokenExpiringSoon() must be implemented by subclass');
  }
  
  /**
   * Get the expiration date of a token
   * @param {string} token - The token to check
   * @returns {Date|null} The expiration date, or null if not available
   */
  getTokenExpiration(token) {
    throw new Error('TokenValidator.getTokenExpiration() must be implemented by subclass');
  }
  
  /**
   * Get the claims from a token
   * @param {string} token - The token to parse
   * @returns {Object|null} The token claims, or null if parsing fails
   */
  getTokenClaims(token) {
    throw new Error('TokenValidator.getTokenClaims() must be implemented by subclass');
  }
}

/**
 * Options for JWTTokenValidator
 * @typedef {Object} JWTTokenValidatorOptions
 * @property {string} [issuer] - Expected token issuer
 * @property {string|string[]} [audience] - Expected token audience
 * @property {number} [clockTolerance=0] - Clock tolerance in seconds
 */

/**
 * JWT implementation of TokenValidator
 * @extends TokenValidator
 */
export class JWTTokenValidator extends TokenValidator {
  /**
   * Create a JWTTokenValidator
   * @param {JWTTokenValidatorOptions} [options] - Validator options
   * @param {Object} [logger] - Logger instance
   */
  constructor(options = {}, logger) {
    super();
    
    this.options = {
      clockTolerance: 0,
      ...options
    };
    
    this.logger = logger || console;
  }
  
  /**
   * Validate a JWT token
   * @param {string} token - The token to validate
   * @returns {Promise<boolean>} True if the token is valid
   */
  async validateToken(token) {
    try {
      if (!token) {
        this.logger.debug('Token validation failed: Token is empty');
        return false;
      }
      
      // Parse the token
      const claims = this.getTokenClaims(token);
      if (!claims) {
        this.logger.debug('Token validation failed: Could not parse token');
        return false;
      }
      
      // Check expiration
      if (this.isTokenExpired(token, -this.options.clockTolerance)) {
        this.logger.debug('Token validation failed: Token is expired');
        return false;
      }
      
      // Check issuer if specified
      if (this.options.issuer && claims.iss !== this.options.issuer) {
        this.logger.debug('Token validation failed: Invalid issuer', {
          expected: this.options.issuer,
          actual: claims.iss
        });
        return false;
      }
      
      // Check audience if specified
      if (this.options.audience) {
        const audiences = Array.isArray(this.options.audience) 
          ? this.options.audience 
          : [this.options.audience];
        
        const tokenAudience = Array.isArray(claims.aud) ? claims.aud : [claims.aud];
        
        const hasValidAudience = audiences.some(audience => 
          tokenAudience.includes(audience)
        );
        
        if (!hasValidAudience) {
          this.logger.debug('Token validation failed: Invalid audience', {
            expected: audiences,
            actual: tokenAudience
          });
          return false;
        }
      }
      
      this.logger.debug('Token validation successful');
      return true;
    } catch (error) {
      this.logger.error('Token validation error', { error });
      return false;
    }
  }
  
  /**
   * Check if a JWT token is expired
   * @param {string} token - The token to check
   * @param {number} [bufferSeconds=0] - Buffer time in seconds
   * @returns {boolean} True if the token is expired
   */
  isTokenExpired(token, bufferSeconds = 0) {
    try {
      const claims = this.getTokenClaims(token);
      if (!claims || !claims.exp) {
        return true;
      }
      
      const now = Math.floor(Date.now() / 1000);
      return claims.exp - bufferSeconds <= now;
    } catch (error) {
      this.logger.error('Error checking token expiration', { error });
      return true;
    }
  }
  
  /**
   * Check if a JWT token is expiring soon
   * @param {string} token - The token to check
   * @param {number} thresholdSeconds - Threshold in seconds
   * @returns {boolean} True if the token is expiring soon
   */
  isTokenExpiringSoon(token, thresholdSeconds) {
    try {
      const claims = this.getTokenClaims(token);
      if (!claims || !claims.exp) {
        return false;
      }
      
      const now = Math.floor(Date.now() / 1000);
      return !this.isTokenExpired(token) && claims.exp - now <= thresholdSeconds;
    } catch (error) {
      this.logger.error('Error checking if token is expiring soon', { error });
      return false;
    }
  }
  
  /**
   * Get the expiration date of a JWT token
   * @param {string} token - The token to check
   * @returns {Date|null} The expiration date, or null if not available
   */
  getTokenExpiration(token) {
    try {
      const claims = this.getTokenClaims(token);
      if (!claims || !claims.exp) {
        return null;
      }
      
      return new Date(claims.exp * 1000);
    } catch (error) {
      this.logger.error('Error getting token expiration', { error });
      return null;
    }
  }
  
  /**
   * Get the claims from a JWT token
   * @param {string} token - The token to parse
   * @returns {Object|null} The token claims, or null if parsing fails
   */
  getTokenClaims(token) {
    try {
      if (!token) {
        return null;
      }
      
      // Split the token into parts
      const parts = token.split('.');
      if (parts.length !== 3) {
        return null;
      }
      
      // Decode the payload (second part)
      const payload = parts[1];
      const decoded = this.base64UrlDecode(payload);
      
      return JSON.parse(decoded);
    } catch (error) {
      this.logger.error('Error parsing token claims', { error });
      return null;
    }
  }
  
  /**
   * Decode a base64url encoded string
   * @param {string} input - The base64url encoded string
   * @returns {string} The decoded string
   * @private
   */
  base64UrlDecode(input) {
    // Replace non-url compatible chars with base64 standard chars
    let base64 = input.replace(/-/g, '+').replace(/_/g, '/');
    
    // Add padding if needed
    while (base64.length % 4) {
      base64 += '=';
    }
    
    // Decode the base64 string
    const decoded = atob(base64);
    
    // Convert to UTF-8 string
    const bytes = new Uint8Array(decoded.length);
    for (let i = 0; i < decoded.length; i++) {
      bytes[i] = decoded.charCodeAt(i);
    }
    
    return new TextDecoder().decode(bytes);
  }
}

/**
 * Create a JWTTokenValidator with the given options
 * @param {JWTTokenValidatorOptions} [options] - Validator options
 * @param {Object} [logger] - Logger instance
 * @returns {JWTTokenValidator} The token validator
 */
export function createJWTTokenValidator(options, logger) {
  return new JWTTokenValidator(options, logger);
}

