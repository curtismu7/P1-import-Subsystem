/**
 * Error System Module
 * 
 * Consolidated JavaScript for PingOne Import Tool
 * Generated: 2025-08-06T19:09:11.421Z
 * 
 * This file was automatically generated by js-final-consolidation.js
 * Organized for better maintainability and performance
 */


/* From: public/js/modules/error/error-manager.js */
import { ErrorReporter } from './error-reporter.js';
import { ErrorTypes, ErrorSeverity } from './error-types.js';

/**
 * Centralized Error Management System
 * 
 * Handles all application errors in a consistent way, providing:
 * - Error categorization and processing
 * - Centralized error logging
 * - Error reporting to UI components
 * - Error recovery strategies
 */
export class ErrorManager {
    /**
     * Create a new ErrorManager
     * @param {Object} logger - Logger instance from LogManager
     * @param {Object} options - Configuration options
     */
    constructor(logger, options = {}) {
        this.logger = logger || console;
        this.errorReporter = new ErrorReporter(options.reporterOptions);
        this.errorHandlers = new Map();
        this.initializeDefaultHandlers();
    }

    /**
     * Initialize default error handlers
     */
    initializeDefaultHandlers() {
        // Network errors
        this.registerHandler(
            ErrorTypes.NETWORK,
            this.handleNetworkError.bind(this)
        );
        
        // Authentication errors
        this.registerHandler(
            ErrorTypes.AUTHENTICATION,
            this.handleAuthError.bind(this)
        );
        
        // Validation errors
        this.registerHandler(
            ErrorTypes.VALIDATION,
            this.handleValidationError.bind(this)
        );
        
        // Default error handler
        this.registerHandler(
            'default',
            this.handleDefaultError.bind(this)
        );
    }

    /**
     * Register a custom error handler
     * @param {string} errorType - Type of error to handle
     * @param {Function} handler - Handler function
     */
    registerHandler(errorType, handler) {
        this.errorHandlers.set(errorType, handler);
    }

    /**
     * Handle an error
     * @param {Error} error - The error to handle
     * @param {Object} context - Additional context
     * @returns {Object} Processed error information
     */
    handleError(error, context = {}) {
        const errorInfo = this.processError(error, context);
        
        // Log the error
        this.logError(errorInfo);
        
        // Report the error
        this.reportError(errorInfo);
        
        // Execute recovery strategy if available
        if (errorInfo.recovery) {
            errorInfo.recovery();
        }
        
        return errorInfo;
    }

    /**
     * Process an error and extract relevant information
     * @private
     */
    processError(error, context) {
        const errorType = this.determineErrorType(error, context);
        const severity = this.determineSeverity(errorType, context);
        
        return {
            id: this.generateErrorId(),
            timestamp: new Date().toISOString(),
            message: error.message || 'An unknown error occurred',
            type: errorType,
            severity,
            stack: error.stack,
            context: {
                component: context.component || 'unknown',
                operation: context.operation || 'unknown',
                ...context
            },
            originalError: error,
            recovery: this.getRecoveryStrategy(errorType, severity, context)
        };
    }

    /**
     * Log an error using the application logger
     * @private
     */
    logError(errorInfo) {
        const logEntry = {
            id: errorInfo.id,
            type: errorInfo.type,
            severity: errorInfo.severity,
            message: errorInfo.message,
            context: errorInfo.context,
            timestamp: errorInfo.timestamp
        };

        if (errorInfo.severity === ErrorSeverity.ERROR) {
            this.logger.error('Error occurred', logEntry);
        } else if (errorInfo.severity === ErrorSeverity.WARNING) {
            this.logger.warn('Warning occurred', logEntry);
        } else {
            this.logger.info('Error occurred', logEntry);
        }
    }

    /**
     * Report an error to the UI
     * @private
     */
    reportError(errorInfo) {
        this.errorReporter.showNotification(
            errorInfo.message,
            {
                title: this.getErrorTitle(errorInfo.type, errorInfo.severity),
                type: this.getNotificationType(errorInfo.severity),
                errorId: errorInfo.id,
                context: errorInfo.context
            }
        );
    }

    // Handler implementations
    handleNetworkError(error, context) {
        // Add network-specific handling here
        return {
            ...error,
            retryable: true
        };
    }

    handleAuthError(error) {
        // Add auth-specific handling here
        return {
            ...error,
            requiresReauth: true
        };
    }

    handleValidationError(error) {
        // Add validation-specific handling here
        return error;
    }

    handleDefaultError(error) {
        // Default error handling
        return error;
    }

    // Helper methods
    determineErrorType(error, context) {
        if (error.type) return error.type;
        if (error.response) {
            const status = error.response.status;
            if (status === 401) return ErrorTypes.AUTHENTICATION;
            if (status >= 400 && status < 500) return ErrorTypes.VALIDATION;
            if (status >= 500) return ErrorTypes.SERVER;
        }
        if (error.message?.includes('Network Error')) return ErrorTypes.NETWORK;
        return ErrorTypes.UNKNOWN;
    }

    determineSeverity(errorType, context) {
        const severityMap = {
            [ErrorTypes.AUTHENTICATION]: ErrorSeverity.ERROR,
            [ErrorTypes.NETWORK]: ErrorSeverity.WARNING, // Often recoverable
            [ErrorTypes.VALIDATION]: ErrorSeverity.WARNING,
            [ErrorTypes.SERVER]: ErrorSeverity.ERROR,
            [ErrorTypes.UNKNOWN]: ErrorSeverity.ERROR
        };
        
        return severityMap[errorType] || ErrorSeverity.ERROR;
    }

    getErrorTitle(errorType, severity) {
        const titles = {
            [ErrorTypes.AUTHENTICATION]: 'Authentication Error',
            [ErrorTypes.NETWORK]: 'Connection Issue',
            [ErrorTypes.VALIDATION]: 'Validation Error',
            [ErrorTypes.SERVER]: 'Server Error',
            [ErrorTypes.UNKNOWN]: 'Error'
        };
        
        return titles[errorType] || 'Error';
    }

    getNotificationType(severity) {
        const typeMap = {
            [ErrorSeverity.ERROR]: 'error',
            [ErrorSeverity.WARNING]: 'warning',
            [ErrorSeverity.INFO]: 'info'
        };
        
        return typeMap[severity] || 'error';
    }

    getRecoveryStrategy(errorType, severity, context) {
        // Implement recovery strategies based on error type and context
        if (errorType === ErrorTypes.NETWORK) {
            return () => {
                // Auto-retry logic for network errors
                if (context.retryCount < 3) {
                    setTimeout(() => context.retry(), 2000);
                }
            };
        }
        
        if (errorType === ErrorTypes.AUTHENTICATION) {
            return () => {
                // Redirect to login or refresh token
                window.location.href = '/login?redirect=' + encodeURIComponent(window.location.pathname);
            };
        }
        
        return null;
    }

    generateErrorId() {
        return 'err_' + Math.random().toString(36).substr(2, 9);
    }

    /**
     * Get the error reporter instance
     * @returns {ErrorReporter} The error reporter
     */
    getErrorReporter() {
        return this.errorReporter;
    }
}



/* From: public/js/modules/error/error-reporter.js */
import { ErrorSeverity } from './error-types.js';

/**
 * Error Reporter
 * 
 * Handles displaying errors to the user in a consistent way
 */
export class ErrorReporter {
    /**
     * Create a new ErrorReporter
     * @param {Object} options - Configuration options
     */
    constructor(options = {}) {
        this.options = {
            defaultDuration: 5000,
            autoDismiss: true,
            showErrorId: true,
            ...options
        };
        
        // Reference to the UI manager for showing notifications
        this.uiManager = null;
        this.notificationQueue = [];
        this.isInitialized = false;
    }

    /**
     * Initialize the error reporter with required dependencies
     * @param {Object} uiManager - The application's UI manager
     */
    initialize(uiManager) {
        if (this.isInitialized) return;
        
        this.uiManager = uiManager;
        this.isInitialized = true;
        
        // Process any queued notifications
        this.processQueue();
    }

    /**
     * Show a notification to the user
     * @param {string} message - The message to display
     * @param {Object} options - Notification options
     */
    showNotification(message, options = {}) {
        const notification = {
            id: `notif_${Date.now()}_${Math.random().toString(36).substr(2, 4)}`,
            message,
            options: {
                title: options.title || 'Error',
                type: options.type || 'error',
                autoDismiss: options.autoDismiss !== undefined ? options.autoDismiss : this.options.autoDismiss,
                duration: options.duration || this.options.defaultDuration,
                errorId: options.errorId,
                context: options.context || {}
            }
        };

        // Add to queue if not initialized yet
        if (!this.isInitialized || !this.uiManager) {
            this.notificationQueue.push(notification);
            return;
        }

        this._displayNotification(notification);
    }

    /**
     * Process any queued notifications
     * @private
     */
    processQueue() {
        if (!this.isInitialized || !this.uiManager) return;
        
        while (this.notificationQueue.length > 0) {
            const notification = this.notificationQueue.shift();
            this._displayNotification(notification);
        }
    }

    /**
     * Display a notification using the UI manager
     * @private
     */
    _displayNotification(notification) {
        if (!this.uiManager) return;
        
        const { message, options } = notification;
        const { title, type, autoDismiss, duration, errorId, context } = options;
        
        // Format the message with error ID if available
        let displayMessage = message;
        if (this.options.showErrorId && errorId) {
            displayMessage = `${message}\n\nError ID: ${errorId}`;
        }
        
        // Add context to the message if in development
        if (process.env.NODE_ENV === 'development' && context) {
            const contextStr = this._formatContext(context);
            if (contextStr) {
                displayMessage += `\n\nContext: ${contextStr}`;
            }
        }
        
        // Show the notification
        if (this.uiManager.showNotification) {
            this.uiManager.showNotification(displayMessage, {
                title,
                type,
                autoDismiss,
                duration
            });
        } else if (this.uiManager.showStatusBar) {
            // Fallback to status bar if showNotification is not available
            this.uiManager.showStatusBar(
                displayMessage, 
                type,
                { 
                    autoDismiss: autoDismiss !== false, 
                    duration: autoDismiss ? duration : 0 
                }
            );
        } else {
            // Last resort: use console
            console[type === 'error' ? 'error' : type === 'warning' ? 'warn' : 'log'](
                `[${type.toUpperCase()}] ${title}: ${message}`,
                context
            );
        }
    }

    /**
     * Format context for display
     * @private
     */
    _formatContext(context) {
        try {
            // Filter out sensitive information
            const safeContext = { ...context };
            const sensitiveKeys = ['password', 'token', 'secret', 'authorization'];
            
            Object.keys(safeContext).forEach(key => {
                const lowerKey = key.toLowerCase();
                if (sensitiveKeys.some(sk => lowerKey.includes(sk))) {
                    safeContext[key] = '***REDACTED***';
                }
            });
            
            return JSON.stringify(safeContext, null, 2);
        } catch (e) {
            return 'Unable to format context';
        }
    }

    /**
     * Show a success notification
     * @param {string} message - The success message
     * @param {Object} options - Additional options
     */
    showSuccess(message, options = {}) {
        this.showNotification(message, {
            ...options,
            type: 'success',
            title: options.title || 'Success'
        });
    }

    /**
     * Show a warning notification
     * @param {string} message - The warning message
     * @param {Object} options - Additional options
     */
    showWarning(message, options = {}) {
        this.showNotification(message, {
            ...options,
            type: 'warning',
            title: options.title || 'Warning'
        });
    }

    /**
     * Show an error notification
     * @param {string} message - The error message
     * @param {Object} options - Additional options
     */
    showError(message, options = {}) {
        this.showNotification(message, {
            ...options,
            type: 'error',
            title: options.title || 'Error',
            autoDismiss: options.autoDismiss !== undefined ? options.autoDismiss : false
        });
    }

    /**
     * Show an info notification
     * @param {string} message - The info message
     * @param {Object} options - Additional options
     */
    showInfo(message, options = {}) {
        this.showNotification(message, {
            ...options,
            type: 'info',
            title: options.title || 'Info'
        });
    }
}



/* From: public/js/modules/error/error-types.js */
/**
 * Error Types
 * 
 * Defines standard error types and severities for consistent error handling
 */

/**
 * Standard error types
 */
export const ErrorTypes = Object.freeze({
    // Client-side errors
    VALIDATION: 'VALIDATION',      // Data validation failed
    AUTHENTICATION: 'AUTHENTICATION', // Authentication/authorization issues
    AUTHORIZATION: 'AUTHORIZATION',   // Permission issues
    NETWORK: 'NETWORK',           // Network connectivity issues
    TIMEOUT: 'TIMEOUT',           // Request timeouts
    
    // Server-side errors
    SERVER: 'SERVER',             // Generic server error (500)
    SERVICE_UNAVAILABLE: 'SERVICE_UNAVAILABLE', // Service unavailable (503)
    NOT_FOUND: 'NOT_FOUND',       // Resource not found (404)
    CONFLICT: 'CONFLICT',         // Resource conflict (409)
    
    // Application-specific errors
    CONFIGURATION: 'CONFIGURATION', // Configuration errors
    INTEGRATION: 'INTEGRATION',   // Third-party service integration errors
    
    // Fallback
    UNKNOWN: 'UNKNOWN'            // Unclassified errors
});

/**
 * Error severity levels
 */
export const ErrorSeverity = Object.freeze({
    FATAL: 'FATAL',     // Application cannot continue
    ERROR: 'ERROR',     // Operation failed, but application can continue
    WARNING: 'WARNING', // Operation completed with issues
    INFO: 'INFO',      // Informational message
    DEBUG: 'DEBUG'     // Debug information
});

/**
 * Standard error codes
 */
export const ErrorCodes = Object.freeze({
    // Authentication (1000-1099)
    INVALID_CREDENTIALS: 1001,
    SESSION_EXPIRED: 1002,
    INVALID_TOKEN: 1003,
    
    // Validation (2000-2099)
    INVALID_INPUT: 2001,
    MISSING_REQUIRED_FIELD: 2002,
    INVALID_FORMAT: 2003,
    
    // Authorization (3000-3099)
    PERMISSION_DENIED: 3001,
    INSUFFICIENT_PERMISSIONS: 3002,
    
    // Network (4000-4099)
    NETWORK_ERROR: 4001,
    REQUEST_TIMEOUT: 4002,
    
    // Server (5000-5099)
    INTERNAL_SERVER_ERROR: 5001,
    SERVICE_UNAVAILABLE: 5002,
    
    // Business Logic (6000-6099)
    DUPLICATE_ENTRY: 6001,
    RESOURCE_NOT_FOUND: 6002,
    
    // Integration (7000-7099)
    EXTERNAL_SERVICE_ERROR: 7001,
    API_RATE_LIMIT_EXCEEDED: 7002
});

/**
 * Standard error messages
 */
export const ErrorMessages = Object.freeze({
    [ErrorTypes.VALIDATION]: 'Validation failed',
    [ErrorTypes.AUTHENTICATION]: 'Authentication required',
    [ErrorTypes.AUTHORIZATION]: 'Permission denied',
    [ErrorTypes.NETWORK]: 'Network error occurred',
    [ErrorTypes.TIMEOUT]: 'Request timed out',
    [ErrorTypes.SERVER]: 'Internal server error',
    [ErrorTypes.SERVICE_UNAVAILABLE]: 'Service unavailable',
    [ErrorTypes.NOT_FOUND]: 'Resource not found',
    [ErrorTypes.CONFLICT]: 'Resource conflict',
    [ErrorTypes.CONFIGURATION]: 'Configuration error',
    [ErrorTypes.INTEGRATION]: 'Integration error',
    [ErrorTypes.UNKNOWN]: 'An unexpected error occurred'
});

/**
 * Error metadata
 * Maps error types to their default properties
 */
export const ErrorMetadata = Object.freeze({
    [ErrorTypes.VALIDATION]: {
        severity: ErrorSeverity.WARNING,
        isRecoverable: true,
        userMessage: 'Please check your input and try again.'
    },
    [ErrorTypes.AUTHENTICATION]: {
        severity: ErrorSeverity.ERROR,
        isRecoverable: true,
        userMessage: 'Your session has expired. Please log in again.'
    },
    [ErrorTypes.AUTHORIZATION]: {
        severity: ErrorSeverity.ERROR,
        isRecoverable: false,
        userMessage: 'You do not have permission to perform this action.'
    },
    [ErrorTypes.NETWORK]: {
        severity: ErrorSeverity.WARNING,
        isRecoverable: true,
        userMessage: 'Unable to connect to the server. Please check your internet connection.'
    },
    [ErrorTypes.SERVER]: {
        severity: ErrorSeverity.ERROR,
        isRecoverable: false,
        userMessage: 'An unexpected server error occurred. Please try again later.'
    },
    [ErrorTypes.UNKNOWN]: {
        severity: ErrorSeverity.ERROR,
        isRecoverable: false,
        userMessage: 'An unexpected error occurred. Please try again.'
    }
});

/**
 * Creates a standard error object
 * @param {string} type - Error type from ErrorTypes
 * @param {string} message - Error message
 * @param {Object} details - Additional error details
 * @returns {Error} Standardized error object
 */
export function createError(type, message, details = {}) {
    const error = new Error(message || ErrorMessages[type] || 'An unknown error occurred');
    error.type = type;
    error.code = details.code || ErrorCodes[type] || 0;
    error.details = details;
    error.timestamp = new Date().toISOString();
    
    // Add metadata if available
    const metadata = ErrorMetadata[type];
    if (metadata) {
        error.severity = metadata.severity;
        error.isRecoverable = metadata.isRecoverable;
        error.userMessage = metadata.userMessage;
    }
    
    return error;
}

/**
 * Checks if an error is of a specific type
 * @param {Error} error - The error to check
 * @param {string} type - The error type to check against
 * @returns {boolean} True if the error is of the specified type
 */
export function isErrorType(error, type) {
    return error && error.type === type;
}

/**
 * Gets the default error message for an error type
 * @param {string} type - The error type
 * @returns {string} The default error message
 */
export function getDefaultMessage(type) {
    return ErrorMessages[type] || 'An unknown error occurred';
}

/**
 * Gets the default severity for an error type
 * @param {string} type - The error type
 * @returns {string} The default severity
 */
export function getDefaultSeverity(type) {
    const metadata = ErrorMetadata[type];
    return metadata ? metadata.severity : ErrorSeverity.ERROR;
}



/* From: public/js/modules/error/ErrorBoundary.js */
import React from 'react';
import PropTypes from 'prop-types';
import { ErrorManager } from './error-manager';
import { ErrorTypes, ErrorSeverity } from './error-types';

/**
 * Error Boundary Component
 * 
 * Catches JavaScript errors in their child component tree, logs those errors,
 * and displays a fallback UI instead of the component tree that crashed.
 */
export class ErrorBoundary extends React.Component {
    constructor(props) {
        super(props);
        this.state = { 
            hasError: false,
            error: null,
            errorInfo: null
        };
        
        // Get error manager from props or context
        this.errorManager = props.errorManager || 
                           (props.context && props.context.errorManager) ||
                           new ErrorManager(console);
    }

    static getDerivedStateFromError(error) {
        // Update state so the next render will show the fallback UI
        return { 
            hasError: true,
            error: error
        };
    }

    componentDidCatch(error, errorInfo) {
        // Log the error to our error manager
        this.errorManager.handleError(error, {
            component: errorInfo.componentStack.split('\n')[0].trim() || 'Unknown',
            stack: errorInfo.componentStack,
            boundary: this.constructor.name,
            ...this.props.errorContext
        });

        // Update state with error info
        this.setState({
            error: error,
            errorInfo: errorInfo
        });
    }

    handleReset = () => {
        // Reset the error state
        this.setState({
            hasError: false,
            error: null,
            errorInfo: null
        });
        
        // Call the onReset callback if provided
        if (this.props.onReset) {
            this.props.onReset();
        }
    };

    renderFallbackUI() {
        const { error, errorInfo } = this.state;
        const { 
            fallback: FallbackComponent, 
            showErrorDetails = process.env.NODE_ENV !== 'production',
            children
        } = this.props;

        // Use custom fallback component if provided
        if (FallbackComponent) {
            return (
                <FallbackComponent 
                    error={error} 
                    errorInfo={errorInfo} 
                    onReset={this.handleReset}
                />
            );
        }

        // Default fallback UI
        return (
            <div className="error-boundary" style={styles.container}>
                <div style={styles.content}>
                    <h2 style={styles.title}>Something went wrong.</h2>
                    <p style={styles.message}>
                        We're sorry for the inconvenience. An error has occurred.
                    </p>
                    
                    {showErrorDetails && (
                        <details style={styles.details}>
                            <summary>Error Details</summary>
                            <pre style={styles.errorText}>
                                {error && error.toString()}
                            </pre>
                            <pre style={styles.stackTrace}>
                                {errorInfo && errorInfo.componentStack}
                            </pre>
                        </details>
                    )}
                    
                    <div style={styles.actions}>
                        <button 
                            onClick={this.handleReset}
                            style={styles.button}
                        >
                            Try Again
                        </button>
                        <button 
                            onClick={() => window.location.reload()}
                            style={{ ...styles.button, ...styles.secondaryButton }}
                        >
                            Reload Page
                        </button>
                    </div>
                </div>
            </div>
        );
    }

    render() {
        if (this.state.hasError) {
            return this.renderFallbackUI();
        }
        
        return this.props.children;
    }
}

// Prop types
ErrorBoundary.propTypes = {
    // Custom fallback component
    fallback: PropTypes.oneOfType([
        PropTypes.node,
        PropTypes.func
    ]),
    
    // Whether to show error details (defaults to true in development)
    showErrorDetails: PropTypes.bool,
    
    // Error manager instance
    errorManager: PropTypes.instanceOf(ErrorManager),
    
    // Additional context for error reporting
    errorContext: PropTypes.object,
    
    // Callback when error is reset
    onReset: PropTypes.func,
    
    // Child components
    children: PropTypes.node
};

// Default props
ErrorBoundary.defaultProps = {
    showErrorDetails: process.env.NODE_ENV !== 'production',
    errorContext: {}
};

// Inline styles
const styles = {
    container: {
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        minHeight: '100vh',
        padding: '20px',
        backgroundColor: '#f8f9fa',
        color: '#212529'
    },
    content: {
        maxWidth: '600px',
        padding: '30px',
        backgroundColor: '#fff',
        borderRadius: '8px',
        boxShadow: '0 2px 10px rgba(0, 0, 0, 0.1)'
    },
    title: {
        color: '#dc3545',
        marginTop: 0
    },
    message: {
        marginBottom: '20px',
        lineHeight: '1.5'
    },
    details: {
        margin: '20px 0',
        padding: '15px',
        backgroundColor: '#f8f9fa',
        border: '1px solid #dee2e6',
        borderRadius: '4px',
        fontSize: '14px'
    },
    errorText: {
        color: '#dc3545',
        whiteSpace: 'pre-wrap',
        margin: '0 0 10px 0',
        fontFamily: 'monospace'
    },
    stackTrace: {
        color: '#6c757d',
        whiteSpace: 'pre-wrap',
        margin: '10px 0 0 0',
        fontFamily: 'monospace',
        fontSize: '12px'
    },
    actions: {
        display: 'flex',
        gap: '10px',
        marginTop: '20px'
    },
    button: {
        padding: '8px 16px',
        backgroundColor: '#007bff',
        color: 'white',
        border: 'none',
        borderRadius: '4px',
        cursor: 'pointer',
        fontSize: '14px',
        transition: 'background-color 0.2s'
    },
    secondaryButton: {
        backgroundColor: '#6c757d'
    }
};

export default ErrorBoundary;



/* From: public/js/modules/error/index.js */
/**
 * Error Handling Module
 * 
 * Centralized error handling for the PingOne Import Tool
 * 
 * This module provides:
 * - ErrorManager: Central error handling and processing
 * - ErrorReporter: UI error reporting and notifications
 * - ErrorBoundary: React component for catching UI errors
 * - Standard error types and utilities
 */

export { ErrorManager } from './error-manager';
export { ErrorReporter } from './error-reporter';
export { ErrorBoundary } from './ErrorBoundary';
export { 
  ErrorTypes, 
  ErrorSeverity, 
  ErrorCodes, 
  ErrorMessages, 
  ErrorMetadata,
  createError,
  isErrorType,
  getDefaultMessage,
  getDefaultSeverity
} from './error-types';

/**
 * Initialize the error handling system
 * @param {Object} logger - Logger instance
 * @param {Object} uiManager - UI Manager instance
 * @param {Object} options - Configuration options
 * @returns {Object} Initialized error handling utilities
 */
export function initializeErrorHandling(logger, uiManager, options = {}) {
  // Create error reporter and manager
  const errorReporter = new ErrorReporter(options.reporterOptions);
  const errorManager = new ErrorManager(logger, {
    ...options,
    reporter: errorReporter
  });
  
  // Initialize the error reporter with UI manager
  errorReporter.initialize(uiManager);
  
  // Set up global error handlers
  setupGlobalErrorHandlers(errorManager, options);
  
  return {
    errorManager,
    errorReporter,
    handleError: (error, context) => errorManager.handleError(error, context)
  };
}

/**
 * Set up global error handlers
 * @private
 */
function setupGlobalErrorHandlers(errorManager, options = {}) {
  const { captureUnhandledRejections = true } = options;
  
  // Handle uncaught exceptions
  if (typeof window !== 'undefined') {
    const originalOnError = window.onerror;
    
    window.onerror = (message, source, lineno, colno, error) => {
      // Call any existing error handler
      if (typeof originalOnError === 'function') {
        originalOnError(message, source, lineno, colno, error);
      }
      
      // Process the error through our error manager
      const errorObj = error || new Error(message);
      errorManager.handleError(errorObj, {
        source: 'window.onerror',
        location: `${source}:${lineno}:${colno}`
      });
      
      // Let the default handler run
      return false;
    };
  }
  
  // Handle unhandled promise rejections
  if (captureUnhandledRejections && typeof window !== 'undefined' && 'addEventListener' in window) {
    window.addEventListener('unhandledrejection', (event) => {
      const error = event.reason || new Error('Unhandled promise rejection');
      errorManager.handleError(error, {
        source: 'unhandledrejection',
        event: {
          type: event.type,
          isTrusted: event.isTrusted
        }
      });
      
      // Prevent default handling (like logging to console)
      event.preventDefault();
    });
  }
}

/**
 * Create an error boundary with the given error manager
 * @param {Object} errorManager - Error manager instance
 * @param {Object} options - Error boundary options
 * @returns {React.Component} Error boundary component
 */
export function createErrorBoundary(errorManager, options = {}) {
  return function ErrorBoundaryWrapper(props) {
    return (
      <ErrorBoundary 
        errorManager={errorManager} 
        {...options} 
        {...props} 
      />
    );
  };
}

/**
 * Higher-order component for error handling
 * @param {React.Component} Component - Component to wrap
 * @param {Object} options - Error handling options
 * @returns {React.Component} Wrapped component with error handling
 */
export function withErrorHandling(Component, options = {}) {
  return function WithErrorHandling(props) {
    const { errorManager } = useErrorManager();
    
    const handleError = useCallback((error, context = {}) => {
      return errorManager.handleError(error, {
        component: Component.displayName || Component.name || 'Unknown',
        ...context
      });
    }, [errorManager]);
    
    try {
      return <Component onError={handleError} {...props} />;
    } catch (error) {
      handleError(error, { location: 'component-render' });
      
      // Return null or a fallback UI
      if (options.FallbackComponent) {
        return <options.FallbackComponent error={error} />;
      }
      
      return null;
    }
  };
}

// Context for error management
const ErrorManagerContext = React.createContext(null);

/**
 * Provider component for error management
 */
export function ErrorManagerProvider({ children, errorManager }) {
  return (
    <ErrorManagerContext.Provider value={errorManager}>
      {children}
    </ErrorManagerContext.Provider>
  );
}

/**
 * Hook to access the error manager from context
 */
export function useErrorManager() {
  const errorManager = React.useContext(ErrorManagerContext);
  
  if (!errorManager) {
    console.warn('ErrorManager not found in context. Using default implementation.');
    return {
      errorManager: new ErrorManager(console),
      handleError: (error) => console.error('Unhandled error:', error)
    };
  }
  
  const handleError = React.useCallback((error, context = {}) => {
    return errorManager.handleError(error, context);
  }, [errorManager]);
  
  return { errorManager, handleError };
}



/* From: public/js/modules/error-logging/models.js */
/**
 * @module
 * @description ES Module (converted from CommonJS)
 */



