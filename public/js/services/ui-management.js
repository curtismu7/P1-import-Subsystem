/**
 * Ui management Module
 * 
 * Consolidated JavaScript for PingOne Import Tool
 * Generated: 2025-08-06T19:08:20.708Z
 * 
 * This file was automatically generated by js-final-cleanup.js
 * Organized for better maintainability and performance
 */


/* From: public/js/modules/history-ui.js */
/**
 * History UI Module
 * Modern ES module for History page UI management using HistorySubsystem
 * Provides event-driven UI components and interactions for operation history
 */

export class HistoryUI {
    constructor(historySubsystem, eventBus, logger) {
        this.historySubsystem = historySubsystem;
        this.eventBus = eventBus;
        this.logger = logger;
        
        // UI state
        this.currentHistory = [];
        this.filteredHistory = [];
        this.currentPage = 1;
        this.itemsPerPage = 20;
        this.isLoading = false;
        
        // Filter state
        this.currentFilters = {
            category: '',
            status: '',
            dateFrom: '',
            dateTo: '',
            search: ''
        };
        
        // UI elements cache
        this.elements = {};
        
        this.logger.debug('HistoryUI initialized');
    }

    /**
     * Initialize the History UI
     */
    async init() {
        try {
            this.logger.info('Initializing HistoryUI');
            
            // Cache DOM elements
            this.cacheElements();
            
            // Setup event listeners
            this.setupEventListeners();
            
            // Setup filter listeners
            this.setupFilterListeners();
            
            // Load initial history
            await this.loadHistory();
            
            this.logger.info('HistoryUI initialized successfully');
            
        } catch (error) {
            this.logger.error('Failed to initialize HistoryUI:', error);
            throw error;
        }
    }

    /**
     * Cache frequently used DOM elements
     */
    cacheElements() {
        this.elements = {
            historyList: document.getElementById('history-list'),
            pagination: document.getElementById('pagination'),
            categoryFilter: document.getElementById('category-filter'),
            statusFilter: document.getElementById('status-filter'),
            dateFromFilter: document.getElementById('date-from'),
            dateToFilter: document.getElementById('date-to'),
            searchFilter: document.getElementById('search-filter'),
            totalOperations: document.getElementById('total-operations'),
            successfulOperations: document.getElementById('successful-operations'),
            failedOperations: document.getElementById('failed-operations'),
            successRate: document.getElementById('success-rate'),
            prevPageBtn: document.getElementById('prev-page'),
            nextPageBtn: document.getElementById('next-page'),
            paginationInfo: document.getElementById('pagination-info')
        };
    }

    /**
     * Setup event listeners for real-time updates
     */
    setupEventListeners() {
        if (this.eventBus) {
            // Listen for history updates from HistorySubsystem
            this.eventBus.on('history:updated', () => {
                this.logger.debug('History updated event received');
                this.loadHistory();
            });
            
            this.eventBus.on('history:entry:added', (data) => {
                this.logger.debug('History entry added:', data);
                this.loadHistory();
            });
            
            this.eventBus.on('history:entry:updated', (data) => {
                this.logger.debug('History entry updated:', data);
                this.loadHistory();
            });
            
            this.eventBus.on('history:entry:deleted', (data) => {
                this.logger.debug('History entry deleted:', data);
                this.loadHistory();
            });
            
            this.eventBus.on('history:cleared', () => {
                this.logger.debug('History cleared event received');
                this.currentHistory = [];
                this.filteredHistory = [];
                this.displayHistory();
            });
        }
    }

    /**
     * Setup filter change listeners
     */
    setupFilterListeners() {
        const filterElements = [
            'categoryFilter',
            'statusFilter', 
            'dateFromFilter',
            'dateToFilter',
            'searchFilter'
        ];

        filterElements.forEach(elementKey => {
            const element = this.elements[elementKey];
            if (element) {
                element.addEventListener('change', () => this.applyFilters());
                if (element.type === 'text') {
                    element.addEventListener('input', () => this.debounceFilter());
                }
            }
        });
    }

    /**
     * Debounce filter for search input
     */
    debounceFilter() {
        clearTimeout(this.filterTimeout);
        this.filterTimeout = setTimeout(() => this.applyFilters(), 300);
    }

    /**
     * Load history from HistorySubsystem
     */
    async loadHistory() {
        if (this.isLoading) return;
        
        try {
            this.isLoading = true;
            this.showLoadingState();
            
            this.logger.debug('Loading history from HistorySubsystem');
            
            // Get history from subsystem with statistics
            const historyData = await this.historySubsystem.getHistory({
                limit: 1000, // Load all for client-side filtering
                includeStats: true
            });
            
            this.currentHistory = historyData.history || [];
            
            // Update statistics if available
            if (historyData.stats) {
                this.updateStatistics(historyData.stats);
            }
            
            // Apply current filters
            this.applyFilters();
            
            this.logger.debug(`Loaded ${this.currentHistory.length} history entries`);
            
        } catch (error) {
            this.logger.error('Failed to load history:', error);
            this.showError('Failed to load history', error.message);
        } finally {
            this.isLoading = false;
        }
    }

    /**
     * Apply current filters to history
     */
    applyFilters() {
        // Get current filter values
        this.currentFilters = {
            category: this.elements.categoryFilter?.value || '',
            status: this.elements.statusFilter?.value || '',
            dateFrom: this.elements.dateFromFilter?.value || '',
            dateTo: this.elements.dateToFilter?.value || '',
            search: this.elements.searchFilter?.value || ''
        };

        // Filter history
        this.filteredHistory = this.currentHistory.filter(entry => {
            return this.matchesFilters(entry);
        });

        // Reset to first page
        this.currentPage = 1;
        
        // Display filtered results
        this.displayHistory();
        
        this.logger.debug(`Applied filters, ${this.filteredHistory.length} entries match`);
    }

    /**
     * Check if entry matches current filters
     */
    matchesFilters(entry) {
        // Category filter
        if (this.currentFilters.category && entry.category !== this.currentFilters.category) {
            return false;
        }
        
        // Status filter
        if (this.currentFilters.status && entry.status !== this.currentFilters.status) {
            return false;
        }
        
        // Date range filter
        if (this.currentFilters.dateFrom || this.currentFilters.dateTo) {
            const entryDate = new Date(entry.timestamp);
            
            if (this.currentFilters.dateFrom) {
                const fromDate = new Date(this.currentFilters.dateFrom);
                if (entryDate < fromDate) return false;
            }
            
            if (this.currentFilters.dateTo) {
                const toDate = new Date(this.currentFilters.dateTo);
                toDate.setHours(23, 59, 59, 999); // End of day
                if (entryDate > toDate) return false;
            }
        }
        
        // Search filter
        if (this.currentFilters.search) {
            const searchTerm = this.currentFilters.search.toLowerCase();
            const searchableText = [
                entry.description,
                entry.category,
                entry.status,
                JSON.stringify(entry.data || {})
            ].join(' ').toLowerCase();
            
            if (!searchableText.includes(searchTerm)) {
                return false;
            }
        }
        
        return true;
    }

    /**
     * Display history entries with pagination
     */
    displayHistory() {
        if (!this.elements.historyList) return;
        
        if (this.filteredHistory.length === 0) {
            this.showNoHistory();
            return;
        }

        // Calculate pagination
        const totalPages = Math.ceil(this.filteredHistory.length / this.itemsPerPage);
        const startIndex = (this.currentPage - 1) * this.itemsPerPage;
        const endIndex = startIndex + this.itemsPerPage;
        const pageHistory = this.filteredHistory.slice(startIndex, endIndex);

        // Generate HTML
        let html = '';
        pageHistory.forEach(entry => {
            html += this.createHistoryEntryHTML(entry);
        });

        this.elements.historyList.innerHTML = html;

        // Update pagination
        this.updatePagination(totalPages);
        
        if (this.elements.pagination) {
            this.elements.pagination.style.display = totalPages > 1 ? 'flex' : 'none';
        }
    }

    /**
     * Create HTML for a history entry
     */
    createHistoryEntryHTML(entry) {
        const timestamp = new Date(entry.timestamp).toLocaleString();
        const statusClass = `status-${entry.status}`;
        const categoryIcon = this.getCategoryIcon(entry.category);
        
        return `
            <div class="history-entry" data-entry-id="${entry.id}">
                <div class="history-entry-header">
                    <div class="history-entry-info">
                        <div class="history-entry-title">
                            ${categoryIcon} ${entry.description}
                        </div>
                        <div class="history-entry-meta">
                            <span><i class="fas fa-clock"></i> ${timestamp}</span>
                            <span><i class="fas fa-tag"></i> ${entry.category}</span>
                            ${entry.data?.sessionId ? `<span><i class="fas fa-fingerprint"></i> ${entry.data.sessionId}</span>` : ''}
                        </div>
                    </div>
                    <div class="history-entry-status ${statusClass}">
                        ${entry.status}
                    </div>
                </div>
                ${this.createEntryDetails(entry)}
            </div>
        `;
    }

    /**
     * Create details section for history entry
     */
    createEntryDetails(entry) {
        if (!entry.data || Object.keys(entry.data).length === 0) {
            return '';
        }
        
        // Sanitize sensitive data for display
        const sanitizedData = this.sanitizeDataForDisplay(entry.data);
        
        return `
            <div class="history-entry-details">
                <strong>Details:</strong>
                <pre>${JSON.stringify(sanitizedData, null, 2)}</pre>
            </div>
        `;
    }

    /**
     * Sanitize data for display (remove sensitive fields)
     */
    sanitizeDataForDisplay(data) {
        const sensitiveFields = ['password', 'token', 'secret', 'key', 'credential'];
        const sanitized = { ...data };
        
        const sanitizeObject = (obj) => {
            for (const key in obj) {
                if (typeof obj[key] === 'object' && obj[key] !== null) {
                    sanitizeObject(obj[key]);
                } else if (sensitiveFields.some(field => key.toLowerCase().includes(field))) {
                    obj[key] = '[REDACTED]';
                }
            }
        };
        
        sanitizeObject(sanitized);
        return sanitized;
    }

    /**
     * Get icon for category
     */
    getCategoryIcon(category) {
        const icons = {
            import: '📥',
            export: '📤',
            delete: '🗑️',
            modify: '✏️',
            settings: '⚙️',
            auth: '🔐',
            system: '🖥️'
        };
        return icons[category] || '📄';
    }

    /**
     * Update statistics display
     */
    updateStatistics(stats) {
        if (this.elements.totalOperations) {
            this.elements.totalOperations.textContent = stats.total || 0;
        }
        
        if (this.elements.successfulOperations) {
            this.elements.successfulOperations.textContent = stats.completed || 0;
        }
        
        if (this.elements.failedOperations) {
            this.elements.failedOperations.textContent = stats.failed || 0;
        }
        
        if (this.elements.successRate) {
            const successRate = stats.total > 0 ? Math.round((stats.completed / stats.total) * 100) : 0;
            this.elements.successRate.textContent = `${successRate}%`;
        }
    }

    /**
     * Update pagination controls
     */
    updatePagination(totalPages) {
        if (this.elements.prevPageBtn) {
            this.elements.prevPageBtn.disabled = this.currentPage <= 1;
        }
        
        if (this.elements.nextPageBtn) {
            this.elements.nextPageBtn.disabled = this.currentPage >= totalPages;
        }
        
        if (this.elements.paginationInfo) {
            this.elements.paginationInfo.textContent = `Page ${this.currentPage} of ${totalPages}`;
        }
    }

    /**
     * Show loading state
     */
    showLoadingState() {
        if (!this.elements.historyList) return;
        
        this.elements.historyList.innerHTML = `
            <div class="no-history">
                <div class="loading-spinner"></div>
                <h3>Loading History...</h3>
                <p>Fetching operation history from HistorySubsystem...</p>
            </div>
        `;
    }

    /**
     * Show no history state
     */
    showNoHistory() {
        if (!this.elements.historyList) return;
        
        this.elements.historyList.innerHTML = `
            <div class="no-history">
                <i class="fas fa-history"></i>
                <h3>No History Found</h3>
                <p>No operations match your current filters.</p>
            </div>
        `;
        
        if (this.elements.pagination) {
            this.elements.pagination.style.display = 'none';
        }
    }

    /**
     * Show error state
     */
    showError(title, message) {
        if (!this.elements.historyList) return;
        
        this.elements.historyList.innerHTML = `
            <div class="no-history">
                <i class="fas fa-exclamation-triangle" style="color: #dc3545;"></i>
                <h3>${title}</h3>
                <p>${message}</p>
                <button class="btn-modern" onclick="window.historyUI?.loadHistory()">
                    <i class="fas fa-retry"></i> Retry
                </button>
            </div>
        `;
    }

    /**
     * Navigate to next page
     */
    nextPage() {
        if (this.currentPage < Math.ceil(this.filteredHistory.length / this.itemsPerPage)) {
            this.currentPage++;
            this.displayHistory();
        }
    }

    /**
     * Navigate to previous page
     */
    previousPage() {
        if (this.currentPage > 1) {
            this.currentPage--;
            this.displayHistory();
        }
    }

    /**
     * Clear all filters
     */
    clearFilters() {
        if (this.elements.categoryFilter) this.elements.categoryFilter.value = '';
        if (this.elements.statusFilter) this.elements.statusFilter.value = '';
        if (this.elements.dateFromFilter) this.elements.dateFromFilter.value = '';
        if (this.elements.dateToFilter) this.elements.dateToFilter.value = '';
        if (this.elements.searchFilter) this.elements.searchFilter.value = '';
        
        this.applyFilters();
        this.logger.debug('Filters cleared');
    }

    /**
     * Export history using HistorySubsystem
     */
    async exportHistory() {
        try {
            this.logger.info('Exporting history');
            
            await this.historySubsystem.exportHistory({
                format: 'csv',
                filtered: true,
                filters: this.currentFilters
            });
            
            this.logger.info('History exported successfully');
            
        } catch (error) {
            this.logger.error('Failed to export history:', error);
            throw error;
        }
    }

    /**
     * Clear all history using HistorySubsystem
     */
    async clearHistory() {
        try {
            this.logger.info('Clearing all history');
            
            await this.historySubsystem.clearHistory();
            
            this.logger.info('History cleared successfully');
            
            // Reload history to reflect changes
            await this.loadHistory();
            
        } catch (error) {
            this.logger.error('Failed to clear history:', error);
            throw error;
        }
    }

    /**
     * Refresh history data
     */
    async refresh() {
        this.logger.debug('Refreshing history');
        await this.loadHistory();
    }

    /**
     * Destroy the UI and cleanup
     */
    destroy() {
        // Clear timeouts
        if (this.filterTimeout) {
            clearTimeout(this.filterTimeout);
        }
        
        // Remove event listeners
        if (this.eventBus) {
            this.eventBus.off('history:updated');
            this.eventBus.off('history:entry:added');
            this.eventBus.off('history:entry:updated');
            this.eventBus.off('history:entry:deleted');
            this.eventBus.off('history:cleared');
        }
        
        this.logger.debug('HistoryUI destroyed');
    }
}

export default HistoryUI;



/* From: public/js/modules/status-widget-integration.js */
/**
 * Status Widget Integration
 * Integrates the unified token management system with the status widget
 */

class StatusWidgetIntegration {
    constructor() {
        this.initialized = false;
        this.updateInterval = null;
        this.statusWidget = null;
        this.bindMethods();
    }

    bindMethods() {
        this.init = this.init.bind(this);
        this.updateStatus = this.updateStatus.bind(this);
        this.handleTokenEvents = this.handleTokenEvents.bind(this);
    }

    /**
     * Initialize the status widget integration
     */
    init() {
        if (this.initialized) {
            console.log('🔧 Status Widget Integration already initialized');
            return;
        }

        console.log('🔧 Initializing Status Widget Integration...');

        // Find status widget
        this.statusWidget = document.querySelector('.token-status-indicator');
        if (!this.statusWidget) {
            console.warn('⚠️ Status widget not found, retrying in 1 second...');
            setTimeout(() => this.init(), 1000);
            return;
        }

        // Check if unified token manager is available
        if (!window.TokenAccess) {
            console.warn('⚠️ TokenAccess not available, retrying in 1 second...');
            setTimeout(() => this.init(), 1000);
            return;
        }

        // Set up event listeners for token events
        this.setupTokenEventListeners();

        // Initial status update
        this.updateStatus();

        // Set up periodic updates
        this.updateInterval = setInterval(() => {
            this.updateStatus();
        }, 10000); // Update every 10 seconds

        this.initialized = true;
        console.log('✅ Status Widget Integration initialized successfully');
    }

    /**
     * Set up event listeners for token events
     */
    setupTokenEventListeners() {
        // Listen for token refresh events
        if (window.PingOneTokenManager && window.PingOneTokenManager.eventBus) {
            window.PingOneTokenManager.eventBus.on('tokenRefreshed', () => {
                console.log('🔄 Token refreshed event received, updating status widget');
                this.updateStatus();
            });

            window.PingOneTokenManager.eventBus.on('tokenError', () => {
                console.log('❌ Token error event received, updating status widget');
                this.updateStatus();
            });
        }

        // Listen for storage events (token changes)
        window.addEventListener('storage', (event) => {
            if (event.key && (event.key.includes('token') || event.key.includes('pingone'))) {
                console.log('🔄 Token storage change detected, updating status widget');
                setTimeout(() => this.updateStatus(), 500); // Small delay to ensure changes are processed
            }
        });
    }

    /**
     * Update the status widget with current token information
     */
    async updateStatus() {
        if (!this.statusWidget || !window.TokenAccess) {
            return;
        }

        try {
            const tokenInfo = window.TokenAccess.getTokenInfo();
            
            // Update status indicator
            let statusText = '●';
            let statusColor = '#6c757d'; // Default gray
            let statusTitle = 'Token status unknown';

            switch (tokenInfo.status) {
                case 'valid':
                    statusColor = '#28a745'; // Green
                    statusTitle = `Token is valid - ${tokenInfo.timeRemainingFormatted || 'Time remaining unknown'}`;
                    break;
                case 'expired':
                    statusColor = '#dc3545'; // Red
                    statusTitle = 'Token has expired';
                    break;
                case 'invalid':
                    statusColor = '#ffc107'; // Yellow
                    statusTitle = 'Token is invalid';
                    break;
                case 'missing':
                    statusColor = '#6c757d'; // Gray
                    statusTitle = 'No token available';
                    break;
                default:
                    statusColor = '#17a2b8'; // Blue
                    statusTitle = 'Checking token status...';
            }

            // Update the widget
            this.statusWidget.textContent = statusText;
            this.statusWidget.style.color = statusColor;
            this.statusWidget.title = statusTitle;

            // Add pulsing animation for checking state
            if (tokenInfo.status === 'checking') {
                this.statusWidget.style.animation = 'pulse 1s infinite';
            } else {
                this.statusWidget.style.animation = 'none';
            }

            // Update any additional status text elements
            const statusTextElements = document.querySelectorAll('.token-status-text, .status-text');
            statusTextElements.forEach(element => {
                element.textContent = tokenInfo.status.charAt(0).toUpperCase() + tokenInfo.status.slice(1);
                element.className = `token-status-text status-${tokenInfo.status}`;
            });

            console.log('✅ Status widget updated:', tokenInfo.status);

        } catch (error) {
            console.error('❌ Error updating status widget:', error);
            
            // Show error state
            if (this.statusWidget) {
                this.statusWidget.textContent = '⚠';
                this.statusWidget.style.color = '#dc3545';
                this.statusWidget.title = 'Error checking token status';
            }
        }
    }

    /**
     * Handle token events from the unified token manager
     */
    handleTokenEvents(event) {
        console.log('🔄 Token event received:', event);
        this.updateStatus();
    }

    /**
     * Cleanup method
     */
    destroy() {
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
        }
        this.initialized = false;
        console.log('🔧 Status Widget Integration destroyed');
    }
}

// Create global instance
window.StatusWidgetIntegration = new StatusWidgetIntegration();

// Auto-initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        window.StatusWidgetIntegration.init();
    });
} else {
    window.StatusWidgetIntegration.init();
}

export default StatusWidgetIntegration;



/* From: public/js/modules/view-management-subsystem.js */
d/**
 * View Management Subsystem
 * 
 * Handles all view transitions, navigation, and view-specific initialization.
 * Manages the single-page application navigation and view state.
 */

export class ViewManagementSubsystem {
    constructor(logger, uiManager) {
        this.logger = logger;
        this.uiManager = uiManager;
        
        // View state management
        this.currentView = 'home';
        this.previousView = null;
        this.viewHistory = [];
        this.viewInitializers = new Map();
        
        this.logger.info('View Management Subsystem initialized with default home view');
    }
    
    /**
     * Initialize the view management subsystem
     */
    async init() {
        try {
            this.setupNavigationListeners();
            this.registerViewInitializers();
            await this.showInitialView();
            this.logger.info('View Management Subsystem initialized successfully');
        } catch (error) {
            this.logger.error('Failed to initialize View Management Subsystem', error);
            throw error;
        }
    }
    
    /**
     * Set up navigation event listeners
     */
    setupNavigationListeners() {
        // Navigation items
        const navItems = document.querySelectorAll('[data-view]');
        navItems.forEach(item => {
            item.addEventListener('click', async (e) => {
                e.preventDefault();
                const view = item.getAttribute('data-view');
                await this.showView(view);
            });
        });
        
        // Browser back/forward buttons
        window.addEventListener('popstate', (e) => {
            if (e.state && e.state.view) {
                this.showView(e.state.view, false);
            }
        });
        
        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                this.handleKeyboardNavigation(e);
            }
        });
    }
    
    /**
     * Register view initializers
     */
    registerViewInitializers() {
        // Import view initializer
        this.viewInitializers.set('import', async () => {
            await this.initializeImportView();
        });
        
        // Export view initializer
        this.viewInitializers.set('export', async () => {
            await this.initializeExportView();
        });
        
        // Modify view initializer
        this.viewInitializers.set('modify', async () => {
            await this.initializeModifyView();
        });
        
        // Delete view initializer
        this.viewInitializers.set('delete-csv', async () => {
            await this.initializeDeleteView();
        });
        
        // Settings view initializer
        this.viewInitializers.set('settings', async () => {
            await this.initializeSettingsView();
        });
        
        // Logs view initializer
        this.viewInitializers.set('logs', async () => {
            await this.initializeLogsView();
        });
        
        // History view initializer
        this.viewInitializers.set('history', async () => {
            await this.initializeHistoryView();
        });
    }
    
    /**
     * Show a specific view
     */
    async showView(view, updateHistory = true) {
        if (!view || view === this.currentView) {
            return;
        }
        
        try {
            this.logger.info('Switching to view', { from: this.currentView, to: view });
            
            // Validate view exists
            if (!this.isValidView(view)) {
                const errorContext = {
                    component: 'ViewManagementSubsystem',
                    operation: 'showView',
                    requestedView: view,
                    currentView: this.currentView,
                    validViews: this.getValidViews(),
                    timestamp: new Date().toISOString(),
                    stackTrace: new Error().stack
                };
                
                this.logger.error('--- Navigation Error: Invalid View ---', errorContext);
                
                if (this.uiManager && typeof this.uiManager.showError === 'function') {
                    this.uiManager.showError('Navigation Error', `Invalid view: ${view}. Valid views are: ${this.getValidViews().join(', ')}`);
                }
                
                // Attempt fallback to home view if not already trying to navigate to home
                if (view !== 'home' && this.isValidView('home')) {
                    this.logger.warn('Attempting fallback to home view', { originalView: view });
                    return this.showView('home', updateHistory);
                }
                
                return;
            }
            
            // Store previous view
            this.previousView = this.currentView;
            
            // Hide current view
            this.hideCurrentView();
            
            // Show new view
            await this.displayView(view);
            
            // Update navigation state
            this.updateNavigationState(view);
            
            // Update browser history
            if (updateHistory) {
                this.updateBrowserHistory(view);
            }
            
            // Initialize view-specific logic
            await this.initializeView(view);
            
            // Update view state
            this.currentView = view;
            this.viewHistory.push(view);
            
            // Update page title
            this.updatePageTitle(view);
            
            // Trigger view change event
            this.triggerViewChangeEvent(view, this.previousView);
        } catch (error) {
            this.logger.error('Failed to switch view', { view, error: error.message });
            if (this.uiManager && typeof this.uiManager.showError === 'function') {
                this.uiManager.showError('Navigation Error', `Failed to switch to ${view} view: ${error.message}`);
            }
        }
    }
    
    /**
     * Hide the current view
     */
    hideCurrentView() {
        const currentViewElement = document.getElementById(`${this.currentView}-view`);
        if (currentViewElement) {
            currentViewElement.style.display = 'none';
            currentViewElement.classList.remove('active');
        }
    }
    
    /**
     * Display the specified view
     */
    async displayView(view) {
        const viewElement = document.getElementById(`${view}-view`);
        if (!viewElement) {
            throw new Error(`View element not found: ${view}-view`);
        }
        
        // Show view with animation
        viewElement.style.display = 'block';
        viewElement.classList.add('active');
        
        // Add fade-in animation
        viewElement.style.opacity = '0';
        viewElement.style.transition = 'opacity 0.3s ease-in-out';
        
        // Trigger reflow and fade in
        requestAnimationFrame(() => {
            viewElement.style.opacity = '1';
        });
    }
    
    /**
     * Update navigation state
     */
    updateNavigationState(view) {
        // Update navigation items
        const navItems = document.querySelectorAll('[data-view]');
        navItems.forEach(item => {
            const itemView = item.getAttribute('data-view');
            if (itemView === view) {
                item.classList.add('active');
            } else {
                item.classList.remove('active');
            }
        });
        
        // Update page title
        this.updatePageTitle(view);
    }
    
    /**
     * Update browser history
     */
    updateBrowserHistory(view) {
        const state = { view, timestamp: Date.now() };
        const title = this.getViewTitle(view);
        const url = `#${view}`;
        
        history.pushState(state, title, url);
    }
    
    /**
     * Initialize view-specific functionality
     */
    async initializeView(view) {
        const initializer = this.viewInitializers.get(view);
        if (initializer) {
            try {
                await initializer();
            } catch (error) {
                this.logger.error('View initialization failed', { view, error: error.message });
            }
        }
    }
    
    /**
     * Initialize import view
     */
    async initializeImportView() {
        // Load populations for import dropdown
        if (window.app && typeof window.app.loadPopulations === 'function') {
            await window.app.loadPopulations('import-population-select');
        }
        
        // Reset file input
        const fileInput = document.getElementById('csv-file');
        if (fileInput) {
            fileInput.value = '';
        }
        
        // Reset progress display
        this.resetProgressDisplay();
    }
    
    /**
     * Initialize export view
     */
    async initializeExportView() {
        // Load populations for export dropdown
        if (window.exportManager && typeof window.exportManager.loadPopulations === 'function') {
            await window.exportManager.loadPopulations();
        }
    }
    
    /**
     * Initialize modify view
     */
    async initializeModifyView() {
        // Load populations for modify dropdown
        if (window.app && typeof window.app.loadPopulations === 'function') {
            await window.app.loadPopulations('modify-population-select');
        }
        
        // Reset file input
        const fileInput = document.getElementById('modify-csv-file');
        if (fileInput) {
            fileInput.value = '';
        }
    }
    
    /**
     * Initialize delete view
     */
    async initializeDeleteView() {
        // Load populations for delete dropdown
        if (window.deleteManager && typeof window.deleteManager.loadPopulations === 'function') {
            await window.deleteManager.loadPopulations();
        }
    }
    
    /**
     * Initialize settings view
     */
    async initializeSettingsView() {
        // Load current settings
        if (window.app && typeof window.app.loadSettings === 'function') {
            await window.app.loadSettings();
        }
    }
    
    /**
     * Initialize logs view
     */
    async initializeLogsView() {
        // Load logs
        if (window.logManager && typeof window.logManager.loadLogs === 'function') {
            await window.logManager.loadLogs();
        }
    }
    
    /**
     * Initialize history view
     */
    async initializeHistoryView() {
        // Load operation history
        if (window.historyManager && typeof window.historyManager.loadHistory === 'function') {
            await window.historyManager.loadHistory();
        }
    }
    
    /**
     * Show initial view based on URL hash or default
     */
    async showInitialView() {
        let initialView = 'import';
        
        // Check URL hash
        const hash = window.location.hash.substring(1);
        if (hash && this.isValidView(hash)) {
            initialView = hash;
        }
        
        await this.showView(initialView, false);
    }
    
    /**
     * Check if view is valid
     */
    isValidView(view) {
        const validViews = [
            'home', 'import', 'export', 'modify', 'delete-csv', 
            'settings', 'logs', 'history'
        ];
        return validViews.includes(view);
    }
    
    /**
     * Get list of valid views
     * @returns {Array} Array of valid view names
     */
    getValidViews() {
        return [
            'home', 'import', 'export', 'modify', 'delete-csv', 
            'settings', 'logs', 'history'
        ];
    }
    
    /**
     * Get view title
     */
    getViewTitle(view) {
        const titles = {
            'import': 'Import Users',
            'export': 'Export Users',
            'modify': 'Modify Users',
            'delete-csv': 'Delete Users',
            'settings': 'Settings',
            'logs': 'Logs',
            'history': 'History'
        };
        
        return titles[view] || 'PingOne Import Tool';
    }
    
    /**
     * Update page title
     */
    updatePageTitle(view) {
        const title = this.getViewTitle(view);
        document.title = `${title} - PingOne Import Tool`;
    }
    
    /**
     * Handle keyboard navigation
     */
    handleKeyboardNavigation(e) {
        const keyMap = {
            '1': 'import',
            '2': 'export',
            '3': 'modify',
            '4': 'delete-csv',
            '5': 'settings',
            '6': 'logs',
            '7': 'history'
        };
        
        const view = keyMap[e.key];
        if (view) {
            e.preventDefault();
            this.showView(view);
        }
    }
    
    /**
     * Reset progress display
     */
    resetProgressDisplay() {
        // Use uiManager to hide progress and reset bar
        if (this.uiManager && typeof this.uiManager.hideProgress === 'function') {
            this.uiManager.hideProgress();
        }
        if (this.uiManager && typeof this.uiManager.updateProgress === 'function') {
            this.uiManager.updateProgress(0, 1, ''); // Reset bar
        }
    }
    
    /**
     * Trigger view change event
     */
    triggerViewChangeEvent(newView, oldView) {
        const event = new CustomEvent('viewChanged', {
            detail: {
                newView,
                oldView,
                timestamp: Date.now()
            }
        });
        
        document.dispatchEvent(event);
    }
    
    /**
     * Go back to previous view
     */
    async goBack() {
        if (this.previousView) {
            await this.showView(this.previousView);
        }
    }
    
    /**
     * Get current view
     */
    getCurrentView() {
        return this.currentView;
    }
    
    /**
     * Get view history
     */
    getViewHistory() {
        return [...this.viewHistory];
    }
    
    /**
     * Clear view history
     */
    clearViewHistory() {
        this.viewHistory = [];
    }
}

