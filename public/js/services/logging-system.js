/**
 * Logging system Module
 * 
 * Consolidated JavaScript for PingOne Import Tool
 * Generated: 2025-08-06T19:08:20.703Z
 * 
 * This file was automatically generated by js-final-cleanup.js
 * Organized for better maintainability and performance
 */


/* From: public/js/modules/log-manager.js */
/**
 * @module
 * @description ES Module (converted from CommonJS)
 */

// LogManager: Handles log page functionality including streaming, filtering, and real-time updates
// Provides comprehensive log management with filtering, real-time updates, and user-friendly display

class LogManager {
    constructor() {
        this.logsContainer = null;
        this.refreshButton = null;
        this.clearButton = null;
        this.currentLogs = [];
        this.isAutoRefresh = true;
        this.refreshInterval = null;
        this.filterLevel = 'all';
        this.filterText = '';
        
        this.initialize();
    }
    
    initialize() {
        this.setupElements();
        this.setupEventListeners();
        this.startAutoRefresh();
        this.loadLogs();
    }
    
    setupElements() {
        this.logsContainer = document.getElementById('logs-container');
        this.refreshButton = document.getElementById('refresh-logs');
        this.clearButton = document.getElementById('clear-logs');
        
        if (!this.logsContainer) {
            console.warn('Logs container not found');
            return;
        }
        
        if (!this.refreshButton) {
            console.warn('Refresh logs button not found');
        }
        
        if (!this.clearButton) {
            console.warn('Clear logs button not found');
        }
    }
    
    setupEventListeners() {
        if (this.refreshButton) {
            this.refreshButton.addEventListener('click', () => this.loadLogs());
        }
        
        if (this.clearButton) {
            this.clearButton.addEventListener('click', () => this.clearLogs());
        }
        
        // Add filter functionality
        this.addFilterControls();
        
        // Add search icon logic for the original search input
        const searchIcon = document.getElementById('logs-search-icon');
        const searchInput = document.getElementById('logs-search-input');
        if (searchIcon && searchInput) {
            searchIcon.addEventListener('click', () => {
                if (searchInput.style.display === 'none') {
                    searchInput.style.display = 'inline-block';
                    searchInput.focus();
                } else {
                    searchInput.value = '';
                    searchInput.style.display = 'none';
                    this.filterText = '';
                    this.applyFilters();
                }
            });
            searchInput.addEventListener('input', (e) => {
                this.filterText = e.target.value.toLowerCase();
                this.applyFilters();
            });
            // Hide input on Escape
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    searchInput.value = '';
                    searchInput.style.display = 'none';
                    this.filterText = '';
                    this.applyFilters();
                }
            });
        }
    }
    
    addFilterControls() {
        const logsHeader = document.querySelector('.logs-header');
        if (!logsHeader) return;
        
        // Create filter controls
        const filterContainer = document.createElement('div');
        filterContainer.className = 'logs-filters';
        filterContainer.innerHTML = `
            <div class="filter-group">
                <label for="log-level-filter">Level:</label>
                <select id="log-level-filter" class="form-control">
                    <option value="all">All Levels</option>
                    <option value="debug">Debug</option>
                    <option value="info">Info</option>
                    <option value="warn">Warning</option>
                    <option value="error">Error</option>
                    <option value="success">Success</option>
                </select>
            </div>
            <div class="filter-group">
                <label>
                    <input type="checkbox" id="auto-refresh-toggle" checked>
                    Auto Refresh
                </label>
            </div>
        `;
        
        logsHeader.appendChild(filterContainer);
        
        // Add event listeners for filters
        const levelFilter = document.getElementById('log-level-filter');
        const autoRefreshToggle = document.getElementById('auto-refresh-toggle');
        
        if (levelFilter) {
            levelFilter.addEventListener('change', (e) => {
                this.filterLevel = e.target.value;
                this.applyFilters();
            });
        }
        
        if (autoRefreshToggle) {
            autoRefreshToggle.addEventListener('change', (e) => {
                this.isAutoRefresh = e.target.checked;
                if (this.isAutoRefresh) {
                    this.startAutoRefresh();
                } else {
                    this.stopAutoRefresh();
                }
            });
        }
    }
    
    async loadLogs() {
        try {
            // Load both logs and history
            const [logsResponse, historyResponse] = await Promise.allSettled([
                fetch('/api/logs/ui?limit=100'),
                fetch('/api/history?limit=50')
            ]);
            
            let logs = [];
            let history = [];
            
            // Process logs response
            if (logsResponse.status === 'fulfilled' && logsResponse.value.ok) {
                const logsData = await logsResponse.value.json();
                if (logsData.success && logsData.logs) {
                    logs = logsData.logs;
                }
            }
            
            // Process history response
            if (historyResponse.status === 'fulfilled' && historyResponse.value.ok) {
                const historyData = await historyResponse.value.json();
                if (historyData.success && historyData.history) {
                    history = historyData.history;
                }
            }
            
            // Combine logs and history
            this.currentLogs = [...logs, ...history.map(item => ({
                timestamp: item.timestamp,
                level: 'info',
                message: item.message,
                data: {
                    type: item.type,
                    fileName: item.fileName,
                    population: item.population,
                    success: item.success,
                    errors: item.errors,
                    skipped: item.skipped,
                    total: item.total
                },
                source: 'history'
            }))];
            
            this.displayLogs();
            this.scrollToBottom();
            
        } catch (error) {
            console.error('Failed to load logs and history:', error);
            this.displayError('Failed to load logs and history: ' + error.message);
        }
    }
    
    displayLogs() {
        if (!this.logsContainer) return;
        
        this.logsContainer.innerHTML = '';
        
        if (this.currentLogs.length === 0) {
            this.displayNoLogs();
            return;
        }
        
        const filteredLogs = this.getFilteredLogs();
        
        filteredLogs.forEach(log => {
            const logElement = this.createLogElement(log);
            this.logsContainer.appendChild(logElement);
        });
        
        // Update log count
        this.updateLogCount(filteredLogs.length, this.currentLogs.length);
    }
    
    getFilteredLogs() {
        return this.currentLogs.filter(log => {
            // Level filter
            if (this.filterLevel !== 'all' && log.level !== this.filterLevel) {
                return false;
            }
            
            // Text filter
            if (this.filterText) {
                const searchText = `${log.message} ${log.data ? JSON.stringify(log.data) : ''}`.toLowerCase();
                if (!searchText.includes(this.filterText)) {
                    return false;
                }
            }
            
            return true;
        });
    }
    
    applyFilters() {
        this.displayLogs();
    }
    
    createLogElement(log) {
        const logElement = document.createElement('div');
        logElement.className = `log-entry ${log.level}`;
        logElement.setAttribute('data-log-id', log.id);
        logElement.setAttribute('tabindex', '0');
        logElement.setAttribute('role', 'button');
        logElement.setAttribute('aria-expanded', 'false');
        logElement.setAttribute('aria-label', `Log entry: ${log.message}`);
        
        const timestamp = new Date(log.timestamp).toLocaleString();
        const levelClass = `log-level ${log.level}`;
        const isHistoryItem = log.source === 'history';
        
        // Create appropriate header based on item type
        let headerContent = '';
        if (isHistoryItem) {
            const operationType = log.data?.type || 'UNKNOWN';
            const successCount = log.data?.success || 0;
            const errorCount = log.data?.errors || 0;
            const skippedCount = log.data?.skipped || 0;
            
            headerContent = `
                <div class="log-info">
                    <span class="${levelClass}">${operationType.toUpperCase()}</span>
                    <span class="log-timestamp">${timestamp}</span>
                    <span class="operation-stats">
                        <span class="stat-success">âœ“ ${successCount}</span>
                        ${errorCount > 0 ? `<span class="stat-error">âœ— ${errorCount}</span>` : ''}
                        ${skippedCount > 0 ? `<span class="stat-skipped">- ${skippedCount}</span>` : ''}
                    </span>
                </div>
            `;
        } else {
            headerContent = `
                <div class="log-info">
                    <span class="${levelClass}">${log.level.toUpperCase()}</span>
                    <span class="log-timestamp">${timestamp}</span>
                </div>
            `;
        }
        
        logElement.innerHTML = `
            <div class="log-header">
                ${headerContent}
                <span class="log-expand-icon" aria-hidden="true">â–¶</span>
            </div>
            <div class="log-message">${this.escapeHtml(log.message)}</div>
            ${log.data ? `
                <div class="log-details" role="region" aria-label="Log details">
                    <div class="log-details-content">
                        ${isHistoryItem ? `
                            <div class="log-detail-section">
                                <h5>Operation Details:</h5>
                                <div class="history-details">
                                    <div><strong>Type:</strong> ${log.data.type}</div>
                                    ${log.data.fileName ? `<div><strong>File:</strong> ${log.data.fileName}</div>` : ''}
                                    ${log.data.population ? `<div><strong>Population:</strong> ${log.data.population}</div>` : ''}
                                    <div><strong>Results:</strong> ${log.data.success} successful, ${log.data.errors} errors, ${log.data.skipped} skipped</div>
                                    <div><strong>Total:</strong> ${log.data.total} items</div>
                                </div>
                            </div>
                        ` : `
                            <div class="log-detail-section">
                                <h5>Data:</h5>
                                <pre class="log-detail-json">${JSON.stringify(log.data, null, 2)}</pre>
                            </div>
                        `}
                        ${log.ip ? `
                            <div class="log-detail-section">
                                <h5>IP:</h5>
                                <span>${log.ip}</span>
                            </div>
                        ` : ''}
                        ${log.userAgent ? `
                            <div class="log-detail-section">
                                <h5>User Agent:</h5>
                                <span>${log.userAgent}</span>
                            </div>
                        ` : ''}
                    </div>
                </div>
            ` : ''}
        `;
        
        // Enhanced click handler for expand/collapse
        const handleToggle = (event) => {
            event.preventDefault();
            event.stopPropagation();
            
            const isExpanded = logElement.classList.contains('expanded');
            const expandIcon = logElement.querySelector('.log-expand-icon');
            const details = logElement.querySelector('.log-details');
            
            if (isExpanded) {
                // Collapse
                logElement.classList.remove('expanded');
                logElement.setAttribute('aria-expanded', 'false');
                if (expandIcon) {
                    expandIcon.textContent = 'â–¶';
                    expandIcon.setAttribute('aria-label', 'Expand log details');
                }
                if (details) {
                    details.style.display = 'none';
                }
            } else {
                // Expand
                logElement.classList.add('expanded');
                logElement.setAttribute('aria-expanded', 'true');
                if (expandIcon) {
                    expandIcon.textContent = 'â–¼';
                    expandIcon.setAttribute('aria-label', 'Collapse log details');
                }
                if (details) {
                    details.style.display = 'block';
                    // Smooth scroll into view if needed
                    setTimeout(() => {
                        if (details.getBoundingClientRect().bottom > window.innerHeight) {
                            details.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                        }
                    }, 100);
                }
            }
        };
        
        // Click handler
        logElement.addEventListener('click', handleToggle);
        
        // Keyboard accessibility
        logElement.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                handleToggle(event);
            }
        });
        
        // Focus management
        logElement.addEventListener('focus', () => {
            logElement.classList.add('focused');
        });
        
        logElement.addEventListener('blur', () => {
            logElement.classList.remove('focused');
        });
        
        return logElement;
    }
    
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    displayNoLogs() {
        if (!this.logsContainer) return;
        this.logsContainer.innerHTML = `
            <div class="no-logs-message">
                <i class="fas fa-info-circle"></i>
                <p>No logs found.</p>
                <small>Logs will appear here when operations are performed</small>
            </div>
        `;
    }
    
    displayError(message) {
        if (!this.logsContainer) return;
        
        this.logsContainer.innerHTML = `
            <div class="log-error-message">
                <i class="fas fa-exclamation-triangle"></i>
                <p>${this.escapeHtml(message)}</p>
                <button class="btn btn-secondary" onclick="window.logManager.loadLogs()">
                    <i class="fas fa-sync-alt"></i> Retry
                </button>
            </div>
        `;
    }
    
    updateLogCount(filtered, total) {
        const logsHeader = document.querySelector('.logs-header h1');
        if (logsHeader) {
            if (filtered === total) {
                logsHeader.textContent = `Logs (${total})`;
            } else {
                logsHeader.textContent = `Logs (${filtered}/${total})`;
            }
        }
    }
    
    scrollToBottom() {
        if (this.logsContainer) {
            this.logsContainer.scrollTop = this.logsContainer.scrollHeight;
        }
    }
    
    async clearLogs() {
        if (!confirm('Are you sure you want to clear all logs? This action cannot be undone.')) {
            return;
        }
        
        try {
            const response = await fetch('/api/logs/ui', {
                method: 'DELETE'
            });
            
            if (response.ok) {
                this.currentLogs = [];
                this.displayLogs();
                console.log('Logs cleared successfully');
            } else {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
        } catch (error) {
            console.error('Failed to clear logs:', error);
            alert('Failed to clear logs: ' + error.message);
        }
    }
    
    startAutoRefresh() {
        if (this.refreshInterval) {
            clearInterval(this.refreshInterval);
        }
        
        this.refreshInterval = setInterval(() => {
            if (this.isAutoRefresh) {
                this.loadLogs();
            }
        }, 5000); // Refresh every 5 seconds
    }
    
    stopAutoRefresh() {
        if (this.refreshInterval) {
            clearInterval(this.refreshInterval);
            this.refreshInterval = null;
        }
    }
    
    destroy() {
        this.stopAutoRefresh();
    }
}

// Initialize log manager when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.logManager = new LogManager();
});

// At the end of the file, expose LogManager as a global for browser use
if (typeof window !== 'undefined') {
  window.LogManager = LogManager;
} 


/* From: public/js/modules/logger.js */
/**
 * @fileoverview Winston-compatible logger for frontend environment
 * 
 * This module provides a Winston-like logging interface for the frontend
 * that maintains consistency with server-side Winston logging while
 * working within browser constraints.
 * 
 * Features:
 * - Winston-compatible API (info, warn, error, debug)
 * - Structured logging with metadata
 * - Timestamp formatting
 * - Log level filtering
 * - Console and server transport support
 * - Error stack trace handling
 * - Environment-aware configuration
 */

import { createWinstonLogger } from './winston-logger.js';
import messageFormatter from './message-formatter.js';
import { UIManager } from './ui-manager.js';
const ui = window.app && window.app.uiManager;

/**
 * Winston-compatible logger for browser environment
 */
class Logger {
    constructor(logElement = null) {
        // Handle different types of logElement parameters
        if (typeof logElement === 'string') {
            // If string provided, try to find DOM element or set to null for UI-less logging
            try {
                const element = document.getElementById(logElement) || document.querySelector(logElement);
                this.logElement = element;
                if (!element) {
                    console.debug(`[LOGGER] DOM element not found for '${logElement}', using UI-less logging`);
                }
            } catch (error) {
                console.debug(`[LOGGER] Error finding DOM element for '${logElement}':`, error.message);
                this.logElement = null;
            }
        } else if (logElement && logElement.nodeType === Node.ELEMENT_NODE) {
            // Valid DOM element
            this.logElement = logElement;
        } else if (logElement && typeof logElement === 'object' && logElement.length !== undefined) {
            // Handle NodeList/HTMLCollection - take first element
            this.logElement = logElement.length > 0 ? logElement[0] : null;
            if (logElement.length > 1) {
                console.debug(`[LOGGER] Multiple elements found, using first element`);
            }
        } else {
            // Null, undefined, or invalid - use UI-less logging
            this.logElement = null;
        }
        
        this.logs = [];
        this.validCount = 0;
        this.errorCount = 0;
        this.initialized = false;
        this.serverLoggingEnabled = true;
        this.isLoadingLogs = false;
        this.offlineLogs = [];
        
        // Initialize Winston-compatible logger
        this.winstonLogger = createWinstonLogger({
            service: 'pingone-import-frontend',
            environment: process.env.NODE_ENV || 'development',
            enableServerLogging: true,
            enableConsoleLogging: true
        });
        
        this.initialize();
    }
    
    /**
     * Initialize the logger
     */
    initialize() {
        try {
            this.winstonLogger.info('Logger initialized successfully');
            this.initialized = true;
        } catch (error) {
            console.error('Failed to initialize logger:', error);
        }
    }
    
    /**
     * Temporarily disable server logging to prevent feedback loops
     */
    disableServerLogging() {
        this.serverLoggingEnabled = false;
        this.winstonLogger.setServerLogging(false);
        this.winstonLogger.debug('Server logging disabled');
    }
    
    /**
     * Re-enable server logging
     */
    enableServerLogging() {
        this.serverLoggingEnabled = true;
        this.winstonLogger.setServerLogging(true);
        this.winstonLogger.debug('Server logging enabled');
    }
    
    /**
     * Set flag to indicate we're loading logs (prevents server logging)
     */
    setLoadingLogs(isLoading) {
        this.isLoadingLogs = isLoading;
        this.winstonLogger.debug(`Loading logs flag set to: ${isLoading}`);
    }
    
    /**
     * Create a safe file logger that handles initialization and errors
     * @private
     */
    _createSafeFileLogger() {
        const logger = {
            _initialized: false,
            _logger: null,
            _queue: [],
            _initializing: false,
            
            async init() {
                if (this._initialized || this._initializing) return;
                
                this._initializing = true;
                try {
                    // Initialize actual FileLogger for client.log
                    const { FileLogger } = await import('./file-logger.js');
                    this._logger = new FileLogger('client.log');
                    this._initialized = true;
                    this._processQueue();
                } catch (error) {
                    console.warn('Failed to initialize file logger, falling back to console:', error.message);
                    // Fallback to console logging
                    this._logger = {
                        log: (level, message, data) => {
                            console[level] || console.log(`[${level.toUpperCase()}] ${message}`, data);
                        }
                    };
                    this._initialized = true;
                    this._processQueue();
                } finally {
                    this._initializing = false;
                }
            },
            
            _processQueue() {
                while (this._queue.length > 0) {
                    const { level, message, data } = this._queue.shift();
                    if (this._logger && typeof this._logger.log === 'function') {
                        this._logger.log(level, message, data);
                    }
                }
            },
            
            log(level, message, data) {
                if (this._initialized && this._logger) {
                    this._logger.log(level, message, data);
                } else {
                    this._queue.push({ level, message, data });
                    if (!this._initializing) {
                        this.init();
                    }
                }
            }
        };
        
        return logger;
    }
    
    /**
     * Parse log arguments into structured format
     * @private
     */
    _parseLogArgs(args) {
        let message = 'Log message';
        let data = null;
        let context = null;

        if (args.length > 0) {
            if (typeof args[0] === 'string') {
                message = args[0];
                if (args.length > 1 && typeof args[1] === 'object') {
                    data = args[1];
                    if (args.length > 2 && typeof args[2] === 'object') {
                        context = args[2];
                    }
                }
            } else if (typeof args[0] === 'object') {
                data = args[0];
                message = 'Log data';
                if (args.length > 1 && typeof args[1] === 'object') {
                    context = args[1];
                }
            }
        }

        return [message, data, context];
    }
    
    /**
     * Main logging method with Winston integration
     */
    log(level, message, data = {}) {
        try {
            // Parse arguments if needed
            if (typeof level === 'string' && typeof message === 'string') {
                // Direct call: log(level, message, data)
                this._logToWinston(level, message, data);
            } else {
                // Legacy call: log(message, level)
                const [parsedMessage, parsedData, context] = this._parseLogArgs(arguments);
                this._logToWinston(level || 'info', parsedMessage, { ...parsedData, ...context });
            }
            
            // Update UI if log element exists
            this._updateLogUI({ level, message, data, timestamp: new Date() });
            
        } catch (error) {
            console.error('Error in logger.log:', error);
        }
    }
    
    /**
     * Log to Winston with proper formatting
     * @private
     */
    _logToWinston(level, message, data = {}) {
        const logData = {
            ...data,
            component: 'frontend-logger',
            timestamp: new Date().toISOString()
        };
        
        this.winstonLogger.log(level, message, logData);
    }
    
    /**
     * Log info level message
     */
    info(message, data = {}) {
        this.log('info', message, data);
    }
    
    /**
     * Log warn level message
     */
    warn(message, data = {}) {
        this.log('warn', message, data);
    }
    
    /**
     * Log error level message
     */
    error(message, data = {}) {
        this.log('error', message, data);
        if (ui) ui.showStatusBar(message, 'error', { autoDismiss: false });
        this.errorCount++;
        this.updateSummary();
    }
    
    /**
     * Log debug level message
     */
    debug(message, data = {}) {
        this.log('debug', message, data);
    }
    
    /**
     * Log success level message
     */
    success(message, data = {}) {
        this.log('info', message, { ...data, type: 'success' });
        this.validCount++;
        this.updateSummary();
    }
    
    /**
     * Log error with stack trace
     */
    errorWithStack(message, error, data = {}) {
        this.winstonLogger.errorWithStack(message, error, data);
        this.errorCount++;
        this.updateSummary();
    }
    
    /**
     * Update log UI with new entry
     * @private
     */
    _updateLogUI(logEntry) {
        if (!this.logElement) return;
        
        try {
            const logElement = document.createElement('div');
            logElement.className = `log-entry ${logEntry.level}`;
            
            // Create timestamp
            const timestamp = document.createElement('span');
            timestamp.className = 'log-timestamp';
            timestamp.textContent = new Date(logEntry.timestamp).toLocaleTimeString();
            logElement.appendChild(timestamp);
            
            // Create level badge
            const levelBadge = document.createElement('span');
            levelBadge.className = 'log-level';
            levelBadge.textContent = logEntry.level.toUpperCase();
            logElement.appendChild(levelBadge);
            
            // Create message with formatting
            const message = document.createElement('span');
            message.className = 'log-message';
            
            // Format the message for better readability
            let formattedMessage = logEntry.message;
            if (logEntry.data && logEntry.data.type) {
                // Format based on message type
                switch (logEntry.data.type) {
                    case 'progress':
                        formattedMessage = messageFormatter.formatProgressMessage(
                            logEntry.data.operation || 'import',
                            logEntry.data.current || 0,
                            logEntry.data.total || 0,
                            logEntry.message,
                            logEntry.data.counts || {}
                        );
                        break;
                    case 'error':
                        formattedMessage = messageFormatter.formatErrorMessage(
                            logEntry.data.operation || 'import',
                            logEntry.message,
                            logEntry.data
                        );
                        break;
                    case 'completion':
                        formattedMessage = messageFormatter.formatCompletionMessage(
                            logEntry.data.operation || 'import',
                            logEntry.data
                        );
                        break;
                    default:
                        // Use original message for other types
                        formattedMessage = logEntry.message;
                }
            }
            
            message.textContent = formattedMessage;
            logElement.appendChild(message);
            
            // Add details if present
            if (logEntry.data && Object.keys(logEntry.data).length > 0) {
                const detailsElement = document.createElement('div');
                detailsElement.className = 'log-details';
                
                const detailsTitle = document.createElement('h4');
                detailsTitle.textContent = 'Details';
                detailsElement.appendChild(detailsTitle);
                
                const detailsContent = document.createElement('pre');
                detailsContent.className = 'log-detail-json';
                detailsContent.textContent = JSON.stringify(logEntry.data, null, 2);
                detailsElement.appendChild(detailsContent);
                
                logElement.appendChild(detailsElement);
            }
            
            // Insert at top (newest first)
            if (this.logElement.firstChild) {
                this.logElement.insertBefore(logElement, this.logElement.firstChild);
            } else {
                this.logElement.appendChild(logElement);
            }
            
            // Auto-scroll to top
            this.logElement.scrollTop = 0;
            
            // Limit UI logs
            const maxUILogs = 100;
            while (this.logElement.children.length > maxUILogs) {
                this.logElement.removeChild(this.logElement.lastChild);
            }
            
        } catch (error) {
            console.error('Error updating log UI:', error);
        }
    }
    
    /**
     * Send log to server
     * @private
     */
    async _sendToServer(logEntry) {
        if (!this.serverLoggingEnabled || this.isLoadingLogs) {
            return;
        }
        
        try {
            await fetch('/api/logs/ui', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    level: logEntry.level,
                    message: logEntry.message,
                    data: logEntry.data
                })
            });
        } catch (error) {
            this.winstonLogger.warn('Failed to send log to server', { error: error.message });
            this.offlineLogs.push(logEntry);
        }
    }
    
    /**
     * Render all logs to UI
     */
    renderLogs() {
        if (!this.logElement) return;
        
        this.logElement.innerHTML = '';
        this.logs.forEach(log => this._updateLogUI(log));
        this.logElement.scrollTop = this.logElement.scrollHeight;
    }
    
    /**
     * Clear all logs
     */
    clearLogs() {
        this.logs = [];
        if (this.logElement) {
            this.logElement.innerHTML = '';
        }
        this.winstonLogger.info('Logs cleared');
    }
    
    /**
     * Get all logs
     */
    getLogs() {
        return [...this.logs];
    }
    
    /**
     * Update summary display
     */
    updateSummary() {
        // Implementation depends on UI structure
        this.winstonLogger.debug('Summary updated', { 
            validCount: this.validCount, 
            errorCount: this.errorCount 
        });
    }
    
    /**
     * Clear summary
     */
    clearSummary() {
        this.validCount = 0;
        this.errorCount = 0;
        this.winstonLogger.debug('Summary cleared');
    }
    
    /**
     * Start a performance timer
     */
    startTimer(label) {
        if (!this.timers) {
            this.timers = new Map();
        }
        this.timers.set(label, Date.now());
        this.debug(`Timer started: ${label}`);
    }
    
    /**
     * End a performance timer and log the duration
     */
    endTimer(label) {
        if (!this.timers || !this.timers.has(label)) {
            this.warn(`Timer '${label}' not found`);
            return 0;
        }
        
        const startTime = this.timers.get(label);
        const duration = Date.now() - startTime;
        this.timers.delete(label);
        
        this.info(`Timer completed: ${label}`, { duration: `${duration}ms` });
        return duration;
    }
    
    /**
     * Create a child logger with additional context
     * This is required for hierarchical logging in subsystems
     */
    child(options = {}) {
        console.log('ðŸ”¥ [LOGGER DEBUG] Creating child logger with options:', options);
        
        // Create a new logger instance that inherits from this one
        const childLogger = Object.create(this);
        
        // Add context from options
        childLogger.context = { ...this.context, ...options };
        
        // Override logging methods to include context
        const originalMethods = ['info', 'warn', 'error', 'debug'];
        originalMethods.forEach(method => {
            const originalMethod = this[method].bind(this);
            childLogger[method] = (message, data = {}) => {
                const contextualData = { ...childLogger.context, ...data };
                return originalMethod(message, contextualData);
            };
        });
        
        console.log('ðŸ”¥ [LOGGER DEBUG] Child logger created successfully');
        return childLogger;
    }
}

// Export the Logger class
export { Logger };



/* From: public/js/modules/logging-subsystem.js */
/**
 * Logging Subsystem
 * Centralized logging system that replaces legacy window.logManager
 * Provides structured logging with levels, categories, and event integration
 */

import { createWinstonLogger } from './winston-logger.js';

export class LoggingSubsystem {
    constructor(eventBus, settingsSubsystem) {
        this.eventBus = eventBus;
        this.settingsSubsystem = settingsSubsystem;
        
        // Initialize Winston logger
        this.logger = createWinstonLogger({
            service: 'logging-subsystem',
            environment: process.env.NODE_ENV || 'development'
        });
        
        // Log storage for UI display
        this.logHistory = [];
        this.maxHistorySize = 1000;
        
        // Log levels
        this.levels = {
            ERROR: 0,
            WARN: 1,
            INFO: 2,
            DEBUG: 3,
            TRACE: 4
        };
        
        // Current log level (configurable)
        this.currentLevel = this.levels.INFO;
        
        // Log categories for filtering
        this.categories = {
            SYSTEM: 'system',
            AUTH: 'auth',
            IMPORT: 'import',
            EXPORT: 'export',
            DELETE: 'delete',
            MODIFY: 'modify',
            UI: 'ui',
            API: 'api',
            ERROR: 'error'
        };
        
        // Initialize subsystem
        this.init();
        
        this.logger.info('LoggingSubsystem initialized successfully');
    }
    
    /**
     * Initialize the logging subsystem
     */
    async init() {
        try {
            // Load logging settings
            await this.loadSettings();
            
            // Set up event listeners
            this.setupEventListeners();
            
            // Replace global logManager if it exists
            this.replaceGlobalLogManager();
            
            this.logger.info('LoggingSubsystem initialization complete');
        } catch (error) {
            this.logger.error('Failed to initialize LoggingSubsystem', error);
            throw error;
        }
    }
    
    /**
     * Load logging settings from SettingsSubsystem
     */
    async loadSettings() {
        try {
            if (this.settingsSubsystem) {
                await this.settingsSubsystem.loadCurrentSettings();
                const settings = this.settingsSubsystem.currentSettings;
                
                // Set log level from settings
                if (settings.logLevel) {
                    this.setLogLevel(settings.logLevel);
                }
                
                // Set max history size from settings
                if (settings.maxLogHistory) {
                    this.maxHistorySize = settings.maxLogHistory;
                }
            }
        } catch (error) {
            this.logger.warn('Could not load logging settings, using defaults', error);
        }
    }
    
    /**
     * Set up event listeners for cross-subsystem communication
     */
    setupEventListeners() {
        if (this.eventBus) {
            // Listen for log level changes
            this.eventBus.on('loggingLevelChanged', (data) => {
                this.setLogLevel(data.level);
            });
            
            // Listen for log clear requests
            this.eventBus.on('clearLogs', () => {
                this.clearLogs();
            });
            
            // Listen for log export requests
            this.eventBus.on('exportLogs', (data) => {
                this.exportLogs(data.options);
            });
        }
    }
    
    /**
     * Replace global window.logManager with this subsystem
     */
    replaceGlobalLogManager() {
        // Create a compatibility layer for legacy code
        window.logManager = {
            log: (level, message, data) => this.log(level, message, data),
            error: (message, data) => this.error(message, data),
            warn: (message, data) => this.warn(message, data),
            info: (message, data) => this.info(message, data),
            debug: (message, data) => this.debug(message, data),
            loadLogs: () => this.loadLogs(),
            clearLogs: () => this.clearLogs(),
            exportLogs: (options) => this.exportLogs(options),
            // Legacy compatibility
            getLogger: (name) => this.getLogger(name)
        };
        
        this.logger.info('Global logManager replaced with LoggingSubsystem compatibility layer');
    }
    
    /**
     * Main logging method
     */
    log(level, message, data = {}, category = this.categories.SYSTEM) {
        const levelValue = typeof level === 'string' ? 
            this.levels[level.toUpperCase()] : level;
        
        // Check if log level is enabled
        if (levelValue > this.currentLevel) {
            return;
        }
        
        const logEntry = {
            timestamp: new Date().toISOString(),
            level: level.toLowerCase(),
            message,
            data: this.sanitizeLogData(data),
            category,
            sessionId: this.generateSessionId()
        };
        
        // Add to history
        this.addToHistory(logEntry);
        
        // Log to Winston
        this.logger[level.toLowerCase()](message, {
            data: logEntry.data,
            category,
            sessionId: logEntry.sessionId
        });
        
        // Emit log event for UI updates
        if (this.eventBus) {
            this.eventBus.emit('logEntry', logEntry);
        }
        
        // Console output for development
        if (process.env.NODE_ENV === 'development') {
            this.consoleLog(logEntry);
        }
    }
    
    /**
     * Error logging
     */
    error(message, data = {}, category = this.categories.ERROR) {
        this.log('ERROR', message, data, category);
    }
    
    /**
     * Warning logging
     */
    warn(message, data = {}, category = this.categories.SYSTEM) {
        this.log('WARN', message, data, category);
    }
    
    /**
     * Info logging
     */
    info(message, data = {}, category = this.categories.SYSTEM) {
        this.log('INFO', message, data, category);
    }
    
    /**
     * Debug logging
     */
    debug(message, data = {}, category = this.categories.SYSTEM) {
        this.log('DEBUG', message, data, category);
    }
    
    /**
     * Trace logging
     */
    trace(message, data = {}, category = this.categories.SYSTEM) {
        this.log('TRACE', message, data, category);
    }
    
    /**
     * Get a logger instance for a specific component
     */
    getLogger(name) {
        return {
            error: (message, data) => this.error(`[${name}] ${message}`, data),
            warn: (message, data) => this.warn(`[${name}] ${message}`, data),
            info: (message, data) => this.info(`[${name}] ${message}`, data),
            debug: (message, data) => this.debug(`[${name}] ${message}`, data),
            trace: (message, data) => this.trace(`[${name}] ${message}`, data)
        };
    }
    
    /**
     * Set the current log level
     */
    setLogLevel(level) {
        if (typeof level === 'string') {
            this.currentLevel = this.levels[level.toUpperCase()] || this.levels.INFO;
        } else {
            this.currentLevel = level;
        }
        
        this.logger.info('Log level changed', { newLevel: this.currentLevel });
        
        // Emit event for UI updates
        if (this.eventBus) {
            this.eventBus.emit('logLevelChanged', { level: this.currentLevel });
        }
    }
    
    /**
     * Add log entry to history
     */
    addToHistory(logEntry) {
        this.logHistory.unshift(logEntry);
        
        // Maintain history size limit
        if (this.logHistory.length > this.maxHistorySize) {
            this.logHistory = this.logHistory.slice(0, this.maxHistorySize);
        }
    }
    
    /**
     * Load logs for UI display
     */
    async loadLogs(options = {}) {
        try {
            const {
                limit = 100,
                offset = 0,
                level = null,
                category = null,
                search = null,
                startDate = null,
                endDate = null
            } = options;
            
            let filteredLogs = [...this.logHistory];
            
            // Apply filters
            if (level) {
                filteredLogs = filteredLogs.filter(log => log.level === level.toLowerCase());
            }
            
            if (category) {
                filteredLogs = filteredLogs.filter(log => log.category === category);
            }
            
            if (search) {
                const searchLower = search.toLowerCase();
                filteredLogs = filteredLogs.filter(log => 
                    log.message.toLowerCase().includes(searchLower) ||
                    JSON.stringify(log.data).toLowerCase().includes(searchLower)
                );
            }
            
            if (startDate) {
                filteredLogs = filteredLogs.filter(log => 
                    new Date(log.timestamp) >= new Date(startDate)
                );
            }
            
            if (endDate) {
                filteredLogs = filteredLogs.filter(log => 
                    new Date(log.timestamp) <= new Date(endDate)
                );
            }
            
            // Apply pagination
            const paginatedLogs = filteredLogs.slice(offset, offset + limit);
            
            const result = {
                logs: paginatedLogs,
                total: filteredLogs.length,
                hasMore: offset + limit < filteredLogs.length
            };
            
            this.logger.debug('Logs loaded', {
                requested: limit,
                returned: paginatedLogs.length,
                total: result.total
            });
            
            return result;
            
        } catch (error) {
            this.logger.error('Failed to load logs', error);
            throw error;
        }
    }
    
    /**
     * Clear all logs
     */
    clearLogs() {
        const previousCount = this.logHistory.length;
        this.logHistory = [];
        
        this.logger.info('Logs cleared', { previousCount });
        
        // Emit event for UI updates
        if (this.eventBus) {
            this.eventBus.emit('logsCleared', { previousCount });
        }
    }
    
    /**
     * Export logs to file
     */
    async exportLogs(options = {}) {
        try {
            const {
                format = 'json',
                filename = `logs_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}`
            } = options;
            
            const logs = await this.loadLogs({ limit: this.maxHistorySize });
            
            let content;
            let mimeType;
            let extension;
            
            switch (format.toLowerCase()) {
                case 'csv':
                    content = this.convertLogsToCSV(logs.logs);
                    mimeType = 'text/csv';
                    extension = 'csv';
                    break;
                case 'txt':
                    content = this.convertLogsToText(logs.logs);
                    mimeType = 'text/plain';
                    extension = 'txt';
                    break;
                case 'json':
                default:
                    content = JSON.stringify(logs.logs, null, 2);
                    mimeType = 'application/json';
                    extension = 'json';
                    break;
            }
            
            // Create and download file
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${filename}.${extension}`;
            link.style.display = 'none';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            this.logger.info('Logs exported successfully', {
                format,
                filename: `${filename}.${extension}`,
                logCount: logs.logs.length
            });
            
        } catch (error) {
            this.logger.error('Failed to export logs', error);
            throw error;
        }
    }
    
    /**
     * Convert logs to CSV format
     */
    convertLogsToCSV(logs) {
        const headers = ['Timestamp', 'Level', 'Category', 'Message', 'Data'];
        const csvRows = [headers.join(',')];
        
        logs.forEach(log => {
            const row = [
                log.timestamp,
                log.level,
                log.category,
                `"${log.message.replace(/"/g, '""')}"`,
                `"${JSON.stringify(log.data).replace(/"/g, '""')}"`
            ];
            csvRows.push(row.join(','));
        });
        
        return csvRows.join('\n');
    }
    
    /**
     * Convert logs to text format
     */
    convertLogsToText(logs) {
        return logs.map(log => {
            const dataStr = Object.keys(log.data).length > 0 ? 
                ` | Data: ${JSON.stringify(log.data)}` : '';
            return `[${log.timestamp}] ${log.level.toUpperCase()} [${log.category}] ${log.message}${dataStr}`;
        }).join('\n');
    }
    
    /**
     * Console logging for development
     */
    consoleLog(logEntry) {
        const { level, message, data, category, timestamp } = logEntry;
        const prefix = `[${timestamp}] [${category}]`;
        
        switch (level) {
            case 'error':
                console.error(prefix, message, data);
                break;
            case 'warn':
                console.warn(prefix, message, data);
                break;
            case 'debug':
                console.debug(prefix, message, data);
                break;
            case 'trace':
                console.trace(prefix, message, data);
                break;
            default:
                console.log(prefix, message, data);
        }
    }
    
    /**
     * Sanitize log data to prevent circular references and sensitive data
     */
    sanitizeLogData(data) {
        if (!data || typeof data !== 'object') {
            return data;
        }
        
        try {
            // Create a deep copy and remove sensitive fields
            const sanitized = JSON.parse(JSON.stringify(data, (key, value) => {
                // Remove sensitive fields
                const sensitiveFields = ['password', 'token', 'secret', 'key', 'apiKey', 'clientSecret'];
                if (sensitiveFields.some(field => key.toLowerCase().includes(field))) {
                    return '[REDACTED]';
                }
                
                // Handle circular references
                if (typeof value === 'object' && value !== null) {
                    if (value.constructor && value.constructor.name === 'HTMLElement') {
                        return '[HTMLElement]';
                    }
                    if (value instanceof Error) {
                        return {
                            name: value.name,
                            message: value.message,
                            stack: value.stack
                        };
                    }
                }
                
                return value;
            }));
            
            return sanitized;
        } catch (error) {
            return { error: 'Failed to sanitize log data', original: String(data) };
        }
    }
    
    /**
     * Generate session ID for log tracking
     */
    generateSessionId() {
        return `log_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    /**
     * Get logging statistics
     */
    getStats() {
        const stats = {
            totalLogs: this.logHistory.length,
            levelCounts: {},
            categoryCounts: {},
            recentActivity: this.logHistory.slice(0, 10)
        };
        
        // Count by level
        this.logHistory.forEach(log => {
            stats.levelCounts[log.level] = (stats.levelCounts[log.level] || 0) + 1;
            stats.categoryCounts[log.category] = (stats.categoryCounts[log.category] || 0) + 1;
        });
        
        return stats;
    }
}

// Export for use in other modules
export default LoggingSubsystem;



/* From: public/js/modules/winston-logger.js */
/**
 * @fileoverview Winston-compatible logger for frontend/browser environment
 * 
 * This module provides a Winston-like logging interface for the frontend
 * that maintains consistency with server-side Winston logging while
 * working within browser constraints.
 * 
 * Features:
 * - Winston-compatible API (info, warn, error, debug)
 * - Structured logging with metadata
 * - Timestamp formatting
 * - Log level filtering
 * - Console and server transport support
 * - Error stack trace handling
 * - Environment-aware configuration
 */

/**
 * Winston-compatible logger for browser environment
 */
class WinstonLogger {
    constructor(options = {}) {
        this.level = options.level || this.getDefaultLevel();
        this.service = options.service || 'pingone-import-frontend';
        this.environment = options.environment || (process.env.NODE_ENV || 'development');
        this.enableServerLogging = options.enableServerLogging !== false;
        this.enableConsoleLogging = options.enableConsoleLogging !== false;
        
        // Log level hierarchy
        this.levels = {
            error: 0,
            warn: 1,
            info: 2,
            debug: 3
        };
        
        // Initialize transports
        this.transports = [];
        this.initializeTransports();
    }
    
    /**
     * Get default log level based on environment
     */
    getDefaultLevel() {
        if (this.environment === 'production') {
            return 'info';
        } else if (this.environment === 'test') {
            return 'warn';
        } else {
            return 'debug';
        }
    }
    
    /**
     * Initialize logging transports
     */
    initializeTransports() {
        // Console transport
        if (this.enableConsoleLogging) {
            this.transports.push({
                name: 'console',
                log: (level, message, meta) => this.logToConsole(level, message, meta)
            });
        }
        
        // Server transport (if enabled)
        if (this.enableServerLogging) {
            this.transports.push({
                name: 'server',
                log: (level, message, meta) => this.logToServer(level, message, meta)
            });
        }
    }
    
    /**
     * Check if a log level should be logged
     */
    shouldLog(level) {
        return this.levels[level] <= this.levels[this.level];
    }
    
    /**
     * Format timestamp
     */
    formatTimestamp() {
        return new Date().toISOString();
    }
    
    /**
     * Format log entry
     */
    formatLogEntry(level, message, meta = {}) {
        const timestamp = this.formatTimestamp();
        
        return {
            timestamp,
            level,
            message,
            service: this.service,
            environment: this.environment,
            ...meta
        };
    }
    
    /**
     * Log to console with Winston-like formatting
     */
    logToConsole(level, message, meta = {}) {
        if (!this.shouldLog(level)) return;
        
        const logEntry = this.formatLogEntry(level, message, meta);
        const timestamp = logEntry.timestamp;
        const levelUpper = level.toUpperCase();
        
        // Create formatted console message
        let consoleMessage = `[${timestamp}] [${this.service}] ${levelUpper}: ${message}`;
        
        // Add metadata if present
        if (Object.keys(meta).length > 0) {
            consoleMessage += `\n${JSON.stringify(meta, null, 2)}`;
        }
        
        // Use appropriate console method
        switch (level) {
            case 'error':
                console.error(consoleMessage);
                break;
            case 'warn':
                console.warn(consoleMessage);
                break;
            case 'info':
                console.info(consoleMessage);
                break;
            case 'debug':
                console.debug(consoleMessage);
                break;
            default:
                console.log(consoleMessage);
        }
    }
    
    /**
     * Log to server via API endpoint
     */
    async logToServer(level, message, meta = {}) {
        if (!this.shouldLog(level)) return;
        
        try {
            // Format the request body according to the API expectations
            const requestBody = {
                message,
                level,
                data: meta,
                source: 'frontend'
            };
            
            // Send to server logging endpoint
            await fetch('/api/logs/ui', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            });
        } catch (error) {
            // Handle connection refused errors silently during startup
            if (error.message.includes('Failed to fetch') || error.message.includes('ERR_CONNECTION_REFUSED')) {
                // Don't log connection refused errors to avoid console spam during startup
                return;
            }
            // Fallback to console if server logging fails
            console.warn('Server logging failed, falling back to console:', error.message);
            this.logToConsole(level, message, meta);
        }
    }
    
    /**
     * Main logging method
     */
    log(level, message, meta = {}) {
        if (!this.shouldLog(level)) return;
        
        // Send to all transports
        this.transports.forEach(transport => {
            try {
                transport.log(level, message, meta);
            } catch (error) {
                console.error(`Error in ${transport.name} transport:`, error);
            }
        });
    }
    
    /**
     * Log info level message
     */
    info(message, meta = {}) {
        this.log('info', message, meta);
    }
    
    /**
     * Log warn level message
     */
    warn(message, meta = {}) {
        this.log('warn', message, meta);
    }
    
    /**
     * Log error level message
     */
    error(message, meta = {}) {
        this.log('error', message, meta);
    }
    
    /**
     * Log debug level message
     */
    debug(message, meta = {}) {
        this.log('debug', message, meta);
    }
    
    /**
     * Log error with stack trace
     */
    errorWithStack(message, error, meta = {}) {
        const errorMeta = {
            ...meta,
            error: {
                message: error.message,
                stack: error.stack,
                code: error.code,
                name: error.name
            }
        };
        
        this.error(message, errorMeta);
    }
    
    /**
     * Create child logger with additional metadata
     */
    child(additionalMeta = {}) {
        const childLogger = new WinstonLogger({
            level: this.level,
            service: this.service,
            environment: this.environment,
            enableServerLogging: this.enableServerLogging,
            enableConsoleLogging: this.enableConsoleLogging
        });
        
        // Override formatLogEntry to include additional metadata
        childLogger.formatLogEntry = (level, message, meta = {}) => {
            const baseEntry = this.formatLogEntry(level, message, meta);
            return {
                ...baseEntry,
                ...additionalMeta
            };
        };
        
        return childLogger;
    }
    
    /**
     * Set log level
     */
    setLevel(level) {
        if (this.levels.hasOwnProperty(level)) {
            this.level = level;
        } else {
            this.warn(`Invalid log level: ${level}`);
        }
    }
    
    /**
     * Enable/disable server logging
     */
    setServerLogging(enabled) {
        this.enableServerLogging = enabled;
        
        // Update transports
        this.transports = this.transports.filter(t => t.name !== 'server');
        if (enabled) {
            this.transports.push({
                name: 'server',
                log: (level, message, meta) => this.logToServer(level, message, meta)
            });
        }
    }
    
    /**
     * Enable/disable console logging
     */
    setConsoleLogging(enabled) {
        this.enableConsoleLogging = enabled;
        
        // Update transports
        this.transports = this.transports.filter(t => t.name !== 'console');
        if (enabled) {
            this.transports.push({
                name: 'console',
                log: (level, message, meta) => this.logToConsole(level, message, meta)
            });
        }
    }
}

/**
 * Create default logger instance
 */
export function createWinstonLogger(options = {}) {
    return new WinstonLogger(options);
}

/**
 * Create component-specific logger
 */
export function createComponentLogger(component, options = {}) {
    return createWinstonLogger({
        ...options,
        service: `${options.service || 'pingone-import'}-${component}`
    });
}

/**
 * Default logger instances
 */
export const defaultLogger = createWinstonLogger();
export const apiLogger = createComponentLogger('api');
export const uiLogger = createComponentLogger('ui');
export const fileLogger = createComponentLogger('file');
export const settingsLogger = createComponentLogger('settings');
export const tokenLogger = createComponentLogger('token');

// Export the class for custom instances
export { WinstonLogger }; 


/* From: public/js/modules/file-logger.js */
/**
 * FileLogger - Handles writing logs to a client.log file using the File System Access API
 */
class FileLogger {
    /**
     * Create a new FileLogger instance
     * @param {string} filename - Name of the log file (default: 'client.log')
     */
    constructor(filename = 'client.log') {
        this.filename = filename;
        this.fileHandle = null;
        this.writableStream = null;
        this.initialized = false;
        this.logQueue = [];
        this.initializationPromise = null;
    }
    
    /**
     * Initialize the file logger
     * @private
     */
    async _initialize() {
        if (this.initialized) return true;
        if (this.initializationPromise) {
            return this.initializationPromise;
        }
        
        this.initializationPromise = (async () => {
            try {
                // Check if we're in a secure context and the API is available
                if (!window.isSecureContext || !window.showSaveFilePicker) {
                    throw new Error('File System Access API not available in this context');
                }
                
                // Only proceed if we're handling a user gesture
                if (!window.__fileLoggerUserGesture) {
                    // Set up event listeners
                    window.addEventListener('online', () => this.handleOnline());
                    window.addEventListener('offline', () => this.handleOffline());
                    
                    // Set up user gesture detection for file logger
                    const handleUserGesture = () => {
                        window.__fileLoggerUserGesture = true;
                        window.removeEventListener('click', handleUserGesture);
                        window.removeEventListener('keydown', handleUserGesture);
                        
                        // Try to initialize the file logger if it hasn't been initialized yet
                        if (this.fileLogger && !this.fileLogger._initialized && this.fileLogger._logger === null) {
                            this.fileLogger._ensureInitialized().catch(console.warn);
                        }
                    };
                    
                    window.addEventListener('click', handleUserGesture, { once: true, passive: true });
                    window.addEventListener('keydown', handleUserGesture, { once: true, passive: true });
                    throw new Error('Waiting for user gesture to initialize file logger');
                }
                
                try {
                    this.fileHandle = await window.showSaveFilePicker({
                        suggestedName: this.filename,
                        types: [{
                            description: 'Log File',
                            accept: { 'text/plain': ['.log'] },
                        }],
                        excludeAcceptAllOption: true
                    });
                    
                    this.writableStream = await this.fileHandle.createWritable({ keepExistingData: true });
                    this.initialized = true;
                    await this._processQueue();
                    return true;
                } catch (error) {
                    console.warn('File System Access API not available:', error);
                    this.initialized = false;
                    return false;
                }
            } catch (error) {
                console.warn('File logger initialization deferred:', error.message);
                this.initialized = false;
                return false;
            }
        })();
        
        return this.initializationPromise;
    }
    
    /**
     * Process any queued log messages
     * @private
     */
    async _processQueue() {
        if (this.logQueue.length === 0) return;
        
        const queue = [...this.logQueue];
        this.logQueue = [];
        
        for (const { level, message, timestamp } of queue) {
            await this._writeLog(level, message, timestamp);
        }
    }
    
    /**
     * Write a log message to the file
     * @private
     */
    async _writeLog(level, message, timestamp) {
        if (!this.initialized) {
            await this._initialize();
        }
        
        const logEntry = `[${timestamp}] [${level.toUpperCase()}] ${message}\n`;
        
        if (this.writableStream) {
            try {
                await this.writableStream.write(logEntry);
            } catch (error) {
                console.error('Error writing to log file:', error);
                this.initialized = false;
                await this._initialize();
                await this.writableStream.write(logEntry);
            }
        } else {
            console[level](`[FileLogger] ${logEntry}`);
        }
    }
    
    /**
     * Log a message
     * @param {string} level - Log level (info, warn, error, debug)
     * @param {string} message - The message to log
     */
    async log(level, message) {
        const timestamp = new Date().toISOString();
        
        if (!this.initialized) {
            this.logQueue.push({ level, message, timestamp });
            await this._initialize();
        } else {
            await this._writeLog(level, message, timestamp);
        }
    }
    
    /**
     * Log an info message
     * @param {string} message - The message to log
     */
    info(message) {
        return this.log('info', message);
    }
    
    /**
     * Log a warning message
     * @param {string} message - The message to log
     */
    warn(message) {
        return this.log('warn', message);
    }
    
    /**
     * Log an error message
     * @param {string} message - The message to log
     */
    error(message) {
        return this.log('error', message);
    }
    
    /**
     * Log a debug message
     * @param {string} message - The message to log
     */
    debug(message) {
        return this.log('debug', message);
    }
    
    /**
     * Close the log file
     */
    async close() {
        if (this.writableStream) {
            try {
                await this.writableStream.close();
            } catch (error) {
                console.error('Error closing log file:', error);
            } finally {
                this.initialized = false;
                this.writableStream = null;
                this.fileHandle = null;
            }
        }
    }
}

export { FileLogger };


