/**
 * Settings management Module
 * 
 * Consolidated JavaScript for PingOne Import Tool
 * Generated: 2025-08-06T19:08:20.704Z
 * 
 * This file was automatically generated by js-final-cleanup.js
 * Organized for better maintainability and performance
 */


/* From: public/js/modules/settings-manager.js */
/**
 * @fileoverview Settings Manager Class
 * 
 * Manages application settings with secure storage and encryption.
 * Handles API credentials, user preferences, and configuration data
 * with automatic encryption for sensitive information.
 * 
 * @param {Object} logger - Winston logger instance for debugging
 */
import { createWinstonLogger } from './winston-logger.js';
import { CryptoUtils } from './crypto-utils.js';

class SettingsManager {
    /**
     * Create a new SettingsManager instance
     * @param {Object} logger - Winston logger instance for debugging
     */
    constructor(logger = null) {
        // Initialize settings with default values
        this.settings = this.getDefaultSettings();
        this.storageKey = 'pingone-import-settings';
        this.encryptionKey = null;
        
        // Initialize Winston logger for debugging and error reporting
        this.initializeLogger(logger);
        
        // Encryption will be initialized in the init method
        this.encryptionInitialized = false;
    }
    
    /**
     * Initialize the settings manager
     * @returns {Promise<void>}
     */
    async init() {
        try {
            await this.initializeEncryption();
            this.encryptionInitialized = true;
            this.logger.info('Settings manager initialized successfully');
        } catch (error) {
            this.logger.error('Failed to initialize settings manager', { error: error.message });
            throw error;
        }
    }
    
    /**
     * Initialize Winston logger
     * @param {Object} logger - Logger instance
     */
    initializeLogger(logger) {
        if (logger && typeof logger.child === 'function') {
            this.logger = logger.child({ component: 'settings-manager' });
        } else {
            this.logger = createWinstonLogger({
                service: 'pingone-import-settings',
                environment: process.env.NODE_ENV || 'development'
            });
        }
    }
    
    /**
     * Create a default console logger if none provided
     * @returns {Object} Default logger object
     */
    createDefaultLogger() {
        return {
            log: (msg, level = 'info') => this.logger.log(level, `[Settings] ${msg}`),
            info: (msg) => this.logger.info(`[Settings] ${msg}`),
            warn: (msg) => this.logger.warn(`[Settings] ${msg}`),
            error: (msg) => this.logger.error(`[Settings] ${msg}`),
            debug: (msg) => this.logger.debug(`[Settings] ${msg}`)
        };
    }
    
    /**
     * Get region info by code
     * @param {string} code - Region code (e.g., 'NA', 'CA', 'EU', 'AU', 'SG', 'AP')
     * @returns {{code: string, tld: string, label: string}} Region information
     */
    static getRegionInfo(code) {
        if (!code) {
            return { code: 'NA', tld: 'com', label: 'North America (excluding Canada)' };
        }
        
        const regions = {
            NA: { code: 'NA', tld: 'com', label: 'North America (excluding Canada)' },
            CA: { code: 'CA', tld: 'ca', label: 'Canada' },
            EU: { code: 'EU', tld: 'eu', label: 'European Union' },
            AU: { code: 'AU', tld: 'com.au', label: 'Australia' },
            SG: { code: 'SG', tld: 'sg', label: 'Singapore' },
            AP: { code: 'AP', tld: 'asia', label: 'Asia-Pacific' }
        };
        return regions[code] || regions['NA'];
    }

    /**
     * Get default settings
     * @returns {Object} Default settings object
     */
    getDefaultSettings() {
        return {
            environmentId: '',
            region: 'NA',
            apiClientId: '',
            populationId: '',
            rateLimit: 50,
            connectionStatus: 'disconnected',
            connectionMessage: 'Not connected',
            lastConnectionTest: null,
            autoSave: true,
            lastUsedDirectory: '',
            theme: 'light',
            pageSize: 50,
            showNotifications: true
        };
    }
    
    /**
     * Normalize field names to support both camelCase and kebab-case formats
     * @param {Object} settings - Settings object to normalize
     * @returns {Object} Normalized settings
     */
    normalizeSettingsFields(settings) {
        if (!settings || typeof settings !== 'object') {
            return settings;
        }
        
        const normalized = { ...settings };
        
        // Map kebab-case to camelCase for compatibility
        const fieldMappings = {
            'environment-id': 'environmentId',
            'api-client-id': 'apiClientId',
            'client-id': 'apiClientId',  // Alternative mapping
            'api-secret': 'apiSecret',
            'client-secret': 'apiSecret',  // Alternative mapping
            'population-id': 'populationId',
            'rate-limit': 'rateLimit'
        };
        
        // Convert kebab-case fields to camelCase
        for (const [kebabKey, camelKey] of Object.entries(fieldMappings)) {
            if (kebabKey in normalized) {
                normalized[camelKey] = normalized[kebabKey];
                delete normalized[kebabKey];
                this.logger.debug(`Normalized field: ${kebabKey} -> ${camelKey}`);
            }
        }
        
        // Also handle alternative camelCase variations
        if (normalized.clientId && !normalized.apiClientId) {
            normalized.apiClientId = normalized.clientId;
            delete normalized.clientId;
            this.logger.debug('Normalized field: clientId -> apiClientId');
        }
        
        if (normalized.clientSecret && !normalized.apiSecret) {
            normalized.apiSecret = normalized.clientSecret;
            delete normalized.clientSecret;
            this.logger.debug('Normalized field: clientSecret -> apiSecret');
        }
        
        return normalized;
    }

    /**
     * Normalize all settings to PINGONE_*_* pattern
     * @param {Object} settings - Raw settings object
     * @returns {Object} Normalized settings
     */
    static normalizeToPingOnePattern(settings) {
        if (!settings || typeof settings !== 'object') return settings;
        const normalized = { ...settings };
        // Map frontend keys to PINGONE_*_* keys
        if (normalized.environmentId) normalized.PINGONE_ENVIRONMENT_ID = normalized.environmentId;
        if (normalized.apiClientId) normalized.PINGONE_CLIENT_ID = normalized.apiClientId;
        if (normalized.apiSecret) normalized.PINGONE_CLIENT_SECRET = normalized.apiSecret;
        if (normalized.region) normalized.PINGONE_REGION = normalized.region;
        // Remove old keys
        delete normalized.environmentId;
        delete normalized.apiClientId;
        delete normalized.apiSecret;
        delete normalized.region;
        return normalized;
    }

    /**
     * Map PINGONE_*_* fields to frontend keys (for legacy compatibility)
     * @param {Object} settings - Raw settings object
     * @returns {Object} Mapped settings
     */
    static mapPingOnePatternToFrontend(settings) {
        if (!settings || typeof settings !== 'object') return settings;
        const mapped = { ...settings };
        if (mapped.PINGONE_ENVIRONMENT_ID) mapped.environmentId = mapped.PINGONE_ENVIRONMENT_ID;
        if (mapped.PINGONE_CLIENT_ID) mapped.apiClientId = mapped.PINGONE_CLIENT_ID;
        if (mapped.PINGONE_CLIENT_SECRET) mapped.apiSecret = mapped.PINGONE_CLIENT_SECRET;
        if (mapped.PINGONE_REGION) mapped.region = mapped.PINGONE_REGION;
        return mapped;
    }

    /**
     * Load settings from storage and .env/settings.json
     * @returns {Promise<Object>} Loaded settings
     */
    async loadSettings() {
        try {
            const storedData = localStorage.getItem(this.storageKey);
            let rawSettings = storedData ? JSON.parse(storedData) : {};
            // Also try to load from window.env or window.settingsJson if present
            if (window.env) {
                rawSettings = { ...rawSettings, ...window.env };
            }
            if (window.settingsJson) {
                rawSettings = { ...rawSettings, ...window.settingsJson };
            }
            // Normalize to PINGONE_*_* pattern
            const pingoneSettings = SettingsManager.normalizeToPingOnePattern(rawSettings);
            // Map to frontend keys for compatibility
            const mappedSettings = SettingsManager.mapPingOnePatternToFrontend(pingoneSettings);
            const normalizedSettings = this.normalizeSettingsFields(mappedSettings);
            this.settings = { ...this.getDefaultSettings(), ...normalizedSettings };
            this.logger.info('Settings loaded and normalized:', this.settings);
            // Diagnostics: warn if required fields are missing
            if (!this.settings.PINGONE_ENVIRONMENT_ID || !this.settings.PINGONE_CLIENT_ID || !this.settings.PINGONE_CLIENT_SECRET) {
                this.logger.warn('Missing required PingOne settings:', {
                    PINGONE_ENVIRONMENT_ID: this.settings.PINGONE_ENVIRONMENT_ID,
                    PINGONE_CLIENT_ID: this.settings.PINGONE_CLIENT_ID,
                    PINGONE_CLIENT_SECRET: !!this.settings.PINGONE_CLIENT_SECRET,
                    PINGONE_REGION: this.settings.PINGONE_REGION
                });
            }
            return this.settings;
        } catch (error) {
            this.logger.error('Failed to load settings:', error.message);
            return this.getDefaultSettings();
        }
    }
    
    /**
     * Save settings to storage
     * @param {Object} settings - Settings to save (optional)
     * @returns {Promise<void>}
     */
    async saveSettings(settings = null) {
        try {
            if (settings) {
                this.settings = { ...this.settings, ...settings };
            }

            const jsonData = JSON.stringify(this.settings);

            if (!this.encryptionInitialized) {
                this.logger.warn('Encryption not initialized, saving settings without encryption');
                localStorage.setItem(this.storageKey, jsonData);
                this.logger.info('Settings saved successfully (unencrypted)', {
                    hasEnvironmentId: !!this.settings.environmentId,
                    hasApiClientId: !!this.settings.apiClientId,
                    region: this.settings.region
                });
                window.dispatchEvent(new CustomEvent('settings:save-success', {
                    detail: { message: 'Settings saved successfully (unencrypted).' }
                }));
                return;
            }

            try {
                const encryptedData = await CryptoUtils.encrypt(jsonData, this.encryptionKey);
                localStorage.setItem(this.storageKey, encryptedData);
                this.logger.info('Settings saved successfully (encrypted)', {
                    hasEnvironmentId: !!this.settings.environmentId,
                    hasApiClientId: !!this.settings.apiClientId,
                    region: this.settings.region
                });
                window.dispatchEvent(new CustomEvent('settings:save-success', {
                    detail: { message: 'Settings saved successfully.' }
                }));
            } catch (encryptionError) {
                this.logger.warn('Encryption failed, saving settings without encryption', { 
                    error: encryptionError.message 
                });
                localStorage.setItem(this.storageKey, jsonData);
                this.logger.info('Settings saved successfully (unencrypted fallback)', {
                    hasEnvironmentId: !!this.settings.environmentId,
                    hasApiClientId: !!this.settings.apiClientId,
                    region: this.settings.region
                });
                window.dispatchEvent(new CustomEvent('settings:save-success', {
                    detail: { message: 'Settings saved successfully (encryption failed, used fallback).' }
                }));
            }
        } catch (error) {
            this.logger.error('Failed to save settings', { error: error.message });
            window.dispatchEvent(new CustomEvent('settings:save-error', {
                detail: { message: `Failed to save settings: ${error.message}` }
            }));
            throw error;
        }
    }
    
    /**
     * Get a specific setting
     * @param {string} key - Setting key
     * @returns {*} Setting value
     */
    getSetting(key) {
        if (!key) {
            throw new Error('Setting key is required');
        }
        
        return this.settings[key];
    }
    
    /**
     * Set a specific setting
     * @param {string} key - Setting key
     * @param {*} value - Setting value
     * @returns {Promise<void>}
     */
    async setSetting(key, value) {
        if (!key) {
            throw new Error('Setting key is required');
        }
        
        try {
            this.settings[key] = value;
            await this.saveSettings();
            
            this.logger.debug('Setting updated', { key, value: typeof value === 'string' ? value : '[object]' });
        } catch (error) {
            this.logger.error('Failed to update setting', { key, error: error.message });
            throw error;
        }
    }
    
    /**
     * Get all settings
     * @returns {Object} All settings
     */
    getAllSettings() {
        return { ...this.settings };
    }
    
    /**
     * Update multiple settings at once
     * @param {Object} newSettings - New settings to update
     * @returns {Promise<void>}
     */
    async updateSettings(newSettings) {
        if (!newSettings || typeof newSettings !== 'object') {
            throw new Error('New settings object is required');
        }
        
        try {
            this.settings = { ...this.settings, ...newSettings };
            await this.saveSettings();
            
            this.logger.info('Multiple settings updated', {
                updatedKeys: Object.keys(newSettings),
                hasEnvironmentId: !!this.settings.environmentId,
                hasApiClientId: !!this.settings.apiClientId
            });
        } catch (error) {
            this.logger.error('Failed to update settings', { error: error.message });
            throw error;
        }
    }
    
    /**
     * Reset settings to defaults
     * @returns {Promise<void>}
     */
    async resetSettings() {
        try {
            this.settings = this.getDefaultSettings();
            await this.saveSettings();
            
            this.logger.info('Settings reset to defaults');
        } catch (error) {
            this.logger.error('Failed to reset settings', { error: error.message });
            throw error;
        }
    }
    
    /**
     * Clear all settings
     * @returns {Promise<void>}
     */
    async clearSettings() {
        try {
            localStorage.removeItem(this.storageKey);
            this.settings = this.getDefaultSettings();
            
            this.logger.info('Settings cleared');
        } catch (error) {
            this.logger.error('Failed to clear settings', { error: error.message });
            throw error;
        }
    }
    
    /**
     * Initialize encryption with a key derived from browser and user-specific data
     * @returns {Promise<void>}
     */
    async initializeEncryption() {
        try {
            let deviceId = await this.getDeviceId();
            if (typeof deviceId !== 'string') deviceId = String(deviceId || '');
            if (!deviceId) deviceId = 'fallback-device-id';
            this.encryptionKey = await CryptoUtils.generateKey(deviceId);
            this.logger.debug('Encryption initialized successfully');
        } catch (error) {
            this.logger.error('Failed to initialize encryption', { error: error.message });
            // Fallback to a less secure but functional approach
            this.encryptionKey = await CryptoUtils.generateKey('fallback-encryption-key');
            this.logger.warn('Using fallback encryption key');
        }
    }
    
    /**
     * Generate a device ID based on browser and system information
     * @returns {Promise<string>} A unique device ID
     */
    async getDeviceId() {
        try {
            // Try to get a stored device ID first
            if (this.isLocalStorageAvailable()) {
                const storedDeviceId = localStorage.getItem('pingone-device-id');
                if (storedDeviceId && typeof storedDeviceId === 'string') {
                    return storedDeviceId;
                }
            }
            
            // Generate device ID from browser info
            const navigatorInfo = {
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                hardwareConcurrency: navigator.hardwareConcurrency,
                deviceMemory: navigator.deviceMemory,
                maxTouchPoints: navigator.maxTouchPoints
            };
            const encoder = new TextEncoder();
            const data = encoder.encode(JSON.stringify(navigatorInfo));
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const deviceId = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            
            if (typeof deviceId !== 'string' || !deviceId) {
                return 'fallback-device-id';
            }
            
            return deviceId;
        } catch (error) {
            this.logger.error('Failed to generate device ID:', error);
            // Fallback to a random string if crypto API fails
            return 'fallback-' + Math.random().toString(36).substring(2, 15);
        }
    }
    
    /**
     * Check if localStorage is available
     * @returns {boolean} True if localStorage is available
     */
    isLocalStorageAvailable() {
        try {
            const test = 'test';
            localStorage.setItem(test, test);
            localStorage.removeItem(test);
            return true;
        } catch (error) {
            this.logger.warn('localStorage not available', { error: error.message });
            return false;
        }
    }
    
    /**
     * Export settings (for backup)
     * @returns {Promise<Object>} Export data
     */
    async exportSettings() {
        try {
            const exportData = {
                settings: this.settings,
                exportDate: new Date().toISOString(),
                version: '1.0'
            };
            
            this.logger.info('Settings exported', { exportDate: exportData.exportDate });
            return exportData;
        } catch (error) {
            this.logger.error('Failed to export settings', { error: error.message });
            throw error;
        }
    }
    
    /**
     * Import settings (from backup)
     * @param {Object} importData - Import data object
     * @returns {Promise<void>}
     */
    async importSettings(importData) {
        if (!importData) {
            throw new Error('Import data is required');
        }
        
        if (!importData.settings) {
            throw new Error('Invalid import data: missing settings');
        }
        
        try {
            this.settings = { ...this.getDefaultSettings(), ...importData.settings };
            await this.saveSettings();
            
            this.logger.info('Settings imported successfully', {
                importDate: importData.exportDate,
                hasEnvironmentId: !!this.settings.environmentId,
                hasApiClientId: !!this.settings.apiClientId
            });
        } catch (error) {
            this.logger.error('Failed to import settings', { error: error.message });
            throw error;
        }
    }
    
    /**
     * Debug method to check localStorage contents
     * @returns {Object|null} Debug information
     */
    debugLocalStorage() {
        try {
            const storedData = localStorage.getItem(this.storageKey);
            if (!storedData) {
                this.logger.info('No data found in localStorage', { key: this.storageKey });
                return null;
            }
            
            this.logger.info('localStorage contents found', { 
                key: this.storageKey,
                length: storedData.length,
                preview: storedData.substring(0, 100) + (storedData.length > 100 ? '...' : '')
            });
            
            // Try to parse as JSON
            try {
                const parsed = JSON.parse(storedData);
                this.logger.info('Data is valid JSON', { 
                    keys: Object.keys(parsed),
                    hasEnvironmentId: !!parsed.environmentId,
                    hasApiClientId: !!parsed.apiClientId
                });
                return parsed;
            } catch (jsonError) {
                this.logger.info('Data is not valid JSON, likely encrypted', { 
                    error: jsonError.message 
                });
                return 'encrypted';
            }
        } catch (error) {
            this.logger.error('Failed to debug localStorage', { error: error.message });
            return null;
        }
    }
}

// Export the SettingsManager class
export { SettingsManager };



/* From: public/js/modules/settings-subsystem.js */
/**
 * Settings Management Subsystem
 * 
 * Handles all settings operations with proper separation of concerns.
 * Manages settings form validation, saving, and UI feedback.
 */

export class SettingsSubsystem {
    constructor(logger, uiManager, localClient, settingsManager, eventBus, credentialsManager) {
        this.logger = logger;
        this.uiManager = uiManager;
        this.localClient = localClient;
        this.settingsManager = settingsManager;
        this.eventBus = eventBus;
        this.credentialsManager = credentialsManager;
        
        // Settings state management
        this.isSaving = false;
        this.currentSettings = null;
        
        this.logger.info('Settings Subsystem initialized');
        
        // Set up event listeners for cross-subsystem communication
        this.setupCrossSubsystemEvents();
    }
    
    /**
     * Initialize the settings subsystem
     */
    async init() {
        try {
            this.setupEventListeners();
            await this.loadCurrentSettings();
            this.logger.info('Settings Subsystem initialized successfully');
        } catch (error) {
            this.logger.error('Failed to initialize Settings Subsystem', error);
            this.uiManager.showSettingsActionStatus('Failed to initialize Settings Subsystem: ' + error.message, 'error');
        }
    }
    
    /**
     * Set up event listeners for settings-related elements
     */
    setupEventListeners() {
        this.logger.info('Setting up Settings Subsystem event listeners');
        
        // Save settings button
        const saveBtn = document.getElementById('save-settings');
        if (saveBtn) {
            this.logger.info('Found save settings button, attaching event listener');
            saveBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                this.logger.info('Save settings button clicked');
                await this.saveSettings();
            });
        } else {
            this.logger.warn('Save settings button not found in DOM');
        }
        
        // Test connection button
        const testBtn = document.getElementById('test-connection-btn');
        if (testBtn) {
            testBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                await this.testConnection();
            });
        }
        
        // Get token button
        const tokenBtn = document.getElementById('get-token-btn');
        if (tokenBtn) {
            tokenBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                await this.getToken();
            });
        }
        
        // API secret visibility toggle
        const toggleBtn = document.getElementById('toggle-api-secret-visibility');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', (e) => {
                e.preventDefault();
                this.toggleSecretVisibility();
            });
        }
        
        this.logger.info('Settings Subsystem event listeners setup complete');
    }
    
    /**
     * Load current settings from settings manager
     */
    async loadCurrentSettings() {
        try {
            // Check if settingsManager exists and has getSettings method
            if (!this.settingsManager) {
                this.logger.warn('Settings manager not available, using default settings');
                this.currentSettings = this.getDefaultSettings();
                return;
            }
            
            if (typeof this.settingsManager.getAllSettings !== 'function') {
                this.logger.warn('Settings manager getAllSettings method not available, using default settings');
                this.currentSettings = this.getDefaultSettings();
                return;
            }
            
            // Try to load settings from settings manager
            this.currentSettings = this.settingsManager.getAllSettings();
            
            // If settings are null or empty, use defaults
            if (!this.currentSettings || Object.keys(this.currentSettings).length === 0) {
                this.logger.info('No existing settings found, using defaults');
                this.currentSettings = this.getDefaultSettings();
            }
            
            this.populateSettingsForm(this.currentSettings);
            this.logger.info('Current settings loaded successfully');
        } catch (error) {
            this.logger.warn('Failed to load current settings, using defaults:', error.message);
            // Don't throw error, use default settings instead
            this.currentSettings = this.getDefaultSettings();
        }
    }
    
    /**
     * Get default settings
     */
    getDefaultSettings() {
        return {
            environmentId: '',
            apiClientId: '',
            apiSecret: '',
            region: 'NorthAmerica',
            rateLimit: 50,
            populationId: ''
        };
    }
    
    /**
     * Save settings
     */
    async saveSettings() {
        if (this.isSaving) {
            this.logger.warn('Settings save already in progress');
            return;
        }
        
        try {
            this.isSaving = true;
            this.logger.info('Starting settings save process');
            
            // Show immediate feedback
            this.uiManager.showSettingsActionStatus('Saving settings...', 'info');
            
            // Get form data
            const settings = this.getFormData();
            this.logger.info('Form data extracted:', settings);
            
            // Validate settings
            if (!this.validateSettings(settings)) {
                return;
            }
            
            // Save to credentials manager if available
            if (this.credentialsManager) {
                const credentials = {
                    environmentId: settings.pingone_environment_id || '',
                    apiClientId: settings.pingone_client_id || '',
                    apiSecret: settings.pingone_client_secret || '',
                    populationId: settings.pingone_population_id || '',
                    region: settings.pingone_region || settings.region || 'NorthAmerica'
                };
                
                // Also include the PingOne-prefixed keys for consistency
                credentials.pingone_environment_id = credentials.environmentId;
                credentials.pingone_client_id = credentials.apiClientId;
                credentials.pingone_client_secret = credentials.apiSecret;
                credentials.pingone_population_id = credentials.populationId;
                credentials.pingone_region = credentials.region;
                
                const validation = this.credentialsManager.validateCredentials(credentials);
                if (!validation.isValid) {
                    throw new Error(`Invalid credentials: ${validation.errors.join(', ')}`);
                }
                
                this.credentialsManager.saveCredentials(credentials);
                this.logger.info('Credentials saved to localStorage using PingOne-prefixed keys', {
                    timestamp: new Date().toISOString(),
                    keysUsed: 'pingone_prefixed'
                });
            }
            
            // Save to server
            try {
                const response = await this.localClient.post('/api/settings', settings);
                this.logger.info('Settings saved to server successfully');
            } catch (serverError) {
                this.logger.warn('Failed to save to server, but credentials saved to localStorage:', serverError.message);
            }
            
            // Update settings manager
            this.settingsManager.updateSettings(settings);
            this.currentSettings = settings;
            
            // Show success feedback
            this.uiManager.showSettingsActionStatus('Settings saved successfully', 'success', { autoHideDelay: 3000 });
            
            // Update connection status
            this.updateConnectionStatus('âœ… Settings saved! Please - Get token', 'success');
            
            // Emit event for other subsystems
            if (this.eventBus) {
                this.eventBus.emit('settingsSaved', { settings });
            }
            
            // Emit credentials-updated event for population dropdown fallback system
            const credentialsUpdatedEvent = new CustomEvent('credentials-updated', {
                detail: { settings, timestamp: Date.now() }
            });
            document.dispatchEvent(credentialsUpdatedEvent);
            this.logger.info('Credentials-updated event dispatched for population dropdown system');
            
            this.logger.info('Settings save process completed successfully');
            
        } catch (error) {
            this.logger.error('Failed to save settings', error);
            this.uiManager.showSettingsActionStatus('Failed to save settings: ' + error.message, 'error', { autoHide: false });
        } finally {
            this.isSaving = false;
        }
    }
    
    /**
     * Get form data from settings form
     */
    getFormData() {
        const form = document.getElementById('settings-form');
        if (!form) {
            throw new Error('Settings form not found');
        }
        
        const formData = new FormData(form);
        const settings = {
            pingone_environment_id: document.getElementById('pingone_environment_id_settings')?.value || '',
            pingone_client_id: document.getElementById('pingone_client_id_settings')?.value || '',
            pingone_client_secret: document.getElementById('pingone_client_secret_settings')?.value || '',
            pingone_region: document.getElementById('pingone_region_settings')?.value || 'NorthAmerica',
            rateLimit: parseInt(document.getElementById('rate-limit')?.value) || 50,
            pingone_population_id: document.getElementById('population-id')?.value || ''
        };
        
        // For backwards compatibility, also set the legacy keys
        settings.environmentId = settings.pingone_environment_id;
        settings.apiClientId = settings.pingone_client_id;
        settings.apiSecret = settings.pingone_client_secret;
        settings.region = settings.pingone_region;
        settings.populationId = settings.pingone_population_id;
        
        // Log migration of keys
        this.logger.info('Settings keys migrated to PingOne-prefixed format', {
            timestamp: new Date().toISOString(),
            migrationResult: 'success'
        });
        
        return settings;
    }
    
    /**
     * Validate settings
     */
    validateSettings(settings) {
        const errors = [];
        
        if (!settings.pingone_environment_id?.trim()) {
            errors.push('PingOne Environment ID is required');
        }
        
        if (!settings.pingone_client_id?.trim()) {
            errors.push('PingOne Client ID is required');
        }
        
        if (!settings.pingone_client_secret?.trim()) {
            errors.push('PingOne Client Secret is required');
        }
        
        if (!settings.pingone_region?.trim()) {
            errors.push('PingOne Region is required');
        }
        
        if (settings.rateLimit && (settings.rateLimit < 1 || settings.rateLimit > 1000)) {
            errors.push('Rate limit must be between 1 and 1000');
        }
        
        if (errors.length > 0) {
            const errorMessage = 'Validation failed: ' + errors.join(', ');
            this.logger.error('Settings validation failed', { errors });
            this.uiManager.showSettingsActionStatus(errorMessage, 'error', { autoHide: false });
            return false;
        }
        
        return true;
    }
    
    /**
     * Populate settings form with current values
     */
    populateSettingsForm(settings) {
        if (!settings) return;
        
        // First, migrate any legacy keys to PingOne-prefixed keys if needed
        this.migrateSettingsKeys(settings);
        
        const fields = {
            'pingone_environment_id_settings': settings.pingone_environment_id || settings.environmentId,
            'pingone_client_id_settings': settings.pingone_client_id || settings.apiClientId,
            'pingone_client_secret_settings': settings.pingone_client_secret || settings.apiSecret,
            'pingone_region_settings': settings.pingone_region || settings.region,
            'rate-limit': settings.rateLimit,
            'population-id': settings.pingone_population_id || settings.populationId
        };
        
        Object.entries(fields).forEach(([fieldId, value]) => {
            const field = document.getElementById(fieldId);
            if (field && value !== undefined && value !== null) {
                field.value = value;
            }
        });
        
        this.logger.info('Settings form populated with current values');
    }
    
    /**
     * Migrate legacy settings keys to PingOne-prefixed keys
     * @param {Object} settings - Settings object to migrate
     * @returns {Object} - Migrated settings object
     */
    migrateSettingsKeys(settings) {
        if (!settings) return settings;
        
        const migrations = [
            { from: 'environmentId', to: 'pingone_environment_id' },
            { from: 'apiClientId', to: 'pingone_client_id' },
            { from: 'apiSecret', to: 'pingone_client_secret' },
            { from: 'region', to: 'pingone_region' },
            { from: 'populationId', to: 'pingone_population_id' }
        ];
        
        let migrationsPerformed = false;
        
        migrations.forEach(({ from, to }) => {
            // Only migrate if source exists and destination doesn't
            if (settings[from] !== undefined && settings[from] !== null && 
                (settings[to] === undefined || settings[to] === null || settings[to] === '')) {
                settings[to] = settings[from];
                migrationsPerformed = true;
                
                this.logger.info(`Migrated setting from ${from} to ${to}`, {
                    timestamp: new Date().toISOString(),
                    field: from,
                    migrationResult: 'success'
                });
            }
        });
        
        if (migrationsPerformed) {
            // Update settings in the settings manager if migrations were performed
            this.settingsManager.updateSettings(settings);
        }
        
        return settings;
    }
    
    /**
     * Test connection
     * CRITICAL: This method MUST use GET /api/pingone/test-connection endpoint
     * DO NOT change to POST or different endpoint without updating server-side route
     * Last fixed: 2025-07-22 - Fixed HTTP method mismatch causing 400 Bad Request errors
     */
    async testConnection() {
        try {
            this.logger.info('Testing connection...');
            this.uiManager.showSettingsActionStatus('Testing connection...', 'info');
            
            const settings = this.getFormData();
            
            // Test connection via API
            // CRITICAL: Use GET request to match server-side endpoint
            // Server endpoint: routes/pingone-proxy-fixed.js - router.get('/test-connection')
            // DO NOT change to POST without updating server-side endpoint
            // Last fixed: 2025-07-22 - HTTP method mismatch caused 400 Bad Request errors
            const response = await this.localClient.get('/api/pingone/test-connection');
            
            if (response.success) {
                this.uiManager.showSettingsActionStatus('Connection test successful', 'success', { autoHideDelay: 3000 });
                this.updateConnectionStatus('âœ… Connection successful', 'success');
            } else {
                this.uiManager.showSettingsActionStatus('Connection test failed: ' + response.message, 'error');
                this.updateConnectionStatus('âŒ Connection failed', 'error');
            }
            
        } catch (error) {
            this.logger.error('Connection test failed', error);
            this.uiManager.showSettingsActionStatus('Connection test failed: ' + error.message, 'error');
            this.updateConnectionStatus('âŒ Connection failed', 'error');
        }
    }
    
    /**
     * Get token
     */
    async getToken() {
        try {
            this.logger.info('Getting token...');
            this.uiManager.showSettingsActionStatus('Getting token...', 'info');
            
            const settings = this.getFormData();
            
            // Get token via API
            const response = await this.localClient.post('/api/token', settings);
            
            if (response.success) {
                this.uiManager.showSettingsActionStatus('Token obtained successfully', 'success', { autoHideDelay: 3000 });
                this.updateConnectionStatus('âœ… Token obtained', 'success');
                
                // NEW: Direct global token status updater for sidebar
                console.log('ðŸš€ [DEBUG] SettingsSubsystem: About to call updateGlobalTokenStatusDirect');
                try {
                    // Get the main app instance to call the direct updater
                    if (window.app && typeof window.app.updateGlobalTokenStatusDirect === 'function') {
                        // Calculate time left from token response
                        const timeLeft = response.timeLeft || response.timeRemaining || '';
                        window.app.updateGlobalTokenStatusDirect(timeLeft);
                        console.log('âœ… [DEBUG] SettingsSubsystem: updateGlobalTokenStatusDirect called successfully with timeLeft:', timeLeft);
                    } else {
                        console.warn('âš ï¸ [DEBUG] SettingsSubsystem: window.app.updateGlobalTokenStatusDirect not available');
                    }
                } catch (error) {
                    console.error('âŒ [DEBUG] SettingsSubsystem: Error calling updateGlobalTokenStatusDirect:', error);
                }
                
                // Emit event for other subsystems
                if (this.eventBus) {
                    this.eventBus.emit('tokenObtained', { token: response.token });
                }
            } else {
                this.uiManager.showSettingsActionStatus('Failed to get token: ' + response.message, 'error');
                this.updateConnectionStatus('âŒ Token failed', 'error');
            }
            
        } catch (error) {
            this.logger.error('Failed to get token', error);
            this.uiManager.showSettingsActionStatus('Failed to get token: ' + error.message, 'error');
            this.updateConnectionStatus('âŒ Token failed', 'error');
        }
    }
    
    /**
     * Toggle API secret visibility
     */
    toggleSecretVisibility() {
        const secretField = document.getElementById('api-secret');
        const toggleBtn = document.getElementById('toggle-api-secret-visibility');
        const icon = toggleBtn?.querySelector('i');
        
        if (secretField && toggleBtn && icon) {
            if (secretField.type === 'password') {
                secretField.type = 'text';
                icon.className = 'fas fa-eye-slash';
                toggleBtn.setAttribute('aria-label', 'Hide password');
            } else {
                secretField.type = 'password';
                icon.className = 'fas fa-eye';
                toggleBtn.setAttribute('aria-label', 'Show password');
            }
        }
    }
    
    /**
     * Update connection status display
     */
    updateConnectionStatus(message, type) {
        const statusElement = document.getElementById('settings-connection-status');
        if (statusElement) {
            statusElement.textContent = message;
            statusElement.className = `connection-status status-${type}`;
        }
    }
    
    /**
     * Set up cross-subsystem event listeners
     */
    setupCrossSubsystemEvents() {
        if (!this.eventBus) {
            this.logger.warn('EventBus not available for cross-subsystem events');
            return;
        }
        
        // Listen for token expiration events
        this.eventBus.on('tokenExpired', (data) => {
            this.logger.warn('Token expired');
            this.updateConnectionStatus('âš ï¸ Token expired', 'warning');
        });
        
        // Listen for token error events
        this.eventBus.on('tokenError', (data) => {
            this.logger.error('Token error detected', data);
            this.updateConnectionStatus('âŒ Token error', 'error');
        });
        
        // Listen for token refresh events
        this.eventBus.on('tokenRefreshed', (data) => {
            this.logger.info('Token refreshed successfully');
            this.updateConnectionStatus('âœ… Token refreshed', 'success');
        });
        
        this.logger.debug('Cross-subsystem event listeners set up for SettingsSubsystem');
    }
    
    /**
     * Get all settings (required by App initialization)
     * @returns {Object} All current settings
     */
    getAllSettings() {
        if (this.settingsManager && this.settingsManager.getAllSettings) {
            return this.settingsManager.getAllSettings();
        } else if (this.settingsManager && this.settingsManager.getSettings) {
            return this.settingsManager.getSettings();
        } else if (this.currentSettings) {
            return this.currentSettings;
        } else {
            this.logger.warn('No settings available, returning empty object');
            return {};
        }
    }
}



/* From: public/js/modules/version-manager.js */
import { APP_VERSION, getFormattedVersion } from '../../../src/version.js';

export class VersionManager {
    constructor() {
        this.version = APP_VERSION; // Using centralized version source
        console.log(`Version Manager initialized with version ${this.version}`);
    }

    getVersion() {
        return this.version;
    }

    getFormattedVersion() {
        return `v${this.version}`;
    }

    updateTitle() {
        // Update the main title
        const title = document.querySelector('h1');
        if (title) {
            // Remove any existing version number
            const baseTitle = title.textContent.replace(/\s*\(v\d+\.\d+\.\d+\)\s*$/, '').trim();
            title.textContent = `${baseTitle} (${this.getFormattedVersion()})`;
        }

        // Update the document title
        document.title = `PingOne User Import ${this.getFormattedVersion()}`;

        // Update the import button text
        this.updateImportButton();

        // Update the top version badge
        this.updateTopVersionBadge();

        // Add version badge to the sidebar above the Ping Identity logo
        this.addSidebarVersionBadge();
    }
    
    updateImportButton() {
        const importButton = document.getElementById('start-import-btn');
        if (importButton) {
            const baseText = importButton.textContent.replace(/\s*\(v\d+\.\d+\.\d+\)\s*$/, '').trim();
            importButton.innerHTML = `<i class="pi pi-upload"></i> ${baseText} (${this.getFormattedVersion()})`;
        }
    }

    updateTopVersionBadge() {
        const versionText = document.getElementById('version-text');
        if (versionText) {
            versionText.textContent = this.getFormattedVersion();
        }
    }

    addSidebarVersionBadge() {
        // Remove existing badges if they exist
        const existingTopLeftBadge = document.getElementById('top-left-version-badge');
        if (existingTopLeftBadge) {
            existingTopLeftBadge.remove();
        }

        const existingSidebarBadge = document.getElementById('sidebar-version-badge');
        if (existingSidebarBadge) {
            existingSidebarBadge.remove();
        }

        // Check if sidebar version badge already exists
        if (document.getElementById('sidebar-version-badge')) {
            return;
        }

        // Create sidebar version badge
        const badge = document.createElement('div');
        badge.id = 'sidebar-version-badge';
        badge.className = 'sidebar-version-badge';
        badge.textContent = this.getFormattedVersion();
        
        // Find the footer and insert the badge in the footer-left section, after the logo and trademark
        const footer = document.querySelector('.ping-footer');
        if (footer) {
            const footerLeft = footer.querySelector('.footer-left');
            if (footerLeft) {
                // Insert the badge after the footer-logo div
                const logoDiv = footerLeft.querySelector('.footer-logo');
                if (logoDiv) {
                    // Insert after the logo div
                    footerLeft.insertBefore(badge, logoDiv.nextSibling);
                } else {
                    // Fallback: insert at the beginning of footer-left
                    footerLeft.insertBefore(badge, footerLeft.firstChild);
                }
            } else {
                // Fallback: insert at the end of the footer
                footer.appendChild(badge);
            }
        } else {
            // Fallback: add to body if footer not found
            document.body.appendChild(badge);
        }
    }
}

// ES Module export


