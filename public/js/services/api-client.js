/**
 * Consolidated API Client
 * 
 * Consolidated JavaScript for PingOne Import Tool
 * Generated: 2025-08-06T19:05:53.920Z
 * 
 * This file was automatically generated by js-cleanup-script.js
 * Organized for better maintainability and performance
 */


/* From: public/js/modules/local-api-client.js */
/**
 * Local API Client
 * Handles all API calls to the local server (localhost:4000)
 */

export class LocalAPIClient {
    /**
     * Create a new LocalAPIClient instance
     * @param {Object} logger - Logger instance
     * @param {string} [baseUrl=''] - Base URL for the API (defaults to relative path)
     */
    constructor(logger, baseUrl = '') {
        this.logger = logger || console;
        this.baseUrl = baseUrl;
        this.serverHealth = {
            lastCheck: 0,
            isHealthy: true,
            consecutiveFailures: 0,
            maxConsecutiveFailures: 3
        };
        this.healthCheckInterval = 30000; // 30 seconds
    }

    /**
     * Check server health before making requests
     * @private
     */
    async _checkServerHealth() {
        const now = Date.now();
        
        // Only check health if enough time has passed since last check
        if (now - this.serverHealth.lastCheck < this.healthCheckInterval) {
            return this.serverHealth.isHealthy;
        }

        try {
            const response = await fetch(`${this.baseUrl}/api/health`, {
                method: 'GET',
                headers: { 'Accept': 'application/json' },
                signal: AbortSignal.timeout(5000) // 5 second timeout
            });

            if (response.ok) {
                this.serverHealth.isHealthy = true;
                this.serverHealth.consecutiveFailures = 0;
                this.logger.debug('✅ Server health check passed');
            } else {
                this.serverHealth.isHealthy = false;
                this.serverHealth.consecutiveFailures++;
                this.logger.warn('⚠️ Server health check failed', { status: response.status });
            }
        } catch (error) {
            this.serverHealth.isHealthy = false;
            this.serverHealth.consecutiveFailures++;
            this.logger.warn('⚠️ Server health check error', { error: error.message });
        }

        this.serverHealth.lastCheck = now;
        return this.serverHealth.isHealthy;
    }

    /**
     * Calculate exponential backoff delay
     * @private
     */
    _calculateBackoffDelay(attempt, baseDelay, maxDelay) {
        const exponentialDelay = baseDelay * Math.pow(2, attempt - 1);
        const jitter = Math.random() * 0.1 * exponentialDelay; // Add 10% jitter
        return Math.min(exponentialDelay + jitter, maxDelay);
    }

    /**
     * Determine if a request should be retried based on error type
     * @private
     */
    _shouldRetry(error, attempt, maxRetries) {
        // Don't retry if we've reached max attempts
        if (attempt >= maxRetries) {
            return false;
        }

        // Retry on network errors (no status code)
        if (!error.status) {
            return true;
        }

        // Retry on server errors (5xx)
        if (error.status >= 500) {
            return true;
        }

        // Retry on rate limits (429)
        if (error.status === 429) {
            return true;
        }

        // Retry on timeout errors (408)
        if (error.status === 408) {
            return true;
        }

        // Don't retry on client errors (4xx except 429, 408)
        return false;
    }

    /**
     * Make an API request to the local server with enhanced retry logic
     * @param {string} method - HTTP method (GET, POST, PUT, DELETE, etc.)
     * @param {string} endpoint - API endpoint (without base URL)
     * @param {Object} [data] - Request body (for POST/PUT/PATCH)
     * @param {Object} [options] - Additional options
     * @returns {Promise<Object>} Response data
     */
    async request(method, endpoint, data = null, options = {}) {
        const url = `${this.baseUrl}${endpoint}`;
        const startTime = Date.now();

        // Enhanced options with retry logic
        const requestOptions = {
            ...options,
            retries: options.retries || 3,
            retryDelay: options.retryDelay || 1000, // 1 second base delay
            maxRetryDelay: options.maxRetryDelay || 30000, // 30 seconds max delay
            healthCheck: options.healthCheck !== false, // Enable health check by default
            timeout: options.timeout || 10000 // 10 second timeout
        };

        // Check server health before making request (if enabled)
        if (requestOptions.healthCheck && endpoint !== '/api/health') {
            const isHealthy = await this._checkServerHealth();
            if (!isHealthy && this.serverHealth.consecutiveFailures >= this.serverHealth.maxConsecutiveFailures) {
                throw new Error('Server is unhealthy and unavailable for requests');
            }
        }

        // Prepare headers
        const headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        };

        // Add authorization if available
        if (this.accessToken) {
            headers.Authorization = `Bearer ${this.accessToken}`;
        }

        // Prepare request body
        let body = null;
        if (data && method !== 'GET') {
            body = JSON.stringify(data);
        }

        // Log the request with minimal details to avoid rate limiting
        const requestLog = {
            type: 'api_request',
            method,
            url,
            timestamp: new Date().toISOString(),
            source: 'local-api-client'
        };
        this.logger.debug('🔄 Local API Request:', requestLog);

        // Retry logic with exponential backoff
        let lastError = null;
        for (let attempt = 1; attempt <= requestOptions.retries; attempt++) {
            try {
                // Create abort controller for timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), requestOptions.timeout);

                const response = await fetch(url, {
                    method,
                    headers,
                    body,
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                const responseData = await this._handleResponse(response);

                // Log successful response with minimal details
                const responseLog = {
                    type: 'api_response',
                    status: response.status,
                    method,
                    duration: Date.now() - startTime,
                    attempt: attempt,
                    source: 'local-api-client'
                };
                this.logger.debug('✅ Local API Response:', responseLog);

                // Update server health on success
                if (requestOptions.healthCheck) {
                    this.serverHealth.isHealthy = true;
                    this.serverHealth.consecutiveFailures = 0;
                }

                return responseData;
            } catch (error) {
                lastError = error;
                
                // Handle timeout errors
                if (error.name === 'AbortError') {
                    error.message = 'Request timeout';
                    error.status = 408;
                }

                this.logger.error(`Local API Error (attempt ${attempt}/${requestOptions.retries}):`, error);

                // Get the friendly error message if available
                const friendlyMessage = error.friendlyMessage || error.message;
                const isRateLimit = error.status === 429;

                // Check if we should retry this error
                if (!this._shouldRetry(error, attempt, requestOptions.retries)) {
                    throw error;
                }

                // Calculate backoff delay
                const baseDelay = isRateLimit ? (requestOptions.retryDelay * 2) : requestOptions.retryDelay;
                const delay = this._calculateBackoffDelay(attempt, baseDelay, requestOptions.maxRetryDelay);

                // Show appropriate UI messages based on error type
                if (window.app && window.app.uiManager) {
                    if (isRateLimit) {
                        if (attempt < requestOptions.retries) {
                            // Use enhanced rate limit warning with retry information
                            window.app.uiManager.showRateLimitWarning(friendlyMessage, {
                                isRetrying: true,
                                retryAttempt: attempt,
                                maxRetries: requestOptions.retries,
                                retryDelay: delay
                            });
                        } else {
                            window.app.uiManager.showError(friendlyMessage);
                        }
                    } else if (attempt === requestOptions.retries) {
                        // For other errors, show friendly message on final attempt
                        window.app.uiManager.showError(friendlyMessage);
                    }
                }

                // Update server health on failure
                if (requestOptions.healthCheck) {
                    this.serverHealth.isHealthy = false;
                    this.serverHealth.consecutiveFailures++;
                }

                // If this is the last attempt, throw with friendly message
                if (attempt === requestOptions.retries) {
                    throw error;
                }

                // Log retry attempt
                this.logger.info(`Retrying request in ${delay}ms... (attempt ${attempt + 1}/${requestOptions.retries})`);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }

        // If all retries fail, throw the last error
        throw lastError;
    }

    /**
     * Handle API response
     * @private
     */
    async _handleResponse(response) {
        const contentType = response.headers.get('content-type');
        let data;

        if (contentType && contentType.includes('application/json')) {
            data = await response.json();
        } else {
            data = await response.text();
        }

        if (!response.ok) {
            let errorMessage;
            
            // Provide user-friendly error messages based on status code
            switch (response.status) {
                case 400:
                    errorMessage = this._getBadRequestMessage(data, response.url);
                    break;
                case 401:
                    errorMessage = this._getUnauthorizedMessage();
                    break;
                case 403:
                    errorMessage = this._getForbiddenMessage(data, response.url);
                    break;
                case 404:
                    errorMessage = this._getNotFoundMessage(data, response.url);
                    break;
                case 429:
                    errorMessage = this._getRateLimitMessage();
                    break;
                case 500:
                case 501:
                case 502:
                case 503:
                case 504:
                    errorMessage = this._getServerErrorMessage(response.status);
                    break;
                default:
                    errorMessage = data.message || `Request failed with status ${response.status}`;
            }
            
            const error = new Error(errorMessage);
            error.status = response.status;
            error.details = data;
            error.friendlyMessage = errorMessage;
            throw error;
        }

        return data;
    }

    /**
     * Get user-friendly error message for 400 Bad Request errors
     * @private
     */
    _getBadRequestMessage(data, url) {
        // Check if it's an import endpoint error
        if (url.includes('/import')) {
            if (data && data.error) {
                // Return the specific error message from the server
                return data.error;
            }
            if (data && data.message) {
                return data.message;
            }
            return '🔍 Import failed. Please check your CSV file and settings.';
        }
        
        // Check if it's a user modification endpoint
        if (url.includes('/users/') && url.includes('PUT')) {
            return '🔍 User data validation failed. Please check the user information and try again.';
        }
        
        // Check if it's a user creation endpoint
        if (url.includes('/users') && url.includes('POST')) {
            return '🔍 User creation failed due to invalid data. Please check required fields and try again.';
        }
        
        // Check if it's a population-related error
        if (url.includes('/populations')) {
            return '🔍 Population data is invalid. Please check your population settings.';
        }
        
        // Generic 400 error
        return '🔍 Request data is invalid. Please check your input and try again.';
    }

    /**
     * Get user-friendly error message for 401 Unauthorized errors
     * @private
     */
    _getUnauthorizedMessage() {
        return '🔑 Authentication failed. Please check your PingOne API credentials in the Settings page.';
    }

    /**
     * Get user-friendly error message for 403 Forbidden errors
     * @private
     */
    _getForbiddenMessage(data, url) {
        // Check if it's a user modification endpoint
        if (url.includes('/users/') && url.includes('PUT')) {
            return '🚫 Permission denied. Your PingOne application may not have permission to modify users.';
        }
        
        // Check if it's a user creation endpoint
        if (url.includes('/users') && url.includes('POST')) {
            return '🚫 Permission denied. Your PingOne application may not have permission to create users.';
        }
        
        // Check if it's a user deletion endpoint
        if (url.includes('/users/') && url.includes('DELETE')) {
            return '🚫 Permission denied. Your PingOne application may not have permission to delete users.';
        }
        
        // Generic 403 error
        return '🚫 Access denied. Your PingOne application may not have the required permissions for this operation.';
    }

    /**
     * Get user-friendly error message for 404 Not Found errors
     * @private
     */
    _getNotFoundMessage(data, url) {
        // Check if it's a user-related endpoint
        if (url.includes('/users/')) {
            return '🔍 User not found. The user may have been deleted or the ID is incorrect.';
        }
        
        // Check if it's a population-related endpoint
        if (url.includes('/populations')) {
            return '🔍 Population not found. Please check your population settings.';
        }
        
        // Check if it's an environment-related endpoint
        if (url.includes('/environments/')) {
            return '🔍 PingOne environment not found. Please check your environment ID.';
        }
        
        // Generic 404 error
        return '🔍 Resource not found. Please check the ID or settings and try again.';
    }

    /**
     * Get user-friendly error message for 429 Too Many Requests errors
     * @private
     */
    _getRateLimitMessage() {
        return '⏰ You are sending requests too quickly. Please wait a moment and try again.';
    }

    /**
     * Get user-friendly error message for 500+ server errors
     * @private
     */
    _getServerErrorMessage(status) {
        if (status >= 500) {
            return '🔧 Server error. Please check your PingOne API credentials in the Settings page.';
        }
        return '🔧 An unexpected error occurred. Please try again.';
    }

    // Convenience methods for common HTTP methods
    get(endpoint, options = {}) {
        return this.request('GET', endpoint, null, options);
    }

    post(endpoint, data, options = {}) {
        return this.request('POST', endpoint, data, options);
    }

    /**
     * Send a POST request with FormData (for file uploads)
     * @param {string} endpoint - API endpoint
     * @param {FormData} formData - FormData object
     * @param {Object} options - Additional options
     * @returns {Promise<Object>} Response data
     */
    async postFormData(endpoint, formData, options = {}) {
        const url = `${this.baseUrl}${endpoint}`;
        const startTime = Date.now();

        // Enhanced options with retry logic
        const requestOptions = {
            ...options,
            retries: options.retries || 3,
            retryDelay: options.retryDelay || 1000 // 1 second base delay
        };

        // Prepare headers for FormData (don't set Content-Type, let browser set it with boundary)
        const headers = {
            'Accept': 'application/json'
        };

        // Add authorization if available
        if (this.accessToken) {
            headers.Authorization = `Bearer ${this.accessToken}`;
        }

        // Log the request with minimal details to avoid rate limiting
        const requestLog = {
            type: 'api_request',
            method: 'POST',
            url,
            timestamp: new Date().toISOString(),
            source: 'local-api-client',
            contentType: 'multipart/form-data'
        };
        this.logger.debug('🔄 Local API FormData Request:', requestLog);

        // Retry logic
        let lastError = null;
        for (let attempt = 1; attempt <= requestOptions.retries; attempt++) {
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers,
                    body: formData
                });

                const responseData = await this._handleResponse(response);

                // Log successful response with minimal details
                const responseLog = {
                    type: 'api_response',
                    status: response.status,
                    method: 'POST',
                    duration: Date.now() - startTime,
                    attempt: attempt,
                    source: 'local-api-client'
                };
                this.logger.debug('✅ Local API FormData Response:', responseLog);

                return responseData;
            } catch (error) {
                lastError = error;
                this.logger.error(`Local API FormData Error (attempt ${attempt}/${requestOptions.retries}):`, error);

                // Get the friendly error message if available
                const friendlyMessage = error.friendlyMessage || error.message;
                const isRateLimit = error.status === 429;

                // Calculate baseDelay and delay here, before using them
                const baseDelay = isRateLimit ? (requestOptions.retryDelay * 2) : requestOptions.retryDelay;
                const delay = baseDelay * Math.pow(2, attempt - 1);

                // Show appropriate UI messages based on error type
                if (window.app && window.app.uiManager) {
                    if (isRateLimit) {
                        if (attempt < requestOptions.retries) {
                            // Use enhanced rate limit warning with retry information
                            window.app.uiManager.showRateLimitWarning(friendlyMessage, {
                                isRetrying: true,
                                retryAttempt: attempt,
                                maxRetries: requestOptions.retries,
                                retryDelay: delay
                            });
                        } else {
                            window.app.uiManager.showError(friendlyMessage);
                        }
                    } else if (attempt === requestOptions.retries) {
                        // For other errors, show friendly message on final attempt
                        window.app.uiManager.showError(friendlyMessage);
                    }
                }

                // If this is the last attempt, throw with friendly message
                if (attempt === requestOptions.retries) {
                    throw error;
                }

                // Only retry for rate limits (429) and server errors (5xx)
                const shouldRetry = isRateLimit || error.status >= 500 || !error.status;
                if (!shouldRetry) {
                    // Don't retry for client errors (4xx except 429), throw immediately
                    throw error;
                }

                // Use the delay calculated above
                this.logger.info(`Retrying FormData request in ${delay}ms... (attempt ${attempt + 1}/${requestOptions.retries})`);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }

        // If all retries fail, throw the last error
        throw lastError;
    }

    put(endpoint, data, options = {}) {
        return this.request('PUT', endpoint, data, options);
    }

    delete(endpoint, options = {}) {
        return this.request('DELETE', endpoint, null, options);
    }

    // Token Management Methods
    
    /**
     * Retrieve PingOne worker token
     * @returns {Promise<Object>} Token data with expiration info
     */
    async getWorkerToken() {
        this.logger.debug('🔐 Retrieving PingOne worker token...');
        
        try {
            const response = await this.post('/api/auth/worker-token', {}, {
                timeout: 15000, // 15 second timeout for token retrieval
                retries: 2 // Fewer retries for token operations
            });
            
            this.logger.debug('✅ Worker token retrieved successfully');
            return response;
            
        } catch (error) {
            this.logger.error('❌ Failed to retrieve worker token:', error);
            throw new Error(`Token retrieval failed: ${error.message}`);
        }
    }
    
    /**
     * Refresh existing PingOne worker token
     * @param {string} currentToken - Current token for authorization
     * @returns {Promise<Object>} Refreshed token data
     */
    async refreshWorkerToken(currentToken) {
        this.logger.debug('🔄 Refreshing PingOne worker token...');
        
        if (!currentToken) {
            throw new Error('Current token is required for refresh');
        }
        
        try {
            const response = await this.post('/api/auth/refresh-token', {}, {
                headers: {
                    'Authorization': `Bearer ${currentToken}`
                },
                timeout: 10000, // 10 second timeout for refresh
                retries: 1 // Single retry for refresh operations
            });
            
            this.logger.debug('✅ Worker token refreshed successfully');
            return response;
            
        } catch (error) {
            this.logger.error('❌ Failed to refresh worker token:', error);
            throw new Error(`Token refresh failed: ${error.message}`);
        }
    }
    
    /**
     * Get current token status without retrieving the actual token
     * @returns {Promise<Object>} Token status information
     */
    async getTokenStatus() {
        this.logger.debug('🔍 Checking worker token status...');
        
        try {
            const response = await this.get('/api/auth/token-status', {
                timeout: 5000, // 5 second timeout for status check
                retries: 1 // Single retry for status check
            });
            
            this.logger.debug('✅ Token status retrieved successfully');
            return response;
            
        } catch (error) {
            this.logger.debug('ℹ️ Could not retrieve token status:', error.message);
            // Don't throw for status checks - return null status
            return {
                success: false,
                hasToken: false,
                error: error.message
            };
        }
    }
    
    /**
     * Clear/invalidate current worker token
     * @returns {Promise<Object>} Clear operation result
     */
    async clearWorkerToken() {
        this.logger.debug('🗑️ Clearing worker token...');
        
        try {
            const response = await this.delete('/api/auth/worker-token', {
                timeout: 5000, // 5 second timeout for clear operation
                retries: 1 // Single retry for clear operation
            });
            
            this.logger.debug('✅ Worker token cleared successfully');
            return response;
            
        } catch (error) {
            this.logger.error('❌ Failed to clear worker token:', error);
            throw new Error(`Token clear failed: ${error.message}`);
        }
    }
    
    /**
     * Validate worker token and get detailed information
     */
    async validateToken(token = null) {
        try {
            const payload = token ? { token: token } : {};
            const response = await this.post('/api/auth/validate-credentials', payload, {
                timeout: 5000, // 5 second timeout for validation
                retries: 1 // Single retry for validation
            });
            
            return {
                success: true,
                valid: response.valid || false,
                details: response.details || {},
                message: response.message || 'Token validation completed'
            };
        } catch (error) {
            return {
                success: false,
                valid: false,
                error: error.message,
                message: 'Token validation failed'
            };
        }
    }
    
    /**
     * Test API connection
     * @returns {Promise<Object>} Connection test result
     */
    async testConnection() {
        try {
            // CRITICAL: This MUST be a GET request to /api/pingone/test-connection
            // Server endpoint: routes/pingone-proxy-fixed.js - router.get('/test-connection')
            // DO NOT change to POST without updating server-side endpoint
            // Last fixed: 2025-07-21 - Fixed HTTP method mismatch causing 400 Bad Request errors
            const response = await this.get('/api/pingone/test-connection', {
                timeout: 10000, // 10 second timeout for connection test
                retries: 1 // Single retry for connection test
            });
            
            return {
                success: true,
                connected: true,
                details: response.details || {},
                message: response.message || 'Connection successful'
            };
        } catch (error) {
            return {
                success: false,
                connected: false,
                error: error.message,
                message: 'Connection test failed'
            };
        }
    }
}

// Export a singleton instance
export const localAPIClient = new LocalAPIClient(console);



/* From: public/js/modules/local-api.js */
/**
 * Local API Client
 * Handles all API calls to the local server (localhost:4000)
 */

class LocalAPI {
    /**
     * Create a new LocalAPI instance
     * @param {Object} logger - Logger instance
     */
    constructor(logger) {
        this.logger = logger || console;
        this.baseUrl = ''; // Relative URL for same-origin requests
    }

    /**
     * Make an authenticated API request to the local server
     * @param {string} method - HTTP method (GET, POST, PUT, DELETE, etc.)
     * @param {string} endpoint - API endpoint (without base URL)
     * @param {Object} [data] - Request body (for POST/PUT/PATCH)
     * @param {Object} [options] - Additional options
     * @returns {Promise<Object>} Response data
     */
    async request(method, endpoint, data = null, options = {}) {
        const url = `${this.baseUrl}${endpoint}`;
        
        // Prepare headers
        const headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            ...options.headers
        };

        // Log the request
        this.logger.debug('Local API Request:', {
            method,
            url,
            headers: { ...headers, 'Authorization': headers.Authorization ? '***REDACTED***' : 'Not set' },
            data
        });

        try {
            const response = await fetch(url, {
                method,
                headers,
                credentials: 'include', // Include cookies for session management
                body: data ? JSON.stringify(data) : undefined
            });

            const responseData = await this._handleResponse(response);
            
            // Log successful response
            this.logger.debug('Local API Response:', {
                status: response.status,
                url,
                data: responseData
            });

            return responseData;
        } catch (error) {
            this.logger.error('Local API Error:', error);
            throw error;
        }
    }

    /**
     * Handle API response
     * @private
     */
    async _handleResponse(response) {
        const contentType = response.headers.get('content-type');
        let data;

        if (contentType && contentType.includes('application/json')) {
            data = await response.json();
        } else {
            data = await response.text();
        }

        if (!response.ok) {
            const error = new Error(data.message || 'API request failed');
            error.status = response.status;
            error.data = data;
            throw error;
        }

        return data;
    }

    // Convenience methods for common HTTP methods
    get(endpoint, options = {}) {
        return this.request('GET', endpoint, null, options);
    }

    post(endpoint, data, options = {}) {
        return this.request('POST', endpoint, data, options);
    }

    put(endpoint, data, options = {}) {
        return this.request('PUT', endpoint, data, options);
    }

    delete(endpoint, options = {}) {
        return this.request('DELETE', endpoint, null, options);
    }
}

// Export a singleton instance
export const localAPI = new LocalAPI(console);



/* From: public/js/modules/pingone-client.js */
/**
 * @fileoverview PingOne Client Class
 * 
 * Handles authentication and API communication with PingOne services.
 * Manages token acquisition, caching, and API requests with Winston logging.
 * 
 * Features:
 * - Token management with localStorage caching
 * - Automatic token refresh
 * - API request handling with retry logic
 * - User import and modification operations
 * - Winston logging integration
 */

import { createWinstonLogger } from './winston-logger.js';
import { UIManager } from './ui-manager.js';
const ui = window.app && window.app.uiManager;
function handleClientError(error) {
    let userMessage = 'An unexpected error occurred. Please try again.';
    if (error && error.message) {
        if (error.message.includes('Network')) {
            userMessage = 'Network error – check your connection.';
        } else if (error.message.includes('timeout')) {
            userMessage = 'Request timed out – try again.';
        } else if (error.message.includes('401')) {
            userMessage = 'Session expired – please log in again.';
        } else if (error.message.includes('404')) {
            userMessage = 'Resource not found.';
        }
    }
    if (ui) ui.showStatusBar(userMessage, 'error');
}

/**
 * PingOne Client Class
 * 
 * Manages PingOne API authentication and requests with Winston logging.
 */
class PingOneClient {
    constructor(logger, localClient) {
        if (!logger || !localClient) {
            throw new Error('PingOneClient: localClient and logger are required.');
        }
        this.logger = logger;
        this.localClient = localClient;
        this.accessToken = null;
        this.tokenExpiry = null;
        this.baseUrl = '/api/pingone';
        
        this.initialize();
    }
    
    /**
     * Initialize the client
     */
    initialize() {
        try {
            this.loadTokenFromStorage();
            this.logger.info('PingOne client initialized successfully');
        } catch (error) {
            this.logger.error('Failed to initialize PingOne client', { error: error.message });
        }
    }
    
    /**
     * Load token from localStorage
     */
    loadTokenFromStorage() {
        try {
            if (typeof localStorage !== 'undefined') {
                const storedToken = localStorage.getItem('pingone_worker_token');
                const storedExpiry = localStorage.getItem('pingone_token_expiry');
                
                if (storedToken && storedExpiry) {
                    const expiryTime = parseInt(storedExpiry, 10);
                    const now = Date.now();
                    
                    if (expiryTime > now) {
                        this.accessToken = storedToken;
                        this.tokenExpiry = expiryTime;
                        this.logger.info('Token loaded from storage', {
                            hasToken: !!this.accessToken,
                            expiryTime: new Date(this.tokenExpiry).toISOString()
                        });
                    } else {
                        this.logger.warn('Stored token has expired');
                        this.clearToken();
                    }
                } else {
                    this.logger.debug('No stored token found');
                }
            } else {
                this.logger.warn('localStorage is not available');
            }
        } catch (error) {
            this.logger.error('Error loading token from storage', { error: error.message });
        }
    }
    
    /**
     * Save token to localStorage
     */
    saveTokenToStorage(token, expiresIn) {
        try {
            if (typeof localStorage !== 'undefined') {
                const expiryTime = Date.now() + (expiresIn * 1000);
                
                localStorage.setItem('pingone_worker_token', token);
                localStorage.setItem('pingone_token_expiry', expiryTime.toString());
                
                this.accessToken = token;
                this.tokenExpiry = expiryTime;
                
                this.logger.info('Token saved to storage', {
                    tokenLength: token.length,
                    expiresIn,
                    expiryTime: new Date(expiryTime).toISOString()
                });
                
                return true;
            } else {
                this.logger.warn('localStorage is not available, cannot save token');
                return false;
            }
        } catch (error) {
            this.logger.error('Error saving token to storage', { error: error.message });
            return false;
        }
    }
    
    /**
     * Clear token from storage
     */
    clearToken() {
        try {
            if (typeof localStorage !== 'undefined') {
                localStorage.removeItem('pingone_worker_token');
                localStorage.removeItem('pingone_token_expiry');
            }
            
            this.accessToken = null;
            this.tokenExpiry = null;
            
            this.logger.info('Token cleared from storage');
        } catch (error) {
            this.logger.error('Error clearing token from storage', { error: error.message });
        }
    }
    
    /**
     * Update credentials and clear existing token
     * @param {Object} credentials - New credentials object
     */
    updateCredentials(credentials) {
        try {
            this.logger.info('Updating PingOne client credentials');
            
            // Clear existing token since credentials are changing
            this.clearToken();
            
            // Store new credentials in localStorage
            if (typeof localStorage !== 'undefined') {
                localStorage.setItem('pingone_credentials', JSON.stringify(credentials));
                this.logger.info('Credentials updated in localStorage');
            }
            
            // Trigger a custom event to notify other components
            window.dispatchEvent(new CustomEvent('credentials-updated', { 
                detail: { credentials } 
            }));
            
            this.logger.info('Credentials updated successfully');
        } catch (error) {
            this.logger.error('Error updating credentials', { error: error.message });
            throw error;
        }
    }
    
    /**
     * Get cached token (alias for getCurrentTokenTimeRemaining for compatibility)
     * Production-ready with comprehensive error handling and validation
     */
    getCachedToken() {
        try {
            // Validate token existence and format
            if (!this.accessToken || typeof this.accessToken !== 'string') {
                this.logger.debug('No valid cached token available');
                return null;
            }
            
            // Validate expiry timestamp
            if (!this.tokenExpiry || typeof this.tokenExpiry !== 'number') {
                this.logger.warn('Invalid token expiry timestamp');
                this.clearToken(); // Clean up invalid state
                return null;
            }
            
            const now = Date.now();
            const isExpired = this.tokenExpiry <= now;
            
            // Add buffer time (5 minutes) to prevent edge cases
            const bufferTime = 5 * 60 * 1000; // 5 minutes in milliseconds
            const isNearExpiry = (this.tokenExpiry - now) <= bufferTime;
            
            if (isExpired) {
                this.logger.debug('Cached token is expired');
                this.clearToken(); // Clean up expired token
                return null;
            }
            
            if (isNearExpiry) {
                this.logger.warn('Token is near expiry, consider refreshing');
            }
            
            // Validate token format (basic JWT structure check)
            if (!this.accessToken.includes('.') || this.accessToken.split('.').length !== 3) {
                this.logger.error('Invalid token format detected');
                this.clearToken(); // Clean up invalid token
                return null;
            }
            
            this.logger.debug('Returning valid cached token');
            return this.accessToken;
        } catch (error) {
            this.logger.error('Error getting cached token', { 
                error: error.message,
                stack: error.stack,
                tokenLength: this.accessToken ? this.accessToken.length : 0
            });
            // Don't expose token in logs for security
            return null;
        }
    }
    
    /**
     * Get current token time remaining
     */
    getCurrentTokenTimeRemaining() {
        try {
            if (!this.accessToken || !this.tokenExpiry) {
                return {
                    token: null,
                    timeRemaining: null,
                    isExpired: true
                };
            }
            
            const now = Date.now();
            const timeRemaining = Math.max(0, this.tokenExpiry - now);
            const isExpired = timeRemaining === 0;
            
            const timeRemainingFormatted = this.formatDuration(Math.floor(timeRemaining / 1000));
            
            // Only log debug message every 5 minutes (300000ms) to reduce noise
            const lastLogTime = this.lastTokenTimeLog || 0;
            const timeSinceLastLog = now - lastLogTime;
            
            if (timeSinceLastLog >= 300000) { // 5 minutes
                this.logger.debug('Token time remaining calculated', {
                    timeRemaining: timeRemainingFormatted,
                    isExpired
                });
                this.lastTokenTimeLog = now;
            }
            
            return {
                token: this.accessToken,
                timeRemaining: timeRemainingFormatted,
                isExpired
            };
        } catch (error) {
            this.logger.error('Error getting token time remaining', { error: error.message });
            return {
                token: null,
                timeRemaining: null,
                isExpired: true
            };
        }
    }
    
    /**
     * Format duration in human-readable format
     */
    formatDuration(seconds) {
        if (seconds <= 0) return 'Expired';
        
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const remainingSeconds = seconds % 60;
        
        if (hours > 0) {
            return `${hours}h ${minutes}m ${remainingSeconds}s`;
        } else if (minutes > 0) {
            return `${minutes}m ${remainingSeconds}s`;
        } else {
            return `${remainingSeconds}s`;
        }
    }
    
    /**
     * Get an access token using client credentials flow
     * @returns {Promise<string>} Access token
     */
    async getAccessToken() {
        try {
            this.logger.debug('getAccessToken called');
            
            // Check if we have a valid cached token
            const tokenInfo = this.getCurrentTokenTimeRemaining();
            if (tokenInfo.token && !tokenInfo.isExpired) {
                this.logger.debug('Using cached token', { 
                    tokenPreview: tokenInfo.token.substring(0, 8) + '...',
                    timeRemaining: tokenInfo.timeRemaining
                });
                return tokenInfo.token;
            }
            
            this.logger.debug('Fetching token from /api/pingone/get-token');
            
            // Fetch new token from server
            const response = await fetch('/api/pingone/get-token', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    // You can add additional parameters here if needed
                    // useOverrideCredentials: false
                })
            });
            
            this.logger.debug('Fetch response', { status: response.status, ok: response.ok });
            
            if (!response.ok) {
                const errorMsg = await response.text();
                this.logger.error('Fetch error', { status: response.status, error: errorMsg });
                throw new Error(`Failed to get token: ${response.status} ${errorMsg}`);
            }
            
            const data = await response.json();
            this.logger.debug('Data received from server', { 
                hasAccessToken: !!data.access_token,
                expiresIn: data.expires_in,
                success: data.success
            });
            
            if (!data.success) {
                this.logger.warn('Server returned error', { data });
                throw new Error(data.error || 'Failed to get token from server');
            }
            
            if (!data.access_token) {
                this.logger.warn('No access_token in server response', { data });
                throw new Error('No access token received from server');
            }
            
            // Save token to storage
            const tokenSaved = this.saveTokenToStorage(data.access_token, data.expires_in || 3600);
            
            if (tokenSaved) {
                this.logger.debug('Token saved to localStorage', {
                    tokenLength: data.access_token.length,
                    expiresIn: data.expires_in || 3600
                });
            } else {
                this.logger.warn('Failed to store token in localStorage');
            }
            
            return data.access_token;
            
        } catch (error) {
            this.logger.error('Error in getAccessToken', { error: error.message });
            throw error;
        }
    }
    
    /**
     * Make authenticated API request with retry logic
     */
    async makeRequest(method, url, data = null, retryAttempts = 3) {
        try {
            const token = await this.getAccessToken();
            
            for (let attempt = 1; attempt <= retryAttempts; attempt++) {
                try {
                    this.logger.debug(`Making API request (attempt ${attempt})`, { 
                        method, 
                        url,
                        hasData: !!data
                    });
                    
                    const requestOptions = {
                        method,
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        }
                    };
                    
                    if (data) {
                        requestOptions.body = JSON.stringify(data);
                    }
                    
                    const response = await fetch(`${this.baseUrl}${url}`, requestOptions);
                    
                    this.logger.debug(`API request completed (attempt ${attempt})`, {
                        status: response.status,
                        ok: response.ok
                    });
                    
                    if (response.ok) {
                        const responseData = await response.json();
                        return responseData;
                    } else {
                        const errorText = await response.text();
                        this.logger.warn(`API request failed (attempt ${attempt})`, {
                            status: response.status,
                            error: errorText
                        });
                        
                        if (attempt === retryAttempts) {
                            throw new Error(`API request failed: ${response.status} ${errorText}`);
                        }
                    }
                } catch (error) {
                    this.logger.error(`API request error (attempt ${attempt})`, { error: error.message });
                    
                    if (attempt === retryAttempts) {
                        throw error;
                    }
                    
                    // Wait before retry
                    await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                }
            }
        } catch (error) {
            this.logger.error('All API request attempts failed', { error: error.message });
            throw error;
        }
    }
    
    /**
     * Get populations from PingOne API
     */
    async getPopulations(options = {}) {
        try {
            this.logger.info('Getting populations from PingOne API');
            
            const url = '/api/pingone/populations';
            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            if (!response.ok) {
                throw new Error(`Failed to fetch populations: ${response.status} ${response.statusText}`);
            }
            
            return response;
            
        } catch (error) {
            this.logger.error('Failed to get populations', { error: error.message });
            throw error;
        }
    }

    /**
     * Import users from CSV data
     */
    async importUsers(csvData, options = {}) {
        try {
            this.logger.info('importUsers method called', { 
                userCount: csvData.length,
                options: Object.keys(options)
            });
            
            const {
                populationId = null,
                batchSize = 10,
                retryAttempts = 3,
                enableUsers = true,
                skipDuplicatesByEmail = false,
                skipDuplicatesByUsername = false
            } = options;
            
            this.logger.debug('Initial setup completed', { batchSize, retryAttempts, enableUsers, skipDuplicatesByEmail, skipDuplicatesByUsername });
            
            // Validate input
            if (!csvData || !Array.isArray(csvData) || csvData.length === 0) {
                throw new Error('Invalid CSV data: must be a non-empty array');
            }
            
            this.logger.debug('Input validation completed');
            
            // Handle population selection
            let fallbackPopulationId = populationId;
            
            if (!fallbackPopulationId) {
                const populationSelect = document.getElementById('import-population-select');
                if (populationSelect && populationSelect.value) {
                    fallbackPopulationId = populationSelect.value;
                    this.logger.debug('Using selected population from dropdown', { fallbackPopulationId });
                } else {
                    // Try to get from settings
                    const settings = JSON.parse(localStorage.getItem('pingone-import-settings') || '{}');
                    fallbackPopulationId = settings.populationId;
                    this.logger.debug('Using default population from settings', { fallbackPopulationId });
                }
            }
            
            // Prepare sets for duplicate detection
            const seenEmails = new Set();
            const seenUsernames = new Set();
            
            // Process users in batches
            const totalUsers = csvData.length;
            const results = {
                success: true,
                processed: 0,
                created: 0,
                skipped: 0,
                failed: 0,
                errors: []
            };
            
            this.logger.debug('Starting user processing loop...');
            
            for (let i = 0; i < totalUsers; i += batchSize) {
                const batch = csvData.slice(i, i + batchSize);
                this.logger.debug(`Processing batch ${Math.floor(i/batchSize) + 1}`, { 
                    users: `${i+1}-${Math.min(i+batchSize, totalUsers)}`,
                    batchSize: batch.length
                });
                
                for (const user of batch) {
                    try {
                        const userPopulationId = user.populationId || fallbackPopulationId;
                        
                        if (!userPopulationId) {
                            const error = `Missing population – user not processed. Username: ${user.email || user.username}`;
                            results.errors.push(error);
                            results.skipped++;
                            continue;
                        }
                        
                        // Duplicate detection
                        if (skipDuplicatesByEmail && user.email) {
                            if (seenEmails.has(user.email.toLowerCase())) {
                                this.logger.info(`Skipping duplicate user by email: ${user.email}`);
                                results.skipped++;
                                continue;
                            }
                            seenEmails.add(user.email.toLowerCase());
                        }
                        if (skipDuplicatesByUsername && user.username) {
                            if (seenUsernames.has(user.username.toLowerCase())) {
                                this.logger.info(`Skipping duplicate user by username: ${user.username}`);
                                results.skipped++;
                                continue;
                            }
                            seenUsernames.add(user.username.toLowerCase());
                        }
                        
                        // Create user
                        const userData = {
                            username: user.username || user.email,
                            email: user.email,
                            name: {
                                given: user.firstName || user.givenName || '',
                                family: user.lastName || user.familyName || ''
                            },
                            enabled: enableUsers,
                            population: {
                                id: userPopulationId
                            }
                        };
                        
                        // Add optional fields
                        if (user.phoneNumber) userData.phoneNumber = user.phoneNumber;
                        if (user.company) userData.company = user.company;
                        
                        const result = await this.createUser(userData, retryAttempts);
                        
                        if (result.success) {
                            results.created++;
                            // Disable user if requested
                            if (!enableUsers && result.userId) {
                                this.logger.debug(`Disabling user ${result.userId} after creation`);
                                try {
                                    await this.makeRequest('PATCH', `/environments/current/users/${result.userId}`, {
                                        enabled: false
                                    });
                                    this.logger.debug(`Successfully disabled user ${result.userId}`);
                                } catch (statusError) {
                                    this.logger.warn(`Failed to disable user ${result.userId}`, { error: statusError.message });
                                }
                            }
                        } else {
                            results.failed++;
                            results.errors.push(result.error);
                        }
                        
                        results.processed++;
                        
                    } catch (error) {
                        results.failed++;
                        results.errors.push(error.message);
                    }
                }
            }
            
            this.logger.info('Batch import summary', {
                total: totalUsers,
                processed: results.processed,
                created: results.created,
                skipped: results.skipped,
                failed: results.failed
            });
            
            return results;
            
        } catch (error) {
            this.logger.error('Import users failed', { error: error.message });
            throw error;
        }
    }
    
    /**
     * Create a single user
     */
    async createUser(userData, retryAttempts = 3) {
        try {
            for (let attempt = 1; attempt <= retryAttempts; attempt++) {
                try {
                    this.logger.debug(`Making API request for user ${userData.email || userData.username} (attempt ${attempt}/${retryAttempts})`);
                    
                    const result = await this.makeRequest('POST', '/environments/current/users', userData);
                    
                    this.logger.debug(`API request completed for user ${userData.email || userData.username}`);
                    
                    if (result.id) {
                        const successMessage = `Successfully created user: ${userData.username || userData.email}`;
                        this.logger.info(successMessage, { userId: result.id, populationId: userData.population.id });
                        
                        return {
                            success: true,
                            userId: result.id,
                            user: result
                        };
                    } else {
                        this.logger.warn('Invalid response structure - no ID found', { result });
                        return {
                            success: false,
                            error: 'Invalid response structure'
                        };
                    }
                    
                } catch (error) {
                    if (error.message.includes('already exists')) {
                        this.logger.debug(`User already exists: ${userData.email || userData.username}`);
                        return {
                            success: true,
                            userId: null,
                            user: null,
                            message: 'User already exists'
                        };
                    }
                    
                    this.logger.error(`API request failed for user ${userData.email || userData.username} (attempt ${attempt})`, { error: error.message });
                    
                    if (attempt === retryAttempts) {
                        return {
                            success: false,
                            error: error.message
                        };
                    }
                    
                    // Wait before retry
                    await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                }
            }
        } catch (error) {
            this.logger.error('Create user failed', { error: error.message, userData });
            return {
                success: false,
                error: error.message
            };
        }
    }
}

// Export the class
export { PingOneClient };


/* From: public/js/modules/pingone-api.js */
const TokenManager = require('./token-manager.js');

class PingOneAPI {
    constructor(logger, settingsManager) {
        this.logger = logger;
        this.settingsManager = settingsManager;
        this.tokenManager = new TokenManager(logger, this.getCurrentSettings());
    }
    
    /**
     * Get the base URL for the PingOne API based on region code
     * @param {string} regionCode - The region code (e.g., 'NA', 'CA', 'EU', 'AU', 'SG', 'AP')
     * @returns {string} The base URL for the API
     */
    getApiBaseUrl(regionCode) {
        const regionInfo = this.settingsManager.constructor.getRegionInfo(regionCode);
        const tld = regionInfo.tld;
        // Compose the base URL
        if (regionCode === 'NA') return `https://api.pingone.com/v1`;
        if (regionCode === 'CA') return `https://api.ca.pingone.ca/v1`;
        if (regionCode === 'EU') return `https://api.eu.pingone.eu/v1`;
        if (regionCode === 'AU') return `https://api.au.pingone.com.au/v1`;
        if (regionCode === 'SG') return `https://api.sg.pingone.sg/v1`;
        if (regionCode === 'AP') return `https://api.ap.pingone.asia/v1`;
        // Fallback to NA
        return `https://api.pingone.com/v1`;
    }
    
    /**
     * Get current settings from settings manager
     * @returns {Object} Current settings
     */
    getCurrentSettings() {
        return {
            apiClientId: this.settingsManager.getSetting('apiClientId'),
            apiSecret: this.settingsManager.getSetting('apiSecret'),
            environmentId: this.settingsManager.getSetting('environmentId'),
            region: this.settingsManager.getSetting('region', 'NorthAmerica')
        };
    }

    /**
     * Get an access token using client credentials flow
     * @returns {Promise<string>} Access token
     */
    async getAccessToken() {
        try {
            // Update token manager with latest settings
            this.tokenManager.updateSettings(this.getCurrentSettings());
            return await this.tokenManager.getAccessToken();
        } catch (error) {
            this.logger.error(`Failed to get access token: ${error.message}`);
            throw error;
        }
    }
    
    /**
     * Clear the current token (force a new one to be fetched on next request)
     */
    clearToken() {
        this.tokenManager.clearToken();
    }

    /**
     * Get all populations from PingOne
     * @returns {Promise<Array>} Array of population objects
     */
    async getPopulations() {
        try {
            const response = await this.apiRequest('GET', '/populations');
            return response._embedded.populations || [];
        } catch (error) {
            this.logger.error('Failed to get populations:', error);
            throw error;
        }
    }

    /**
     * Get the default population ID
     * @returns {Promise<string>} The default population ID
     */
    async getDefaultPopulationId() {
        try {
            const populations = await this.getPopulations();
            
            // First try to find a population with 'default' in the name
            const defaultPop = populations.find(pop => 
                pop.name && pop.name.toLowerCase().includes('default'));
                
            if (defaultPop) {
                return defaultPop.id;
            }
            
            // If no default found, return the first population ID
            if (populations.length > 0) {
                return populations[0].id;
            }
            
            throw new Error('No populations found');
        } catch (error) {
            this.logger.error('Failed to get default population ID:', error);
            throw error;
        }
    }

    /**
     * Update the API settings and refresh the token manager
     * @param {Object} settings - New settings object
     */
    updateSettings(settings) {
        // Update settings in settings manager
        Object.entries(settings).forEach(([key, value]) => {
            this.settingsManager.setSetting(key, value);
        });
        
        // Update token manager with new settings
        this.tokenManager.updateSettings(this.getCurrentSettings());
        
        // Clear any existing token to force refresh
        this.clearToken();
    }
    
    /**
     * Make an authenticated API request
     * @param {string} method - HTTP method (GET, POST, PUT, DELETE, etc.)
     * @param {string} endpoint - API endpoint (without base URL)
     * @param {Object} [data] - Request body (for POST/PUT/PATCH)
     * @param {Object} [options] - Additional options
     * @param {AbortSignal} [options.signal] - Abort signal for request cancellation
     * @returns {Promise<Object>} Response data
     */
    async apiRequest(method, endpoint, data = null, options = {}) {
        const settings = this.getCurrentSettings();
        
        // For PingOne API calls, use the proxy endpoint
        const isPingOneApi = endpoint.startsWith('/v1/');
        const url = isPingOneApi ? `/api/proxy${endpoint}` : endpoint;
        
        // Prepare headers
        const requestHeaders = {
            'Accept': 'application/json',
            ...options.headers
        };
        
        // Add Authorization header for PingOne API calls
        if (isPingOneApi) {
            requestHeaders['Authorization'] = `Bearer ${await this.getAccessToken()}`;
        }
        
        // Set content type based on the request
        if (method !== 'GET' && method !== 'HEAD') {
            if (endpoint.endsWith('/users') && method === 'POST') {
                requestHeaders['Content-Type'] = 'application/vnd.pingidentity.user.import+json';
            } else if (!requestHeaders['Content-Type']) {
                requestHeaders['Content-Type'] = 'application/json';
            }
        }
        
        // Log the request details
        console.log('=== API REQUEST ===');
        console.log('Method:', method);
        console.log('URL:', url);
        console.log('Endpoint:', endpoint);
        
        const headers = {
            'Authorization': `Bearer ${await this.getAccessToken()}`,
            'Accept': 'application/json',
            ...options.headers
        };
        
        console.log('Headers:', JSON.stringify(headers, null, 2));
        
        let requestBody = null;
        const requestContentType = headers['Content-Type'] || 'application/json';
        
        // Set Content-Type header based on the content type
        headers['Content-Type'] = requestContentType;
        
        console.log('Request Content Type:', requestContentType);
        
        // For user import, format the request body
        if (requestContentType === 'application/vnd.pingidentity.user.import+json') {
            console.log('Processing user import request');
            requestBody = JSON.stringify(data);
            console.log('Request Body:', requestBody);
        } else if (requestContentType === 'application/json') {
            requestBody = JSON.stringify(data);
            console.log('Request Body:', requestBody);
        } else {
            requestBody = data;
            console.log('Request Body (raw):', requestBody);
        }
        
        // Prepare fetch options with CORS mode
        const fetchOptions = {
            method,
            headers: requestHeaders,
            body: requestBody,
            mode: 'cors',
            credentials: 'omit' // Don't send cookies with CORS requests
        };
        
        // For preflight requests, ensure the content type is set correctly
        if (method === 'OPTIONS') {
            fetchOptions.headers['Access-Control-Request-Method'] = method;
            fetchOptions.headers['Access-Control-Request-Headers'] = 'authorization,content-type';
        }
        
        // Make the request
        try {
            console.log('Sending request to proxy:', url);
            const response = await fetch(url, fetchOptions);
            
            // Clone the response so we can read it multiple times if needed
            const responseClone = response.clone();
            
            // Log response status
            console.log('Response Status:', response.status, response.statusText);
            
            // Handle non-2xx responses
            if (!response.ok) {
                let errorMessage = `Request failed with status ${response.status}`;
                try {
                    const errorData = await responseClone.json();
                    console.error('Error response:', JSON.stringify(errorData, null, 2));
                    errorMessage = errorData.detail || errorData.message || JSON.stringify(errorData);
                } catch (e) {
                    console.error('Failed to parse error response:', e);
                    const text = await responseClone.text();
                    console.error('Raw error response:', text);
                    errorMessage = `${response.status} ${response.statusText}`;
                }
                
                const error = new Error(errorMessage);
                error.status = response.status;
                error.response = response;
                throw error;
            }
            
            // For 204 No Content responses, return null
            if (response.status === 204) {
                return null;
            }
            
            // Parse and return JSON response
            const responseData = await response.json();
            console.log('Response Data:', JSON.stringify(responseData, null, 2));
            return responseData;
            
        } catch (error) {
            console.error('API request failed:', error);
            if (error.response) {
                try {
                    const errorData = await error.response.json();
                    console.error('Error details:', errorData);
                } catch (e) {
                    console.error('Could not parse error response:', e);
                }
            }
            throw error;
        }
    }
    
    /**
     * Get a list of users
     * @param {Object} [params] - Query parameters
     * @returns {Promise<Array>} List of users
     */
    async getUsers(params = {}) {
        const query = new URLSearchParams(params).toString();
        return this.apiRequest('GET', `/users${query ? `?${query}` : ''}`);
    }

    /**
     * Create a new user
     * @param {Object} userData - User data
     * @returns {Promise<Object>} Created user
     */
    async createUser(userData) {
        return this.apiRequest('POST', '/users', userData);
    }

    /**
     * Update an existing user
     * @param {string} userId - User ID
     * @param {Object} userData - Updated user data
     * @returns {Promise<Object>} Updated user
     */
    async updateUser(userId, userData) {
        return this.apiRequest('PUT', `/users/${userId}`, userData);
    }

    /**
     * Delete a user
     * @param {string} userId - User ID
     * @returns {Promise<void>}
     */
    async deleteUser(userId) {
        return this.apiRequest('DELETE', `/users/${userId}`);
    }

    /**
     * Get user by ID
     * @param {string} userId - User ID
     * @returns {Promise<Object>} User data
     */
    async getUser(userId) {
        return this.apiRequest('GET', `/users/${userId}`);
    }

    /**
     * Search for users
     * @param {Object} filter - Filter criteria
     * @returns {Promise<Array>} Matching users
     */
    async searchUsers(filter) {
        return this.apiRequest('POST', '/users/.search', { filter });
    }

    /**
     * Check if a user with the given email already exists in PingOne
     * @param {string} email - User email to check
     * @returns {Promise<boolean>} True if user exists, false otherwise
     */
    async userExists(email) {
        try {
            const users = await this.searchUsers({ email: { $eq: email } });
            return users.length > 0;
        } catch (error) {
            this.logger.error(`Error checking if user exists (${email}):`, error);
            throw error;
        }
    }

    /**
     * Helper to get field value case-insensitively
     */
    getField(obj, possibleNames, defaultValue = '') {
        if (!obj) return defaultValue;
        
        const key = Object.keys(obj).find(k => 
            possibleNames.map(n => n.toLowerCase()).includes(k.toLowerCase())
        );
        
        return key ? obj[key] : defaultValue;
    }

    /**
     * Import multiple users
     * @param {Array<Object>} users - Array of user objects to import
     * @param {Object} [options] - Import options
     * @param {boolean} [options.skipExisting=false] - Whether to skip users that already exist
     * @param {boolean} [options.skipErrors=false] - Whether to continue on error
     * @param {string} [options.populationId] - Population ID to assign users to
     * @returns {Promise<Object>} Import results
     */
    /**
     * Import multiple users into PingOne
     * @param {Array<Object>} users - Array of user objects to import
     * @param {Object} [options] - Import options
     * @param {boolean} [options.skipExisting=false] - Whether to skip users that already exist
     * @param {boolean} [options.continueOnError=false] - Whether to continue on error
     * @param {string} [options.populationId] - Population ID to assign users to
     * @returns {Promise<Object>} Import results
     */
    async importUsers(users, options = {}, signal = null) {
        if (!users || !Array.isArray(users) || users.length === 0) {
            throw new Error('No users provided for import');
        }

        const results = [];
        const populationId = options.populationId || await this.getDefaultPopulationId();
        
        if (!populationId) {
            throw new Error('No population ID provided and no default population found');
        }

        this.logger.log(`Starting import of ${users.length} users to population ${populationId}`, 'info');

        for (const [index, user] of users.entries()) {
            try {
                // Format user data according to PingOne API requirements
                const userData = {
                    name: {
                        given: this.getField(user, ['firstName', 'givenName', 'firstname', 'first_name', 'first']) || '',
                        family: this.getField(user, ['lastName', 'familyName', 'lastname', 'last_name', 'last']) || ''
                    },
                    email: this.getField(user, ['email', 'mail', 'Email', 'e-mail']),
                    username: this.getField(user, ['username', 'userName', 'login', 'user']) || user.email,
                    population: { id: populationId },
                    password: {
                        value: this.getField(user, ['password', 'pwd', 'pass']) || this.generateTemporaryPassword()
                    },
                    enabled: user.enabled !== false
                };

                // Add phone number if available
                const phone = this.getField(user, ['phone', 'mobile', 'mobilePhone', 'phoneNumber']);
                if (phone) {
                    userData.phoneNumbers = [{
                        type: 'mobile',
                        value: phone
                    }];
                }

                // Skip if user exists and skipExisting is true
                if (options.skipExisting) {
                    const exists = await this.userExists(userData.email);
                    if (exists) {
                        results.push({
                            success: true,
                            skipped: true,
                            user: userData.email,
                            message: 'User already exists'
                        });
                        continue;
                    }
                }

                // Make the API request to create the user
                const response = await this.apiRequest('POST', '/users', userData, {
                    headers: {
                        'Content-Type': 'application/vnd.pingidentity.user.import+json',
                        'Accept': 'application/json'
                    },
                    signal
                });

                results.push({
                    success: true,
                    userId: response.id,
                    email: userData.email,
                    details: response
                });

            } catch (error) {
                this.logger.error(`Error importing user at index ${index}:`, error);
                
                let errorMessage = error.message;
                if (error.response) {
                    try {
                        const errorData = await error.response.json();
                        errorMessage = errorData.detail || errorData.message || JSON.stringify(errorData);
                    } catch (e) {
                        errorMessage = `${error.response.status} ${error.response.statusText}`;
                    }
                }

                results.push({
                    success: false,
                    email: user.email || `user_${index}`,
                    error: errorMessage,
                    details: error.response?.data || error
                });

                if (!options.continueOnError) {
                    throw error;
                }
            }
        }

        const successful = results.filter(r => r.success);
        const failed = results.filter(r => !r.success);
        
        return {
            total: users.length,
            successful: successful.length,
            failed: failed.length,
            skipped: results.filter(r => r.skipped).length,
            results
        };
    }

    /**
     * Generate a secure random password
     * @returns {string} A random password
     * @private
     */
    generateTemporaryPassword() {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()';
        let password = '';
        for (let i = 0; i < 16; i++) {
            password += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return password;
    }
}

// ES Modules export
export { PingOneAPI };
export default PingOneAPI;



/* From: public/js/modules/api-factory.js */
/**
 * API Factory - Creates API clients with automatic token re-authentication
 * 
 * This module provides a factory for creating API clients that automatically
 * handle token expiration by detecting 401 responses and retrying with new tokens
 * using stored credentials.
 */

import TokenManager from './token-manager.js';
import { LocalAPIClient, localAPIClient } from './local-api-client.js';
import { PingOneClient } from './pingone-client.js';

/**
 * Create an API client with automatic token re-authentication
 * @param {Object} settings - API settings including credentials
 * @param {Object} logger - Logger instance
 * @returns {Object} API client with auto-retry capabilities
 */
export function createAutoRetryAPIClient(settings, logger) {
    if (!settings) {
        throw new Error('Settings are required for API client creation');
    }
    
    const tokenManager = new TokenManager(logger, settings);
    
    /**
     * Make an API request with automatic token re-authentication
     * @param {string} url - The API endpoint URL
     * @param {Object} options - Request options
     * @returns {Promise<Object>} The API response
     */
    async function makeRequest(url, options = {}) {
        if (!url) {
            throw new Error('URL is required for API request');
        }
        
        return await tokenManager.retryWithNewToken(async (token) => {
            const requestOptions = {
                ...options,
                headers: {
                    ...options.headers,
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                }
            };
            
            const response = await fetch(url, requestOptions);
            
            // Check for token expiration
            if (response.status === 401) {
                const responseText = await response.text().catch(() => '');
                const isTokenExpired = responseText.includes('token_expired') || 
                                     responseText.includes('invalid_token') ||
                                     responseText.includes('expired');
                
                if (isTokenExpired) {
                    throw new Error('TOKEN_EXPIRED');
                }
            }
            
            return response;
        });
    }
    
    /**
     * GET request with auto-retry
     * @param {string} url - The API endpoint URL
     * @param {Object} options - Request options
     * @returns {Promise<Object>} The API response
     */
    async function get(url, options = {}) {
        if (!url) {
            throw new Error('URL is required for GET request');
        }
        
        return await makeRequest(url, { ...options, method: 'GET' });
    }
    
    /**
     * POST request with auto-retry
     * @param {string} url - The API endpoint URL
     * @param {Object} data - Request body data
     * @param {Object} options - Request options
     * @returns {Promise<Object>} The API response
     */
    async function post(url, data = null, options = {}) {
        if (!url) {
            throw new Error('URL is required for POST request');
        }
        
        const requestOptions = { ...options, method: 'POST' };
        
        if (data) {
            requestOptions.body = JSON.stringify(data);
        }
        
        return await makeRequest(url, requestOptions);
    }
    
    /**
     * PUT request with auto-retry
     * @param {string} url - The API endpoint URL
     * @param {Object} data - Request body data
     * @param {Object} options - Request options
     * @returns {Promise<Object>} The API response
     */
    async function put(url, data = null, options = {}) {
        if (!url) {
            throw new Error('URL is required for PUT request');
        }
        
        const requestOptions = { ...options, method: 'PUT' };
        
        if (data) {
            requestOptions.body = JSON.stringify(data);
        }
        
        return await makeRequest(url, requestOptions);
    }
    
    /**
     * DELETE request with auto-retry
     * @param {string} url - The API endpoint URL
     * @param {Object} options - Request options
     * @returns {Promise<Object>} The API response
     */
    async function del(url, options = {}) {
        if (!url) {
            throw new Error('URL is required for DELETE request');
        }
        
        return await makeRequest(url, { ...options, method: 'DELETE' });
    }
    
    /**
     * PATCH request with auto-retry
     * @param {string} url - The API endpoint URL
     * @param {Object} data - Request body data
     * @param {Object} options - Request options
     * @returns {Promise<Object>} The API response
     */
    async function patch(url, data = null, options = {}) {
        if (!url) {
            throw new Error('URL is required for PATCH request');
        }
        
        const requestOptions = { ...options, method: 'PATCH' };
        
        if (data) {
            requestOptions.body = JSON.stringify(data);
        }
        
        return await makeRequest(url, requestOptions);
    }
    
    /**
     * Get token information
     * @returns {Object|null} Token info
     */
    function getTokenInfo() {
        return tokenManager.getTokenInfo();
    }
    
    /**
     * Update settings and clear token cache if credentials changed
     * @param {Object} newSettings - New settings
     */
    function updateSettings(newSettings) {
        if (!newSettings) {
            throw new Error('New settings are required');
        }
        
        tokenManager.updateSettings(newSettings);
    }
    
    return {
        get,
        post,
        put,
        del,
        patch,
        getTokenInfo,
        updateSettings,
        tokenManager
    };
}

/**
 * Create a PingOne API client with automatic token re-authentication
 * @param {Object} settings - PingOne API settings
 * @param {Object} logger - Logger instance
 * @returns {Object} PingOne API client
 */
export function createPingOneAPIClient(settings, logger) {
    if (!settings) {
        throw new Error('Settings are required for PingOne API client creation');
    }
    
    if (!settings.environmentId) {
        throw new Error('Environment ID is required for PingOne API client');
    }
    
    const baseURL = getPingOneBaseURL(settings.region);
    const apiClient = createAutoRetryAPIClient(settings, logger);
    
    /**
     * Get PingOne base URL for the region
     * @param {string} region - The region
     * @returns {string} Base URL
     */
    function getPingOneBaseURL(region) {
        const baseURLs = {
            'NorthAmerica': 'https://api.pingone.com',
            'Europe': 'https://api.eu.pingone.com',
            'Canada': 'https://api.ca.pingone.com',
            'Asia': 'https://api.apsoutheast.pingone.com',
            'Australia': 'https://api.aus.pingone.com',
            'US': 'https://api.pingone.com',
            'EU': 'https://api.eu.pingone.com',
            'AP': 'https://api.apsoutheast.pingone.com'
        };
        return baseURLs[region] || 'https://api.pingone.com';
    }
    
    /**
     * Make a PingOne API request
     * @param {string} endpoint - API endpoint (without base URL)
     * @param {Object} options - Request options
     * @returns {Promise<Object>} The API response
     */
    async function pingOneRequest(endpoint, options = {}) {
        if (!endpoint) {
            throw new Error('Endpoint is required for PingOne request');
        }
        
        const url = `${baseURL}/v1${endpoint}`;
        return await apiClient.makeRequest(url, options);
    }
    
    /**
     * Get users from PingOne
     * @param {Object} options - Query options
     * @returns {Promise<Object>} Users response
     */
    async function getUsers(options = {}) {
        const queryParams = new URLSearchParams(options).toString();
        const endpoint = `/environments/${settings.environmentId}/users${queryParams ? `?${queryParams}` : ''}`;
        return await pingOneRequest(endpoint, { method: 'GET' });
    }
    
    /**
     * Create user in PingOne
     * @param {Object} userData - User data
     * @returns {Promise<Object>} Create user response
     */
    async function createUser(userData) {
        if (!userData) {
            throw new Error('User data is required for user creation');
        }
        
        const endpoint = `/environments/${settings.environmentId}/users`;
        return await pingOneRequest(endpoint, { 
            method: 'POST',
            body: JSON.stringify(userData)
        });
    }
    
    /**
     * Update user in PingOne
     * @param {string} userId - User ID
     * @param {Object} userData - User data
     * @returns {Promise<Object>} Update user response
     */
    async function updateUser(userId, userData) {
        if (!userId) {
            throw new Error('User ID is required for user update');
        }
        
        if (!userData) {
            throw new Error('User data is required for user update');
        }
        
        const endpoint = `/environments/${settings.environmentId}/users/${userId}`;
        return await pingOneRequest(endpoint, { 
            method: 'PUT',
            body: JSON.stringify(userData)
        });
    }
    
    /**
     * Delete user from PingOne
     * @param {string} userId - User ID
     * @returns {Promise<Object>} Delete user response
     */
    async function deleteUser(userId) {
        if (!userId) {
            throw new Error('User ID is required for user deletion');
        }
        
        const endpoint = `/environments/${settings.environmentId}/users/${userId}`;
        return await pingOneRequest(endpoint, { method: 'DELETE' });
    }
    
    /**
     * Get populations from PingOne
     * @param {Object} options - Query options
     * @returns {Promise<Object>} Populations response
     */
    async function getPopulations(options = {}) {
        const queryParams = new URLSearchParams(options).toString();
        const endpoint = `/environments/${settings.environmentId}/populations${queryParams ? `?${queryParams}` : ''}`;
        return await pingOneRequest(endpoint, { method: 'GET' });
    }
    
    /**
     * Create population in PingOne
     * @param {Object} populationData - Population data
     * @returns {Promise<Object>} Create population response
     */
    async function createPopulation(populationData) {
        if (!populationData) {
            throw new Error('Population data is required for population creation');
        }
        
        const endpoint = `/environments/${settings.environmentId}/populations`;
        return await pingOneRequest(endpoint, { 
            method: 'POST',
            body: JSON.stringify(populationData)
        });
    }
    
    /**
     * Delete population from PingOne
     * @param {string} populationId - Population ID
     * @returns {Promise<Object>} Delete population response
     */
    async function deletePopulation(populationId) {
        if (!populationId) {
            throw new Error('Population ID is required for population deletion');
        }
        
        const endpoint = `/environments/${settings.environmentId}/populations/${populationId}`;
        return await pingOneRequest(endpoint, { method: 'DELETE' });
    }
    
    return {
        // API methods
        getUsers,
        createUser,
        updateUser,
        deleteUser,
        getPopulations,
        createPopulation,
        deletePopulation,
        
        // Token management
        getTokenInfo: apiClient.getTokenInfo,
        updateSettings: apiClient.updateSettings,
        
        // Raw request method
        request: pingOneRequest
    };
}

/**
 * API Factory class - Backward compatibility
 */
class APIFactory {
    /**
     * Create a new APIFactory instance
     * @param {Object} logger - Logger instance
     * @param {Object} settingsManager - Settings manager instance
     */
    constructor(logger, settingsManager) {
        if (!settingsManager) {
            throw new Error('Settings manager is required for API factory');
        }
        
        this.logger = logger || console;
        this.settingsManager = settingsManager;
        this.clients = new Map();
    }

    /**
     * Get or create a PingOne API client
     * @returns {PingOneClient} PingOne API client instance
     */
    getPingOneClient() {
        if (!this.clients.has('pingone')) {
            this.clients.set('pingone', new PingOneClient(this.logger, this.settingsManager));
        }
        return this.clients.get('pingone');
    }

    /**
     * Get or create a local API client
     * @param {string} [baseUrl=''] - Base URL for the API
     * @returns {LocalAPIClient} Local API client instance
     */
    getLocalClient(baseUrl = '') {
        const cacheKey = `local_${baseUrl}`;
        if (!this.clients.has(cacheKey)) {
            this.clients.set(cacheKey, new LocalAPIClient(this.logger, baseUrl));
        }
        return this.clients.get(cacheKey);
    }

    /**
     * Get the default local API client (singleton)
     * @returns {LocalAPIClient} Default local API client instance
     */
    getDefaultLocalClient() {
        return localAPIClient;
    }
}

// Create a singleton instance but don't export it directly
let _apiFactoryInstance = null;
let isInitializing = false;
let initializationPromise = null;

/**
 * Initialize the API factory with required dependencies
 * @param {Object} logger - Logger instance
 * @param {Object} settingsManager - Settings manager instance
 * @returns {Promise<APIFactory>} Initialized API factory instance
 */
const initAPIFactory = async (logger, settingsManager) => {
    // If already initialized, return the existing instance
    if (_apiFactoryInstance) {
        return _apiFactoryInstance;
    }
    
    // If initialization is in progress, wait for it to complete
    if (isInitializing) {
        if (initializationPromise) {
            return initializationPromise;
        }
    }
    
    // Set initialization flag and create a new promise
    isInitializing = true;
    initializationPromise = new Promise(async (resolve, reject) => {
        try {
            // Create the factory instance
            const factory = new APIFactory(logger, settingsManager);
            
            // Set the instance
            _apiFactoryInstance = factory;
            defaultAPIFactory = factory;
            
            // Log successful initialization
            if (logger && logger.info) {
                logger.info('API Factory initialized successfully');
            } else {
                console.log('API Factory initialized successfully');
            }
            
            resolve(factory);
        } catch (error) {
            const errorMsg = `Failed to initialize API Factory: ${error.message}`;
            if (logger && logger.error) {
                logger.error(errorMsg, { error });
            } else {
                console.error(errorMsg, error);
            }
            reject(new Error(errorMsg));
        } finally {
            isInitializing = false;
            initializationPromise = null;
        }
    });
    
    return initializationPromise;
};

// Export the singleton instance and initialization function
export { APIFactory, initAPIFactory };

// For backward compatibility, export a default instance (will be initialized when initAPIFactory is called)
let defaultAPIFactory = null;

/**
 * API Factory singleton for backward compatibility
 */
export const apiFactory = {
    /**
     * Get PingOne client
     * @returns {PingOneClient} PingOne API client
     * @throws {Error} If API factory is not initialized
     */
    getPingOneClient: () => {
        if (!defaultAPIFactory) {
            throw new Error('API Factory not initialized. Call initAPIFactory() first.');
        }
        return defaultAPIFactory.getPingOneClient();
    },
    
    /**
     * Get local client
     * @param {string} [baseUrl=''] - Base URL for the API
     * @returns {LocalAPIClient} Local API client
     * @throws {Error} If API factory is not initialized
     */
    getLocalClient: (baseUrl = '') => {
        if (!defaultAPIFactory) {
            throw new Error('API Factory not initialized. Call initAPIFactory() first.');
        }
        return defaultAPIFactory.getLocalClient(baseUrl);
    }
};

/**
 * Get the default API factory instance
 * @returns {APIFactory|null} The default API factory instance
 */
export const getAPIFactory = () => defaultAPIFactory;

export default {
    createAutoRetryAPIClient,
    createPingOneAPIClient,
    initAPIFactory,
    apiFactory
};



/* From: public/js/modules/safe-api.js */
/**
 * @module
 * @description ES Module (converted from CommonJS)
 */


/**
 * Safe API Wrappers - Prevents common API misuse bugs
 */
class SafeAPI {
    static parseJSON(jsonString, defaultValue = null) {
        try {
            if (typeof jsonString !== 'string' || jsonString.trim() === '') {
                return defaultValue;
            }
            return JSON.parse(jsonString);
        } catch (error) {
            console.error('JSON parse error:', error.message);
            return defaultValue;
        }
    }

    static getElement(selector, context = document) {
        try {
            const element = context.querySelector(selector);
            if (!element) {
                console.warn(`Element not found: ${selector}`);
            }
            return element;
        } catch (error) {
            console.error('Selector error:', error.message);
            return null;
        }
    }

    static getElements(selector, context = document) {
        try {
            return Array.from(context.querySelectorAll(selector));
        } catch (error) {
            console.error('Selector error:', error.message);
            return [];
        }
    }

    static parseInt(value, defaultValue = 0) {
        const result = parseInt(value, 10);
        return isNaN(result) ? defaultValue : result;
    }

    static async safeFetch(url, options = {}, timeout = 10000) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        
        try {
            const response = await fetch(url, {
                ...options,
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            return response;
        } catch (error) {
            clearTimeout(timeoutId);
            if (error.name === 'AbortError') {
                throw new Error(`Request timeout: ${url}`);
            }
            throw error;
        }
    }
}

// Make available globally
window.SafeAPI = SafeAPI;
window.safeParseJSON = SafeAPI.parseJSON;
window.getElement = SafeAPI.getElement;
window.getElements = SafeAPI.getElements;
window.safeParseInt = SafeAPI.parseInt;
window.safeFetch = SafeAPI.safeFetch;


