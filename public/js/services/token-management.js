/**
 * Token management Module
 * 
 * Consolidated JavaScript for PingOne Import Tool
 * Generated: 2025-08-06T19:08:20.700Z
 * 
 * This file was automatically generated by js-final-cleanup.js
 * Organized for better maintainability and performance
 */


/* From: public/js/modules/token-manager.js */
/**
 * TokenManager - Handles OAuth 2.0 token acquisition and caching with automatic re-authentication
 * 
 * Features:
 * - Automatic token refresh before expiry
 * - Detection of token expiration via 401 responses
 * - Automatic retry of failed requests with new tokens
 * - Secure credential storage and retrieval
 * - Rate limiting to prevent API abuse
 */
class TokenManager {
    /**
     * Create a new TokenManager instance
     * @param {Object} logger - Logger instance for logging messages
     * @param {Object} settings - Settings object containing API credentials
     */
    constructor(logger, settings, eventBus) {
        if (!settings) {
            throw new Error('Settings are required for TokenManager');
        }
        
        this.logger = logger || console;
        this.settings = settings || {};
        this.eventBus = eventBus;
        this.tokenCache = {
            accessToken: null,
            expiresAt: 0,
            tokenType: 'Bearer',
            lastRefresh: 0
        };
        this.tokenExpiryBuffer = 5 * 60 * 1000; // 5 minutes buffer before token expiry
        this.isRefreshing = false;
        this.refreshQueue = [];
        
        // Auto-retry configuration
        this.maxRetries = 1; // Only retry once with new token
        this.retryDelay = 1000; // 1 second delay before retry
        
        // Bind methods
        this.getAccessToken = this.getAccessToken.bind(this);
        this._requestNewToken = this._requestNewToken.bind(this);
        this._isTokenValid = this._isTokenValid.bind(this);
        this.handleTokenExpiration = this.handleTokenExpiration.bind(this);
        this.retryWithNewToken = this.retryWithNewToken.bind(this);
    }

    /**
     * Get a valid access token, either from cache or by requesting a new one
     * @returns {Promise<string>} The access token
     */
    async getAccessToken() {
        // Check if we have a valid cached token
        if (this._isTokenValid()) {
            this.logger.debug('Using cached access token');
            return this.tokenCache.accessToken;
        }

        // If a refresh is already in progress, queue this request
        if (this.isRefreshing) {
            return new Promise((resolve) => {
                this.refreshQueue.push(resolve);
            });
        }

        // Otherwise, request a new token
        try {
            this.isRefreshing = true;
            const token = await this._requestNewToken();
            
            // Resolve all queued requests
            while (this.refreshQueue.length > 0) {
                const resolve = this.refreshQueue.shift();
                resolve(token);
            }
            
            return token;
        } catch (error) {
            // Clear token cache on error
            this.tokenCache = {
                accessToken: null,
                expiresAt: 0,
                tokenType: 'Bearer',
                lastRefresh: 0
            };
            
            // Emit token error event
            if (this.eventBus) {
                this.eventBus.emit('tokenError', { error: error.message });
            }
            
            // Reject all queued requests
            while (this.refreshQueue.length > 0) {
                const resolve = this.refreshQueue.shift();
                resolve(Promise.reject(error));
            }
            
            throw error;
        } finally {
            this.isRefreshing = false;
        }
    }

    /**
     * Handle token expiration detected from API response
     * @param {Object} response - The failed API response
     * @param {Function} retryFn - Function to retry the original request
     * @returns {Promise<Object>} The retry result
     */
    async handleTokenExpiration(response, retryFn) {
        if (!response) {
            throw new Error('Response is required for token expiration handling');
        }
        
        if (!retryFn || typeof retryFn !== 'function') {
            throw new Error('Retry function is required for token expiration handling');
        }
        
        this.logger.warn('Token expiration detected, attempting automatic re-authentication');
        
        // Clear the expired token
        this.tokenCache = {
            accessToken: null,
            expiresAt: 0,
            tokenType: 'Bearer',
            lastRefresh: 0
        };
        
        // Emit token expiration event
        if (this.eventBus) {
            this.eventBus.emit('tokenExpired', { response });
        }
        
        try {
            // Get a new token using stored credentials
            const newToken = await this.getAccessToken();
            
            if (!newToken) {
                throw new Error('Failed to obtain new token for retry');
            }
            
            this.logger.info('Successfully obtained new token, retrying request');
            
            // Wait a moment before retrying to avoid rate limiting
            await new Promise(resolve => setTimeout(resolve, this.retryDelay));
            
            // Retry the original request with the new token
            return await retryFn(newToken);
            
        } catch (error) {
            this.logger.error('Failed to re-authenticate and retry request', {
                error: error.message,
                originalStatus: response.status
            });
            throw error;
        }
    }

    /**
     * Retry a failed request with a new token
     * @param {Function} requestFn - Function that makes the API request
     * @param {Object} options - Request options
     * @returns {Promise<Object>} The API response
     */
    async retryWithNewToken(requestFn, options = {}) {
        if (!requestFn || typeof requestFn !== 'function') {
            throw new Error('Request function is required for retry operation');
        }
        
        let retryCount = 0;
        
        while (retryCount <= this.maxRetries) {
            try {
                // Get current token
                const token = await this.getAccessToken();
                
                // Make the request
                const response = await requestFn(token);
                
                // Check if the response indicates token expiration
                if (response.status === 401) {
                    const responseText = await response.text().catch(() => '');
                    const isTokenExpired = responseText.includes('token_expired') || 
                                         responseText.includes('invalid_token') ||
                                         responseText.includes('expired');
                    
                    if (isTokenExpired && retryCount < this.maxRetries) {
                        this.logger.warn(`Token expired on attempt ${retryCount + 1}, retrying with new token`);
                        
                        // Clear expired token and get new one
                        this.tokenCache = {
                            accessToken: null,
                            expiresAt: 0,
                            tokenType: 'Bearer',
                            lastRefresh: 0
                        };
                        
                        retryCount++;
                        continue;
                    }
                }
                
                // If we get here, the request was successful or we've exhausted retries
                return response;
                
            } catch (error) {
                if (retryCount >= this.maxRetries) {
                    throw error;
                }
                
                this.logger.warn(`Request failed on attempt ${retryCount + 1}, retrying`, {
                    error: error.message
                });
                
                retryCount++;
                
                // Wait before retrying
                await new Promise(resolve => setTimeout(resolve, this.retryDelay));
            }
        }
        
        throw new Error('Max retries exceeded');
    }

    /**
     * Create a request wrapper that automatically handles token expiration
     * @param {Function} requestFn - Function that makes the API request
     * @returns {Function} Wrapped function that handles token expiration
     */
    createAutoRetryWrapper(requestFn) {
        if (!requestFn || typeof requestFn !== 'function') {
            throw new Error('Request function is required for auto-retry wrapper');
        }
        
        return async (...args) => {
            return await this.retryWithNewToken(async (token) => {
                // Add the token to the request arguments
                const requestArgs = [...args];
                
                // If the first argument is an options object, add the token to it
                if (requestArgs[0] && typeof requestArgs[0] === 'object') {
                    requestArgs[0].headers = {
                        ...requestArgs[0].headers,
                        'Authorization': `Bearer ${token}`
                    };
                }
                
                return await requestFn(...requestArgs);
            });
        };
    }

    /**
     * Get token information including expiry details
     * @returns {Object|null} Token info object or null if no token
     */
    getTokenInfo() {
        if (!this.tokenCache.accessToken) {
            return null;
        }
        
        const now = Date.now();
        const expiresIn = Math.max(0, this.tokenCache.expiresAt - now);
        
        return {
            accessToken: this.tokenCache.accessToken,
            expiresIn: Math.floor(expiresIn / 1000), // Convert to seconds
            tokenType: this.tokenCache.tokenType,
            expiresAt: this.tokenCache.expiresAt,
            lastRefresh: this.tokenCache.lastRefresh,
            isValid: this._isTokenValid()
        };
    }

    /**
     * Check if the current token is still valid
     * @returns {boolean} True if token is valid, false otherwise
     * @private
     */
    _isTokenValid() {
        const now = Date.now();
        return this.tokenCache.accessToken && 
               this.tokenCache.expiresAt > (now + this.tokenExpiryBuffer) &&
               // Ensure token isn't too old (max 1 hour)
               (now - this.tokenCache.lastRefresh) < (60 * 60 * 1000);
    }

    /**
     * Get the auth domain for a given region
     * @param {string} region - The region to get auth domain for
     * @returns {string} The auth domain URL
     * @private
     */
    _getAuthDomain(region) {
        if (!region) {
            return 'auth.pingone.com';
        }
        
        const authDomainMap = {
            'NorthAmerica': 'auth.pingone.com',
            'Europe': 'auth.eu.pingone.com',
            'Canada': 'auth.ca.pingone.com',
            'Asia': 'auth.apsoutheast.pingone.com',
            'Australia': 'auth.aus.pingone.com',
            'US': 'auth.pingone.com',
            'EU': 'auth.eu.pingone.com',
            'AP': 'auth.apsoutheast.pingone.com'
        };
        return authDomainMap[region] || 'auth.pingone.com';
    }

    /**
     * Request a new access token from PingOne using stored credentials
     * @returns {Promise<string>} The new access token
     * @private
     */
    async _requestNewToken() {
        const { apiClientId, apiSecret, environmentId, region = 'NorthAmerica' } = this.settings;
        const requestId = `req_${Math.random().toString(36).substr(2, 9)}`;
        const startTime = Date.now();
        
        // Validate required settings
        if (!apiClientId || !apiSecret || !environmentId) {
            const error = new Error('Missing required API credentials in settings');
            this.logger.error('Token request failed: Missing credentials', {
                requestId,
                hasClientId: !!apiClientId,
                hasSecret: !!apiSecret,
                hasEnvId: !!environmentId
            });
            throw error;
        }

        // Prepare request
        const authDomain = this._getAuthDomain(region);
        const tokenUrl = `https://${authDomain}/${environmentId}/as/token`;
        const credentials = btoa(`${apiClientId}:${apiSecret}`);
        
        try {
            this.logger.debug('Requesting new access token from PingOne...', {
                requestId,
                authDomain,
                environmentId,
                region
            });
            
            const response = await fetch(tokenUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Authorization': `Basic ${credentials}`
                },
                body: 'grant_type=client_credentials',
                credentials: 'omit'
            });

            const responseTime = Date.now() - startTime;
            let responseData;
            
            try {
                responseData = await response.json();
            } catch (e) {
                const text = await response.text().catch(() => 'Failed to read response text');
                throw new Error(`Invalid JSON response: ${e.message}. Response: ${text}`);
            }
            
            if (!response.ok) {
                const errorMsg = responseData.error_description || 
                               responseData.error || 
                               `HTTP ${response.status} ${response.statusText}`;
                
                this.logger.error('Token request failed', {
                    requestId,
                    status: response.status,
                    error: responseData.error,
                    errorDescription: responseData.error_description,
                    responseTime: `${responseTime}ms`,
                    url: tokenUrl
                });
                
                throw new Error(errorMsg);
            }
            
            if (!responseData.access_token) {
                throw new Error('No access token in response');
            }
            
            // Update token cache
            const expiresInMs = (responseData.expires_in || 3600) * 1000;
            this.tokenCache = {
                accessToken: responseData.access_token,
                expiresAt: Date.now() + expiresInMs,
                tokenType: responseData.token_type || 'Bearer',
                lastRefresh: Date.now()
            };
            
            this.logger.info('Successfully obtained new access token', {
                requestId,
                tokenType: this.tokenCache.tokenType,
                expiresIn: Math.floor(expiresInMs / 1000) + 's',
                responseTime: `${responseTime}ms`
            });
            
            // Emit token refresh event
            if (this.eventBus) {
                this.eventBus.emit('tokenRefreshed', {
                    tokenType: this.tokenCache.tokenType,
                    expiresAt: this.tokenCache.expiresAt
                });
            }
            
            return this.tokenCache.accessToken;
            
        } catch (error) {
            this.logger.error('Error getting access token', {
                requestId,
                error: error.toString(),
                message: error.message,
                url: tokenUrl,
                responseTime: `${Date.now() - startTime}ms`
            });
            
            // Clear token cache on error
            this.tokenCache = {
                accessToken: null,
                expiresAt: 0,
                tokenType: 'Bearer',
                lastRefresh: 0
            };
            
            throw error;
        }
    }
    
    /**
     * Update settings and clear token cache if credentials changed
     * @param {Object} newSettings - New settings object
     */
    updateSettings(newSettings) {
        if (!newSettings) {
            throw new Error('New settings are required for update');
        }
        
        const credentialsChanged = 
            newSettings.apiClientId !== this.settings.apiClientId ||
            newSettings.apiSecret !== this.settings.apiSecret ||
            newSettings.environmentId !== this.settings.environmentId ||
            newSettings.region !== this.settings.region;
        
        this.settings = { ...this.settings, ...newSettings };
        
        if (credentialsChanged) {
            this.logger.debug('API credentials changed, clearing token cache');
            this.tokenCache = {
                accessToken: null,
                expiresAt: 0,
                tokenType: 'Bearer',
                lastRefresh: 0
            };
        }
    }
}

export { TokenManager };



/* From: public/js/modules/token-refresh-handler.js */
/**
 * Token Refresh Handler
 * 
 * Provides automatic token refresh functionality for API calls
 * with retry logic and error handling.
 */

class TokenRefreshHandler {
    constructor() {
        this.tokenRefreshInProgress = false;
        this.tokenRefreshPromise = null;
        this.lastRefreshTime = 0;
        this.minRefreshInterval = 5000; // 5 seconds
    }

    /**
     * Get a fresh token with automatic refresh if needed
     * @param {Object} tokenManager - Token manager instance
     * @returns {Promise<string>} Fresh token
     */
    async getFreshToken(tokenManager) {
        if (!tokenManager) {
            throw new Error('Token manager is required');
        }

        // Check if we already have a valid token
        try {
            const currentToken = await tokenManager.getAccessToken();
            if (currentToken) {
                return currentToken;
            }
        } catch (error) {
            console.warn('Error getting current token:', error);
            // Continue with refresh
        }

        // If refresh is already in progress, wait for it
        if (this.tokenRefreshInProgress) {
            console.log('Token refresh already in progress, waiting...');
            return this.tokenRefreshPromise;
        }

        // Check if we've refreshed recently
        const now = Date.now();
        if (now - this.lastRefreshTime < this.minRefreshInterval) {
            console.log('Token was refreshed recently, using cached token');
            return tokenManager.getAccessToken();
        }

        // Start refresh process
        this.tokenRefreshInProgress = true;
        this.tokenRefreshPromise = this._refreshToken(tokenManager);

        try {
            const token = await this.tokenRefreshPromise;
            return token;
        } finally {
            this.tokenRefreshInProgress = false;
            this.lastRefreshTime = Date.now();
        }
    }

    /**
     * Refresh token with retry logic
     * @private
     * @param {Object} tokenManager - Token manager instance
     * @returns {Promise<string>} Fresh token
     */
    async _refreshToken(tokenManager) {
        console.log('Refreshing token...');
        
        // Clear current token to force refresh
        if (typeof tokenManager.clearToken === 'function') {
            tokenManager.clearToken();
        }
        
        // Try to get a new token
        try {
            const token = await tokenManager.getAccessToken();
            if (!token) {
                throw new Error('Failed to get new token');
            }
            
            console.log('Token refreshed successfully');
            return token;
        } catch (error) {
            console.error('Failed to refresh token:', error);
            throw error;
        }
    }

    /**
     * Make an API call with automatic token refresh
     * @param {Function} apiCall - Function that makes the API call
     * @param {Object} tokenManager - Token manager instance
     * @param {number} maxRetries - Maximum number of retries
     * @returns {Promise<Object>} API response
     */
    async callWithTokenRefresh(apiCall, tokenManager, maxRetries = 1) {
        let retries = 0;
        
        while (retries <= maxRetries) {
            try {
                // Get fresh token
                const token = await this.getFreshToken(tokenManager);
                
                // Make API call
                return await apiCall(token);
            } catch (error) {
                // Check if error is due to token expiration
                const isTokenError = error.status === 401 || 
                                    (error.message && error.message.includes('token'));
                
                if (isTokenError && retries < maxRetries) {
                    console.log(`Token error, retrying (${retries + 1}/${maxRetries})...`);
                    retries++;
                    
                    // Force token refresh
                    if (typeof tokenManager.clearToken === 'function') {
                        tokenManager.clearToken();
                    }
                    
                    // Wait before retry
                    await new Promise(resolve => setTimeout(resolve, 1000));
                } else {
                    // Rethrow error if not token related or max retries reached
                    throw error;
                }
            }
        }
    }
}

// Create and export a singleton instance
const tokenRefreshHandler = new TokenRefreshHandler();
export { tokenRefreshHandler };


/* From: public/js/modules/token-status-indicator.js */
/**
 * Token Status Indicator Module
 * 
 * Provides a visible token status indicator across all pages in the application.
 * Shows current PingOne token state with color-coded status and automatic refresh.
 */

class TokenStatusIndicator {
    constructor() {
        this.statusBar = null;
        this.statusIcon = null;
        this.statusText = null;
        this.statusTime = null;
        this.refreshButton = null;
        this.getTokenButton = null;
        this.refreshInterval = null;
        this.refreshIntervalMs = 30000; // 30 seconds
        this.warningThresholdMs = 5 * 60 * 1000; // 5 minutes
        this.isInitialized = false;
        
        this.init();
    }

    /**
     * Initialize the token status indicator
     */
    async init() {
        if (this.isInitialized) {
            console.log('TokenStatusIndicator already initialized');
            return;
        }

        console.log('🔄 Initializing TokenStatusIndicator...');
        
        try {
            this.createStatusBar();
            this.bindEvents();
            this.startRefreshTimer();
            
            // Force initial status update
            await this.updateStatus();
            
            this.isInitialized = true;
            console.log('✅ TokenStatusIndicator initialized successfully');
            
            // Debug: Check if Get Token button exists and is visible
            if (this.getTokenButton) {
                console.log('✅ Get Token button found:', {
                    exists: !!this.getTokenButton,
                    display: this.getTokenButton.style.display,
                    visible: this.getTokenButton.style.display !== 'none'
                });
            } else {
                console.warn('⚠️ Get Token button not found in status bar');
            }
        } catch (error) {
            console.error('❌ Failed to initialize TokenStatusIndicator:', error);
            throw error;
        }
    }

    /**
     * Create the status bar HTML structure
     */
    createStatusBar() {
        console.log('Creating status bar...');
        // Check if status bar already exists
        if (document.getElementById('token-status-indicator')) {
            console.log('Token status indicator already exists, using existing element');
            this.statusBar = document.getElementById('token-status-indicator');
            this.statusIcon = this.statusBar.querySelector('.token-status-icon');
            this.statusText = this.statusBar.querySelector('.token-status-text');
            this.statusTime = this.statusBar.querySelector('.token-status-time');
            this.refreshButton = this.statusBar.querySelector('#refresh-token-status');
            this.getTokenButton = this.statusBar.querySelector('#get-token-quick');
            console.log('Found existing elements:', {
                statusBar: !!this.statusBar,
                statusIcon: !!this.statusIcon,
                statusText: !!this.statusText,
                statusTime: !!this.statusTime,
                refreshButton: !!this.refreshButton,
                getTokenButton: !!this.getTokenButton
            });
            return;
        }

        // Create status bar
        this.statusBar = document.createElement('div');
        this.statusBar.id = 'token-status-indicator';
        this.statusBar.className = 'token-status-indicator';
        this.statusBar.setAttribute('role', 'status');
        this.statusBar.setAttribute('aria-live', 'polite');

        this.statusBar.innerHTML = `
            <div class="token-status-content">
                <span class="token-status-icon" aria-hidden="true">⏳</span>
                <span class="token-status-text">Checking token status...</span>
                <span class="token-status-time"></span>
            </div>
            <div class="token-status-actions">
                <button id="refresh-token-status" class="btn btn-sm btn-outline-secondary" title="Refresh token status">
                    <i class="fas fa-sync-alt"></i>
                </button>
                <button id="get-token-quick" class="btn btn-sm btn-success" title="Get new token" style="display: none;">
                    <i class="fas fa-key"></i> Get Token
                </button>
            </div>
        `;

        // Get references to elements
        this.statusIcon = this.statusBar.querySelector('.token-status-icon');
        this.statusText = this.statusBar.querySelector('.token-status-text');
        this.statusTime = this.statusBar.querySelector('.token-status-time');
        this.refreshButton = this.statusBar.querySelector('#refresh-token-status');
        this.getTokenButton = this.statusBar.querySelector('#get-token-quick');

        // Add to page
        this.insertStatusBar();
    }

    /**
     * Insert status bar into the page
     */
    insertStatusBar() {
        // Try to find the sidebar first
        const sidebar = document.querySelector('.sidebar');
        if (sidebar) {
            // Insert at the end of the sidebar, after the nav-links
            const navLinks = sidebar.querySelector('.nav-links');
            if (navLinks) {
                // Insert after nav-links
                sidebar.appendChild(this.statusBar);
                return;
            }
        }

        // Fallback: Try to find a good location for the status bar
        const locations = [
            () => document.querySelector('.main-content'),
            () => document.querySelector('#app'),
            () => document.body
        ];

        for (const getLocation of locations) {
            const location = getLocation();
            if (location) {
                // Insert at the beginning of the main content
                location.insertBefore(this.statusBar, location.firstChild);
                return;
            }
        }

        // Fallback to body
        document.body.appendChild(this.statusBar);
    }

    /**
     * Bind event listeners
     */
    bindEvents() {
        if (this.refreshButton) {
            this.refreshButton.addEventListener('click', () => {
                this.refreshStatus();
            });
        }

        if (this.getTokenButton) {
            this.getTokenButton.addEventListener('click', () => {
                this.getNewToken();
            });
        }

        // Listen for token updates from other parts of the app
        window.addEventListener('token-updated', () => {
            this.updateStatus();
        });

        // Listen for page visibility changes to refresh when tab becomes visible
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                this.updateStatus();
            }
        });
    }

    /**
     * Start the automatic refresh timer
     */
    startRefreshTimer() {
        if (this.refreshInterval) {
            clearInterval(this.refreshInterval);
        }

        this.refreshInterval = setInterval(() => {
            this.updateStatus();
        }, this.refreshIntervalMs);

        console.log(`Token status auto-refresh started (${this.refreshIntervalMs / 1000}s interval)`);
    }

    /**
     * Stop the automatic refresh timer
     */
    stopRefreshTimer() {
        if (this.refreshInterval) {
            clearInterval(this.refreshInterval);
            this.refreshInterval = null;
            console.log('Token status auto-refresh stopped');
        }
    }

    /**
     * Get current token information using Unified Token Manager
     */
    async getTokenInfo() {
        try {
            // Use unified token manager if available
            if (window.TokenAccess) {
                console.log('🔧 Using Unified Token Manager for token info');
                const tokenInfo = window.TokenAccess.getTokenInfo();
                
                return {
                    status: tokenInfo.status,
                    message: tokenInfo.message,
                    timeRemaining: tokenInfo.timeRemaining,
                    isExpired: tokenInfo.isExpired,
                    isExpiring: tokenInfo.isExpiring
                };
            }
            
            // Fallback to legacy method if unified manager not available
            console.log('⚠️ Unified Token Manager not available, using legacy method');
            
            // Check localStorage first - try both formats
            const token = await TokenAccess.getToken();
            const expiry = TokenAccess.getTokenInfo().expiresAt;

            if (token && expiry) {
                const expiryTime = parseInt(expiry, 10);
                const now = Date.now();
                const timeRemaining = expiryTime - now;

                if (timeRemaining > 0) {
                    const isExpiring = timeRemaining <= this.warningThresholdMs;
                    const status = isExpiring ? 'expiring' : 'valid';
                    const message = isExpiring ? 'Token expires soon' : 'Token valid';

                    return {
                        status,
                        message,
                        timeRemaining,
                        isExpired: false,
                        isExpiring
                    };
                }
            }

            // Check for token cache format
            const tokenCache = localStorage.getItem('pingone_token_cache');
            if (tokenCache) {
                try {
                    const cachedToken = JSON.parse(tokenCache);
                    if (cachedToken && cachedToken.token && cachedToken.expiresAt) {
                        const now = Date.now();
                        const timeRemaining = cachedToken.expiresAt - now;

                        if (timeRemaining > 0) {
                            const isExpiring = timeRemaining <= this.warningThresholdMs;
                            const status = isExpiring ? 'expiring' : 'valid';
                            const message = isExpiring ? 'Token expires soon' : 'Token valid';

                            console.log('✅ Found valid token in cache:', {
                                expiresAt: new Date(cachedToken.expiresAt).toISOString(),
                                timeRemaining: Math.floor(timeRemaining / 1000 / 60) + ' minutes'
                            });

                            return {
                                status,
                                message,
                                timeRemaining,
                                isExpired: false,
                                isExpiring
                            };
                        }
                    }
                } catch (e) {
                    console.warn('Failed to parse token cache:', e);
                }
            }

            // If no token in localStorage or expired, check server token status
            console.log('🔍 No valid token in localStorage, checking server /api/token/status...');
            const response = await fetch('/api/token/status');
            if (!response.ok) {
                throw new Error(`Token status check failed: ${response.status}`);
            }

            const statusPayload = await response.json();
            const serverStatus = statusPayload && (statusPayload.data || statusPayload.status || statusPayload);
            const serverToken = serverStatus && (serverStatus.data || serverStatus); // normalize

            if (!serverToken || !serverToken.hasToken || !serverToken.isValid) {
                return {
                    status: 'missing',
                    message: 'No token available',
                    timeRemaining: null,
                    isExpired: true,
                    isExpiring: false
                };
            }

            // Server has valid token, calculate time remaining (exposed as seconds)
            const timeRemaining = (serverToken.expiresIn || 0) * 1000; // Convert seconds to ms
            
            if (timeRemaining <= 0) {
                return {
                    status: 'expired',
                    message: 'Token expired',
                    timeRemaining: 0,
                    isExpired: true,
                    isExpiring: false
                };
            }

            const isExpiring = timeRemaining <= this.warningThresholdMs;
            const status = isExpiring ? 'expiring' : 'valid';
            const message = isExpiring ? 'Token expires soon' : 'Token valid';

            return {
                status,
                message,
                timeRemaining,
                isExpired: false,
                isExpiring
            };
        } catch (error) {
            console.error('Error getting token info:', error);
            return {
                status: 'error',
                message: 'Error retrieving token',
                timeRemaining: null,
                isExpired: true,
                isExpiring: false
            };
        }
    }

    /**
     * Format time remaining
     */
    formatTimeRemaining(ms) {
        if (!ms || ms <= 0) return '0m 0s';

        const minutes = Math.floor(ms / 60000);
        const seconds = Math.floor((ms % 60000) / 1000);

        if (minutes > 0) {
            return `${minutes}m ${seconds}s`;
        } else {
            return `${seconds}s`;
        }
    }

    /**
     * Update the token status indicator display with actual token status
     * @param {string} status - Token status ('valid', 'expired', 'missing', 'error', etc.)
     * @param {string} [message] - Optional status message
     */
    async updateDisplay(status, message) {
        const indicator = document.getElementById('token-status-indicator');
        if (!indicator) return;

        try {
            // Get actual token status
            const tokenInfo = await this.getTokenInfo();
            
            let text = tokenInfo.message;
            let className = 'token-status-indicator';

            switch (tokenInfo.status) {
                case 'valid':
                    text = tokenInfo.message;
                    className += ' valid';
                    break;
                case 'expired':
                    text = ''; // Keep empty as requested
                    className += ' expired';
                    break;
                case 'missing':
                    text = tokenInfo.message;
                    className += ' missing';
                    break;
                case 'error':
                    text = tokenInfo.message;
                    className += ' error';
                    break;
                case 'expiring':
                    text = tokenInfo.message;
                    className += ' expiring';
                    break;
                default:
                    text = tokenInfo.message || 'Checking token...';
            }

            indicator.textContent = text;
            indicator.className = className;
            indicator.style.display = '';
            
            console.log('✅ updateDisplay updated with actual token status:', tokenInfo.status, tokenInfo.message);
            
        } catch (error) {
            console.error('❌ Error in updateDisplay:', error);
            
            // Fallback to original behavior if error
            let text = 'Checking token...';
            let className = 'token-status-indicator';

            switch (status) {
                case 'valid':
                    text = 'Token valid';
                    className += ' valid';
                    break;
                case 'expired':
                    text = '';
                    className += ' expired';
                    break;
                case 'missing':
                    text = 'Token missing';
                    className += ' missing';
                    break;
                case 'error':
                    text = 'Token error';
                    className += ' error';
                    break;
                default:
                    text = message || 'Checking token...';
            }

            indicator.textContent = text;
            indicator.className = className;
            indicator.style.display = '';
        }
    }

    /**
     * Update the token status indicator
     */
    async updateStatus() {
        try {
            console.log('🔄 Updating token status...');
            
            const tokenInfo = await this.getTokenInfo();
            console.log('📊 Token info:', tokenInfo);
            
            // Update status bar elements
            if (this.statusIcon) {
                let icon = '⏳';
                let iconClass = '';
                
                switch (tokenInfo.status) {
                    case 'valid':
                        icon = '✅';
                        iconClass = 'valid';
                        break;
                    case 'expired':
                        icon = '❌';
                        iconClass = 'expired';
                        break;
                    case 'missing':
                        icon = '⚠️';
                        iconClass = 'missing';
                        break;
                    case 'error':
                        icon = '🚨';
                        iconClass = 'error';
                        break;
                    case 'expiring':
                        icon = '⏰';
                        iconClass = 'expiring';
                        break;
                }
                
                this.statusIcon.textContent = icon;
                this.statusIcon.className = `token-status-icon ${iconClass}`;
            }
            
            if (this.statusText) {
                this.statusText.textContent = tokenInfo.message;
            }
            
            if (this.statusTime && tokenInfo.timeRemaining !== null) {
                this.statusTime.textContent = `(${this.formatTimeRemaining(tokenInfo.timeRemaining)})`;
            }
            
            // Update status bar class
            if (this.statusBar) {
                this.statusBar.className = `token-status-indicator ${tokenInfo.status}`;
            }
            
            // Show/hide Get Token button based on token state
            if (this.getTokenButton) {
                if (tokenInfo.isExpired || tokenInfo.status === 'missing' || tokenInfo.status === 'error') {
                    this.getTokenButton.style.display = 'inline-block';
                    console.log('✅ Showing Get Token button - token is expired/missing/error');
                } else {
                    this.getTokenButton.style.display = 'none';
                    console.log('✅ Hiding Get Token button - token is valid');
                }
            } else {
                console.warn('⚠️ Get Token button not found in status bar');
            }
            
            console.log('✅ Token status updated successfully');
            
            // NEW: Direct global token status updater for sidebar
            console.log('🚀 [DEBUG] TokenStatusIndicator: About to call updateGlobalTokenStatusDirect');
            try {
                // Get the main app instance to call the direct updater
                if (window.app && typeof window.app.updateGlobalTokenStatusDirect === 'function') {
                    // Calculate time left from token info
                    const timeLeft = tokenInfo.timeRemaining ? this.formatTimeRemaining(tokenInfo.timeRemaining) : '';
                    window.app.updateGlobalTokenStatusDirect(timeLeft);
                    console.log('✅ [DEBUG] TokenStatusIndicator: updateGlobalTokenStatusDirect called successfully with timeLeft:', timeLeft);
                } else {
                    console.warn('⚠️ [DEBUG] TokenStatusIndicator: window.app.updateGlobalTokenStatusDirect not available');
                }
            } catch (error) {
                console.error('❌ [DEBUG] TokenStatusIndicator: Error calling updateGlobalTokenStatusDirect:', error);
            }
            
            return tokenInfo;
        } catch (error) {
            console.error('❌ Error updating token status:', error);
            
            // Set error state
            if (this.statusIcon) this.statusIcon.textContent = '🚨';
            if (this.statusText) this.statusText.textContent = 'Error checking token';
            if (this.statusBar) this.statusBar.className = 'token-status-indicator error';
            
            // Show Get Token button on error
            if (this.getTokenButton) {
                this.getTokenButton.style.display = 'inline-block';
            }
            
            return {
                status: 'error',
                message: 'Error checking token',
                timeRemaining: null,
                isExpired: true,
                isExpiring: false
            };
        }
    }

    /**
     * Set error state
     */
    setErrorState() {
        if (this.statusIcon) this.statusIcon.textContent = '🚨';
        if (this.statusText) this.statusText.textContent = 'Token error';
        if (this.statusBar) this.statusBar.className = 'token-status-indicator error';
        if (this.getTokenButton) this.getTokenButton.style.display = 'inline-block';
    }

    /**
     * Refresh token status
     */
    async refreshStatus() {
        console.log('Manually refreshing token status...');
        await this.updateStatus();
    }

    /**
     * Get new token
     */
    async getNewToken() {
        try {
            console.log('Requesting new token...');
            
            // Use unified backend refresh endpoint
            const response = await fetch('/api/token/refresh', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`Failed to get token: ${response.status}`);
            }

            // The refresh endpoint returns status only; token is stored server-side.
            // Simply update the UI based on new status.
            await response.json().catch(() => ({}));

            // Update status
            await this.updateStatus();

            // Dispatch event for other components
            window.dispatchEvent(new CustomEvent('token-updated'));

            console.log('New token obtained successfully');
        } catch (error) {
            console.error('Error getting new token:', error);
            this.setErrorState();
        }
    }

    /**
     * Show the status indicator
     */
    show() {
        if (this.statusBar) {
            this.statusBar.style.display = 'block';
        }
    }

    /**
     * Hide the status indicator
     */
    hide() {
        if (this.statusBar) {
            this.statusBar.style.display = 'none';
        }
    }

    /**
     * Destroy the indicator
     */
    destroy() {
        this.stopRefreshTimer();
        
        if (this.statusBar && this.statusBar.parentNode) {
            this.statusBar.parentNode.removeChild(this.statusBar);
        }
        
        this.isInitialized = false;
    }

    /**
     * Get current status
     */
    getCurrentStatus() {
        return this.getTokenInfo();
    }
}

// ES Modules export
export { TokenStatusIndicator };

// Browser global fallback for legacy compatibility
if (typeof window !== 'undefined') {
    window.TokenStatusIndicator = TokenStatusIndicator;
}

// Browser global fallback for legacy compatibility
if (typeof window !== 'undefined') {
window.TokenStatusIndicator = TokenStatusIndicator;
}

// Auto-initialize when DOM is ready
if (document.readyState === 'loading') {
document.addEventListener('DOMContentLoaded', () => {
        window.tokenStatusIndicator = new TokenStatusIndicator();
    });
} else {
    window.tokenStatusIndicator = new TokenStatusIndicator();
} 


/* From: public/js/modules/token-alert-modal.js */
// Token Alert Modal - blocks interaction and guides user to settings if no valid token is available
class TokenAlertModal {
    constructor({ tokenStatus = '', expiry = '', operation = '' } = {}) {
        if (TokenAlertModal.hasShownThisSession()) return;
        TokenAlertModal.setShownThisSession();
        this.operation = operation;
        this.createModal(tokenStatus, expiry);
        this.showModal();
    }

    createModal(tokenStatus, expiry) {
        // Overlay
        const overlay = document.createElement('div');
        overlay.className = 'token-alert-overlay';
        overlay.setAttribute('role', 'dialog');
        overlay.setAttribute('aria-modal', 'true');
        overlay.setAttribute('aria-labelledby', 'token-alert-title');
        overlay.setAttribute('aria-describedby', 'token-alert-content');

        // Modal content with enhanced styling and action button
        overlay.innerHTML = `
            <div class="token-alert-modal" tabindex="-1">
                <div class="token-alert-header">
                    <h2 id="token-alert-title">
                        <span class="warning-icon" aria-hidden="true">⚠️</span>
                        <span>Authentication Required</span>
                    </h2>
                    <button type="button" class="token-alert-close" id="token-alert-close" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="token-alert-body">
                    <div id="token-alert-content" class="token-alert-content">
                        <div class="token-alert-icon">
                            <span aria-hidden="true">🔐</span>
                        </div>
                        <h3>No Valid Token Available</h3>
                        <p class="token-alert-message">
                            <strong>Authentication is required to continue.</strong>
                            ${this.operation ? `You need valid credentials to perform the "${this.operation}" operation.` : 'You need valid credentials to use this application.'}
                        </p>
                        ${tokenStatus || expiry ? `<div class="token-status-info">
                            <p><strong>Current Status:</strong> ${tokenStatus ? tokenStatus : 'No token available'}</p>
                            ${expiry ? `<p style="visibility: hidden;"><strong>Token Expired:</strong> ${expiry}</p>` : ''}
                        </div>` : ''}
                        <div class="token-alert-actions">
                            <button type="button" class="btn btn-primary btn-lg" id="token-alert-settings-btn">
                                <span class="btn-icon">⚙️</span>
                                Go to Settings
                            </button>
                            <p class="token-alert-help">
                                Add your PingOne credentials in the Settings page to generate a new token.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(overlay);
        this.overlay = overlay;
        this.modal = overlay.querySelector('.token-alert-modal');
        this.settingsBtn = overlay.querySelector('#token-alert-settings-btn');
        this.closeBtn = overlay.querySelector('#token-alert-close');
        this.bindEvents();
    }

    bindEvents() {
        // Settings button - navigate to settings
        this.settingsBtn.addEventListener('click', () => {
            this.hideModal();
            // Navigate to settings view within the SPA instead of redirecting
            if (window.app && window.app.showView) {
                window.app.showView('settings');
            } else {
                // Fallback: navigate to settings view by triggering the settings nav item
                const settingsNavItem = document.querySelector('[data-view="settings"]');
                if (settingsNavItem) {
                    settingsNavItem.click();
                } else {
                    // Final fallback: redirect to home page which will show settings
                    window.location.href = '/';
                }
            }
        });

        // Close button - allow manual dismissal
        this.closeBtn.addEventListener('click', () => {
            this.hideModal();
        });

        // Trap focus within modal
        this.overlay.addEventListener('keydown', (e) => this.handleKeyboardNavigation(e));
        
        // Prevent closing by outside click (modal should be persistent)
        this.overlay.addEventListener('click', (e) => {
            if (e.target === this.overlay) {
                e.preventDefault();
                // Don't close on outside click - keep modal visible
            }
        });

        // Prevent escape key from closing modal (should be persistent)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                e.preventDefault();
                // Don't close on escape - keep modal visible
            }
        });
    }

    handleKeyboardNavigation(e) {
        const focusable = this.modal.querySelectorAll('button, [tabindex]:not([tabindex="-1"])');
        if (e.key === 'Tab') {
            if (focusable.length === 0) return;
            const first = focusable[0];
            const last = focusable[focusable.length - 1];
            if (e.shiftKey) {
                if (document.activeElement === first) {
                    e.preventDefault();
                    last.focus();
                }
            } else {
                if (document.activeElement === last) {
                    e.preventDefault();
                    first.focus();
                }
            }
        }
    }

    showModal() {
        document.body.classList.add('token-alert-open');
        this.overlay.classList.add('active');
        this.modal.focus();
        
        // Add styles to body to prevent scrolling
        document.body.style.overflow = 'hidden';
    }

    hideModal() {
        this.overlay.classList.remove('active');
        document.body.classList.remove('token-alert-open');
        document.body.style.overflow = '';
        
        setTimeout(() => {
            if (this.overlay && this.overlay.parentNode) {
                this.overlay.parentNode.removeChild(this.overlay);
            }
        }, 300);
    }

    static hasShownThisSession() {
        return sessionStorage.getItem('tokenAlertModalShown') === 'true';
    }
    
    static setShownThisSession() {
        sessionStorage.setItem('tokenAlertModalShown', 'true');
    }
    
    static clearShownThisSession() {
        sessionStorage.removeItem('tokenAlertModalShown');
    }
}

// Export a function to show the modal
export function showTokenAlertModal({ tokenStatus = '', expiry = '', operation = '' } = {}) {
    new TokenAlertModal({ tokenStatus, expiry, operation });
}

// Export function to clear the session flag (useful for testing)
export function clearTokenAlertSession() {
    TokenAlertModal.clearShownThisSession();
} 


/* From: public/js/modules/token-manager-ui-integration.js */
/**
 * Token Manager UI Integration
 * Integrates the unified token management system with the token manager page UI
 */

class TokenManagerUIIntegration {
    constructor() {
        this.initialized = false;
        this.updateInterval = null;
        this.bindMethods();
    }

    bindMethods() {
        this.init = this.init.bind(this);
        this.updateTokenDisplay = this.updateTokenDisplay.bind(this);
        this.refreshTokenStatus = this.refreshTokenStatus.bind(this);
        this.getCurrentToken = this.getCurrentToken.bind(this);
        this.refreshToken = this.refreshToken.bind(this);
        this.clearToken = this.clearToken.bind(this);
        this.testToken = this.testToken.bind(this);
        this.decodeToken = this.decodeToken.bind(this);
        this.copyToken = this.copyToken.bind(this);
    }

    /**
     * Initialize the token manager UI integration
     */
    init() {
        if (this.initialized) {
            console.log('🔧 Token Manager UI Integration already initialized');
            return;
        }

        console.log('🔧 Initializing Token Manager UI Integration...');

        // Check if unified token manager is available
        if (!window.TokenAccess) {
            console.warn('⚠️ TokenAccess not available, retrying in 1 second...');
            setTimeout(() => this.init(), 1000);
            return;
        }

        // Set up event listeners
        this.setupEventListeners();

        // Initial token display update
        this.updateTokenDisplay();

        // Set up periodic updates
        this.updateInterval = setInterval(() => {
            this.updateTokenDisplay();
        }, 30000); // Update every 30 seconds

        this.initialized = true;
        console.log('✅ Token Manager UI Integration initialized successfully');
    }

    /**
     * Set up event listeners for token manager UI elements
     */
    setupEventListeners() {
        // Refresh token status button
        const refreshStatusBtn = document.getElementById('refresh-token-status');
        if (refreshStatusBtn) {
            refreshStatusBtn.addEventListener('click', this.refreshTokenStatus);
        }

        // Get current token button
        const getCurrentTokenBtn = document.getElementById('get-current-token');
        if (getCurrentTokenBtn) {
            getCurrentTokenBtn.addEventListener('click', this.getCurrentToken);
        }

        // Refresh token button
        const refreshTokenBtn = document.getElementById('refresh-access-token');
        if (refreshTokenBtn) {
            refreshTokenBtn.addEventListener('click', this.refreshToken);
        }

        // Clear token button
        const clearTokenBtn = document.getElementById('clear-token');
        if (clearTokenBtn) {
            clearTokenBtn.addEventListener('click', this.clearToken);
        }

        // Test token button
        const testTokenBtn = document.getElementById('test-token');
        if (testTokenBtn) {
            testTokenBtn.addEventListener('click', this.testToken);
        }

        // Decode token button
        const decodeTokenBtn = document.getElementById('decode-token');
        if (decodeTokenBtn) {
            decodeTokenBtn.addEventListener('click', this.decodeToken);
        }

        // Copy token button
        const copyTokenBtn = document.getElementById('copy-token');
        if (copyTokenBtn) {
            copyTokenBtn.addEventListener('click', this.copyToken);
        }

        console.log('✅ Event listeners set up for token manager UI');
    }

    /**
     * Update the token display with current token information
     */
    async updateTokenDisplay() {
        if (!window.TokenAccess) {
            console.warn('⚠️ TokenAccess not available for token display update');
            return;
        }

        try {
            const tokenInfo = window.TokenAccess.getTokenInfo();
            
            // Update token date
            const tokenDateEl = document.getElementById('token-date');
            if (tokenDateEl) {
                const date = new Date().toLocaleString();
                tokenDateEl.textContent = date;
            }

            // Update token status
            const tokenStatusEl = document.getElementById('token-status-indicator');
            if (tokenStatusEl) {
                tokenStatusEl.textContent = tokenInfo.status.toUpperCase();
                tokenStatusEl.className = `status-badge ${tokenInfo.status}`;
                
                // Update status colors
                if (tokenInfo.status === 'valid') {
                    tokenStatusEl.style.backgroundColor = '#d4edda';
                    tokenStatusEl.style.color = '#155724';
                } else if (tokenInfo.status === 'expired') {
                    tokenStatusEl.style.backgroundColor = '#f8d7da';
                    tokenStatusEl.style.color = '#721c24';
                } else {
                    tokenStatusEl.style.backgroundColor = '#fff3cd';
                    tokenStatusEl.style.color = '#856404';
                }
            }

            // Update environment ID
            const envIdEl = document.getElementById('token-environment-id');
            if (envIdEl) {
                try {
                    const resp = await fetch('/api/settings');
                    const payload = await resp.json();
                    const settings = payload && (payload.data || payload) || {};
                    const environmentId = settings.environmentId || settings.ENVIRONMENT_ID || settings.environment_id || '';
                    if (environmentId) {
                        envIdEl.textContent = environmentId;
                        envIdEl.title = 'Click to copy';
                        envIdEl.style.cursor = 'pointer';
                        envIdEl.onclick = () => {
                            navigator.clipboard.writeText(environmentId);
                            this.showToast('Environment ID copied to clipboard');
                        };
                    } else {
                        envIdEl.textContent = 'Not Available';
                    }
                } catch (error) {
                    envIdEl.textContent = 'Error loading';
                    console.error('Error loading environment ID:', error);
                }
            }

            // Update time remaining display
            if (tokenInfo.timeRemainingFormatted) {
                const timeDisplay = document.createElement('div');
                timeDisplay.className = 'status-item';
                timeDisplay.innerHTML = `
                    <div class="status-title">Time Remaining</div>
                    <div class="status-value">${tokenInfo.timeRemainingFormatted}</div>
                `;
                
                const statusGrid = document.querySelector('.token-status-grid');
                if (statusGrid && !statusGrid.querySelector('.time-remaining')) {
                    timeDisplay.classList.add('time-remaining');
                    statusGrid.appendChild(timeDisplay);
                }
            }

            console.log('✅ Token display updated successfully');

        } catch (error) {
            console.error('❌ Error updating token display:', error);
        }
    }

    /**
     * Refresh token status
     */
    async refreshTokenStatus() {
        const btn = document.getElementById('refresh-token-status');
        if (btn) {
            const originalText = btn.innerHTML;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Refreshing...';
            btn.disabled = true;
        }

        try {
            await this.updateTokenDisplay();
            this.showToast('Token status refreshed successfully');
        } catch (error) {
            console.error('Error refreshing token status:', error);
            this.showToast('Error refreshing token status', 'error');
        } finally {
            if (btn) {
                btn.innerHTML = '<i class="fas fa-sync-alt"></i> Refresh Status';
                btn.disabled = false;
            }
        }
    }

    /**
     * Get and display current token
     */
    async getCurrentToken() {
        const btn = document.getElementById('get-current-token');
        const tokenDisplay = document.getElementById('raw-token-display');
        const copyBtn = document.getElementById('copy-token');

        if (btn) {
            const originalText = btn.innerHTML;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Getting Token...';
            btn.disabled = true;
        }

        try {
            if (!window.TokenAccess) {
                throw new Error('TokenAccess not available');
            }

            const token = await window.TokenAccess.getAccessToken();
            
            if (tokenDisplay) {
                tokenDisplay.value = token;
                tokenDisplay.style.display = 'block';
            }

            if (copyBtn) {
                copyBtn.style.display = 'inline-block';
            }

            this.showToast('Current token retrieved successfully');

        } catch (error) {
            console.error('Error getting current token:', error);
            this.showToast('Error getting current token: ' + error.message, 'error');
            
            if (tokenDisplay) {
                tokenDisplay.value = 'Error: ' + error.message;
            }
        } finally {
            if (btn) {
                btn.innerHTML = '<i class="fas fa-download"></i> Get Current Token';
                btn.disabled = false;
            }
        }
    }

    /**
     * Refresh access token
     */
    async refreshToken() {
        const btn = document.getElementById('refresh-access-token');
        
        if (btn) {
            const originalText = btn.innerHTML;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Refreshing...';
            btn.disabled = true;
        }

        try {
            if (!window.TokenAccess) {
                throw new Error('TokenAccess not available');
            }

            await window.TokenAccess.refreshToken();
            await this.updateTokenDisplay();
            this.showToast('Token refreshed successfully');

        } catch (error) {
            console.error('Error refreshing token:', error);
            this.showToast('Error refreshing token: ' + error.message, 'error');
        } finally {
            if (btn) {
                btn.innerHTML = '<i class="fas fa-sync-alt"></i> Refresh Token';
                btn.disabled = false;
            }
        }
    }

    /**
     * Clear current token
     */
    async clearToken() {
        const btn = document.getElementById('clear-token');
        
        if (btn) {
            const originalText = btn.innerHTML;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Clearing...';
            btn.disabled = true;
        }

        try {
            if (!window.TokenAccess) {
                throw new Error('TokenAccess not available');
            }

            await window.TokenAccess.clearToken();
            
            // Clear token display
            const tokenDisplay = document.getElementById('raw-token-display');
            if (tokenDisplay) {
                tokenDisplay.value = '';
            }

            // Hide copy button
            const copyBtn = document.getElementById('copy-token');
            if (copyBtn) {
                copyBtn.style.display = 'none';
            }

            await this.updateTokenDisplay();
            this.showToast('Token cleared successfully');

        } catch (error) {
            console.error('Error clearing token:', error);
            this.showToast('Error clearing token: ' + error.message, 'error');
        } finally {
            if (btn) {
                btn.innerHTML = '<i class="fas fa-trash"></i> Clear Token';
                btn.disabled = false;
            }
        }
    }

    /**
     * Test current token
     */
    async testToken() {
        const btn = document.getElementById('test-token');
        
        if (btn) {
            const originalText = btn.innerHTML;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Testing...';
            btn.disabled = true;
            try {
                const response = await fetch('/api/token/status');
                const payload = await response.json();
                const statusData = payload && (payload.data || payload.status || payload);
                const token = statusData && (statusData.data || statusData);

                if (token && token.hasToken && token.isValid) {
                    this.showToast('Token is valid');
                } else {
                    this.showToast('Token is invalid or expired', 'warning');
                }
            } catch (error) {
                console.error('Error testing token:', error);
                this.showToast('Error testing token: ' + error.message, 'error');
            } finally {
                btn.innerHTML = originalText || '<i class="fas fa-vial"></i> Test Token';
                btn.disabled = false;
            }
        }
    }

    /**
     * Decode JWT token
     */
    decodeToken() {
        const tokenDisplay = document.getElementById('raw-token-display');
        const decodedContainer = document.getElementById('decoded-token-container');

        if (!tokenDisplay || !tokenDisplay.value) {
            this.showToast('Please get the current token first', 'warning');
            return;
        }

        try {
            const token = tokenDisplay.value.trim();
            const parts = token.split('.');

            if (parts.length !== 3) {
                throw new Error('Invalid JWT token format');
            }

            // Decode header
            const header = JSON.parse(atob(parts[0]));
            document.getElementById('jwt-header').textContent = JSON.stringify(header, null, 2);

            // Decode payload
            const payload = JSON.parse(atob(parts[1]));
            document.getElementById('jwt-payload').textContent = JSON.stringify(payload, null, 2);

            // Show signature (can't decode without key)
            document.getElementById('jwt-signature').textContent = parts[2];

            if (decodedContainer) {
                decodedContainer.style.display = 'block';
            }

            this.showToast('JWT token decoded successfully');

        } catch (error) {
            console.error('Error decoding token:', error);
            this.showToast('Error decoding token: ' + error.message, 'error');
        }
    }

    /**
     * Copy token to clipboard
     */
    async copyToken() {
        const tokenDisplay = document.getElementById('raw-token-display');
        
        if (!tokenDisplay || !tokenDisplay.value) {
            this.showToast('No token to copy', 'warning');
            return;
        }

        try {
            await navigator.clipboard.writeText(tokenDisplay.value);
            this.showToast('Token copied to clipboard');
        } catch (error) {
            console.error('Error copying token:', error);
            this.showToast('Error copying token to clipboard', 'error');
        }
    }

    /**
     * Show toast notification
     */
    showToast(message, type = 'success') {
        // Create toast element
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        toast.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 4px;
            color: white;
            font-weight: 500;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease;
        `;

        // Set background color based on type
        switch (type) {
            case 'success':
                toast.style.backgroundColor = '#28a745';
                break;
            case 'error':
                toast.style.backgroundColor = '#dc3545';
                break;
            case 'warning':
                toast.style.backgroundColor = '#ffc107';
                toast.style.color = '#212529';
                break;
            default:
                toast.style.backgroundColor = '#17a2b8';
        }

        toast.textContent = message;
        document.body.appendChild(toast);

        // Fade in
        setTimeout(() => {
            toast.style.opacity = '1';
        }, 100);

        // Fade out and remove
        setTimeout(() => {
            toast.style.opacity = '0';
            setTimeout(() => {
                document.body.removeChild(toast);
            }, 300);
        }, 3000);
    }

    /**
     * Cleanup method
     */
    destroy() {
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
        }
        this.initialized = false;
        console.log('🔧 Token Manager UI Integration destroyed');
    }
}

// Create global instance
window.TokenManagerUIIntegration = new TokenManagerUIIntegration();

// Auto-initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        window.TokenManagerUIIntegration.init();
    });
} else {
    window.TokenManagerUIIntegration.init();
}

export default TokenManagerUIIntegration;


